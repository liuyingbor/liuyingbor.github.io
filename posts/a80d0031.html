<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>动态规划 | 狼唤</title><meta name="author" content="刘英博"><meta name="copyright" content="刘英博"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="动态规划为什么重要？从面试的角度看，动态规划是正规算法面试中无论如何都逃不掉的必考题。 其实最主要的原因就是动态规划非常适合面试，因为动态规划没办法「背」。 我们很多求职者其实是通过背题来面试的，而之前这个做法屡试不爽，什么翻转二叉树、翻转链表，快排、归并、冒泡一顿背，基本上也能在面试中浑水摸鱼过去，其实这哪是考算法能力、算法思维，这就是考谁的备战态度好，愿意花时间去背题而已，把连背都懒得背的筛出"><meta property="og:type" content="article"><meta property="og:title" content="动态规划"><meta property="og:url" content="https://liuyingbo.com/posts/a80d0031.html"><meta property="og:site_name" content="狼唤"><meta property="og:description" content="动态规划为什么重要？从面试的角度看，动态规划是正规算法面试中无论如何都逃不掉的必考题。 其实最主要的原因就是动态规划非常适合面试，因为动态规划没办法「背」。 我们很多求职者其实是通过背题来面试的，而之前这个做法屡试不爽，什么翻转二叉树、翻转链表，快排、归并、冒泡一顿背，基本上也能在面试中浑水摸鱼过去，其实这哪是考算法能力、算法思维，这就是考谁的备战态度好，愿意花时间去背题而已，把连背都懒得背的筛出"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-01-15T16:46:46.000Z"><meta property="article:modified_time" content="2022-11-13T11:01:46.733Z"><meta property="article:author" content="刘英博"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liuyingbo.com/posts/a80d0031"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"动态规划",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-11-13 11:01:46"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="狼唤" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211100000064.JPG" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">狼唤</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">动态规划</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-15T16:46:46.000Z" title="发表于 2022-01-15 16:46:46">2022-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-13T11:01:46.733Z" title="更新于 2022-11-13 11:01:46">2022-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="动态规划"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="动态规划为什么重要？"><a href="#动态规划为什么重要？" class="headerlink" title="动态规划为什么重要？"></a>动态规划为什么重要？</h2><p>从面试的角度看，动态规划是正规算法面试中无论如何都逃不掉的必考题。</p><p>其实最主要的原因就是动态规划非常适合面试，因为动态规划没办法「背」。</p><p>我们很多求职者其实是通过背题来面试的，而之前这个做法屡试不爽，什么翻转二叉树、翻转链表，快排、归并、冒泡一顿背，基本上也能在面试中浑水摸鱼过去，其实这哪是考算法能力、算法思维，这就是考谁的备战态度好，愿意花时间去背题而已，把连背都懒得背的筛出去就完事了。</p><p>但是随着互联网遇冷，人才供给进一步过热，背题的人越来越多，面试的门槛被增加了，因此这个时候需要一种非常考验算法思维、变化多端而且容易设计的题目类型，动态规划就完美符合这个要求。</p><p>比如 LeetCode 中有1261道算法类题目,其中动态规划题目占据了近200道，动态规划能占据总题目的 1&#x2F;6 的比例,可见其火热程度。</p><p>更重要的是，动态规划的题目难度以中高难度为主</p><p>所以,既然我们已经知道这是算法面试的必考题了,我们怎么准备都不为过。</p><h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>动态规划(Dynamic programming，简称DP)是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>态规划与分治方法类似，都是通过组合子问题的解来来求解原问题的。再来了解一下什么是分治方法，以及这两者之间的差别，分治方法将问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来，求出原问题的解。而动态规划与之相反，动态规划应用与子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治方法会做许多不必要的工作，他会反复求解那些公共子子问题。而动态规划对于每一个子子问题只求解一次，将其解保存在一个表格里面，从而无需每次求解一个子子问题时都重新计算，避免了不必要的计算工作。</p><h2 id="动态规划题目的特点"><a href="#动态规划题目的特点" class="headerlink" title="动态规划题目的特点"></a>动态规划题目的特点</h2><h3><a href="#" class="headerlink"></a><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/1502700-20200320161943044-1421872138.png" alt="img"></h3><h2 id="从「钱」讲起"><a href="#从「钱」讲起" class="headerlink" title="从「钱」讲起"></a>从「钱」讲起</h2><p><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/image-20220115172412260.png" alt="image-20220115172412260"></p><p><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/image-20220115172506732.png" alt="image-20220115172506732"></p><p>我们可以算一下，按照贪心算法的策略，我们先拿出3个最大面值的7，再拿出一个面值5然后就没有办法继续了。</p><p><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/image-20220115173020707.png" alt="image-20220115173020707"></p><p>这里就有问题了,贪心算法的弊端在这种特殊面值钱币面前展露无疑,原因就在于「只顾眼前，无大局观」，在先拿出最大的 7 面值的硬币后就彻底把周旋余地堵死了,因为剩下的 21 要想凑足付出的代价是非常高的,我们需要依次拿出4个面值为2的硬币。</p><h2 id="改进计算策略"><a href="#改进计算策略" class="headerlink" title="改进计算策略"></a>改进计算策略</h2><p>那么既然贪心算法已经不适用于这种场景了,我们应该如何改变计算策略呢?</p><p>当我们面试过程中遇到这种问题时,如果一时没有思路,也要想到一种万能算法–暴力破解。</p><p>我们分析一下上述题目,它的问题其实是「给定一组面额的硬币,我们用现有的币值凑出27最少需要多少个币」。</p><ul><li>那么假设最后一个硬币为a[k]的话，那么剩下27 - a[k]，这个时候问题又变成了，我们凑出 27 - a[k]最少需要多少个币</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/image-20220115180634272.png" alt="image-20220115180634272"></p><p>问题可以不断被分解为「我们用现有的币值凑出 n 最少需要多少个币」,比如我们用 f(n) 函数代表 「凑出 n 最少需要多少个币」.</p><p>把「原有的大问题逐渐分解成类似的但是规模更小的子问题」这就是最优子结构,我们可以通过自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><p>这个时候我们分别假设 2、5、7 三种面值的币分别为最后一个硬币的情况：</p><ul><li>最后一枚硬币的面额为 7: min &#x3D; f(20) + 1</li><li>最后一枚硬币的面额为 5: min &#x3D; f(22) + 1</li><li>最后一枚硬币的面额为 2: min &#x3D; f(25) + 1</li></ul><p>这个时候大家发现问题所在了吗?最少找零 min 与 <code>f(20)、f(22)、f(25)</code> 三个函数解中的最小值是有关的，毕竟后面的「+1」是大家都有的。</p><p>假设凑的硬币总额为 n，那么 <code>f(20) = f(n-7)</code>、<code>f(22) = f(n-5)</code>、<code>f(25) = f(n-2)</code>，我们得出以下公式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = min&#123;f(n-2), f(n-5), f(n-7)&#125; + 1</span><br></pre></td></tr></table></figure><p>我们再具体到上面公式中 <code>f(n-1)</code> 凑够它的最小硬币数量是多少,是不是又变成下面这个公式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n-1) = min&#123;f(n-2-1), f(n-1-5), f(n-1-7)&#125; + 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/1642246223503.jpg" alt="image-20220115193905486"></p><p>这真是似曾相识,这不就是递归吗?</p><p>是的,我们可以通过递归来求出最少找零问题的解,代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f(n) &#123;</span><br><span class="line">    if(n === 0) return 0</span><br><span class="line">    let min = Infinity</span><br><span class="line">    if (n &gt;= 2) &#123;</span><br><span class="line">        min = Math.min(f(n-2) + 1, min)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (n &gt;= 5) &#123;</span><br><span class="line">        min = Math.min(f(n-5) + 1, min)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (n &gt;= 7) &#123;</span><br><span class="line">        min = Math.min(f(n-7) + 1, min)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(f(27)) // 4</span><br></pre></td></tr></table></figure><h2 id="递归的弊端"><a href="#递归的弊端" class="headerlink" title="递归的弊端"></a>递归的弊端</h2><p>我们看似已经把问题解决了,但是别着急,我们继续测试,当n&#x3D;70的时候,我们测试要凑出这个数最少我们需要多少个硬币。</p><p>答案是10,但是我们的耗时如下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f12830652d~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-21-23-02-13"></p><p>如果n&#x3D;270呢?在八代i7处理器和node.js 12.x版本的加持下我跑了这么长时间都没算出来:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f1288dc98d~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-21-23-04-26"></p><p>当n&#x3D;27000的时候,我们成功的爆栈了:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f1293a772f~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-21-23-05-56"></p><p>所以为什么会造成如此长的执行耗时?归根到底是递归算法的低效导致的,我们看如下图:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f15419200d~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-21-23-12-00"></p><p>我们如果计算f(70)就需要分别计算最后一个币为2、5、7三种面值时的不同情况，而这三种不同情况作为子问题又可以被分解为三种情况，依次类推…这样的算法复杂度有 O(3ⁿ),这是极为低效的。</p><p>我们再仔细看图:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f158144d68~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-21-23-17-13"></p><p>我们用红色标出来的都是相同的计算函数，比如有两个f(64)、f(58)、f(54)，这些都是重复的,这些只是我们整个计算体系下的冰山一角,我们还有非常多的重复计算没办法在图中展示出来。</p><p>可见我们重复计算了非常多的无效函数，浪费了算力,到底有多浪费我们已经从上面函数执行时间测试上有了一定的认识。</p><p>我们不妨再举一个简单的例子，比如我们要计算 「1 + 1 + 1 + 1 + 1 + 1 + 1 + 1」的和。</p><p>我们开始数数…,直到我们数出上面计算的和为 8，那么，我们再在上述 「1 + 1 + 1 + 1 + 1 + 1 + 1 + 1」 后面 「+ 1」，那么和是多少？</p><p>这个时候你肯定数都不会数，脱口而出「9」。</p><p>为什么我们在后面的计算这么快？是因为我们已经在大脑中记住了之前的结果 「8」，我们只需要计算「8 + 1」即可，这避免了我们重复去计算前面的已经计算过的内容。</p><p>我们用的递归像什么？像继续数「1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1」来计算出「9」，这是非常耗时的。</p><p>我们假设用 m 种面值的硬币凑 n 最少需要多少硬币，在上述问题下递归的时间复杂度是惊人的O(nᵐ),指数级的时间复杂度可以说是最差的时间复杂度之一了。</p><p>我们已经发现问题所在了,大量的重复计算导致时间复杂度奇高,我们必须想办法解决这个问题。</p><h2 id="备忘录与递归"><a href="#备忘录与递归" class="headerlink" title="备忘录与递归"></a>备忘录与递归</h2><p>既然已经知道存在大量冗余计算了,那么我们可不可以建立一个备忘录,把计算过的答案记录在备忘录中,再有我们需要答案的时候,我们去备忘录中查找,如果能查找到就直接返回答案,这样就避免了重复计算,这就是算法中典型的空间换时间的思维，我们用备忘录占用的额外内存换取了更高效的计算。</p><p>有了思路后,其实代码实现非常简单,我们只需要建立一个缓存备忘录,在函数内部校验校验是否存在在结果,如果存在返回即可。我们的执行时间只有:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f159d606b0~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-22-09-52-37"></p><p>实际上利用备忘录来解决递归重复计算的问题叫做「记忆化搜索」。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f158144d68~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-21-23-17-13"></p><p>这个方法本质上跟回溯法的「剪枝」是一个目的，就是把上图中存在重复的节点全部剔除,只保留一个节点即可,当然上图没办法把所有节点全部展示出来,如果剔除全部重复节点最后只会留下线性的节点形式:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f15e62e10e~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-22-10-04-33"></p><p>这个带备忘录的递归算法时间复杂度只有O(n),已经跟动态规划的时间复杂度相差不大了。</p><p>那么这不就可以了吗？为什么还要搞动态规划？</p><p>还记得我们上面提到递归的另一大问题吗？</p><p>爆栈！</p><p>这是我们备忘录递归计算 <code>f(27000)</code> 的结果:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f1736bae9e~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-22-10-07-19"></p><p>编程语言栈的深度是有限的,即使我们进行了剪枝,在五位数以上的情况下就会再次产生爆栈的情况,这导致递归根本无法完成大规模的计算任务。</p><p>这是递归的计算形式决定的,我们这里的递归是「自顶向下」的计算思路，即从 <code>f(70) f(69)...f(1)</code> 逐步分解,这个思路在这里并不完全适用,我们需要一种「自底向上」的思路来解决问题。</p><p>「自底向上」就是 <code>f(1) ... f(70) f(69)</code>通过小规模问题递推来解决大规模问题,动态规划通常是用迭代取代递归来解决问题。</p><blockquote><p>「自顶向下」的思路在另一种算法思想中非常常见,那就是分治算法</p></blockquote><p>除此之外,递归+备忘录的另一个缺陷就是再没有优化空间了,因为在最坏的情况下，递归的最大深度是 n。</p><p>因此，我们需要系统递归堆栈使用 O(n) 的空间,这是递归形式决定的,而换成迭代之后我们根本不需要如此多的的储存空间,我们可以继续往下看。</p><h2 id="动态转移方程"><a href="#动态转移方程" class="headerlink" title="动态转移方程"></a>动态转移方程</h2><p>还记得上面我们利用备忘录缓存之后各个节点的形式是什么样的吗,我们把它这个「备忘录」作为一张表，这张表就叫做 DP table,如下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f17e8707fb~tplv-t2oaga2asx-watermark.awebp" alt="2020-01-22-22-06-59"></p><blockquote><p>注意: 上图中 <code>f[n]</code> 代表凑够 n 最少需要多少币的函数,方块内的数字代表函数的结果</p></blockquote><p>我们不妨在上图中找找规律?</p><p>我们观察<code>f[1]</code>: <code>f[1] = min(f[-1], f[-5], f[-7]) + 1</code></p><p>由于<code>f[-5]</code> 这种负数是不存在的,我们都设为正无穷大,那么<code>f[1] = 1</code>。</p><p>再看看<code>f[5]</code>: <code>f[1] = min(f[3], f[0], f[-2]) + 1</code>,这实际是在求<code>f[3] = Infinity、</code>f[0] &#x3D; 0<code>、</code>f[-2]&#x3D;Infinity<code>中最小的值即0，最后加上1，即1，那么</code>f[5] &#x3D; 1&#96;。</p><p>发现了吗？我们任何一个节点都可以通过之前的节点来推导出来，根本无需再做重复计算，这个相关的方程是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[n] = min(f[n-2], f[n-5], f[n-7]) + 1</span><br></pre></td></tr></table></figure><p>还记得我们提到的动态规划有更大的优化空间吗?递归+备忘录由于递归深度的原因需要 O(n) 的空间复杂度,但是基于迭代的动态规划只需要常数级别的复杂度。</p><p>看下图,比如我们求解 f(70),只需要前面三个解,即 <code>f(59)</code> <code>f(69)</code> <code>f(65)</code> 套用公式即可求得,那么 <code>f(0)f(1) ... f(58)</code> 根本就没有用了,我们可以不再储存它们占用额外空间,这就留下了我们优化的空间。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713e9f18101f3b9~tplv-t2oaga2asx-watermark.awebp" alt="2020-03-09-19-10-43"></p><p>上面的方程就是动态转移方程,而解决动态规划题目的钥匙也正是这个动态转移方程。</p><p>当然,如果你只推导出了动态转移方程基本上可以把动态规划题做出来了,但是往往很多人却做不对,这是为什么?这就得考虑边界问题。</p><h2 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h2><p>部分的边界问题其实我们在上面的部分已经给出解决方案了,针对这个找零问题我们有以下边界问题。</p><p><strong>处理f[n]中n为负数的问题</strong>: 针对这个问题我们的解决方案是凡是n为负数的情况,一律将<code>f[n]</code>视为正无穷大,因为正常情况下我们是不会有下角标为负数的数组的,所以其实 n 为负数的 <code>f[n]</code> 根本就不存在,又因为我们要求最少找零,为了排除这种不存在的情况,也便于我们计算,我们直接将其视为正无穷大,可以最大程度方便我们的动态转移方程的实现。</p><p><strong>处理f[n]中n为0的问题</strong>：<code>n=0</code> 的情况属于动态转移方程的初始条件,初始条件也就是动态转移方程无法处理的特殊情况,比如我们如果没有这个初始条件,我们的方程是这样的: <code>f[0] = min(f[-2], f[-5], f[-7]) + 1</code>,最小的也是正无穷大,这是特殊情况无法处理,因此我们只能人肉设置初始条件。</p><p>处理好边界问题我们就可以得到完整的动态转移方程了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[0] = 0 (n=0)</span><br><span class="line">f[n] = min(f[n-2], f[n-5], f[n-7]) + 1 (n&gt;0)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="找零问题完整解析"><a href="#找零问题完整解析" class="headerlink" title="找零问题完整解析"></a><a href="https://link.juejin.cn/?target=https://leetcode-cn.com/problems/coin-change/">找零问题完整解析</a></h2><p>那么我们再回到这个找零问题中,这次我们假设给出不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其实上面的找零问题就是我们一直处理的找零问题的通用化,我们的面额是定死的,即1、5、11，这次是不定的，而是给了一个数组 coins 包含了相关的面值。</p><p><strong>确定最优子结构:</strong> 最优子结构即原问题的解由子问题的最优解构成,我们假设最少需要k个硬币凑足总面额n,那么<code>f(n) = min&#123;f(n-cᵢ)&#125;</code>, <code>cᵢ</code> 即是硬币的面额。</p><p><strong>处理边界问题:</strong> 依然是老套路,当n为负数的时候,值为正无穷大,当n&#x3D;0时,值也为0.</p><p><strong>得出动态转移方程</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[0] = 0 (n=0)</span><br><span class="line">f[n] = min(f[n-cᵢ]) + 1 (n&gt;0)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们总结一下学习历程：</p><ol><li>从贪心算法入手来解决找零问题，发现贪心算法并不是在任何情况下都能找到最优解</li><li>我们决定换一种思路来解决存在的问题，我们最终发现了关键点,即「最优子结构」</li><li>借助上面的两个发现，我们用递归的方式解决了最少找零问题</li><li>但是经过算法复杂度分析和实际测试，我们发现递归的方法效率奇低，我们必须用一种方法来解决当前问题</li><li>我们用备忘录+递归的形式解决了时间复杂度问题,但是自顶向下的思路导致我们无法摆脱爆栈的阴霾,我们需要一种「自底向上」的全新思路</li><li>我们通过动态转移方程以迭代的方式高效地解出了此题</li></ol><p>其实动态规划本质上就是被一再优化过的暴力破解,我们通过动态规划减少了大量的重叠子问题,此后我们讲到的所有动态规划题目的解题过程，都可以从暴力破解一步步优化到动态规划。</p><p>本文我们学习了动态规划到底是怎么来的，在此后的解题过程中我们如果没有思路可以在脑子里把这个过程再过一遍，但是我们之后的题解就不会再把整个过程走一遍了，而是直接用动态规划来解题。</p><p>可能你会问面试题这么多,到底哪一道应该用动态规划?如何判断?</p><p>其实最准确的办法就是看题目中的给定的问题，这个问题能不能被分解为子问题，再根据子问题的解是否可以得出原问题的解。</p><p>当然上面的方法虽然准确,但是需要一定的经验积累,我们可以用一个虽然不那么准确,但是足够简单粗暴的办法,如果题目满足以下条件之一,那么它大概率是动态规划题目:</p><ul><li>求最大值，最小值</li><li>判断方案是否可行</li><li>统计方案个数</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://liuyingbo.com">刘英博</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://liuyingbo.com/posts/a80d0031.html">https://liuyingbo.com/posts/a80d0031.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://liuyingbo.com" target="_blank">狼唤</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/376d0826.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">回溯算法</div></div></a></div><div class="next-post pull-right"><a href="/posts/183e2cbd.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">IOC</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/e85d694a.html" title="二叉树"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-25</div><div class="title">二叉树</div></div></a></div><div><a href="/posts/undefined.html" title="四叉树碰撞检测算法"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-01</div><div class="title">四叉树碰撞检测算法</div></div></a></div><div><a href="/posts/376d0826.html" title="回溯算法"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-25</div><div class="title">回溯算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211100000064.JPG" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">刘英博</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">动态规划为什么重要？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.</span> <span class="toc-text">什么是动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E7%9B%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">动态规划题目的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.</span><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E3%80%8C%E9%92%B1%E3%80%8D%E8%AE%B2%E8%B5%B7"><span class="toc-number">4.</span> <span class="toc-text">从「钱」讲起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E8%AE%A1%E7%AE%97%E7%AD%96%E7%95%A5"><span class="toc-number">5.</span> <span class="toc-text">改进计算策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">6.</span> <span class="toc-text">递归的弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E4%B8%8E%E9%80%92%E5%BD%92"><span class="toc-number">7.</span> <span class="toc-text">备忘录与递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">动态转移方程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">边界问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98%E5%AE%8C%E6%95%B4%E8%A7%A3%E6%9E%90"><span class="toc-number">10.</span> <span class="toc-text">找零问题完整解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ba6d86a1.html" title="C#数据结构与算法"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="C#数据结构与算法"></a><div class="content"><a class="title" href="/posts/ba6d86a1.html" title="C#数据结构与算法">C#数据结构与算法</a><time datetime="2022-11-13T11:01:46.729Z" title="发表于 2022-11-13 11:01:46">2022-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1d0254fc.html" title="Unity-移动平台相关（一）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-移动平台相关（一）"></a><div class="content"><a class="title" href="/posts/1d0254fc.html" title="Unity-移动平台相关（一）">Unity-移动平台相关（一）</a><time datetime="2022-09-01T15:06:06.000Z" title="发表于 2022-09-01 15:06:06">2022-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ba9e7782.html" title="Unity-网络开发（三）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-网络开发（三）"></a><div class="content"><a class="title" href="/posts/ba9e7782.html" title="Unity-网络开发（三）">Unity-网络开发（三）</a><time datetime="2022-08-14T22:13:47.000Z" title="发表于 2022-08-14 22:13:47">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34c3e4a1.html" title="Unity-UniTask"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-UniTask"></a><div class="content"><a class="title" href="/posts/34c3e4a1.html" title="Unity-UniTask">Unity-UniTask</a><time datetime="2022-08-14T21:24:49.000Z" title="发表于 2022-08-14 21:24:49">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c7963808.html" title="Unity-网络开发（一）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-网络开发（一）"></a><div class="content"><a class="title" href="/posts/c7963808.html" title="Unity-网络开发（一）">Unity-网络开发（一）</a><time datetime="2022-05-16T15:06:06.000Z" title="发表于 2022-05-16 15:06:06">2022-05-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 刘英博</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>