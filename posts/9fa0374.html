<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Unity-Shader | 狼唤</title><meta name="author" content="刘英博"><meta name="copyright" content="刘英博"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MeshMeshFilter 网格过滤器 主要从众多的资源中挑选需要的Mesh，把它丢给MeshRender。 MeshRenderer 网格渲染器 主要是负责把MeshFilter丢过来的Mesh，绘制显示到我们的场景中，当然这项工作是非常复杂的。 Material 材质球 Material是MeshRenderer中非常重要的角色，它的配置决定了物体表面的外观将以怎样的质地呈现到我们眼前。如果"><meta property="og:type" content="article"><meta property="og:title" content="Unity-Shader"><meta property="og:url" content="https://liuyingbo.com/posts/9fa0374.html"><meta property="og:site_name" content="狼唤"><meta property="og:description" content="MeshMeshFilter 网格过滤器 主要从众多的资源中挑选需要的Mesh，把它丢给MeshRender。 MeshRenderer 网格渲染器 主要是负责把MeshFilter丢过来的Mesh，绘制显示到我们的场景中，当然这项工作是非常复杂的。 Material 材质球 Material是MeshRenderer中非常重要的角色，它的配置决定了物体表面的外观将以怎样的质地呈现到我们眼前。如果"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192022487.jpg"><meta property="article:published_time" content="2022-03-06T22:25:02.000Z"><meta property="article:modified_time" content="2023-04-10T06:08:54.267Z"><meta property="article:author" content="刘英博"><meta property="article:tag" content="Unity"><meta property="article:tag" content="Shader"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192022487.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liuyingbo.com/posts/9fa0374"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Unity-Shader",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-04-10 06:08:54"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="css/color.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="狼唤" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211100000064.JPG" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-comment-dots"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192022487.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">狼唤</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-comment-dots"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity-Shader</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-06T22:25:02.000Z" title="发表于 2022-03-06 22:25:02">2022-03-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-10T06:08:54.267Z" title="更新于 2023-04-10 06:08:54">2023-04-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Unity-Shader"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h1><p><strong>MeshFilter 网格过滤器</strong></p><p>主要从众多的资源中挑选需要的<strong>Mesh</strong>，把它丢给<strong>MeshRender</strong>。</p><p><strong>MeshRenderer 网格渲染器</strong></p><p>主要是负责把<strong>MeshFilter</strong>丢过来的<strong>Mesh</strong>，绘制显示到我们的场景中，当然这项工作是非常复杂的。</p><p><strong>Material 材质球</strong></p><p><strong>Material</strong>是<strong>MeshRenderer</strong>中非常重要的角色，它的配置决定了物体表面的外观将以怎样的质地呈现到我们眼前。如果天<strong>MeshRenderer</strong>不小心弄丢了<strong>Material</strong>，那这个物体就会变成让人烦躁的品红色。其实它跟大家经常看到的网页Error404差不多，RGB调成101就是这个颜色啦。</p><p>如果说<strong>Material</strong>是<strong>MeshRenderer</strong>的灵魂，那<strong>Shader</strong>就是<strong>Material</strong>的灵魂，但凡<strong>Shader</strong>哪里不开心了，即使<strong>MeshRenderer</strong>没有弄丢<strong>Material</strong>，物体依旧会变成前面所说的101颜色。</p><p><strong>Mesh 网格</strong></p><p><strong>Mesh</strong>指的就是模型的网格，它决定了物体的表面形状是怎样的，一个模型的表面大多是由多个彼此相连的三角面构成，当然也有其它类型。我们平时听到的建模，可以简单理解为就是在建网格，那为什么Unity中的网格大多都是三角形而不是四边形呢？正所谓一生二，二生三，三生万物。三角形可以说是最为基础的面了，可以简单理解为三角形具有更广泛的适用性，而Mesh则是构成这些三角面所需的信息集合。</p><p>通过 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2021.3/Manual/AnatomyofaMesh.html">Mesh data - Unity 手册</a> 我们可以看到构成这些三角面所需的信息。</p><p><strong>Vertices</strong> <strong>顶点数组 Vector3[]</strong></p><p>顾名思义它存储的是顶点的相关信息，所谓点成线，线成面，可以理解为这里面存储的是构成网格面全部的点</p><p><strong>Topology 拓扑类型</strong></p><p>它存储的就是一个类型信息，可以理解为它是图形表面排列结构的组成方式，Unity给我们提供了5种拓扑类型，三角面、四边形、线条、虚线、点阵，最常用的则是三角面。</p><p><strong>Indices</strong> <strong>索引数组 int[]</strong></p><p>它是每个三角面顶点 的索引，可以理解为他存储了构网格三角面所用到的顶点索引。</p><p><strong>Vertex data</strong> <strong>顶点数据</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171628215.png" alt="img"></p><p>它包含了顶点的位置、法线、切线、UV等属性</p><p><strong>Normal 法线 Vector3[]</strong></p><p>法线就是垂直于该顶点三角面的一条三维向量，它只有方向，没有大小。法线的方向就是顶点三角面朝外的方向。假设我们面前有一面镜子，它的正中心会有一条法线垂直于镜面指向我们，指向我们的面就是正面，相反就是背面</p><p><strong>Tangent 切线 Vector3[]</strong></p><p>它是垂直于法线的一条向量，而由于垂直于法线的向量有无数条，所以切线最终是由UV坐标来决定朝向的</p><p><strong>UV 纹理坐标 Vector2[]</strong></p><p>上面所说的UV坐标其实就是它，U增长的方向就是切线的方向，它和三维空间的X, Y, Z较为类似，它是一个二维的坐标系统，模型网格除了有三维空间的xyz坐标外，还有一个二维的UV坐标，在UV坐标中，U和V分别代表顶点在Texture水平和垂直方向上的采样坐标，这些坐标通常位于(0，0)和(1，1)之间，（0，0）代表最左下角，而（1，1）代表最右上角。这就跟平时装修房子贴墙纸一样，可以理解为它是Texture映射到模型表面的依据，模型顶点 会依据UV坐标对Texture进行采样。</p><p><strong>Index data 索引数据</strong></p><p>这个数据取决于拓扑类型，如果是三角面他储存的就是[0,1,2]，四边形储存的就是[0,1,2,3]，这个索引数值对应的就是顶点数组的下标。</p><h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>渲染管线通常来说就是在虚拟相机、三维物体、光源、照明模式、纹理等诸多条件都给定的情况下，生成或是绘制一幅二维图像的过程。而这个过程会有很多步骤，这些步骤就渲染阶段。</p><p>一般这个过程会分为四个主要阶段：应用程序阶段、几何阶段、光栅化阶段、像素处理阶段。而每个阶段 又会分为很多个部分。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171636205.png" alt="image-20230317163626180"></p><p><strong>应用程序阶段 （The Application Stage） CPU</strong></p><p>它最主要是负责数据的准备，也就是准备后面的阶段 所需的数据，像如模型，贴图，光照，相机位置等信息。</p><p>-——————————————————————————————————————————————————————</p><p><strong>几何阶段（The Geometry Stage） GPU</strong></p><p><strong>顶点着色：</strong>可编程部分，顾名思义，它会对逐个顶点相关的信息进行处理，生成图元，计算并传递给接下来的渲染流程。就像我们平时切菜一样，这个阶段就是为了控制食材的形态，</p><p>它对应的则是这里的VertxShader，它的工作主要是计算顶点的位置、法线、纹理坐标，根据材质、纹理、以及光源属性进行顶点光照的计算，平时常见的顶点动画一般就是在这里实现的。</p><p>[ <strong>图元：</strong>可以简单理解为它是渲染管线中所有点，线，面的统称 ]</p><p><strong>几何着色：</strong> 可选可编程部分，并非所有GPU都支持 ，它可以把简单的图元拓展成更复杂的形式，通常我们认为，这两大着色器共同构成了 几何阶段的可编程部分。</p><p><strong>裁剪 ：</strong> 固定功能硬件实现，对顶点几何两大着色器的输出结果进行处理，它会把完全处于视锥体交界外 以及屏幕窗口外的 几何体部分裁剪掉， 只留下用户能看到的部分，并且对生成的新顶点部分进行插值，输送给接下来的阶段。</p><p>-——————————————————————————————————————————————————————</p><p><strong>光栅化阶段（Rasterization）</strong> <strong>GPU</strong></p><p><strong>屏幕映射：</strong>经过裁剪之后，硬件会通过透视除法将物体从 裁剪空间 变换 为 标准化设备坐标也叫<strong>NDC</strong>，之后GPU会把得到的NDC空间坐标下的顶点，映射到屏幕空间坐标中，进行图元装配，这一步会计算微分、边方程和其他三角形数据，三角形的朝向剔除就是在这个阶段完成的。</p><p><strong>NDC：</strong>全称Normalized Device Coordinates，一般来说裁剪完成后，会通过透视除法，将物体从裁剪空间 变换为标准化设备坐标NDC，透视除法是将裁剪空间中，顶点的4个分量都除以w分量，从裁剪空间转换到NDC。它是一个长宽高取值范围为[-1,1]的立方体，之所以要转到NDC，是为了方面我们后面进行视口变换把它映射到屏幕空间，不过Unity已经帮我们都完成这些了。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171640103.png" alt="img"></p><p><strong>图元装配：</strong></p><p>主要是计算微分（differentials）、边方程（edge equations）和其他三角形数据（顶点属性插值）</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171640429.png" alt="img"></p><p><strong>光栅化：</strong></p><p>它会在每个像素点上生成一个片元，如果开启了多重采样抗锯齿，就会对每个像素进行多次采样，产生多个片元，最终进行混合来达到抗锯齿的效果。</p><p>[ <strong>片元</strong>：是光栅化之后产生的像素点，因为没有被画到屏幕上，不能被直接称为像素一个像素的最终结果可能是由多个片元来决定的，渲染管线为了细分，就单独创造了片元这个词来描述它，片元只是渲染管线的概念 ]</p><p>[ <strong>像素</strong>：则是最后写到图像上的值 ]</p><p>-——————————————————————————————————————————————————————</p><p><strong>像素处理阶段 （ Pixel Processing ）GPU</strong></p><p><strong>像素 (片元) 着色器：</strong>可编程部分，它的工作主要是根据顶点的插值属性，进行逐像素计算，因为它需要处理每一个像素，所以这也是最耗时的一个阶段。它的输入输出都是片元数据，输入的数据是 颜色 和纹理坐标，输出的则是计算后所得的每个像素的色彩值，像是逐像素光照、反射、阴影等等更为复杂的效果都是可以在这里实现的，这一步更像是再给我们的食材上色。</p><p><strong>合并：</strong>只可配置不可编程部分，在一系列的测试后会进行合并，所谓的测试则是判断一个像素点最终是否应该被显示在屏幕上，通过测试的颜色会和缓冲区的颜色叠加混合。</p><p>-——————————————————————————————————————————————————————</p><p><strong>坐标空间</strong></p><p><strong>模型空间</strong> 以物体本身为原点的坐标空间，<strong>世界空间</strong>以世界的(0,0)为原点的坐标空间，<strong>视图空间</strong> 以相机为原点的坐标空间，描述的物体在相机的哪个位置，<strong>裁剪空间</strong> 顶点坐标乘以MVP矩阵之后所在的空间，<strong>屏幕空间</strong> 窗口屏幕上的二维像素坐标空间。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171643181.png" alt="image-20230317164308152"></p><h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><p><strong>Shader</strong>比较学术的百科回答就是用来实现图像渲染的，用来替代固定渲染管线的可编辑程序。其中Vertex Shader（顶点着色器）主要负责顶点的几何关系等的运算，Pixel Shader（像素着色器）主要负责片元颜色等的计算。</p><h2 id="Unity中的Shader类型"><a href="#Unity中的Shader类型" class="headerlink" title="Unity中的Shader类型"></a>Unity中的Shader类型</h2><p><strong>Standard Surface Shader</strong></p><p>标准表面着色器，它是一种基于物理的着色系统，可以理解为 它是通过对物理现象的简单模拟，可以实现生活中各种物品的效果，比如石头、木材、玻璃、塑料和金属等等。</p><p><strong>Unlit Shader</strong></p><p>它是最简单的着色器，与 Standard Surface Shader 相比，它去除了冗长的光照公式以及阴影解算，因此得名 Unlit，翻译过来就是无光照，也正因如此，它只由最基础的 Vertex Shader 和 Fragment Shader 组成，最为基础易懂。</p><p><strong>Image Effect Shader</strong></p><p>它其实也是也是顶点片元着色器，不过它主要针对实现各种屏幕后处理效果，那后处理是什么呢？一般像是泛光、调色、景深、模糊等基于最终整个屏幕画面而进行再次处理的就是后处理，这里做个简单的了解即可。</p><p><strong>Compute Shader</strong></p><p>计算着色器，它是在GPU中运行的一段程序，独立于常规渲染管线之外的，它可以直接将GPU作为并行处理器加以利用，从而使GPU不仅具有3D渲染能力，还具有其他的运算能力。一般会在需要大量并行计算的时候使用。</p><p><strong>Ray Tracing Shader</strong></p><p>光线追踪着色器，光线追踪是指从摄像机出发的若干条光线，每条光线会和场景里的物体求交，根据交点位置获取表面的材质、纹理等信息，并结合光源信息计算光照。相对于传统的光栅化渲染，光线追踪可以轻松模拟各种光学效果，如反射、折射、散射、色散等。但由于在进行求交计算时需要知道整个场景的信息，它的计算成本也是非常高的。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171644436.png" alt="image-20230317164459408"></p><h2 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h2><p>Unity为我们封装的着色器语言，而目前主流的着色器语言有3种，基于OpenGL的<strong>GLSL</strong> / 基于DX的<strong>HLSL</strong> / NVIDIA公司的<strong>CG</strong>。</p><p>GLSL与HLSL分别是基于OpenGL和Direct3D的接口，两者不能混用。而CG则是为了使图形硬件的编程变得和 C语言编程一样方便自由，它本身基于C语言。如果你之前使用过C系语言其中的任意一个，那CG的语法也是比较容易掌握的。但其实由于Microsoft和NVIDIA的相互协作，他们在标准硬件光照语言的语法和语义上达成了一致，所以HLSL和Cg其实可以看为是同一种语言。</p><p>而<strong>ShaderLab</strong>则是Unity在HLSL和CG的基础之上封装的只属于Unity的着色器语言，它的灵活性更高，而且不再需要将 Shader 的配置 硬写在引擎代码中，本质是在底层着色语言的基础上，额外提供了声明信息，以数据驱动的方式使我们在渲染管线内自由发挥。</p><h3 id="ShaderLab语法详细解析"><a href="#ShaderLab语法详细解析" class="headerlink" title="ShaderLab语法详细解析"></a><strong>ShaderLab语法详细解析</strong></h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shader 的路径名称  默认为文件名,也可以与文件名不同</span></span><br><span class="line">Shader &quot;Unlit/MyShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 属性 </span></span><br><span class="line">    <span class="comment">// Material Inspector显示的所有参数都在需要在这里进行声明</span></span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通常所有属性名都以下划线字符开头 _MainTex</span></span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较常见的属性类型</span></span><br><span class="line">        <span class="comment">// ————————————————————————————————————————————————</span></span><br><span class="line">        _Integer (&quot;整数(新版)&quot;, Integer) = <span class="number">1</span></span><br><span class="line">        _Int (&quot;整数(旧版)&quot;, Int) = <span class="number">1</span></span><br><span class="line">        _Float (&quot;浮点数&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">        _FloatRange (&quot;浮点数滑动条&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span></span><br><span class="line">        <span class="comment">// Unity包含以下内置纹理, 可以直接填充</span></span><br><span class="line">        <span class="comment">// “white”（RGBA：1,1,1,1）</span></span><br><span class="line">        <span class="comment">// “black”（RGBA：0,0,0,1）</span></span><br><span class="line">        <span class="comment">// “gray”（RGBA：0.5,0.5,0.5,1）</span></span><br><span class="line">        <span class="comment">// “bump”（RGBA：0.5,0.5,1,0.5）</span></span><br><span class="line">        <span class="comment">// “red”（RGBA：1,0,0,1）</span></span><br><span class="line">        _Texture2D (&quot;<span class="number">2</span>D纹理贴图&quot;, <span class="number">2</span>D) = &quot;red&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 字符串留空或输入无效值，则它默认为 “gray”</span></span><br><span class="line">        _DefaultTexture2D (&quot;<span class="number">2</span>D纹理贴图&quot;, <span class="number">2</span>D) = &quot;&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 默认值为 “gray”（RGBA：0.5,0.5,0.5,1）</span></span><br><span class="line">        _Texture3D (&quot;<span class="number">3</span>D纹理贴图&quot;, <span class="number">3</span>D) = &quot;&quot; &#123;&#125;</span><br><span class="line">        _Cubemap (&quot;立方体贴图&quot;, Cube) = &quot;&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// Inspector会显示四个单独的浮点数字段</span></span><br><span class="line">        _Vector (&quot;Example vector&quot;, Vector) = (<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// Inspector会显示拾色器拾取色彩RGBA值</span></span><br><span class="line">        _Color(&quot;色彩&quot;, Color) = (<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// ————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除此之外 属性声明还可以具有一个可选特性 用来告知Unity如何处理它们</span></span><br><span class="line">        <span class="comment">// HDR可以使色彩亮度的值超过1</span></span><br><span class="line">        [HDR]_HDRColor(&quot;HDR色彩&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// Inspector隐藏此属性</span></span><br><span class="line">        [HideInInspector]_Hide(&quot;看不见我~&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// Inspector隐藏此纹理属性的Scale Offset字段</span></span><br><span class="line">        [NoScaleOffset]_HideScaleOffset(&quot;隐藏ScaleOffset&quot;, <span class="number">2</span>D) = &quot;&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 指示纹理属性为法线贴图，如果分配了不兼容的纹理，编辑器则会显示警告。</span></span><br><span class="line">        [Normal]_Normal(&quot;法线贴图&quot;, <span class="number">2</span>D) = &quot;&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子着色器 </span></span><br><span class="line">    <span class="comment">// 一个Shader至少有一个或者多个子着色器SubShader，这些子着色器互不干扰，且只有一个会运行</span></span><br><span class="line">    <span class="comment">// 在加载shader时Unity会遍历所有SubShader列表，并最终选择用户机器支持的第一个</span></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以通过Tags来向子着色器分配标签</span></span><br><span class="line">        <span class="comment">// 只可以写在SubShader语块内,不可写在Pass内</span></span><br><span class="line">        <span class="comment">/* 以键值对的形式存在,可以出现多个键值对</span></span><br><span class="line"><span class="comment">        Tags &#123; </span></span><br><span class="line"><span class="comment">            &quot;TagName1&quot; = &quot;Value1&quot;</span></span><br><span class="line"><span class="comment">            &quot;TagName2&quot; = &quot;Value2&quot;</span></span><br><span class="line"><span class="comment">            &quot;TagName3&quot; = &quot;Value3&quot;</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// RenderPipeline: 声明子着色器是否与通用渲染管线 (URP) 或高清渲染管线 (HDRP) 兼容</span></span><br><span class="line">        <span class="comment">// 仅与 URP 兼容</span></span><br><span class="line">        <span class="comment">// Tags &#123; &quot;RenderPipeline&quot;=&quot;UniversalRenderPipeline&quot; &#125;</span></span><br><span class="line">        <span class="comment">// 仅与 HDRP 兼容</span></span><br><span class="line">        <span class="comment">// Tags &#123; &quot;RenderPipeline&quot;=&quot;HighDefinitionRenderPipeline&quot; &#125;</span></span><br><span class="line">        <span class="comment">// RenderPipeline不声明或任何其他值表示与 URP 和 HDRP 不兼容</span></span><br><span class="line">        <span class="comment">// ————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Queue: 声明渲染队列</span></span><br><span class="line">        <span class="comment">// Tags &#123; &quot;Queue&quot;=&quot;Background&quot; &#125; // 最早被调用的渲染，用来渲染天空盒或者背景</span></span><br><span class="line">        <span class="comment">// Tags &#123; &quot;Queue&quot;=&quot;Geometry&quot; &#125;   // 这是默认值，用来渲染非透明物体（普通情况下，场景中的绝大多数物体应该是非透明的）</span></span><br><span class="line">        <span class="comment">// Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &#125;  // 用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑</span></span><br><span class="line">        <span class="comment">// Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &#125;// 以从后往前的顺序渲染透明物体</span></span><br><span class="line">        <span class="comment">// Tags &#123; &quot;Queue&quot;=&quot;Overlay&quot; &#125;    // 用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）</span></span><br><span class="line">        <span class="comment">// ————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// RenderType: 用来区别这个Shader要渲染的对象是属于什么类别的。</span></span><br><span class="line">        <span class="comment">// 设置渲染类型 用一种称为着色器替换的技术在运行时交换子着色器,用来区别这个Shader要渲染的对象是属于什么类别的</span></span><br><span class="line">        <span class="comment">// 这里表示非透明物体渲染</span></span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Opaque&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更多详细内容可参考官网文档 https://docs.unity.cn/cn/2021.3/Manual/SL-SubShaderTags.html</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// LOD (Level of Detail)</span></span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个子着色器由多个通道组成，许多简单的着色器只使用一个通道，但想要一些更复杂的效果，着色器可能需要更多通道</span></span><br><span class="line">        <span class="comment">// 一个Pass就是一次绘制，可以看成是一个Draw Call而Pass的意义在于多次渲染，</span></span><br><span class="line">        <span class="comment">// 如果你有一个Pass，那么着色器只会被调用一次，如果你有多个Pass的话，</span></span><br><span class="line">        <span class="comment">// 那么就相当于执行多次SubShader了，这就叫双通道或者多通道。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw Call：其实就是CPU调用图像编程接口的渲染命令，CPU每次调用DrawCall，都需要向GPU发送许多数据啊、渲染状态等等，</span></span><br><span class="line">        <span class="comment">// 一旦CPU执行完应用阶段，GPU就会开始执行这次的渲染流程。而GPU渲染的速度比CPU提交命令的速度要快的多，</span></span><br><span class="line">        <span class="comment">// 所以如果DrawCall数量过多的情况下，CPU需要进行大量的计算，进而就会导致CPU过载，影响游戏的运行效率。</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">// 声明顶点着色器</span></span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="comment">// 声明像素着色器</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// 使雾生效</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 引用CG的核心代码库</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 应用程序阶段结构体</span></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 参考：https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics</span></span><br><span class="line">                <span class="comment">// POSITION 着色器语言的语义，用来限定着色器的输入输出值的类型</span></span><br><span class="line">                <span class="comment">// 模型空间的顶点坐标</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                <span class="comment">// 模型的第一套UV坐标</span></span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// UV</span></span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">                <span class="comment">// SV_POSITION 当这个值需要作为输出值输出给系统用的时候 前面需要加SV_前缀</span></span><br><span class="line">                <span class="comment">// 当然因为有向下兼容的机制 不加也没啥太大问题</span></span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在Properties中声明的参数要在这里相对应的定义后才可以使用</span></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义顶点着色器函数 函数名要与声明顶点着色器名称相同</span></span><br><span class="line">            v2f vert(appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 将顶点坐标从模型空间变换到裁剪空间</span></span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// Transforms 2D UV by scale/bias property</span></span><br><span class="line">                <span class="comment">// #define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)</span></span><br><span class="line">                <span class="comment">// 等价于v.uv.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span></span><br><span class="line">                <span class="comment">// 简单来说，TRANSFORM_TEX主要作用是拿顶点的uv去和材质球的tiling和offset作运算，</span></span><br><span class="line">                <span class="comment">// 确保材质球里的缩放和偏移设置是正确的</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o, o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// SV_Target可以视为COLOR ，虽说他也是作为输出值输出给系统的</span></span><br><span class="line">            <span class="comment">// 但它其实是告诉系统把输出的颜色值存储到RenderTarget中</span></span><br><span class="line">            <span class="comment">// 所以这里我们用SV_Target</span></span><br><span class="line">            fixed4 frag(v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 采样2D纹理贴图</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">// 应用雾</span></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                <span class="comment">// 返回经过处理后的最终色彩</span></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用结构体简化Shader代码"><a href="#使用结构体简化Shader代码" class="headerlink" title="使用结构体简化Shader代码"></a>使用结构体简化Shader代码</h3><h4 id="无返回值（in-out）"><a href="#无返回值（in-out）" class="headerlink" title="无返回值（in,out）"></a>无返回值（in,out）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Shader&quot;Custom/Struct&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过材质面板的颜色和纹理来修改fragment</span></span><br><span class="line">        _MainColor(&quot;MainColor&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex(&quot;MainTex&quot;,<span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">//在CG中调用属性变量</span></span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义顶点着色器的输入结构体</span></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//定义顶点着色器的输出结构体</span></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">void</span> vert (<span class="keyword">in</span> appdata v, <span class="keyword">out</span> v2f o)</span><br><span class="line">            &#123;</span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.texcoord = v.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">void</span> frag(<span class="keyword">in</span> v2f i ,<span class="keyword">out</span> fixed4 color : SV_TARGET)</span><br><span class="line">            &#123;</span><br><span class="line">                color = tex2D(_MainTex,i.texcoord) * _MainColor;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">      &#123;</span><br><span class="line">          CGPROGRAM</span><br><span class="line">          <span class="comment">//在CG中调用属性变量</span></span><br><span class="line">          <span class="meta">#pragma vertex vert</span></span><br><span class="line">          <span class="meta">#pragma fragment frag</span></span><br><span class="line">          <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//定义顶点着色器的输入结构体</span></span><br><span class="line">          struct appdata</span><br><span class="line">          &#123;</span><br><span class="line">              float4 vertex : POSITION;</span><br><span class="line">              float2 uv : TEXCOORD0;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="comment">//定义顶点着色器的输出结构体</span></span><br><span class="line">          struct v2f</span><br><span class="line">          &#123;</span><br><span class="line">              float4 position : SV_POSITION;</span><br><span class="line">              float2 texcoord : TEXCOORD0;</span><br><span class="line">          &#125;;</span><br><span class="line">          fixed4 _MainColor;</span><br><span class="line">          <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">          float4 _MainTex_ST;</span><br><span class="line">          v2f vert (appdata v)</span><br><span class="line">          &#123;</span><br><span class="line">              v2f o;</span><br><span class="line">              o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">              o.texcoord = v.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">              <span class="keyword">return</span> o;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          fixed4 frag(v2f i) : SV_TARGET</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> tex2D(_MainTex,i.texcoord) * _MainColor;               </span><br><span class="line">          &#125;</span><br><span class="line">          ENDCG</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="使用Include”UnityCG-cginc”简化Shader"><a href="#使用Include”UnityCG-cginc”简化Shader" class="headerlink" title="使用Include”UnityCG.cginc”简化Shader"></a>使用Include”UnityCG.cginc”简化Shader</h3><p>使用预制结构体appdata_img（vertex和texcoord）和v2f_img（pos和uv）,以及纹理坐标计算宏TRANSFORM_TEX()。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/IncludeShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _MainColor (&quot;MainColor&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line"></span><br><span class="line">            v2f_img vert (appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f_img o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f_img i) : SV_TARGET</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> tex2D(_MainTex, i.uv) * _MainColor;   </span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h3><p>返回输入向量的归一化，输出向量将与输入向量具有相同的方向，但长度为 1。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303172248157.png" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303172250147.png" alt="img"></p><h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><p>Unlit 默认是不受光材质，纹理什么颜色它就直接显示出来了，但通常来说，光照是三维世界不可或缺的部分，现实世界中，当光照射到物体表面时, 物体对光会发生反射、透射、吸收、折射等被物体反射的光进入视觉系统，使看见物体的表面有明暗之分，为了模拟这一现象，科研家建立了一些数学模型来替代复杂的物理模型，统称为光照模型。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171720724.png" alt="image-20230317172053669"></p><p>比较常见的光照模型有漫反射的 Half Lambert 模型 ，以及镜面反射的 Blinn-Phong 模型。 Half Lambert 能够较好地表现粗糙表面上的光照现象，像如石灰墙，纸张等等，但是在渲染金属材质制成的物体时，则会显得呆板，表现不出光泽。主要原因是其没有考虑到镜面反射效果，所以 Blinn-Phong 对其进行了很好的补充。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171724563.png" alt="image-20230317172443528"></p><h3 id="Lambert模型"><a href="#Lambert模型" class="headerlink" title="Lambert模型"></a>Lambert模型</h3><p>Lambert光照模型计算公式为：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171746970.png" alt="alt"></p><p>使用入射光颜色和漫反射颜色相乘再乘以saturate裁剪后的光线方向（从入射点到光源方向）和法线方向夹角大小（点乘cos值）。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Lambert&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor(&quot;MainColor&quot;,Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityLightingCommon.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed4 dif : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//法线向量 由模型空间变换到世界空间并标准化</span></span><br><span class="line">                float3 n = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                n = <span class="built_in">normalize</span>(n);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//灯光法向向量</span></span><br><span class="line">                fixed3 l = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//按照公式计算漫反射</span></span><br><span class="line">                fixed ndotl = <span class="built_in">dot</span>(n,l);</span><br><span class="line">                o.dif = _LightColor0 * _MainColor * saturate(ndotl);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i.dif;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HalfLambert模型"><a href="#HalfLambert模型" class="headerlink" title="HalfLambert模型"></a>HalfLambert模型</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171748305.png" alt="alt"></p><p>修改公式将夹角值映射到[0.5,1]避免背面全黑。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_base v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//法线向量 由模型空间变换到世界空间并标准化</span></span><br><span class="line">    float3 n = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    n = <span class="built_in">normalize</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//灯光法向向量</span></span><br><span class="line">    fixed3 l = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按照公式计算漫反射</span></span><br><span class="line">    fixed ndotl = <span class="built_in">dot</span>(n,l);</span><br><span class="line">    o.dif = _LightColor0 * _MainColor * (<span class="number">0.5</span> * ndotl+<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Phong光照模型"><a href="#Phong光照模型" class="headerlink" title="Phong光照模型"></a>Phong光照模型</h3><p>Phong光照理论：物体表面反射光由三部分组成：环境光，漫反射，镜面反射（高光）。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171750792.png" alt="alt"></p><p>漫反射的计算即Lambert光照模型，镜面反射的计算如下。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171750731.png" alt="alt"></p><p>与Lambert公式类似，不同之处在于，这里和法线点乘的向量有入射光方向变成了视线方向（人直接看到的地方才高亮），并加以光泽度约束（实际约束了高光部分的范围，越小高光区域越大）。</p><p>环境光ambient、漫反射diffuse、高光specular三个光照计算都是用颜色乘法计算的，但是最后返回的颜色值，确实把三个光照颜色相加，这是为什么呢？以下是我的理解：</p><p><strong>加法是没有关系的颜色之间的叠加，而乘法是模拟光的照射过程</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Phong&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor(&quot;MainColor&quot;,Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Shininess(&quot;Shininess&quot;,Range(<span class="number">1</span>,<span class="number">100</span>)) = <span class="number">1</span></span><br><span class="line">        _SpecularColor(&quot;Specular Color&quot;,Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityLightingCommon.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed4 color : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line">            fixed4 _SpecularColor;</span><br><span class="line">            half _Shininess;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//法线向量 由模型空间变换到世界空间并标准化</span></span><br><span class="line">                float3 n = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                n = <span class="built_in">normalize</span>(n);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//灯光法向向量</span></span><br><span class="line">                fixed3 l = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//视线方向向量</span></span><br><span class="line">                fixed3 view = <span class="built_in">normalize</span>(WorldSpaceViewDir(v.vertex));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//漫反射</span></span><br><span class="line">                fixed ndotl = <span class="built_in">dot</span>(n,l);</span><br><span class="line">                fixed4 dif = _LightColor0 * _MainColor * saturate(ndotl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//镜面反射 光线方向取负，输入Reflect函数为光源到顶点的方向</span></span><br><span class="line">                float3 ref = <span class="built_in">reflect</span>(-l, n);</span><br><span class="line">                ref = <span class="built_in">normalize</span>(ref);</span><br><span class="line">                fixed rdotv = saturate(<span class="built_in">dot</span>(ref,view));</span><br><span class="line">                fixed4 spec = _LightColor0 * _SpecularColor * <span class="built_in">pow</span>(rdotv, _Shininess);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//环境光 + 漫反射 +镜面反射</span></span><br><span class="line">                o.color = unity_AmbientSky + dif + spec;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i.color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Blinn-Phong"><a href="#Blinn-Phong" class="headerlink" title="Blinn-Phong"></a>Blinn-Phong</h3><p>为减少计算量，将Phong光照模型中的v替换成半角向量h（视角方向和灯光方向角平分方向），视觉效果差距不大，但当观察者和灯光离物体很远时镜面反射近似为常数。</p><p>半角向量计算公式：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171751741.png" alt="alt"></p><p>Blinn-Phong 镜面反射计算公式：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171751523.png" alt="alt"></p><p>修改镜面反射部分代码。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="comment">//法线向量 由模型空间变换到世界空间并标准化</span></span><br><span class="line">               float3 n = UnityObjectToWorldNormal(i.normal);</span><br><span class="line">               n = <span class="built_in">normalize</span>(n);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//灯光法向向量</span></span><br><span class="line">               fixed3 l = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//视线方向向量</span></span><br><span class="line">               fixed3 view = <span class="built_in">normalize</span>(WorldSpaceViewDir(i.vertex));</span><br><span class="line"></span><br><span class="line">               <span class="comment">//漫反射</span></span><br><span class="line">               fixed ndotl = <span class="built_in">dot</span>(n,l);</span><br><span class="line">               fixed4 dif = _LightColor0 * _MainColor * saturate(ndotl);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//镜面反射 光线方向取负，输入Reflect函数为光源到顶点的方向</span></span><br><span class="line">               float3 h = <span class="built_in">normalize</span>(l + view);</span><br><span class="line">               fixed ndoth = saturate(<span class="built_in">dot</span>(h, n));</span><br><span class="line">               fixed4 spec = _LightColor0 * _SpecularColor * <span class="built_in">pow</span>(ndoth, _Shininess);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//环境光 + 漫反射 +镜面反射</span></span><br><span class="line">               <span class="keyword">return</span> unity_AmbientSky + dif + spec;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h3 id="逐像素光照"><a href="#逐像素光照" class="headerlink" title="逐像素光照"></a>逐像素光照</h3><p>对于顶点数量较少的Sphere类型，可以很明显的看到光照范围边缘并不光滑，可以通过增加曲面细分等级或者改由片段着色器逐像素计算光照。光照计算交由frag进行，顶点着色器只负责传递发现和顶点（pos是裁切空间的顶点，vertex是模型空间的顶点用于计算方向向量），在frag里面texcoord语义可以用于存任意的float4类型，不局限于UV。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Phong_Pixel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor(&quot;MainColor&quot;,Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Shininess(&quot;Shininess&quot;,Range(<span class="number">1</span>,<span class="number">100</span>)) = <span class="number">1</span></span><br><span class="line">        _SpecularColor(&quot;Specular Color&quot;,Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityLightingCommon.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : TEXCOORD0;</span><br><span class="line">                float4 vertex : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line">            fixed4 _SpecularColor;</span><br><span class="line">            half _Shininess;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.normal = v.normal;</span><br><span class="line">                o.vertex = v.vertex;              </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="comment">//法线向量 由模型空间变换到世界空间并标准化</span></span><br><span class="line">                float3 n = UnityObjectToWorldNormal(i.normal);</span><br><span class="line">                n = <span class="built_in">normalize</span>(n);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//灯光法向向量</span></span><br><span class="line">                fixed3 l = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//视线方向向量</span></span><br><span class="line">                fixed3 view = <span class="built_in">normalize</span>(WorldSpaceViewDir(i.vertex));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//漫反射</span></span><br><span class="line">                fixed ndotl = <span class="built_in">dot</span>(n,l);</span><br><span class="line">                fixed4 dif = _LightColor0 * _MainColor * saturate(ndotl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//镜面反射 光线方向取负，输入Reflect函数为光源到顶点的方向</span></span><br><span class="line">                float3 ref = <span class="built_in">reflect</span>(-l, n);</span><br><span class="line">                ref = <span class="built_in">normalize</span>(ref);</span><br><span class="line">                fixed rdotv = saturate(<span class="built_in">dot</span>(ref,view));</span><br><span class="line">                fixed4 spec = _LightColor0 * _SpecularColor * <span class="built_in">pow</span>(rdotv, _Shininess);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//环境光 + 漫反射 +镜面反射</span></span><br><span class="line">                <span class="keyword">return</span> unity_AmbientSky + dif + spec;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171757748.png" alt="alt" style="zoom:200%"></p><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><h3 id="Unity的渲染路径"><a href="#Unity的渲染路径" class="headerlink" title="Unity的渲染路径"></a>Unity的渲染路径</h3><p>在Unity中，渲染路径（Rendering Path）决定了<strong>光照</strong>是如何应用到Unity Shader中的。如果要和光源打交道，就需要为每个pass指定使用的渲染路径。这样，才能让Unity为我们提供正确的数据信息。</p><p>在pass中，通过设置LightMode标签来指定使用的渲染路径。</p><blockquote><p>Tags { “LightMode” = “ForwardBase” }</p></blockquote><p>下表给出Pass的LightMode标签支持的主要渲染路径设置：</p><div class="table-container"><table><thead><tr><th>标签名</th><th>描述</th></tr></thead><tbody><tr><td>Always</td><td>不管使用哪种渲染路径，该Pass总会被渲染，但不会计算任何光照</td></tr><tr><td>ForwardBase</td><td>用于前向渲染。该Pass会计算环境光，最重要的平行光、逐顶点/SH光源和Lightmaps</td></tr><tr><td>ForwardAdd</td><td>用于前向渲染。该Pass会计算额外的逐像素光源，每个Pass对应一个光源</td></tr><tr><td>Deffered</td><td>用于延迟渲染。该Pass会渲染G缓冲（G-buffer）</td></tr><tr><td>ShadowCaster</td><td>把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中</td></tr></tbody></table></div><p>官方LightMode介绍见链接：<a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/2019.4/Documentation/Manual/shader-predefined-pass-tags-built-in.html">ShaderLab: Predefined Pass tags in the Built-in Render Pipeline</a></p><p>为Pass指定渲染路径标签可以使Unity提供正确的（对于shader编写者来说）内置光照变量。</p><h3 id="延迟着色渲染路径"><a href="#延迟着色渲染路径" class="headerlink" title="延迟着色渲染路径"></a>延迟着色渲染路径</h3><p>先裁切再计算光照，因此光照在屏幕空间计算，所有灯光都是逐像素计算，计算量与场景复杂度无关，避免计算深度测试未通过的遮挡部分，提升性能，但不支持抗锯齿，半透明，正交相机且对硬件有要求。</p><h3 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h3><p>先计算光照再裁切，支持所有Unity图形功能，一部分最亮的灯光（离物体近）用逐像素光照渲染，然后最多4个灯光用逐顶点光照渲染，剩余用SH光照渲染，不同灯光组之间会重叠熏染，基础Pass包括一个逐像素平行光和所有逐顶点/SH的灯光，每多一个逐像素灯光会额外产生一个Pass，可以设置每个灯光的渲染模式Important来决定用顶点/像素光照渲染。</p><h3 id="PassFlags标签"><a href="#PassFlags标签" class="headerlink" title="PassFlags标签"></a>PassFlags标签</h3><p>用于更改渲染流水线传递数据给Pass的方式，目前仅可使用的值为OnlyDirectional，使得前向渲染时，SH和逐顶点灯光不能传数据。</p><h3 id="内置的multi-compile"><a href="#内置的multi-compile" class="headerlink" title="内置的multi_compile"></a>内置的multi_compile</h3><p>默认情况前向渲染只支持一个投射阴影的平行光，可以通过multi_compile_fwdbase/fwdadd/fwaddshadows添加多重编译指令编译出不同的Shader变体来处理不同类型的灯光、阴影和灯光贴图。</p><h3 id="实现阴影效果"><a href="#实现阴影效果" class="headerlink" title="实现阴影效果"></a>实现阴影效果</h3><p>（使用Lambert光照模型） 第一个Pass用于渲染平行光、逐顶点、SH的灯光，为平行光产生阴影投射。第二个Pass用于渲染其他逐像素的灯光并为其产生阴影投射。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Shadow&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainColor (&quot;Main Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//平行光投影（还包括逐顶点或SH的灯光渲染）</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;   </span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;   </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : TEXCOORD0;</span><br><span class="line">                float4 vertex : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>) <span class="comment">//使用预定义宏保存阴影坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.normal = v.normal;</span><br><span class="line">                o.vertex = v.vertex;</span><br><span class="line">                TRANSFER_SHADOW(o) <span class="comment">//将阴影纹理坐标装入结构体</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">//世界空间法向量、光照方向、顶点坐标</span></span><br><span class="line">                float3 n = UnityObjectToWorldNormal(i.normal);</span><br><span class="line">                n = <span class="built_in">normalize</span>(n);</span><br><span class="line">                float3 l = WorldSpaceLightDir(i.vertex); <span class="comment">//使用WorldSpaceLightDir计算光照方向而不用WorldSpaceLightPos（只计算平行光）</span></span><br><span class="line">                l = <span class="built_in">normalize</span>(l);</span><br><span class="line">                float4 worldPos = mul(unity_ObjectToWorld,i.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Lambert光照</span></span><br><span class="line">                fixed ndotl = saturate(<span class="built_in">dot</span>(n, l));</span><br><span class="line">                fixed4 color = _LightColor0 * _MainColor * ndotl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//点光源的光照</span></span><br><span class="line">                color.rgb += Shade4PointLights(</span><br><span class="line">                unity_4LightPosX0,unity_4LightPosY0,unity_4LightPosZ0,</span><br><span class="line">                unity_LightColor[<span class="number">0</span>].rgb, unity_LightColor[<span class="number">1</span>].rgb,</span><br><span class="line">                unity_LightColor[<span class="number">2</span>].rgb, unity_LightColor[<span class="number">3</span>].rgb,</span><br><span class="line">                unity_4LightAtten0, worldPos.rgb, n) * _MainColor;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//环境光照</span></span><br><span class="line">                color += unity_AmbientSky;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算阴影系数</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(shadowmask,i,worldPos.rgb);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//阴影合成</span></span><br><span class="line">                color.rgb *= shadowmask;</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他逐像素灯光投影</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardAdd&quot;&#125;</span><br><span class="line">            <span class="comment">//使用相加混合，与上个Pass融合</span></span><br><span class="line">            Blend One One </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;   </span><br><span class="line">                </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : TEXCOORD0;</span><br><span class="line">                float4 vertex : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>) <span class="comment">//使用预定义宏保存阴影坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _MainColor;</span><br><span class="line">            v2f vert (appdata_base v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.normal = v.normal;</span><br><span class="line">                o.vertex = v.vertex;</span><br><span class="line">                TRANSFER_SHADOW(o) <span class="comment">//将阴影纹理坐标装入结构体</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">//世界空间法向量、光照方向、顶点坐标</span></span><br><span class="line">                float3 n = UnityObjectToWorldNormal(i.normal);</span><br><span class="line">                n = <span class="built_in">normalize</span>(n);</span><br><span class="line">                float3 l = WorldSpaceLightDir(i.vertex); <span class="comment">//使用WorldSpaceLightDir计算光照方向而不用WorldSpaceLightPos（只计算平行光）</span></span><br><span class="line">                l = <span class="built_in">normalize</span>(l);</span><br><span class="line">                float4 worldPos = mul(unity_ObjectToWorld,i.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Lambert光照</span></span><br><span class="line">                fixed ndotl = saturate(<span class="built_in">dot</span>(n, l));</span><br><span class="line">                fixed4 color = _LightColor0 * _MainColor * ndotl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//点光源的光照</span></span><br><span class="line">                color.rgb += Shade4PointLights(</span><br><span class="line">                    unity_4LightPosX0,unity_4LightPosY0,unity_4LightPosZ0,</span><br><span class="line">                    unity_LightColor[<span class="number">0</span>].rgb, unity_LightColor[<span class="number">1</span>].rgb,</span><br><span class="line">                    unity_LightColor[<span class="number">2</span>].rgb, unity_LightColor[<span class="number">3</span>].rgb,</span><br><span class="line">                    unity_4LightAtten0, worldPos.rgb,n) * _MainColor;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//环境光照不再计算 上个Pass已做</span></span><br><span class="line">                <span class="comment">//color += unity_AmbientSky;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算阴影系数</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(shadowmask,i,worldPos.rgb);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//阴影合成</span></span><br><span class="line">                color.rgb *= shadowmask;</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot; <span class="comment">//使用Difuuse中的阴影投射Pass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303172304490.png" alt="image-20230317230457449"></p><h2 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h2><p>透明是游戏中经常要用的一种效果，在实时渲染中要实现透明效果，通常会在渲染模型时控制它的透明通道(Alpha Channel)。当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值外，他还有另外一个属性——<code>透明度</code>。当透明度为1时。表示该像素是完全不透明的，而当其为0时，则表示改像素完全不会显示。<br>在Unity中，我们通常使用<code>透明度测试</code>（这种方法其实无法得到真正的的半透明效果）和<code>透明度混合</code>实现透明效果。<br>对于不透明物体，不考虑他们渲染顺序也能得到正确的排序效果，这是由于强大深度缓冲（depth buffer也被称为z-buffer）。<br>在实时渲染中，深度缓冲是用于解决可见性问题的，核心思想：根据深度缓冲中的值来判断该片元距离摄像机的距离，当渲染一个片元时，需要把它的深度值和已经存在与深度缓冲中的值进行比较（如果开启了深度测试），<code>如果它的值距离摄像机更远，则不需要渲染到屏幕（有物体挡住了它），否则这个片元将会覆盖掉此时颜色缓冲中的像素值，并把它的深度值更新到深度缓冲中（如果开启深度写入）。</code><br>但是如果要实现透明效果，当使用透明度混合时，我们关闭了深度写入（ZWrite）。<br>简单来说，透明度测试和透明度混合的基本原理如下。<br><strong>透明度测试</strong><br>只要一个片元的透明度不满足条件，那么它对应的片元就会被舍弃，并且不会再做任何处理，也不会影响颜色缓冲。<code>透明度测试不需要关闭深度写入。</code>只会产生两个结果，要么完全透明看不到，要么完全不透明。<br><strong>透明度混合</strong><br>使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是<code>透明度混合需要关闭深度写入。这是因为，如果不关闭深度写入，一个半透明表面背后的表面本来是可以透过它被我们看到的，但是由于深度测试时判断结果是该半透明表面距离摄像机更近，导致后面的表面将会被剔除，我们也无法通过半透明表面看到后面的物体了。</code><br>透明度混合只关闭了深度写入，没有关闭深度测试，即<code>当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前深度缓冲中的深度值，如果它的深度值距离摄像机更远，就不会进行混合操作</code>。所以，当一个不透明物体出现在一个透明物体前面，而我们先渲染了不透明物体，他仍然可以正常遮挡住透明物体。<br><code>总结：对于透明度混合来说，深度缓冲是只读的。</code></p><h3 id="为什么渲染顺序很重要"><a href="#为什么渲染顺序很重要" class="headerlink" title="为什么渲染顺序很重要"></a>为什么渲染顺序很重要</h3><p>因为透明度关闭了深度写入，如果不保证渲染顺序的话，会导致错误的渲染结果。<br>比如半透明A（离摄像机近），不透明B（离摄相机远），如果先渲染A，不会在深度缓冲区写入数据，但会写入颜色缓冲区。再渲染B，会在深度缓冲区写入深度值，然后写入颜色缓冲区，即覆盖A的颜色，看起来物体B在A前面了。<br>再比如半透明A（离摄像机近），半透明B（离摄像机远），如果先渲染A，不会在深度缓冲区写入数据，但会写入颜色缓冲区。再渲染B，不会在深度缓冲区写入深度值，会与颜色缓冲区中的A进行颜色混合，看起来物体B在A前面了。<br>因此，渲染引擎一般会对物体进行排序，再渲染，常用方法是：<br>先渲染所有不透明物体，并开启他们深度测试和深度写入。<br>把半透明物体按他们距离摄像机远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启他们的深度测试，关闭深度写入。<br>但是如果仅此而已，还是不够的，因为会有一些特殊情况。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182314829.png!webp" alt="img"></p><p>而我们是根据他们离摄像机远近来排序的，而距离摄像机远近依靠的是深度值（像素级，即每个像素都有一个深度值)，但我们现在是对单个物体级进行排序，所以要么A全在B前面，要么A全在B后面。</p><h3 id="Unity-Shader的渲染顺序"><a href="#Unity-Shader的渲染顺序" class="headerlink" title="Unity Shader的渲染顺序"></a>Unity Shader的渲染顺序</h3><p>Unity为了解决渲染顺序的问题，提供了渲染队列（render queue）这一解决方案、我们可以使用SubShader的Queue标签来决定我们模型将归于哪个渲染队列。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308604.png!webp" alt="img"></p><h3 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/AlphaTest&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(&quot;Main Tint&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//决定我们调用clip进行透明度测试时使用的判断条件。</span></span><br><span class="line">        <span class="comment">//它的范围是[0,1]这是因为纹理像素的透明度就是在此范围内。</span></span><br><span class="line">        _Cutoff(&quot;Alpha Cutoff&quot;,Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Queue定义归属渲染队列</span></span><br><span class="line">        <span class="comment">//IgnoreProjector为true表示这个Shader不会受到投影器影响</span></span><br><span class="line">        <span class="comment">//RenderType可以让Unity把这个Shader归入到提前定义的组</span></span><br><span class="line">        Tags &#123; &quot;Queue&quot; = &quot;AlphaTest&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;TransparentCutout&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭剔除，可以看到背面</span></span><br><span class="line">        Cull Off</span><br><span class="line"> </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//定义光照模式</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f vert (a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//把顶点位置从模型空间转换到裁剪空间中</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//计算出世界空间法线方向</span></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal (v.normal);</span><br><span class="line">                <span class="comment">//计算出世界空间顶点位置</span></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                <span class="comment">//计算经过平铺和偏移后的纹理坐标</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                <span class="comment">//对纹理进行采样</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex,i.uv);</span><br><span class="line">                <span class="comment">//会判断texColor.a - _Cutoff是否为负，如果是就会舍弃该片元的输出</span></span><br><span class="line">                <span class="comment">//当texColor.a小于材质参数_Cutoff时，该片元就会产生完全透明的效果</span></span><br><span class="line">                clip(texColor.a - _Cutoff);</span><br><span class="line">                <span class="comment">//得到环境光</span></span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">//计算高光反射</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">//计算漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo*<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(worldNormal,worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse,<span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308713.png!webp" alt="img"></p><h3 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h3><p>为了进行混合，我们需要使用Unity提供的混合命令——Blend。Blend是Unity提供的设置混合模式的命令。想要实现半透明效果就需要把当前自身的颜色和已经存在于颜色缓冲中的颜色值进行混合。混合时使用的函数就是由该指令决定的。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308808.png!webp" alt="img"></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/AlphaBlend&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//_AlphaScale用于在透明纹理的基础上控制整体的透明度</span></span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Queue定义归属渲染队列，因为是透明度混合，所以是Transparent队列</span></span><br><span class="line">        <span class="comment">//IgnoreProjector为true表示这个Shader不会受到投影器影响</span></span><br><span class="line">        <span class="comment">//RenderType可以让Unity把这个Shader归入到提前定义的组</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭剔除，可以看到背面</span></span><br><span class="line">        Cull Off</span><br><span class="line"> </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//定义光照模式</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">            <span class="comment">//关闭深度写入</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            <span class="comment">//将该片元着色器产生的颜色混合因子设置为SrcAlpha</span></span><br><span class="line">            <span class="comment">//将已经存在与颜色缓冲中的颜色混合因子设置为OneMinusSrcAlpha</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f vert (a2v v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//把顶点位置从模型空间转换到裁剪空间中</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//计算出世界空间法线方向</span></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal (v.normal);</span><br><span class="line">                <span class="comment">//计算出世界空间顶点位置</span></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                <span class="comment">//计算经过平铺和偏移后的纹理坐标</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                <span class="comment">//对纹理进行采样</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex,i.uv);</span><br><span class="line">                <span class="comment">//得到环境光</span></span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">//计算高光反射</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">//计算漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo*<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(worldNormal,worldLightDir));</span><br><span class="line">                <span class="comment">//设置片元着色器返回值的透明通道</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse,texColor.a*_AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308888.png!webp" alt="img"></p><p>但是会有一种情况，得到错误的渲染结果</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308973.png!webp" alt="img"></p><h3 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h3><p>为了解决上述问题，我们通常使用两个Pass进行渲染，第一个Pass开启深度写入，但不输出颜色，它的目的仅仅是为了把模型的深度值写入深度缓冲中，第二个Pass进行正常的透明度混合，由于上一个Pass已经得到了逐像素的正确的深度信息，该Pass就可以按照像素级别的深度排序结果进行透明渲染。但是<code>这样会消耗一定的额外性能</code>。</p><h3 id="ShaderLab的混合命令"><a href="#ShaderLab的混合命令" class="headerlink" title="ShaderLab的混合命令"></a>ShaderLab的混合命令</h3><p>混合的实现原理：当片元着色器产生一个颜色时，可以选择与颜色缓存中的颜色进行混合，然后重新写入颜色缓冲。（注意，我们平时谈论混合中的颜色都是RGBA四个通道的）。<br>在Unity中，当我们使用Blend（Blend Off命令除外）时，除了设置混合状态外，也开启了混合，但是<code>在其他图形API中我们是需要手动开启的</code>。</p><h4 id="混合等式和参数"><a href="#混合等式和参数" class="headerlink" title="混合等式和参数"></a>混合等式和参数</h4><p>混合是一个逐片元操作，而且他是不可编程的，但却是高度可配置的。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308221.png!webp" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308248.png!webp" alt="img"></p><h4 id="混合操作"><a href="#混合操作" class="headerlink" title="混合操作"></a>混合操作</h4><p>当把原颜色和目标颜色与他们对应的混合因子相乘后，我们都是把他们的结果加起来作为输出颜色的。我们也可以使用别的混合操作：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308272.png!webp" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308425.png!webp" alt="img"></p><p>混合操作命令通常是与混合因子命令一起工作的。但需要注意的是，当使用Min或Max混合操作时，混合因子实际上是不起任何作用的，他们仅仅会判断原始的源颜色和目的颜色之间的比较结果。</p><h4 id="常见的混合类型"><a href="#常见的混合类型" class="headerlink" title="常见的混合类型"></a>常见的混合类型</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303182308504.png!webp" alt="img"></p><h3 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h3><p>和透明度测试相比。想让透明度混合实现双面渲染会更加复杂一点，这是因为关闭了深度写入。如果我们仍然直接关闭剔除功能，那么我们就无法保证同一个物体的正面和背面图元的渲染顺序。<code>就有可能得到错误的半透明效果。</code><br>为此我们把双面渲染工作分成两个Pass——第一个Pass只渲染背面，第二个Pass只渲染正面，我们可以保证背面总是在正面被渲染前渲染，从而保证正确的深度渲染关系。</p><h1 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h1><p><strong>PBR</strong>是 <strong>Physically Based Rendering</strong>的简称，也就是图形渲染中的真实感渲染，简单理解就是基于物理的渲染技术，但它只是对现实世界物理的一种近似，并非完全的物理渲染，与之前学习的NPR属于完全不同的两种渲染理念，PBR是以基于<strong>微平面理论</strong>，<strong>能量守恒</strong>，以及物理的<strong>BRDF</strong>为核心的渲染理念。</p><h2 id="微平面理论"><a href="#微平面理论" class="headerlink" title="微平面理论"></a>微平面理论</h2><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171807512.png" alt="img"></p><p>简单来说就是物体表面持续放大至微观尺度后，任何平面都是由 无数微小的无序随机朝向的镜面组成。</p><p>平面越是粗糙，这个平面上的微平面的排列就越混乱，平面越是光滑，光线大体上会更趋向于同一个方向反射，形成更小更锐利的反射。</p><p>其实在微观尺度下，没有任何平面是完全光滑的。但由于这些微平面已经微小到无法逐像素继续进行区分，因此会假设一个粗糙度参数，然后用统计学的方法来估算微平面的粗糙程度，通过这个粗糙度计算出某个向量的方向，与微平面平均取向的一致性。</p><p>一般粗糙度越高的显示出来的镜面反射的轮廓要更大一些，相反则会更小更锐利。在实际的PBR 中，这种物体表面的不规则性一般会用粗糙度贴图或者高光度贴图来表示~</p><h2 id="能量守恒"><a href="#能量守恒" class="headerlink" title="能量守恒"></a>能量守恒</h2><p>说白了就是反射光的能量永远不能超过入射光的能量，为了遵守能量守恒定律，通常我们会对漫反射光和镜面反射光之间做出明确的区分。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171808677.png" alt="img"></p><p>在PBR中，镜面光指的就是光线射入物体表面时所反射的那部分能量，而漫反射光则是指光线进入物体后再均匀的发散出来的那部分能量。当光线碰撞到一个表面的时候，一部分能量被反射，另一部分能量进入物体内部。</p><p>不过不同的材质表面它的反射细节也会有所不同，通常会分为金属和非金属材质，其中金属表面由于有自由电子，所以进入表面的能量会被完全吸收。而非金属表面由于没有自由电子，进入表面的能量有一部分会被均匀的释放出来，所以金属度低，但是完全光滑的物体，不会呈现金属那样的镜面效果，而是带有自身的颜色晕染。</p><h2 id="菲涅尔现象"><a href="#菲涅尔现象" class="headerlink" title="菲涅尔现象"></a>菲涅尔现象</h2><p>一般来说漫反射光和镜面反射光之间都是受菲涅尔参数所控制，通过菲涅尔我们可以根据观察的角度得到被反射的能量所占的百分比。利用这个反射比率和能量守恒原则，可以直接得出光线进入物体的部分以及光线剩余的能量。</p><p>菲涅尔表示的是看到的光线的反射率与视角相关的现象，视线垂直于表面时反射较弱，而当视线与表面夹角越小时，反射越明显。</p><p>这就好比我们平时拿吸管插奶茶杯一样，物体的表面就可以看作是奶茶杯的那层膜，光线的光子可以看作是吸管，当你越是斜着插的时候 吸管就越容易被弹开 ， 很难插进去，而当你越是竖着插的时候，吸管也就越容易进去。这也就是所谓的菲涅尔现象。</p><p>而光线的能量进入物体之后会有不同的释放形式</p><ul><li>对于金属表面来说，能量进去后，会全部吸收掉。</li><li>而对于非金属表面来说，能量进去后，只会吸收一部分，余下的部分则会被释放。</li><li>对于玉石这类 次表面 散射的 材质来说，能量进去后，会吸收一部分，而余下的能量会从正面出来一部分，从侧面也漏出来一部分。</li><li>对于玻璃这类透明的材质来说，能量进去后，吸收的部分很少，正面出来也很少，基本都会从另一面出来。</li></ul><h2 id="真实感光照"><a href="#真实感光照" class="headerlink" title="真实感光照"></a>真实感光照</h2><p>PBR的光照不止是直接光，如果只是直接光，那PBR渲染出来的画面，其实和以前并没有多少明显的进步。通常我们会通过叠加计算直接光和间接光得到最终的光照结果，这个结果被称为全局光照，也就是常听到的GI。</p><p>说白点就是通过模拟光线的传播路径，将物体反射的间接光纳入计算，从而提高画面的真实感。直接光就是光线从光源直接照射到物体表面上的光，而间接光则是光线经过多次弹射到物体表面上的光。不过因为我们无法完全模拟现实中如此复杂的物理环境，像如阳光的大气折射与场景弹射次数和质量等，所以通常会加入环境光去做近似模拟。</p><p>这也是PBR中比较重要的光照部分 - IBL 也就是基于图像的光照。它会把周围的环境颜色完整的保存到一张贴图上，PBR材质会把这个贴图当作光源来进行采样，通过一系列的公式计算得到最终的环境光。如果是金属材质，并且粗糙度比较低，他就能够近乎完整的映射出周围的环境的镜像倒影。不过IBL不处理多次反射，它只是单纯的把环境贴图当成了光源的预积分，这里不做过多赘述，有个大致概念即可。</p><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p>学术一点的叫法就是双向反射分布函数，通过入射光方向，反射光方向，平面法线以及微平面粗糙程度作为函数的输入参数，求出最终反射光的强度。</p><p>其实我们之前做的Blinn-Phone也可以看作是一个BRDF，但由于Blinn-Phong并没有遵循能量守恒的定律，所以它不被认为是基于物理的渲染。</p><p>在早期 PBR模型包含了众多复杂的物理属性，学习成本高、不易于理解，后来在SIGGRAPH 2012，迪士尼提出了Disney BRDF <a target="_blank" rel="noopener" href="https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf">s2012_pbs_disney_brdf_notes_v3.pdf (disneyanimation.com)</a> ，它把众多复杂的物理属性简化成更少更为直观的属性，以极高的易用性、便捷性正式进入了大众的视野，逐渐在业界内被广泛应用，可以说是PBR史上的里程碑。</p><p>Unity基于Disney BRDF的启发在GDC 2014 推出了Physically Based Shading in Unity <a target="_blank" rel="noopener" href="https://aras-p.info/texts/files/201403-GDC_UnityPhysicallyBasedShading_notes.pdf">201403-GDC_UnityPhysicallyBasedShading.key (aras-p.info)</a> ，将传统的渲染工作流升级为基于物理的渲染工作流，美术同学只需要调节Unity内置的Standard Shader，就可以实现绝大多数常见的材质。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171814378.png" alt="img"></p><p>那最终Disney BRDF得到了1个颜色参数以及10个标量参数，颜色参数就是 <strong>BaseColor</strong> 表面颜色，通常由纹理贴图提供</p><p><strong>Subsurface</strong>：使用 次表面近似 控制 漫反射的形状</p><p><strong>Metallic</strong>：金属与非金属两种不同模型之间的线性混合。金属模型没有漫反射的成分</p><p><strong>Specular</strong>：一般用来控制镜面反射的强度</p><p><strong>SpecularTint</strong>：镜面反射的颜色啦，不过这个相对过时，通常很少有对美术控制的让步，一般会用于对基础色的入射镜面反射，进行颜色的控制。</p><p><strong>Roughness</strong>：用来控制表面的粗糙度啦</p><p><strong>Anisotropic</strong>：各向异性的强度，主要用于头发啊金属之类的材质</p><p><strong>Sheen &amp; SheenTint</strong>：控制的是光泽的强度和颜色，一般会用于布料</p><p><strong>Clearcoat &amp; ClearcoatGloss:</strong> 则是清漆强度和光泽度，平时用到的很少，知道有这么个东西就好啦</p><h2 id="Standard-Shader"><a href="#Standard-Shader" class="headerlink" title="Standard Shader"></a>Standard Shader</h2><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303171812041.png" alt="image-20230317181247011"></p><p><strong>RenderingMode</strong>：控制的是物体的渲染模式，简单理解就是设定物体是透明的渲染模式还是不透明的渲染模式</p><p><strong>Albedo</strong>：其实就是材质的基础固有色，你可以给它一张纹理贴图也可以选择单色，当你选择纹理贴图的时候这个调色板则为纹理之上的叠加色</p><p><strong>Metallic &amp; Smoothness</strong>：这里则是用来控制材质的金属度和光滑度，金属度只是决定了物体最终渲染的结果是以高光为主，还是漫反射为主。而光滑度则是决定了物体的高光部分是否清晰。通常来说不使用贴图的话材质只能具有单一的金属度，这并不理想，毕竟同一个物体表面 可能会具有不同的表面特性，那这里如果你选择了金属度贴图，这里的滑动条会直接隐藏掉，通过贴图所存储的 金属度信息来进行采样计算。光滑度的概念其实和我们之前所提的的粗糙度大同小异，反过来了而已。</p><p><strong>Source</strong>：可以理解为就是选择光滑贴图，它的数据可以来源于金属贴图，也可以是色彩贴图，这就根据美术来定啦~</p><p><strong>NormalMap</strong>：法线贴图，它属于凹凸贴图的一种，通常用来给模型增加一些微小的凸起、凹槽和划痕等细节，在逐像素计算光照时，每个像素都会根据该点的法向量来计算最终该点的光照结果，可以通过法线贴图，改变这个点法线方向，影响它的光照结果，进而影响模型表面凹凸感。</p><p><strong>HeightMap</strong>：视差贴图，又可以称之为高度贴图，是法线贴图的改进版，属于一个经常被忽略的高级功能。大家都知道法线，可以将一个平面做成凹凸不平的效果，但是当视角方向水平于该平面的时候，理论上凸起的部分会遮挡住后面的部分，而法线贴图却没有这个效果，但是高度贴图，就可以。那原理呢，就是根据该点的高度以及该点指向摄像机的向量，计算出一个UV偏移，来影响之后的采样。</p><p><strong>Occlusion</strong>：环境光遮蔽贴图，通常又会叫AO贴图，在PBR中计算光照的时候，一般直接通过采样IBL来得到环境光，这个环境光是该点上一个半球上的积分。但是因为自身的之间会有凹凸，在凹陷的地方，环境光会被周围给遮挡，所以看起来并不是那么亮，通过AO贴图我们可以让调整环境光的大小，从而达到更真实的效果。</p><p><strong>Emission</strong>：材质的自发光属性，通常用于控制从表面发出的光的颜色和强度，用的比较多的地方像如霓虹灯、LED屏幕等等。</p><p><strong>Tiling &amp; Offset</strong>：控制的则是以上所有贴图的Tiling Offset</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://liuyingbo.com">刘英博</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://liuyingbo.com/posts/9fa0374.html">https://liuyingbo.com/posts/9fa0374.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://liuyingbo.com" target="_blank">狼唤</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/Shader/">Shader</a></div><div class="post_share"><div class="social-share" data-image="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192022487.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b6d0915c.html"><img class="prev-cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192048985.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity-底层原理</div></div></a></div><div class="next-post pull-right"><a href="/posts/6739242f.html"><img class="next-cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192048985.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity-简易对象池</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/d1e0.html" title="Unity-Dots"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202304101313250.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">Unity-Dots</div></div></a></div><div><a href="/posts/undefined.html" title="Unity-全局屏幕点击特效"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192048985.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-14</div><div class="title">Unity-全局屏幕点击特效</div></div></a></div><div><a href="/posts/b6d0915c.html" title="Unity-底层原理"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192048985.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-12</div><div class="title">Unity-底层原理</div></div></a></div><div><a href="/posts/6739242f.html" title="Unity-简易对象池"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192048985.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-01</div><div class="title">Unity-简易对象池</div></div></a></div><div><a href="/posts/cffbee7c.html" title="Unity-编辑器扩展"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192048985.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-29</div><div class="title">Unity-编辑器扩展</div></div></a></div><div><a href="/posts/ba9e7782.html" title="Unity-网络开发（三）"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192048985.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-14</div><div class="title">Unity-网络开发（三）</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211100000064.JPG" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">刘英博</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/liuyingbor" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gitHub"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=liuyingbo666@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/11929004" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=594686596&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ1"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Mesh"><span class="toc-number">1.</span> <span class="toc-text">Mesh</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">2.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="toc-number">2.1.</span> <span class="toc-text">渲染管线</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shader"><span class="toc-number">3.</span> <span class="toc-text">Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E4%B8%AD%E7%9A%84Shader%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">Unity中的Shader类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShaderLab"><span class="toc-number">3.2.</span> <span class="toc-text">ShaderLab</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ShaderLab%E8%AF%AD%E6%B3%95%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="toc-number">3.2.1.</span> <span class="toc-text">ShaderLab语法详细解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E7%AE%80%E5%8C%96Shader%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.2.</span> <span class="toc-text">使用结构体简化Shader代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%88in-out%EF%BC%89"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">无返回值（in,out）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">有返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Include%E2%80%9DUnityCG-cginc%E2%80%9D%E7%AE%80%E5%8C%96Shader"><span class="toc-number">3.2.3.</span> <span class="toc-text">使用Include”UnityCG.cginc”简化Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#normalize"><span class="toc-number">3.2.4.</span> <span class="toc-text">normalize</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%85%A7"><span class="toc-number">3.3.</span> <span class="toc-text">光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambert%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">Lambert模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HalfLambert%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">HalfLambert模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Phong%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">Phong光照模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blinn-Phong"><span class="toc-number">3.3.4.</span> <span class="toc-text">Blinn-Phong</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E5%83%8F%E7%B4%A0%E5%85%89%E7%85%A7"><span class="toc-number">3.3.5.</span> <span class="toc-text">逐像素光照</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1"><span class="toc-number">3.4.</span> <span class="toc-text">阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E7%9A%84%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">Unity的渲染路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E7%9D%80%E8%89%B2%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">3.4.2.</span> <span class="toc-text">延迟着色渲染路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">3.4.3.</span> <span class="toc-text">前向渲染路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PassFlags%E6%A0%87%E7%AD%BE"><span class="toc-number">3.4.4.</span> <span class="toc-text">PassFlags标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84multi-compile"><span class="toc-number">3.4.5.</span> <span class="toc-text">内置的multi_compile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C"><span class="toc-number">3.4.6.</span> <span class="toc-text">实现阴影效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">3.5.</span> <span class="toc-text">透明效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E5%BE%88%E9%87%8D%E8%A6%81"><span class="toc-number">3.5.1.</span> <span class="toc-text">为什么渲染顺序很重要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity-Shader%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">Unity Shader的渲染顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">3.5.3.</span> <span class="toc-text">透明度测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88"><span class="toc-number">3.5.4.</span> <span class="toc-text">透明度混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%B7%B1%E5%BA%A6%E5%86%99%E5%85%A5%E7%9A%84%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">3.5.5.</span> <span class="toc-text">开启深度写入的半透明效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ShaderLab%E7%9A%84%E6%B7%B7%E5%90%88%E5%91%BD%E4%BB%A4"><span class="toc-number">3.5.6.</span> <span class="toc-text">ShaderLab的混合命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%AD%89%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0"><span class="toc-number">3.5.6.1.</span> <span class="toc-text">混合等式和参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.6.2.</span> <span class="toc-text">混合操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.6.3.</span> <span class="toc-text">常见的混合类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">3.5.7.</span> <span class="toc-text">双面渲染的透明效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PBR"><span class="toc-number">4.</span> <span class="toc-text">PBR</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%B9%B3%E9%9D%A2%E7%90%86%E8%AE%BA"><span class="toc-number">4.1.</span> <span class="toc-text">微平面理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E9%87%8F%E5%AE%88%E6%81%92"><span class="toc-number">4.2.</span> <span class="toc-text">能量守恒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8F%B2%E6%B6%85%E5%B0%94%E7%8E%B0%E8%B1%A1"><span class="toc-number">4.3.</span> <span class="toc-text">菲涅尔现象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9E%E6%84%9F%E5%85%89%E7%85%A7"><span class="toc-number">4.4.</span> <span class="toc-text">真实感光照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BRDF"><span class="toc-number">4.5.</span> <span class="toc-text">BRDF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Standard-Shader"><span class="toc-number">4.6.</span> <span class="toc-text">Standard Shader</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d1e0.html" title="Unity-Dots"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202304101313250.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-Dots"></a><div class="content"><a class="title" href="/posts/d1e0.html" title="Unity-Dots">Unity-Dots</a><time datetime="2023-04-10T13:10:43.000Z" title="发表于 2023-04-10 13:10:43">2023-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/29f6.html" title="Unity-移动端屏幕适配"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242151718.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-移动端屏幕适配"></a><div class="content"><a class="title" href="/posts/29f6.html" title="Unity-移动端屏幕适配">Unity-移动端屏幕适配</a><time datetime="2023-04-10T06:08:54.267Z" title="发表于 2023-04-10 06:08:54">2023-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7c40.html" title="Unity-性能优化"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303052044934.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-性能优化"></a><div class="content"><a class="title" href="/posts/7c40.html" title="Unity-性能优化">Unity-性能优化</a><time datetime="2023-03-05T21:31:20.000Z" title="发表于 2023-03-05 21:31:20">2023-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/66fe.html" title="Unity-移动端打包记录（持续更新）"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202303052044934.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-移动端打包记录（持续更新）"></a><div class="content"><a class="title" href="/posts/66fe.html" title="Unity-移动端打包记录（持续更新）">Unity-移动端打包记录（持续更新）</a><time datetime="2023-03-05T20:34:23.000Z" title="发表于 2023-03-05 20:34:23">2023-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4ac7.html" title="C# LINQ"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191917907.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="C# LINQ"></a><div class="content"><a class="title" href="/posts/4ac7.html" title="C# LINQ">C# LINQ</a><time datetime="2022-11-24T22:49:16.000Z" title="发表于 2022-11-24 22:49:16">2022-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 刘英博</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.liuyingbo.com/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.liuyingbo.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/title.js"></script><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true"></div><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script></body></html>