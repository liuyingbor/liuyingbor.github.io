<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>IOC | 狼唤</title><meta name="author" content="刘英博"><meta name="copyright" content="刘英博"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介IOC简介IOC全称为Invertuon Of Control，也就是控制反转。控制反转是一种设计思想。而不是具体的技术。IOC这种设计思想有很多方式实现，最常见的实现方式就是DI。 DI简介DI的全称是Dependency Injection，也就是依赖注入，是IOC思想的一种实现。 依赖什么是依赖？看下面这段代码： 1234public class A&amp;#123;  public B b"><meta property="og:type" content="article"><meta property="og:title" content="IOC"><meta property="og:url" content="https://liuyingbo.com/posts/183e2cbd.html"><meta property="og:site_name" content="狼唤"><meta property="og:description" content="简介IOC简介IOC全称为Invertuon Of Control，也就是控制反转。控制反转是一种设计思想。而不是具体的技术。IOC这种设计思想有很多方式实现，最常见的实现方式就是DI。 DI简介DI的全称是Dependency Injection，也就是依赖注入，是IOC思想的一种实现。 依赖什么是依赖？看下面这段代码： 1234public class A&amp;#123;  public B b"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191859764.jpg"><meta property="article:published_time" content="2022-01-15T16:09:32.000Z"><meta property="article:modified_time" content="2022-11-19T11:08:28.052Z"><meta property="article:author" content="刘英博"><meta property="article:tag" content="IOC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191859764.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liuyingbo.com/posts/183e2cbd"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"IOC",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-11-19 11:08:28"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="css/color.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="狼唤" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211100000064.JPG" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-comment-dots"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191859764.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">狼唤</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-comment-dots"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">IOC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-15T16:09:32.000Z" title="发表于 2022-01-15 16:09:32">2022-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-19T11:08:28.052Z" title="更新于 2022-11-19 11:08:28">2022-11-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="IOC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="IOC简介"><a href="#IOC简介" class="headerlink" title="IOC简介"></a>IOC简介</h2><p>IOC全称为Invertuon Of Control，也就是控制反转。<br>控制反转是一种设计思想。而不是具体的技术。<br>IOC这种设计思想有很多方式实现，最常见的实现方式就是DI。</p><h2 id="DI简介"><a href="#DI简介" class="headerlink" title="DI简介"></a>DI简介</h2><p>DI的全称是Dependency Injection，也就是依赖注入，是IOC思想的一种实现。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>什么是依赖？看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">  public B b = new B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中就是A依赖B。<br>我再这里理解为，A对象里面持有B对象，如果B对象不存在，那么A就无法成立，所以是A对象依赖B。</p><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>什么是注入呢？看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">  public B b = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B &#123;&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  var a = new A();</span><br><span class="line">  var b = new B();</span><br><span class="line"></span><br><span class="line">  a.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出总共有两个对象，分别是a和b。可以看出现在的A对象是依赖B对象的。<br><strong>a.b=b;</strong>这句代码就是将b对象注入到a对象的b成员中。<br>有时候可以把注入就理解成设置值。<br>依赖注入也就是吧某个对象依赖的对象进行赋值。</p><h1 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h1><h2 id="QF中的IOC"><a href="#QF中的IOC" class="headerlink" title="QF中的IOC"></a>QF中的IOC</h2><p>QF是一种框架，是作者最近正在学习的一种框架，这个框架不要求会，我们就拿QF中的DI来进行详细的了解一下DI。<br>我们在使用DI方案的时候一般都离不开DI容器这个概念。育德时候DI容易也叫做IOC容器。就是：DIContainer 和 IOCContainer。<br>下面我们来看看QF中是如何使用IOC的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace QF.Master.Example</span><br><span class="line">&#123;    </span><br><span class="line"></span><br><span class="line">    public class ServiceA</span><br><span class="line">    &#123;</span><br><span class="line">        public void Say()</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;I am ServiceA:&quot; + this.GetHashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class IOCExample : MonoBehaviour </span><br><span class="line">    &#123;</span><br><span class="line">        // 声明为需要注入的对象</span><br><span class="line">        [Inject] </span><br><span class="line">        public ServiceA A &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        void Start () </span><br><span class="line">        &#123;</span><br><span class="line">            // 创建实例容器</span><br><span class="line">            var container = new QFrameworkContainer();</span><br><span class="line"></span><br><span class="line">            // 注册类型</span><br><span class="line">            container.Register&lt;ServiceA&gt;();</span><br><span class="line"></span><br><span class="line">            // 注入对象（会自动查找 Inject Atrributet的对象)</span><br><span class="line">            container.Inject(this);</span><br><span class="line"></span><br><span class="line">            // 注入之后，就可以直接使用 A 对象了</span><br><span class="line">            A.Say();        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是完整的案例，我们只要仔细看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建实例容器</span><br><span class="line">var container = new QFrameworkContainer();</span><br><span class="line"></span><br><span class="line">// 注册类型</span><br><span class="line">container.Register&lt;ServiceA&gt;();</span><br><span class="line"></span><br><span class="line">// 注入对象（会自动查找 Inject Atrributet的对象)</span><br><span class="line">container.Inject(this);</span><br><span class="line"></span><br><span class="line">// 注入之后，就可以直接使用 A 对象了</span><br><span class="line">A.Say();</span><br></pre></td></tr></table></figure><p>首先我们创建了一个容器，并且在容器里注册了一个ServiceA对象。这些其实都是可以自己写一个脚本进行封装的。<br>接下来我们来看注入：<strong>container.Inject(this);</strong>这句就是注入对象，注入的就是刚才注册的对象。<br>接下来我们就可以使用this对象里的ServiceA对象了，为啥注入到A对象了，这里是框架给设计好了，只要在对应的对象上面添加[Inject]就代表是需要注入的对象。注入的时候就会对其进行赋值。<br>我们可以看下面的图进行理解：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902943.png" alt="img"></p><p>这是QF框架中的使用方法，我们不用会这种方法，因为只是针对QF框架的，我们学习的是IOC的这种思想。</p><h2 id="DI容器的强大之处"><a href="#DI容器的强大之处" class="headerlink" title="DI容器的强大之处"></a>DI容器的强大之处</h2><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><p>一般情况下DI容器会提供如下的API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注册类型：Register&lt;TSource,TTarget&gt;</span><br><span class="line">注入:Inject(object obj)</span><br><span class="line">解析:Resolve&lt;T&gt;()</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>注册和注入在刚才代码中已经有体现了。<br>在 DI Container 中，Resolve 实际上是根据类型返回实例。<br>DI容器的职责很简单，就是管理依赖和注入依赖。<br>DI容器中的容器代表的就是存储依赖的容器，容器里面装的就是依赖。<br>一般的DI容器利用的其实就是Dictonary<type ,object>来作为核心数据结构。<br>根据Type就可以得到依赖的对象，然后通过Inject注入到对象中。</type></p><h3 id="强大之处"><a href="#强大之处" class="headerlink" title="强大之处"></a>强大之处</h3><p>有了单例这个工具，当我们需要写一个独立模块的时候，很容易用单例就实现了。而且通过单例（或静态类）实现的独立模块，与其他模块之间的交互会变得非常容易。<br>这种结构好于直接撸的结构，毕竟它有一定的扩展性（只需实现单例），维护性上也还可以（模块独立），但是它很容易达到瓶颈，尤其是当单例的数量逐渐随着项目变多的时候。<br>因为单例的获取是没有限制的，任何层级的代码都可以获取到任何层级的单例，如下图示：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902488.png" alt="img"></p><p>虽然我们在预定上分了很多层，但是当我们的模块数量超过一定数量时，约定就很难遵循，因为我们访问模块的时候就需要去看一遍层级的示意图：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902548.png" alt="img"></p><p>这就造成项目达到一定规模，约定就变成了限制，让我们很难遵循。<br>从约定上，来说，我们怎么约定都可以，而约定的图示，就是上边的图。那些分层都是一些抽象的概念，比如游戏流程、主逻辑层、业务模块、框架层、底层，这些都是约定的结构。一般都是存在于文档上，并不会通过技术手段表达。<br>而从技术限制这个角度来说，单例的访问是没有限制的，就算是用最佳实践，也是没有限制的。而且单例难以表达约定上的分层的那些概念，因为只要一个模块变成单例了，那么这个模块就在技术上失去了层次关系。<br>如下图：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902306.png" alt="img"></p><p>如图所示，在使用单例的时候蓝牙和商店模块就在同一层级了，就失去了层级的约定。<br>使用单例时，项目结构的设计非常依赖于约定（文档等等）。<br>在项目规模比较少的时候，是没问题的，因为模块数量也比较少，但是一旦项目规模变大，模块数量变多，那么约定就会越来越难以遵循，就会非常容易导致项目结构的崩溃。<br>这个时候，有一种很简单的解决方式，就是最顶层模块都用单例，然后一些底层的模块，作为顶层的成员变量，从而达到逻辑层无法直接访问底层模块，而是必须通过顶层模块间接地使用底层模块服务。<br>如下图：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902290.png" alt="img"></p><p>这样就解决了单例结构无法表达层级的问题，但是同时也失去了单例带来的种种好处，比如易扩展，维护性（模块独立）。<br>现在不容易扩展模块了，因为要扩展模块需要考虑依赖关系，也不容易维护了，因为模块不独立了。<br>而这里不容易维护指的是各个模块不容易单独维护了，但是整体项目会更容易维护。<br>接下来就体现DI Container 的作用了，它的出现可以让各个模块容易维护，也容易扩展，同时让整个项目也同样容易维护，而且可以通过技术限制来分担一部分约定。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>从上面解决单例问题的图我们可以看到，有大量的依赖关系，这个依赖关系我们可以理解成对象的持有或者变量。<br>就是因为这些依赖关系，造成了此结构的维护性和扩展性降低了。因为模块本身也是对象，对象就有声明周期，那么对象和是去new就很重要。<br>我们来看看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public  class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB ModuleB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ModuleB</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以知道ModuleA是依赖ModuleB，这样我们在使用ModuleA的时候要考虑A中ModuleB是不是有值。<br>创建ModuleB我们可以考虑在ModuleA内部创建和外部创建两种情况：</p><h3 id="在ModuleA内部创建"><a href="#在ModuleA内部创建" class="headerlink" title="在ModuleA内部创建"></a>在ModuleA内部创建</h3><p>看下列代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public  class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB ModuleB = new ModuleB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式也很简单，创建ModuleA的时候ModuleB一定被创建了，但是此时的ModuleB是比较难共用的。</p><h3 id="在ModuleA外部创建"><a href="#在ModuleA外部创建" class="headerlink" title="在ModuleA外部创建"></a>在ModuleA外部创建</h3><p>看下列代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  var moduleA = new ModuleA();</span><br><span class="line">  moduleA.ModuleB = new ModuleB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来没问题，因为在外部创建过程中，我们非常清晰地知道，moduleA.ModuleB 是有实例的。 但是我们看下在 ModuleA 内部使用 ModuleB 时的情况，代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB ModuleB;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  void XXX()</span><br><span class="line">  &#123;</span><br><span class="line">    ModuleB. // 在这里会想 ModuleB 到底有没有值？在哪里设置的值？</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看看单例的解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  void XXX()</span><br><span class="line">  &#123;</span><br><span class="line">    ModuleB.Instance.DoSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不用考虑ModuleB的创建过程。<br>现在这种结构就是有大量的依赖，不易维护不易扩展也都出现在这个依赖上，因为依赖要考虑依赖对象的创建过程。</p><h3 id="使用-DI-Container-管理依赖"><a href="#使用-DI-Container-管理依赖" class="headerlink" title="使用 DI Container 管理依赖"></a>使用 DI Container 管理依赖</h3><p>利用DI代码就变成下面的方式了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  [Inject]</span><br><span class="line">  public ModuleB ModuleB &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">  void XXX()</span><br><span class="line">  &#123;</span><br><span class="line">    ModuleB.DoSomeThing(); // 放心用，因为不用考虑依赖的创建过程。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要在启动程序的时候进行注册：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static QFrameworkContainer Container &#123;get;private set;&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  Container = new Contaner();</span><br><span class="line"></span><br><span class="line">  Container.Register&lt;ModuleB&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们在创建ModuleA的时候需要注入对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void MethodA()</span><br><span class="line">&#123;</span><br><span class="line">  App.Container.Inject(new ModuleA());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 DIContainer之后我们的结构就变成了下图所示：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902598.png" alt="img"></p><p>我们只需要，在模块内部声明模块作为变量，而不需要考虑创建过程，这样就导致每个模块都是可独立测试的（易维护），而扩展一个模块，不需要用单例实现，而是注册到类型容器即可，扩展性比单例还容易。这就是 DI Container 的最核心的优势。</p><h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><p>我们来了解DIContainer 的一个基础知识：域</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>域这个概念我们在学习C#的时候接触过，域的俗称就是代码块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class A</span><br><span class="line">// 类范围内的域</span><br><span class="line">&#123;</span><br><span class="line">  public void Main()</span><br><span class="line">  // 方法范围内的域</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码的注释就可以看出，代码块其实就是域<br>C# 的域的特性就是内部的域中的代码可以调用外部域中的变量。</p><h2 id="DIContainer中的域"><a href="#DIContainer中的域" class="headerlink" title="DIContainer中的域"></a>DIContainer中的域</h2><p>首先我们要考虑一个问题，每次DIContainer在注入实例的时候，注入的是新的还是返回的同一个实例呢？<br>而这个问题所描述的行为指的是 DIContainer 的域。<br>我们来看看QF中是如何注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当注册依赖时，使用 Register&lt;Type&gt;() 方法时，每次注入都会创建新的实例。</span><br><span class="line">当注册依赖时，使用 RegisterInstance(object obj) 方法时，每次注入都会使用 obj 实例。</span><br></pre></td></tr></table></figure><p>我们来看看演示的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace QF.Master.Example</span><br><span class="line">&#123;</span><br><span class="line">    public class SomeService </span><br><span class="line">    &#123;</span><br><span class="line">        public void Description()</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;SomeService:&quot; + this.GetHashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class SomeObject</span><br><span class="line">    &#123;</span><br><span class="line">        public void Description()</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;SomeObject:&quot; + this.GetHashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class IOCScopeExample : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeObject ObjA &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeObject ObjB &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeObject ObjC &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeService ServiceA &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeService ServiceB &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        void Start () </span><br><span class="line">        &#123;</span><br><span class="line">            var container = new QFrameworkContainer();</span><br><span class="line"></span><br><span class="line">            // 每次注入都创建新的实例</span><br><span class="line">            container.Register&lt;SomeObject&gt;();</span><br><span class="line"></span><br><span class="line">            // 每次注入都使用同一个实例</span><br><span class="line">            container.RegisterInstance(new SomeService());</span><br><span class="line"></span><br><span class="line">            // 注入</span><br><span class="line">            container.Inject(this);</span><br><span class="line"></span><br><span class="line">            ObjA.Description();</span><br><span class="line">            ObjB.Description();</span><br><span class="line">            ObjC.Description();</span><br><span class="line">            ServiceA.Description();</span><br><span class="line">            ServiceB.Description();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看看运行的结果：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191903164.png" alt="img"></p><p>我们不难看到过 Register</p><p>() 注册的依赖，每次注入时创建新的实例，而通过 RegisterInstance(object obj) 注册的依赖，每次注入都返回同一个 obj 实例。<br>总结如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Register&lt;T&gt;，每次注入时创建新的实例。</span><br><span class="line">RegisterInstance(object obj)，每次注入时，返回同一个 obj 对象。</span><br></pre></td></tr></table></figure><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖倒置原则，即：Dependency Inversion Principle，很多时候缩写成 DIP。<br>这个原则包含了两个主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。</span><br><span class="line">抽象接口不应该依赖于实现，而实现依赖于抽象接口</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念"><a href="#高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念" class="headerlink" title="高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念"></a>高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念</h2><p>我们来拿一个司机开车的例子，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Driver</span><br><span class="line">&#123;</span><br><span class="line">  // 司机的职责是开车</span><br><span class="line">  public void Drive(Benz benz)</span><br><span class="line">  &#123;</span><br><span class="line">    benz.Run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Benz</span><br><span class="line">&#123;</span><br><span class="line">  public void Run()</span><br><span class="line">  &#123;</span><br><span class="line">    Debug.Log(&quot;奔驰汽车开始运行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  var lucas = new Driver();</span><br><span class="line">  var benz = new Benz();</span><br><span class="line"></span><br><span class="line">  lucas.Drive(benz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前A同学负责开发Driver类，B同学负责开发Benz类。这时候突然多了一个需求，那就是有一个同学的车换成了宝马，那我们需要重新创建一个BMW类。<br>然而因为A同学和B同学开发的类耦合性太强了，所以都需要重新改一下代码，这时候看看这句话：高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。这样我们把车和司机都依赖于抽象，更改后的代码是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Driver</span><br><span class="line">&#123;</span><br><span class="line">  // 司机的职责是开车</span><br><span class="line">  public void Drive(ICar car)</span><br><span class="line">  &#123;</span><br><span class="line">    car.Run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface ICar</span><br><span class="line">&#123;</span><br><span class="line">  void Run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//public class Benz : ICar</span><br><span class="line">//&#123;</span><br><span class="line">//  public void Run()</span><br><span class="line">//  &#123;</span><br><span class="line">//    Debug.Log(&quot;奔驰汽车开始运行&quot;)</span><br><span class="line">//  &#125;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">public class BMW : ICar</span><br><span class="line">&#123;</span><br><span class="line">  public void Run()</span><br><span class="line">  &#123;</span><br><span class="line">    Debug.Log(&quot;宝马汽车开始运行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  var lucas = new Driver();</span><br><span class="line">  var bmw = new BMW();</span><br><span class="line"></span><br><span class="line">  lucas.Drive(bmw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，当更换车的时候，不需要修改高层的代码，只需要把车的类更换掉就行了。<br>实际上，要完全实现”高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念“这一个主题的话，Driver 类也应该抽象出来一个 IDriver，不过对于目前的结构来说没有必要。</p><h2 id="抽象接口不应该依赖于实现，而实现依赖于抽象接口"><a href="#抽象接口不应该依赖于实现，而实现依赖于抽象接口" class="headerlink" title="抽象接口不应该依赖于实现，而实现依赖于抽象接口"></a>抽象接口不应该依赖于实现，而实现依赖于抽象接口</h2><p>我们直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lucas = new Driver();</span><br><span class="line">ICar car = new BMW();</span><br><span class="line"></span><br><span class="line">lucas.Drive(car);</span><br></pre></td></tr></table></figure><p>其中的 ICar car = new BMW() 就实现了“实现依赖于抽象接口”这一主题。<br>依赖这个概念需要再次更新了，上文中说到司机需要车才能当好司机，所以司机依赖车，那么现在 BMW 需要实现 ICar 接口，才能正常使用，那么 BMW 类依赖 ICar 接口，（实现依赖抽象接口)。<br>实际上依赖倒置原则的两个主题都在说一件事情，两个类之间的交互通过抽象（接口、抽象类）来完成。<br>而通过一个抽象，可以将两个类的变化隔离。即 A 类修改或扩展甚至是替换都不影响 B，反过来也是如此。<br>通过依赖倒置原则可以提高整个系统的灵活性和扩展性还有维护性。</p><h1 id="通过DIContainer实现DIP"><a href="#通过DIContainer实现DIP" class="headerlink" title="通过DIContainer实现DIP"></a>通过DIContainer实现DIP</h1><p>我们这时候来想想，其实依赖也就等于需求了。<br>而 QF 中的 DIContainer 支持前两种依赖管理，而市面上有个 IOC 容器，叫做 Zenject，支持以上全部的依赖关系。</p><h2 id="DIContainer-中的接口依赖管理（QF）"><a href="#DIContainer-中的接口依赖管理（QF）" class="headerlink" title="DIContainer 中的接口依赖管理（QF）"></a>DIContainer 中的接口依赖管理（QF）</h2><p>在上文中，我们说过QF中的依赖注入的时候DIContainer提供了两个API，分别是Register 与 RegisterInstance，分别是注入的时候是新的还是说同一个。<br>实际上这两者都有一些重载，即支持接口依赖的注册。<br>多说无用，放出来代码大家来体会一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace QF.Master.Example</span><br><span class="line">&#123;</span><br><span class="line">    public interface ILoginService</span><br><span class="line">    &#123;</span><br><span class="line">        void Login();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class LoginService : ILoginService</span><br><span class="line">    &#123;</span><br><span class="line">        public void Login()</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;登录成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class IOCInterfaceExample : MonoBehaviour </span><br><span class="line">    &#123;</span><br><span class="line">        [Inject]</span><br><span class="line">        public ILoginService LoginService &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        void Start () </span><br><span class="line">        &#123;</span><br><span class="line">            var container = new QFrameworkContainer();</span><br><span class="line"></span><br><span class="line">            container.RegisterInstance&lt;ILoginService&gt;(new LoginService());</span><br><span class="line"></span><br><span class="line">            // Register 也支持注册接口依赖</span><br><span class="line">            //container.Register&lt;ILoginService,LoginService&gt;();</span><br><span class="line"></span><br><span class="line">            container.Inject(this);</span><br><span class="line"></span><br><span class="line">            LoginService.Login();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，代码中可以根据接口注入具体的实例，使脚本可以依赖 ILoginService 接口而不依赖于 LoginService 类。</p><h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>在上文我们已经了解了依赖倒置原则和依赖注入的方案。了解了上面两个概念。这样会让我们更容易了解控制反转。</p><h2 id="控制正转"><a href="#控制正转" class="headerlink" title="控制正转"></a>控制正转</h2><p>有反转就有正转，我们先来看看正转的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB B = new ModuleB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ModuleB</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是正转，就是依赖的对象在内部进行创建，其实这不叫正转，这是正常的控制过程。<br>控制的意思其实就是依赖的对象创建的过程。也就是上述代码中的B的创建控制过程。<br>正转的过程就是被依赖对象B的创建是由依赖对象A控制，谁依赖谁创建。<br>控制反转就好理解了，就是被依赖对象B的创建是由外部控制了，就不需要依赖对象A进行控制创建了。<br>控制反转代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ModuleB</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  var moduleA = new ModuleA();</span><br><span class="line">  // 对象创建过程由外部控制</span><br><span class="line">  moduleA.B = new ModuleB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制反转意思是类依赖对象创建的过程由外部控制，而不是在类内部控制。</strong></p><h1 id="依赖注入与控制反转"><a href="#依赖注入与控制反转" class="headerlink" title="依赖注入与控制反转"></a>依赖注入与控制反转</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">控制反转：依赖对象的创建过程交给外部控制。 </span><br><span class="line">依赖注入：依赖对象在外部进行设置。</span><br></pre></td></tr></table></figure><p>控制反转是设计原则，或者说是设计模式，而依赖注入是控制反转的具体实现。<br>控制反转的具体实现除了有常用的依赖注入还有一种方案叫依赖查找，这里我们不介绍。<br>控制反转和依赖注入有一些细微的差别，控制反转的重点在于依赖对象创建过程的控制，而依赖注入的重点在于依赖对象如何设置，实际上这两个概念都在说，依赖对象的创建和设置都在外边搞，不要在类内部搞。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://liuyingbo.com">刘英博</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://liuyingbo.com/posts/183e2cbd.html">https://liuyingbo.com/posts/183e2cbd.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://liuyingbo.com" target="_blank">狼唤</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/IOC/">IOC</a></div><div class="post_share"><div class="social-share" data-image="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191859764.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/a80d0031.html"><img class="prev-cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191859764.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">动态规划</div></div></a></div><div class="next-post pull-right"><a href="/posts/364ea8cc.html"><img class="next-cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191859764.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211100000064.JPG" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">刘英博</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/liuyingbor" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gitHub"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=liuyingbo666@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/11929004" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=594686596&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ1"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">IOC简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DI%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">DI简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text">注入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DI"><span class="toc-number">2.</span> <span class="toc-text">DI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QF%E4%B8%AD%E7%9A%84IOC"><span class="toc-number">2.1.</span> <span class="toc-text">QF中的IOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DI%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BC%BA%E5%A4%A7%E4%B9%8B%E5%A4%84"><span class="toc-number">2.2.</span> <span class="toc-text">DI容器的强大之处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text">职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%A4%A7%E4%B9%8B%E5%A4%84"><span class="toc-number">2.2.2.</span> <span class="toc-text">强大之处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">依赖管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8ModuleA%E5%86%85%E9%83%A8%E5%88%9B%E5%BB%BA"><span class="toc-number">2.3.1.</span> <span class="toc-text">在ModuleA内部创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8ModuleA%E5%A4%96%E9%83%A8%E5%88%9B%E5%BB%BA"><span class="toc-number">2.3.2.</span> <span class="toc-text">在ModuleA外部创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-DI-Container-%E7%AE%A1%E7%90%86%E4%BE%9D%E8%B5%96"><span class="toc-number">2.3.3.</span> <span class="toc-text">使用 DI Container 管理依赖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%9F"><span class="toc-number">3.</span> <span class="toc-text">域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DIContainer%E4%B8%AD%E7%9A%84%E5%9F%9F"><span class="toc-number">3.2.</span> <span class="toc-text">DIContainer中的域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">依赖倒置原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B1%82%E6%A8%A1%E5%9D%97%E4%B8%8D%E5%BA%94%E8%AF%A5%E4%BE%9D%E8%B5%96%E4%BA%8E%E4%BD%8E%E5%B1%82%E6%A8%A1%E5%9D%97%EF%BC%8C%E4%B8%A4%E8%80%85%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BE%9D%E8%B5%96%E4%BA%8E%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%8E%A5%E5%8F%A3%E4%B8%8D%E5%BA%94%E8%AF%A5%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%80%8C%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E4%BA%8E%E6%8A%BD%E8%B1%A1%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">抽象接口不应该依赖于实现，而实现依赖于抽象接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87DIContainer%E5%AE%9E%E7%8E%B0DIP"><span class="toc-number">5.</span> <span class="toc-text">通过DIContainer实现DIP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DIContainer-%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%EF%BC%88QF%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">DIContainer 中的接口依赖管理（QF）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">6.</span> <span class="toc-text">控制反转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%AD%A3%E8%BD%AC"><span class="toc-number">6.1.</span> <span class="toc-text">控制正转</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">7.</span> <span class="toc-text">依赖注入与控制反转</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ba6d86a1.html" title="C#数据结构与算法"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="C#数据结构与算法"></a><div class="content"><a class="title" href="/posts/ba6d86a1.html" title="C#数据结构与算法">C#数据结构与算法</a><time datetime="2022-11-19T11:08:28.048Z" title="发表于 2022-11-19 11:08:28">2022-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1d0254fc.html" title="Unity-移动平台相关（一）"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-移动平台相关（一）"></a><div class="content"><a class="title" href="/posts/1d0254fc.html" title="Unity-移动平台相关（一）">Unity-移动平台相关（一）</a><time datetime="2022-09-01T15:06:06.000Z" title="发表于 2022-09-01 15:06:06">2022-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ba9e7782.html" title="Unity-网络开发（三）"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-网络开发（三）"></a><div class="content"><a class="title" href="/posts/ba9e7782.html" title="Unity-网络开发（三）">Unity-网络开发（三）</a><time datetime="2022-08-14T22:13:47.000Z" title="发表于 2022-08-14 22:13:47">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34c3e4a1.html" title="Unity-UniTask"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-UniTask"></a><div class="content"><a class="title" href="/posts/34c3e4a1.html" title="Unity-UniTask">Unity-UniTask</a><time datetime="2022-08-14T21:24:49.000Z" title="发表于 2022-08-14 21:24:49">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c7963808.html" title="Unity-网络开发（一）"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-网络开发（一）"></a><div class="content"><a class="title" href="/posts/c7963808.html" title="Unity-网络开发（一）">Unity-网络开发（一）</a><time datetime="2022-05-16T15:06:06.000Z" title="发表于 2022-05-16 15:06:06">2022-05-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 刘英博</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.liuyingbo.com/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.liuyingbo.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/title.js"></script><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true"></div><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script></body></html>