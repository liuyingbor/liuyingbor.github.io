<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Unity-Asset资源 | 狼唤</title><meta name="author" content="刘英博"><meta name="copyright" content="刘英博"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Unity资源文件夹介绍 编辑时在Asset文件下存在Resources和SteamingAsset文件夹； Resources只读不可修改，打包时直接写死，没有办法通过热更新替换资源； 可以存放任何格式的资源； 通过Resources.Load加载； 一般只存登录UI，congfig配置等不会修改的文件； 1234&#x2F;&#x2F;加载GameObject go &#x3D; Resources.Load&lt;Gam"><meta property="og:type" content="article"><meta property="og:title" content="Unity-Asset资源"><meta property="og:url" content="https://liuyingbo.com/posts/521e43fc.html"><meta property="og:site_name" content="狼唤"><meta property="og:description" content="Unity资源文件夹介绍 编辑时在Asset文件下存在Resources和SteamingAsset文件夹； Resources只读不可修改，打包时直接写死，没有办法通过热更新替换资源； 可以存放任何格式的资源； 通过Resources.Load加载； 一般只存登录UI，congfig配置等不会修改的文件； 1234&#x2F;&#x2F;加载GameObject go &#x3D; Resources.Load&lt;Gam"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png"><meta property="article:published_time" content="2022-02-20T15:37:00.000Z"><meta property="article:modified_time" content="2022-11-16T16:11:17.075Z"><meta property="article:author" content="刘英博"><meta property="article:tag" content="Unity"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liuyingbo.com/posts/521e43fc"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Unity-Asset资源",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-11-16 16:11:17"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="css/color.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="狼唤" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211100000064.JPG" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-comment-dots"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">狼唤</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-comment-dots"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity-Asset资源</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-20T15:37:00.000Z" title="发表于 2022-02-20 15:37:00">2022-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-16T16:11:17.075Z" title="更新于 2022-11-16 16:11:17">2022-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Unity-Asset资源"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Unity资源文件夹介绍"><a href="#Unity资源文件夹介绍" class="headerlink" title="Unity资源文件夹介绍"></a>Unity资源文件夹介绍</h1><p><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/image-20211008233301906.png" alt="image-20211008233301906"></p><h2 id="编辑时"><a href="#编辑时" class="headerlink" title="编辑时"></a>编辑时</h2><p>在Asset文件下存在Resources和SteamingAsset文件夹；</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>只读不可修改，打包时直接写死，没有办法通过热更新替换资源；</p><p>可以存放任何格式的资源；</p><p>通过Resources.Load加载；</p><p>一般只存登录UI，congfig配置等不会修改的文件；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载</span></span><br><span class="line">GameObject go = Resources.Load&lt;GameObject&gt;(path);</span><br><span class="line">Sprite sp = Resouces.Load(path,<span class="keyword">typeof</span>(sprite)) <span class="keyword">as</span> sprite;</span><br><span class="line">TextAsset txt = Resources.Load(path) <span class="keyword">as</span> TextAsset;</span><br></pre></td></tr></table></figure><h3 id="SteamingAssets"><a href="#SteamingAssets" class="headerlink" title="SteamingAssets"></a>SteamingAssets</h3><p>存放打包后Unity打包后的资源，也就是我说的AssetBundle（ab包）；</p><p>可读可写，打包后移动端不能使用File类读取（用过www读取streamingAssetspath数据拷贝到persistentDataPath）；</p><h2 id="安装后"><a href="#安装后" class="headerlink" title="安装后"></a>安装后</h2><h3 id="Application-dataPath"><a href="#Application-dataPath" class="headerlink" title="Application.dataPath"></a>Application.dataPath</h3><p>包含游戏数据文件夹的路径，app程序包安装路径（不常用）；</p><p>1.UnityEditor——<strong>默认Assets</strong>——可读可写 using StreamReader/StreamWriter/异步</p><p>2.Andriod——data/app/xxx.apk——不可读不可写</p><p>3.IOS——Application/…..app/Data——可读不可写（读没意义）</p><h3 id="Application-streamingAssetsPath"><a href="#Application-streamingAssetsPath" class="headerlink" title="Application.streamingAssetsPath"></a>Application.streamingAssetsPath</h3><p>数据流换成目录，外部数据文件（二进制，AssetsBundle.csv、数据裸露不加密）；</p><p>1.除了Andriod都可读可写，使用WWW或者System.IO都可以；</p><p>2.Andriod只读，只能用WWW读写——第三方压缩/解压库实现读写（待研究）；</p><p><strong>3.安装包资源目录，不可修改；</strong></p><h3 id="Application-presistentDataPath"><a href="#Application-presistentDataPath" class="headerlink" title="Application.presistentDataPath"></a>Application.presistentDataPath</h3><p>持久化存储目录，应用更新、覆盖安装都不会清除；</p><p>1.全平台可读可写——stream和file都可以读写；</p><p><strong>2.热更新资源存放目录；</strong></p><h3 id="Application-temporaryCachePath"><a href="#Application-temporaryCachePath" class="headerlink" title="Application.temporaryCachePath"></a>Application.temporaryCachePath</h3><p>临时换成目录，可读可写（只有ios常用）；</p><h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><p>资源压缩文件（ab包），非路径，一种压缩文件的格式；</p><h1 id="AssetBundle-1"><a href="#AssetBundle-1" class="headerlink" title="AssetBundle"></a>AssetBundle</h1><h2 id="Asset-Bundle："><a href="#Asset-Bundle：" class="headerlink" title="Asset Bundle："></a><strong>Asset Bundle：</strong></h2><p><strong>AssetBundle</strong> 是一个存档文件，包含可在运行时加载的特定于平台的资源（模型、纹理、预制件、音频剪辑甚至整个场景）。AssetBundle 可以表达彼此之间的依赖关系；例如 AssetBundle A 中的材质可以引用 AssetBundle B 中的纹理。为了通过网络进行有效传递，可以根据用例要求选用内置算法来压缩 AssetBundle（LZMA 和 LZ4）。</p><p>AssetBundle 可用于可下载内容（DLC），减小初始安装大小，加载针对最终用户平台优化的资源，以及减轻运行时内存压力。</p><h2 id="AssetBundle-中有什么"><a href="#AssetBundle-中有什么" class="headerlink" title="AssetBundle 中有什么:"></a><strong>AssetBundle 中有什么:</strong></h2><p>“AssetBundle”可以指两种不同但相关的东西。</p><p>首先是磁盘上的实际文件。对于这种情况，我们称之为 AssetBundle 存档，在本文档中简称“存档”。存档可以被视为一个容器，就像文件夹一样，可以在其中包含其他文件。这些附加文件包含两种类型：</p><p>序列化文件和资源文件。序列化文件包含分解为各个对象并写入此单个文件的资源。资源文件只是为某些资源（纹理和音频）单独存储的二进制数据块，允许我们有效地在另一个线程上从磁盘加载它们。</p><p>其次是通过代码进行交互以便从特定存档加载资源的实际 AssetBundle 对象。此对象包含一个映射，即从已添加到此存档的资源的所有文件路径到按需加载的资源所包含的对象之间的映射。</p><h2 id="为-AssetBundle-分配资源"><a href="#为-AssetBundle-分配资源" class="headerlink" title="为 AssetBundle 分配资源"></a>为 AssetBundle 分配资源</h2><p>要为 AssetBundle 分配指定资源，请按照下列步骤操作：</p><p>1.从 Project 视图中选择要为捆绑包分配的资源</p><p>2.在 Inspector 中检查对象</p><p>3.在 Inspector 底部，应该会看到一个用于分配 AssetBundle 和变体的部分：</p><p>4.左侧下拉选单分配 AssetBundle，而右侧下拉选单分配变量</p><p>5.单击左侧下拉选单，其中显示“None”，表示当前注册的 AssetBundle 名称</p><p>6.单击“New…”以创建新的 AssetBundle</p><p>7.输入所需的 AssetBundle 名称。请注意，AssetBundle 名称支持某种类型的文件夹结构，具体取决于您输入的内容。要添加子文件夹，请用“/”分隔文件夹名称。例如：AssetBundle 名称“environment/forest”将在 environment 子文件夹下创建名为 forest 的捆绑包</p><p>8.一旦选择或创建了 AssetBundle 名称，便可以重复此过程在右侧下拉选单中分配或创建变体名称（如果需要）。构建 AssetBundle 不需要变体名称</p><h2 id="构建-AssetBundle"><a href="#构建-AssetBundle" class="headerlink" title="构建 AssetBundle"></a>构建 AssetBundle</h2><p>在 Assets 文件夹中创建一个名为 Editor 的文件夹，并将包含以下内容的脚本放在该文件夹中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System.IO;</span><br><span class="line">using UnityEditor;</span><br><span class="line"></span><br><span class="line">public class CreateAssetBundles</span><br><span class="line">&#123;</span><br><span class="line">    [MenuItem(&quot;Assets/Build AssetBundles&quot;)]</span><br><span class="line">    static void BuildAllAssetBundles()</span><br><span class="line">    &#123;</span><br><span class="line">        string assetBundleDirectory = &quot;Assets/AssetBundles&quot;;</span><br><span class="line">        if (!Directory.Exists(assetBundleDirectory))</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(assetBundleDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">        BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, BuildTarget.StandaloneOSX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此脚本将在 Assets 菜单底部创建一个名为“Build AssetBundles”的菜单项，该菜单项将执行与该标签关联的函数中的代码。单击 Build AssetBundles 时，将随构建对话框一起显示一个进度条。此过程将会获取带有 AssetBundle 名称标签的所有资源，并将它们放在 assetBundleDirectory 定义的路径中的文件夹中。</p><h2 id="将-AssetBundle-上传到场外存储"><a href="#将-AssetBundle-上传到场外存储" class="headerlink" title="将 AssetBundle 上传到场外存储"></a>将 AssetBundle 上传到场外存储</h2><p>此步骤对每个用户都是不同的，因此 Unity 不能告诉您应该具体如何操作。如果计划将 AssetBundle 上传到第三方托管站点，请在此步中执行该操作。如果正在严格执行本地开发并打算将所有 AssetBundle 都放在磁盘上，请跳转到下一步。</p><h2 id="加载-AssetBundle-和资源"><a href="#加载-AssetBundle-和资源" class="headerlink" title="加载 AssetBundle 和资源"></a>加载 AssetBundle 和资源</h2><p>打算从本地存储加载的用户可能会对 AssetBundles.LoadFromFile API 感兴趣。该 API 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LoadFromFileExample extends MonoBehaviour &#123;</span><br><span class="line">    function Start() &#123;</span><br><span class="line">        var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));</span><br><span class="line">        if (myLoadedAssetBundle == null) &#123;</span><br><span class="line">            Debug.Log(&quot;Failed to load AssetBundle!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(&quot;MyObject&quot;);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为-AssetBundle-准备资源"><a href="#为-AssetBundle-准备资源" class="headerlink" title="为 AssetBundle 准备资源"></a>为 AssetBundle 准备资源</h1><p>使用 AssetBundle 时，可以任意将任何资源分配给所需的任何捆绑包。但是，在设置捆绑包时需要考虑某些策略。以下分组策略旨在用于您认为适合的具体项目。可以根据需要随意混合和搭配这些策略。</p><h2 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h2><p>逻辑实体分组是指根据资源所代表的项目功能部分将资源分配给 AssetBundle。这包括各种不同部分，比如用户界面、角色、环境以及在应用程序整个生命周期中可能经常出现的任何其他内容。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>捆绑用户界面屏幕的所有纹理和布局数据</li><li>捆绑一个/一组角色的所有模型和动画</li><li>捆绑在多个关卡之间共享的景物的纹理和模型</li></ul><p>逻辑实体分组非常适合于可下载内容 (DLC)，因为通过这种方式将所有内容隔离后，可以对单个实体进行更改，而无需下载其他未更改的资源。</p><p>为了能够正确实施此策略，最大诀窍在于，负责为各自捆绑包分配资源的开发人员必须熟悉项目使用每个资源的准确时机和场合。</p><h2 id="类型分组"><a href="#类型分组" class="headerlink" title="类型分组"></a>类型分组</h2><p>根据此策略，可以将相似类型的资源（例如音频轨道或语言本地化文件）分配到单个 AssetBundle。</p><p>要构建供多个平台使用的 AssetBundle，类型分组是最佳策略之一。例如，如果音频压缩设置在 Windows 和 Mac 平台上完全相同，则可以自行将所有音频数据打包到 AssetBundle 并重复使用这些捆绑包，而着色器往往使用更多特定于平台的选项进行编译，因此为 Mac 构建的着色器捆绑包可能无法在 Windows 上重复使用。此外，这种方法非常适合让 AssetBundle 与更多 Unity 播放器版本兼容，因为纹理压缩格式和设置的更改频率低于代码脚本或预制件。</p><h2 id="并发内容分组"><a href="#并发内容分组" class="headerlink" title="并发内容分组"></a>并发内容分组</h2><p>并发内容分组是指将需要同时加载和使用的资源捆绑在一起。可以将这些类型的捆绑包用于基于关卡的游戏（其中每个关卡包含完全独特的角色、纹理、音乐等）。有时可能希望确保其中一个 AssetBundle 中的资源与该捆绑包中的其余资源同时使用。依赖于并发内容分组捆绑包中的单个资源会导致加载时间显著增加。您将被迫下载该单个资源的整个捆绑包。</p><p>并发内容分组捆绑包最常见的用例是针对基于场景的捆绑包。在此分配策略中，每个场景捆绑包应包含大部分或全部场景依赖项。</p><p>请注意，项目绝对可以也应该根据您的需求混用这些策略。对任何给定情形使用最优资源分配策略可以大大提高项目的效率。</p><p>例如，一个项目可能决定将不同平台的用户界面 (UI) 元素分组到各自的 Platform-UI 特定捆绑包中，但按关卡/场景对其交互式内容进行分组。</p><p>无论遵循何种策略，下面这些额外提示都有助于掌控全局：</p><ul><li>将频繁更新的对象与很少更改的对象拆分到不同的 AssetBundle 中</li><li>将可能同时加载的对象分到一组。例如模型及其纹理和动画</li><li>如果发现多个 AssetBundle 中的多个对象依赖于另一个完全不同的 AssetBundle 中的单个资源，请将依赖项移动到单独的 AssetBundle。如果多个 AssetBundle 引用其他 AssetBundle 中的同一组资源，一种有价值的做法可能是将这些依赖项拉入一个共享 AssetBundle 来减少重复。</li><li>如果不可能同时加载两组对象（例如标清资源和高清资源），请确保它们位于各自的 AssetBundle 中。</li><li>如果一个 AssetBundle 中只有不到 50% 的资源经常同时加载，请考虑拆分该捆绑包</li><li>考虑将多个小型的（少于 5 到 10 个资源）但经常同时加载内容的 AssetBundle 组合在一起</li><li>如果一组对象只是同一对象的不同版本，请考虑使用 AssetBundle 变体</li></ul><h1 id="构建-AssetBundle-1"><a href="#构建-AssetBundle-1" class="headerlink" title="构建 AssetBundle"></a>构建 AssetBundle</h1><p>在有关 <a href="AssetBundles-Workflow.html">AssetBundle 工作流程</a>的文档中，我们有一个代码示例将三个参数传递给 <code>BuildPipeline.BuildAssetBundles</code> 函数。让我们深入了解一下这方面。</p><p><em>Assets/AssetBundles</em>：这是 AssetBundle 要输出到的目录。可以将其更改为所需的任何输出目录，只需确保在尝试构建之前文件夹实际存在。</p><h4 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h4><p>可以指定几个具有各种效果的不同 <code>BuildAssetBundleOptions</code>。请参阅关于 <a href="../ScriptReference/BuildAssetBundleOptions.html">BuildAssetBundleOptions</a> 的脚本 API 参考查看所有这些选项的表格。</p><p>虽然可以根据需求变化和需求出现而自由组合 <code>BuildAssetBundleOptions</code>，但有三个特定的 <code>BuildAssetBundleOptions</code> 可以处理 AssetBundle 压缩：</p><ul><li><code>BuildAssetBundleOptions.None</code>:</li><li>此捆绑选项使用 LZMA 格式压缩，它是序列化数据文件的单个压缩 LZMA 流。LZMA 压缩要求在使用之前解压缩整个包。这会导致文件大小尽可能小，但由于解压缩，加载时间会稍长。值得注意的是，在使用此 BuildAssetBundleOptions 时，为了使用包中的任何资产，必须首先解压缩整个包。<br>解压缩包后，它将使用 LZ4 压缩在磁盘上重新压缩，这不需要在使用包中的资产之前解压缩整个包。当捆绑包包含资产时最好使用此方法，以便使用捆绑包中的一个资产意味着所有资产都将被加载。打包角色或场景的所有资产是可能使用此功能的捆绑包的一些示例。<br>由于文件较小，建议仅在从异地主机初始下载 AssetBundle 时使用 LZMA 压缩。<a href="../ScriptReference/Networking.UnityWebRequestAssetBundle.html">通过UnityWebRequestAssetBundle</a>加载的 LZMA 压缩资产包会自动重新压缩为 LZ4 压缩并缓存在本地文件系统上。如果您通过其他方式下载并存储该捆绑包，您可以使用<a href="../ScriptReference/AssetBundle.RecompressAssetBundleAsync.html">AssetBundle.RecompressAssetBundleAsync</a> API。</li><li><code>BuildAssetBundleOptions.UncompressedAssetBundle</code>：此捆绑包选项采用使数据完全未压缩的方式构建捆绑包。未压缩的缺点是文件下载大小增大。但是，下载后的加载时间会快得多。</li><li><code>BuildAssetBundleOptions.ChunkBasedCompression</code>：此捆绑包选项使用称为 LZ4 的压缩方法，因此压缩文件大小比 LZMA 更大，但不像 LZMA 那样需要解压缩整个包才能使用捆绑包。LZ4 使用基于块的算法，允许按段或“块”加载 AssetBundle。解压缩单个块即可使用包含的资源，即使 AssetBundle 的其他块未解压缩也不影响。</li></ul><p>使用 <code>ChunkBasedCompression</code> 时的加载时间与未压缩捆绑包大致相当，额外的优势是减小了占用的磁盘大小。</p><h4 id="BuildTarget"><a href="#BuildTarget" class="headerlink" title="BuildTarget"></a>BuildTarget</h4><p><code>BuildTarget.Standalone</code>：这里我们告诉构建管线，我们要将这些 AssetBundle 用于哪些目标平台。可以在关于 <a href="../ScriptReference/BuildTarget.html">BuildTarget</a> 的脚本 API 参考中找到可用显式构建目标的列表。但是，如果不想在构建目标中进行硬编码，请充分利用 <code>EditorUserBuildSettings.activeBuildTarget</code>，它将自动找到当前设置的目标构建平台，并根据该目标构建 AssetBundle。</p><p>一旦正确设置构建脚本，最后便可以开始构建资源包了。如果是按照上面的脚本示例进行的操作，请单击 <strong>Assets</strong> &gt; <strong>Build AssetBundles</strong> 以开始该过程。</p><p>现在已经成功构建了 AssetBundle，您可能会注意到 AssetBundles 目录包含的文件数量超出了最初的预期。确切地说，是多出了 2*(n+1) 个文件。让我们花点时间详细了解一下 <code>BuildPipeline.BuildAssetBundles</code> 产生的结果。</p><p>对于在编辑器中指定的每个 AssetBundle，可以看到一个具有 AssetBundle 名称+“.manifest”的文件。</p><p>随后会有一个额外捆绑包和清单的名称不同于先前创建的任何 AssetBundle。相反，此包以其所在的目录（构建 AssetBundle 的目录）命名。这就是清单捆绑包。我们以后会对此进行详细讨论并介绍使用方法。</p><h4 id="AssetBundle-文件"><a href="#AssetBundle-文件" class="headerlink" title="AssetBundle 文件"></a>AssetBundle 文件</h4><p>这是缺少 .manifest 扩展名的文件，其中包含在运行时为了加载资源而需要加载的内容。</p><p>AssetBundle 文件是一个存档，在内部包含多个文件。此存档的结构根据它是 AssetBundle 还是场景 AssetBundle 可能会略有不同。以下是普通 AssetBundle 的结构：</p><p><img src="/Users/liuyingbo/MyWorkSpace/hexo/source/uploads/Main/AssetBundles-Building-0.png" alt="img"></p><p>场景 AssetBundle 与普通 AssetBundle 的不同之处在于，它针对场景及其内容的串流加载进行了优化。</p><h4 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h4><p>对于生成的每个捆绑包（包括附加的清单捆绑包），都会生成关联的清单文件。清单文件可以使用任何文本编辑器打开，并包含诸如循环冗余校验 (CRC) 数据和捆绑包的依赖性数据之类的信息。对于普通 AssetBundle，它们的清单文件将如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ManifestFileVersion: 0</span><br><span class="line">CRC: 2422268106</span><br><span class="line">Hashes:</span><br><span class="line">  AssetFileHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 8b6db55a2344f068cf8a9be0a662ba15</span><br><span class="line">  TypeTreeHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 37ad974993dbaa77485dd2a0c38f347a</span><br><span class="line">HashAppended: 0</span><br><span class="line">ClassTypes:</span><br><span class="line">- Class: 91</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">Assets:</span><br><span class="line">  Asset_0: Assets/Mecanim/StateMachine.controller</span><br><span class="line">Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure><p>其中显示了包含的资源、依赖项和其他信息。</p><p>生成的清单捆绑包将有一个清单，但看起来更可能如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ManifestFileVersion: 0</span><br><span class="line">AssetBundleManifest:</span><br><span class="line">  AssetBundleInfos:</span><br><span class="line">    Info_0:</span><br><span class="line">      Name: scene1assetbundle</span><br><span class="line">      Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure><p>这将显示 AssetBundle 之间的关系以及它们的依赖项。就目前而言，只需要了解这个捆绑包中包含 AssetBundleManifest 对象，这对于确定在运行时加载哪些捆绑包依赖项非常有用。</p><h1 id="AssetBundle-依赖项"><a href="#AssetBundle-依赖项" class="headerlink" title="AssetBundle 依赖项"></a>AssetBundle 依赖项</h1><p>如果一个或多个 <code>UnityEngine.Objects</code> 包含对位于另一个捆绑包中的 <code>UnityEngine.Object</code> 的引用，则 AssetBundle 可以变为依赖于其他 AssetBundle。如果 <code>UnityEngine.Object</code> 包含对任何 AssetBundle 中未包含的 <code>UnityEngine.Object</code> 的引用，则不会发生依赖关系。在这种情况下，在构建 AssetBundle 时，捆绑包所依赖的对象的副本将复制到捆绑包中。如果多个捆绑包中的多个对象包含对未分配给捆绑包的同一对象的引用，则每个对该对象具有依赖关系的捆绑包将创建其自己的对象副本并将其打包到构建的 AssetBundle 中。</p><p>如果 AssetBundle 中包含依赖项，则在加载尝试实例化的对象之前，务必加载包含这些依赖项的捆绑包。Unity 不会尝试自动加载依赖项。</p><p>参考以下示例，<strong>Bundle 1</strong> 中的材质引用了 <strong>Bundle 2</strong> 中的纹理：</p><p>在此示例中，在从 <strong>Bundle 1</strong> 加载材质之前，需要将 <strong>Bundle 2</strong> 加载到内存中。加载 <strong>Bundle 1</strong> 和 <strong>Bundle 2</strong> 的顺序无关紧要，重要的是在从 <strong>Bundle 1</strong> 加载材质之前应加载 <strong>Bundle 2</strong>。在下一部分，我们将讨论如何使用我们在上一部分介绍的 <code>AssetBundleManifest</code> 对象在运行时确定并加载依赖项。</p><h1 id="使用-AssetBundle"><a href="#使用-AssetBundle" class="headerlink" title="使用 AssetBundle"></a>使用 AssetBundle</h1><p>可以使用四种不同的 API 来加载 AssetBundle。它们的行为根据加载捆绑包的平台和构建 AssetBundle 时使用的压缩方法（未压缩、LZMA 和 LZ4）而有所不同。</p><p>我们必须使用的四个 API 是：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromMemoryAsync.html?_ga=1.226802969.563709772.1479226228">AssetBundle.LoadFromMemoryAsync</a></li><li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromFile.html?_ga=1.259297550.563709772.1479226228">AssetBundle.LoadFromFile</a></li><li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/WWW.LoadFromCacheOrDownload.html?_ga=1.226802969.563709772.1479226228">WWW.LoadfromCacheOrDownload</a></li><li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.html?_ga=1.259297550.563709772.1479226228">UnityWebRequest</a> 的 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Networking.DownloadHandlerAssetBundle.html?_ga=1.264500235.563709772.1479226228">DownloadHandlerAssetBundle</a> （Unity 5.3 或更高版本）</li></ul><h2 id="AssetBundle-LoadFromMemoryAsync"><a href="#AssetBundle-LoadFromMemoryAsync" class="headerlink" title="AssetBundle.LoadFromMemoryAsync"></a>AssetBundle.LoadFromMemoryAsync</h2><p><a href="../ScriptReference/AssetBundle.LoadFromMemoryAsync.html">AssetBundle.LoadFromMemoryAsync</a></p><p>此函数采用包含 AssetBundle 数据的字节数组。也可以根据需要传递 CRC 值。如果捆绑包采用的是 LZMA 压缩方式，将在加载时解压缩 AssetBundle。LZ4 压缩包则会以压缩状态加载。</p><p>以下是如何使用此方法的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">public class Example : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"> 		IEnumerator Start()</span><br><span class="line">    &#123;</span><br><span class="line">        string path = Application.streamingAssetsPath + &quot;/AssetBundles/OSX/wall&quot;;</span><br><span class="line">    		AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line">        Debug.Log(&quot;Failed to load AssetBundle!&quot; + createRequest);</span><br><span class="line">        yield return createRequest;</span><br><span class="line"></span><br><span class="line">        AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line">        var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这不是实现 LoadFromMemoryAsync 的唯一策略。File.ReadAllBytes(path) 可以替换为获得字节数组的任何所需过程。</p><h2 id="AssetBundle-LoadFromFile"><a href="#AssetBundle-LoadFromFile" class="headerlink" title="AssetBundle.LoadFromFile"></a>AssetBundle.LoadFromFile</h2><p><a href="../ScriptReference/AssetBundle.LoadFromFile.html">AssetBundle.LoadFromFile</a></p><p>从本地存储中加载未压缩的捆绑包时，此 API 非常高效。如果捆绑包未压缩或采用了数据块 (LZ4) 压缩方式，LoadFromFile 将直接从磁盘加载捆绑包。使用此方法加载完全压缩的 (LZMA) 捆绑包将首先解压缩捆绑包，然后再将其加载到内存中。</p><p>如何使用 <code>LoadFromFile</code> 的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LoadFromFileExample extends MonoBehaviour &#123;</span><br><span class="line">    function Start() &#123;</span><br><span class="line">        var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));</span><br><span class="line">        if (myLoadedAssetBundle == null) &#123;</span><br><span class="line">            Debug.Log(&quot;Failed to load AssetBundle!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(&quot;MyObject&quot;);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在使用 Unity 5.3 或更早版本的 Android 设备上，尝试从流媒体资源 (Streaming Assets) 路径加载 AssetBundle 时，此 API 将失败。这是因为该路径的内容将驻留在压缩的 .jar 文件中。Unity 5.4 和更高版本则可以将此 API 调用与流媒体资源一起使用。</p><h2 id="WWW-LoadFromCacheOrDownload"><a href="#WWW-LoadFromCacheOrDownload" class="headerlink" title="WWW.LoadFromCacheOrDownload"></a>WWW.LoadFromCacheOrDownload</h2><p><a href="../ScriptReference/WWW.LoadFromCacheOrDownload.html">WWW.LoadFromCacheOrDownload</a></p><p><strong>即将弃用（使用 UnityWebRequest）</strong></p><p>此 API 对于从远程服务器下载 AssetBundle 或加载本地 AssetBundle 非常有用。这是一个陈旧且不太理想的 UnityWebRequest API 版本。</p><p>从远程位置加载 AssetBundle 将自动缓存 AssetBundle。如果 AssetBundle 被压缩，则将启动工作线程来解压缩捆绑包并将其写入缓存。一旦捆绑包被解压缩并缓存，它就会像 AssetBundle.LoadFromFile 一样加载。</p><p>如何使用 <code>LoadFromCacheOrDownload</code> 的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class LoadFromCacheOrDownloadExample : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    IEnumerator Start ()</span><br><span class="line">    &#123;</span><br><span class="line">           while (!Caching.ready)</span><br><span class="line">            yield return null;</span><br><span class="line"></span><br><span class="line">        var www = WWW.LoadFromCacheOrDownload(&quot;file://&quot; + path, 5);</span><br><span class="line">        Debug.Log(path);</span><br><span class="line">        yield return www;</span><br><span class="line">        if (!string.IsNullOrEmpty(www.error))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(www.error);</span><br><span class="line">            yield break;</span><br><span class="line">        &#125;</span><br><span class="line">        AssetBundle bundle = www.assetBundle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在 WWW 对象中缓存 AssetBundle 字节所需的内存开销，建议所有使用 WWW.LoadFromCacheOrDownload 的开发人员都应该确保自己的 AssetBundle 保持较小的大小 - 最多只有几兆字节。此外，还建议在有限内存平台（如移动设备）上运行的开发人员确保其代码一次只下载一个 AssetBundle，以此避免内存峰值。</p><p>如果缓存文件夹没有任何空间来缓存其他文件，LoadFromCacheOrDownload 将以迭代方式从缓存中删除最近最少使用的 AssetBundle，直到有足够的空间来存储新的 AssetBundle。如果无法腾出空间（因为硬盘已满，或者缓存中的所有文件当前都处于使用状态），LoadFromCacheOrDownload() 将不会使用缓存，而将文件流式传输到内存中</p><p>为了强制执行 LoadFromCacheOrDownload，需要更改版本参数（第二个参数）。仅当传递给函数的版本与当前缓存的 AssetBundle 的版本匹配，才会从缓存加载 AssetBundle。</p><h2 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h2><p><a href="../ScriptReference/Networking.UnityWebRequest.GetAssetBundle.html">UnityWebRequest</a></p><p>UnityWebRequest 有一个特定 API 调用来处理 AssetBundle。首先，需要使用 <code>UnityWebRequest.GetAssetBundle</code> 来创建 Web 请求。返回请求后，请将请求对象传递给 <code>DownloadHandlerAssetBundle.GetContent(UnityWebRequest)</code>。<code>GetContent</code> 调用将返回 AssetBundle 对象。</p><p>下载捆绑包后，还可以在 <a href="../ScriptReference/Networking.DownloadHandlerAssetBundle.html">DownloadHandlerAssetBundle</a> 类上使用 <code>assetBundle</code> 属性，从而以 <code>AssetBundle.LoadFromFile</code> 的效率加载 AssetBundle。</p><p>以下示例说明了如何加载包含两个游戏对象的 AssetBundle 并实例化这些游戏对象。要开始这个过程，我们只需要调用 <code>StartCoroutine(InstantiateObject())</code>;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator InstantiateObject()</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(&quot;file://&quot; + path, 0);</span><br><span class="line">        yield return request.SendWebRequest();</span><br><span class="line">        AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">        GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);</span><br><span class="line"></span><br><span class="line">        Instantiate(cube);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用 UnityWebRequest 的优点在于，它允许开发人员以更灵活的方式处理下载的数据，并可能消除不必要的内存使用。这是比 UnityEngine.WWW 类更新和更优的 API。</p><h4 id="从-AssetBundle-加载资源"><a href="#从-AssetBundle-加载资源" class="headerlink" title="从 AssetBundle 加载资源"></a>从 AssetBundle 加载资源</h4><p>现在已经成功下载 AssetBundle，因此是时候最终加载一些资源了。</p><p>通用代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</span><br></pre></td></tr></table></figure><p>T 是尝试加载的资源类型。</p><p>决定如何加载资源时有几个选项。我们有 <code>LoadAsset</code>、<code>LoadAllAssets</code> 及其各自的异步对应选项 <code>LoadAssetAsync</code> 和 <code>LoadAllAssetsAsync</code>。</p><p>同步从 AssetBundle 加载资源的方法如下：</p><p>加载单个游戏对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject gameObject = loadedAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);</span><br></pre></td></tr></table></figure><p>加载所有资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();</span><br></pre></td></tr></table></figure><p>现在，在前面显示的方法返回要加载的对象类型或对象数组的情况下，异步方法返回 <a href="../ScriptReference/AssetBundleRequest.html">AssetBundleRequest</a>。在访问资源之前，需要等待此操作完成。加载资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync&lt;GameObject&gt;(assetName);</span><br><span class="line">yield return request;</span><br><span class="line">var loadedAsset = request.asset;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();</span><br><span class="line">yield return request;</span><br><span class="line">var loadedAssets = request.allAssets;</span><br></pre></td></tr></table></figure><p>加载资源后，就可以开始了！可以像使用 Unity 中的任何对象一样使用加载的对象。</p><h4 id="加载-AssetBundle-清单"><a href="#加载-AssetBundle-清单" class="headerlink" title="加载 AssetBundle 清单"></a>加载 AssetBundle 清单</h4><p>加载 AssetBundle 清单可能非常有用。特别是在处理 AssetBundle 依赖关系时。</p><p>要获得可用的 <a href="../ScriptReference/AssetBundleManifest.html">AssetBundleManifest</a> 对象，需要加载另外的 AssetBundle（与其所在的文件夹名称相同的那个）并从中加载 AssetBundleManifest 类型的对象。</p><p>加载清单本身的操作方法与 AssetBundle 中的任何其他资源完全相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);</span><br></pre></td></tr></table></figure><p>现在，可以通过上面示例中的清单对象访问 <code>AssetBundleManifest</code> API 调用。从这里，可以使用清单获取所构建的 AssetBundle 的相关信息。此信息包括 AssetBundle 的依赖项数据、哈希数据和变体数据。</p><p>别忘了在前面的部分中，我们讨论过 AssetBundle 依赖项以及如果一个捆绑包对另一个捆绑包有依赖性，那么在从原始捆绑包加载任何资源之前，需要加载哪些捆绑包？清单对象可以动态地查找加载依赖项。假设我们想要为名为“assetBundle”的 AssetBundle 加载所有依赖项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);</span><br><span class="line">string[] dependencies = manifest.GetAllDependencies(&quot;assetBundle&quot;); //传递想要依赖项的捆绑包的名称。</span><br><span class="line">foreach(string dependency in dependencies)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经加载 AssetBundle、AssetBundle 依赖项和资源，因此是时候讨论如何管理所有这些已加载的 AssetBundle 了。</p><h2 id="管理已加载的-AssetBundle"><a href="#管理已加载的-AssetBundle" class="headerlink" title="管理已加载的 AssetBundle"></a>管理已加载的 AssetBundle</h2><p>从活动场景中删除对象时，Unity 不会自动卸载对象。资源清理在特定时间触发，也可以手动触发。</p><p>了解何时加载和卸载 AssetBundle 非常重要。不正确地卸载 AssetBundle 会导致在内存中复制对象或其他不良情况，例如缺少纹理。</p><p>关于 AssetBundle 管理最重要的事情就是何时调用</p><p><a href="../ScriptReference/AssetBundle.Unload.html">AssetBundle.Unload(bool)</a>; 以及应该将 true 还是 false 传递给函数调用。Unload 是一个非静态函数，可用于卸载 AssetBundle。此 API 会卸载正在调用的 AssetBundle 的标头信息。该参数指示是否还要卸载通过此 AssetBundle 实例化的所有对象。</p><p><code>AssetBundle.Unload(true)</code> 卸载从 AssetBundle 加载的所有游戏对象（及其依赖项）。这不包括复制的游戏对象（例如实例化的游戏对象），因为它们不再属于 AssetBundle。发生这种情况时，从该 AssetBundle 加载的纹理（并且仍然属于它）会从场景中的游戏对象消失，因此 Unity 将它们视为缺少纹理。</p><p>假设材质 M 是从 AssetBundle AB 加载的，如下所示。</p><p>如果调用 AB.Unload(true)，活动场景中的任何 M 实例也将被卸载并销毁。</p><p>如果改作调用 AB.Unload(false)，那么将会中断 M 和 AB 当前实例的链接关系。</p><p><img src="/Users/liuyingbo/MyWorkSpace/hexo/source/uploads/Main/AssetBundles-Native-1.png" alt="img"></p><p>如果稍后再次加载 AB 并且调用 AB.LoadAsset()，则 Unity 不会将现有 M 副本重新链接到新加载的材质。而是将加载 M 的两个副本。</p><p><img src="/Users/liuyingbo/Downloads/UnityDocumentation_2019.1/uploads/Main/AssetBundles-Native-1.png" alt="img"></p><p><img src="/Users/liuyingbo/Downloads/UnityDocumentation_2019.1/uploads/Main/AssetBundles-Native-2.png" alt="img"></p><p>通常，使用 <code>AssetBundle.Unload(false)</code> 不会带来理想情况。大多数项目应该使用 <code>AssetBundle.Unload(true)</code> 来防止在内存中复制对象。</p><p>大多数项目应该使用 <code>AssetBundle.Unload(true)</code> 并采用一种方法来确保对象不会重复。两种常用方法是：</p><ul><li>在应用程序生命周期中具有明确定义的卸载瞬态 AssetBundle 的时间点，例如在关卡之间或在加载屏幕期间。</li><li>维护单个对象的引用计数，仅当未使用所有组成对象时才卸载 AssetBundle。这允许应用程序卸载和重新加载单个对象，而无需复制内存。</li></ul><p>如果应用程序必须使用 <code>AssetBundle.Unload(false)</code>，则只能以两种方式卸载单个对象：</p><ul><li>在场景和代码中消除对不需要的对象的所有引用。完成此操作后，调用 <a href="../ScriptReference/Resources.UnloadUnusedAssets.html">Resources.UnloadUnusedAssets</a>。</li><li>以非附加方式加载场景。这样会销毁当前场景中的所有对象并自动调用 <a href="../ScriptReference/Resources.UnloadUnusedAssets.html">Resources.UnloadUnusedAssets</a>。</li></ul><h1 id="加载依赖资源"><a href="#加载依赖资源" class="headerlink" title="加载依赖资源"></a>加载依赖资源</h1><h2 id="通过-API-获取-AssetBundle-依赖信息"><a href="#通过-API-获取-AssetBundle-依赖信息" class="headerlink" title="通过 API 获取 AssetBundle 依赖信息"></a>通过 API 获取 AssetBundle 依赖信息</h2><ul><li>GetAllAssetBundles()<ul><li>描述：获取所有的 AssetBundle 的名字</li></ul></li><li>GetAllDependencies(bundleName)<ul><li>描述：获取目标 AssetBundle 的所有依赖 AssetBundle 名字 (递归遍历)</li></ul></li><li>GetDirectDependencies(bundleName)<ul><li>获取目标 AssetBundle 的直接的依赖 AssetBundle 名字(只遍</li></ul></li></ul><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System.Linq;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace LYFramework.Tests</span><br><span class="line">&#123;</span><br><span class="line">	public class AssetBundleManifestExample : MonoBehaviour</span><br><span class="line">	&#123;</span><br><span class="line">		void Start()</span><br><span class="line">		&#123;</span><br><span class="line">			var windowsBundlePath = AssetBundleUtil.FullPathForAssetBundleName(&quot;Windows&quot;);</span><br><span class="line"></span><br><span class="line">			var windowsBundle = AssetBundle.LoadFromFile(windowsBundlePath);</span><br><span class="line"></span><br><span class="line">			var manifest = windowsBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);</span><br><span class="line"></span><br><span class="line">			manifest.GetAllAssetBundles()</span><br><span class="line">				.ToList()</span><br><span class="line">				.ForEach(Debug.Log);</span><br><span class="line"></span><br><span class="line">			manifest.GetAllDependencies(&quot;coin_get_prefab&quot;)</span><br><span class="line">				.ToList()</span><br><span class="line">				.ForEach(dependBundle =&gt; Debug.LogFormat(&quot;coin_get_prefab depends:&#123;0&#125;&quot;, dependBundle));</span><br><span class="line"></span><br><span class="line">			windowsBundle.Unload(true);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coin_get</span><br><span class="line">coin_get_prefab</span><br><span class="line">coin_get_prefab depends:coin_get</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://liuyingbo.com">刘英博</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://liuyingbo.com/posts/521e43fc.html">https://liuyingbo.com/posts/521e43fc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://liuyingbo.com" target="_blank">狼唤</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post_share"><div class="social-share" data-image="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/e85d694a.html"><img class="prev-cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">二叉树</div></div></a></div><div class="next-post pull-right"><a href="/posts/6b63b37.html"><img class="next-cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity协程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6b63b37.html" title="Unity协程"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-09</div><div class="title">Unity协程</div></div></a></div><div><a href="/posts/9fa0374.html" title="Unity-Shader"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-06</div><div class="title">Unity-Shader</div></div></a></div><div><a href="/posts/undefined.html" title="Unity-全局屏幕点击特效"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-14</div><div class="title">Unity-全局屏幕点击特效</div></div></a></div><div><a href="/posts/b6d0915c.html" title="Unity-底层原理"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-12</div><div class="title">Unity-底层原理</div></div></a></div><div><a href="/posts/6739242f.html" title="Unity-简易对象池"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-01</div><div class="title">Unity-简易对象池</div></div></a></div><div><a href="/posts/cffbee7c.html" title="Unity-编辑器扩展"><img class="cover" src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-29</div><div class="title">Unity-编辑器扩展</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211100000064.JPG" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">刘英博</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/liuyingbor" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gitHub"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=liuyingbo666@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/11929004" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=594686596&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ1"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">Unity资源文件夹介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E6%97%B6"><span class="toc-number">1.1.</span> <span class="toc-text">编辑时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Resources"><span class="toc-number">1.1.1.</span> <span class="toc-text">Resources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SteamingAssets"><span class="toc-number">1.1.2.</span> <span class="toc-text">SteamingAssets</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%90%8E"><span class="toc-number">1.2.</span> <span class="toc-text">安装后</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Application-dataPath"><span class="toc-number">1.2.1.</span> <span class="toc-text">Application.dataPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Application-streamingAssetsPath"><span class="toc-number">1.2.2.</span> <span class="toc-text">Application.streamingAssetsPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Application-presistentDataPath"><span class="toc-number">1.2.3.</span> <span class="toc-text">Application.presistentDataPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Application-temporaryCachePath"><span class="toc-number">1.2.4.</span> <span class="toc-text">Application.temporaryCachePath</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AssetBundle"><span class="toc-number">1.3.</span> <span class="toc-text">AssetBundle</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AssetBundle-1"><span class="toc-number">2.</span> <span class="toc-text">AssetBundle</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Asset-Bundle%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">Asset Bundle：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AssetBundle-%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.</span> <span class="toc-text">AssetBundle 中有什么:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA-AssetBundle-%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90"><span class="toc-number">2.3.</span> <span class="toc-text">为 AssetBundle 分配资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-AssetBundle"><span class="toc-number">2.4.</span> <span class="toc-text">构建 AssetBundle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86-AssetBundle-%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%9C%BA%E5%A4%96%E5%AD%98%E5%82%A8"><span class="toc-number">2.5.</span> <span class="toc-text">将 AssetBundle 上传到场外存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-AssetBundle-%E5%92%8C%E8%B5%84%E6%BA%90"><span class="toc-number">2.6.</span> <span class="toc-text">加载 AssetBundle 和资源</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA-AssetBundle-%E5%87%86%E5%A4%87%E8%B5%84%E6%BA%90"><span class="toc-number">3.</span> <span class="toc-text">为 AssetBundle 准备资源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%AE%9E%E4%BD%93%E5%88%86%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">逻辑实体分组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">类型分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%86%85%E5%AE%B9%E5%88%86%E7%BB%84"><span class="toc-number">3.3.</span> <span class="toc-text">并发内容分组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-AssetBundle-1"><span class="toc-number">4.</span> <span class="toc-text">构建 AssetBundle</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BuildAssetBundleOptions"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">BuildAssetBundleOptions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BuildTarget"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">BuildTarget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AssetBundle-%E6%96%87%E4%BB%B6"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">AssetBundle 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E5%8D%95%E6%96%87%E4%BB%B6"><span class="toc-number">4.0.0.4.</span> <span class="toc-text">清单文件</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#AssetBundle-%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="toc-number">5.</span> <span class="toc-text">AssetBundle 依赖项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-AssetBundle"><span class="toc-number">6.</span> <span class="toc-text">使用 AssetBundle</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AssetBundle-LoadFromMemoryAsync"><span class="toc-number">6.1.</span> <span class="toc-text">AssetBundle.LoadFromMemoryAsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AssetBundle-LoadFromFile"><span class="toc-number">6.2.</span> <span class="toc-text">AssetBundle.LoadFromFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WWW-LoadFromCacheOrDownload"><span class="toc-number">6.3.</span> <span class="toc-text">WWW.LoadFromCacheOrDownload</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UnityWebRequest"><span class="toc-number">6.4.</span> <span class="toc-text">UnityWebRequest</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-AssetBundle-%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90"><span class="toc-number">6.4.0.1.</span> <span class="toc-text">从 AssetBundle 加载资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-AssetBundle-%E6%B8%85%E5%8D%95"><span class="toc-number">6.4.0.2.</span> <span class="toc-text">加载 AssetBundle 清单</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%B7%B2%E5%8A%A0%E8%BD%BD%E7%9A%84-AssetBundle"><span class="toc-number">6.5.</span> <span class="toc-text">管理已加载的 AssetBundle</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%BE%9D%E8%B5%96%E8%B5%84%E6%BA%90"><span class="toc-number">7.</span> <span class="toc-text">加载依赖资源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-API-%E8%8E%B7%E5%8F%96-AssetBundle-%E4%BE%9D%E8%B5%96%E4%BF%A1%E6%81%AF"><span class="toc-number">7.1.</span> <span class="toc-text">通过 API 获取 AssetBundle 依赖信息</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ba6d86a1.html" title="C#数据结构与算法"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="C#数据结构与算法"></a><div class="content"><a class="title" href="/posts/ba6d86a1.html" title="C#数据结构与算法">C#数据结构与算法</a><time datetime="2022-11-16T16:11:17.071Z" title="发表于 2022-11-16 16:11:17">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1d0254fc.html" title="Unity-移动平台相关（一）"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-移动平台相关（一）"></a><div class="content"><a class="title" href="/posts/1d0254fc.html" title="Unity-移动平台相关（一）">Unity-移动平台相关（一）</a><time datetime="2022-09-01T15:06:06.000Z" title="发表于 2022-09-01 15:06:06">2022-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ba9e7782.html" title="Unity-网络开发（三）"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-网络开发（三）"></a><div class="content"><a class="title" href="/posts/ba9e7782.html" title="Unity-网络开发（三）">Unity-网络开发（三）</a><time datetime="2022-08-14T22:13:47.000Z" title="发表于 2022-08-14 22:13:47">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34c3e4a1.html" title="Unity-UniTask"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-UniTask"></a><div class="content"><a class="title" href="/posts/34c3e4a1.html" title="Unity-UniTask">Unity-UniTask</a><time datetime="2022-08-14T21:24:49.000Z" title="发表于 2022-08-14 21:24:49">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c7963808.html" title="Unity-网络开发（一）"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211142315362.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Unity-网络开发（一）"></a><div class="content"><a class="title" href="/posts/c7963808.html" title="Unity-网络开发（一）">Unity-网络开发（一）</a><time datetime="2022-05-16T15:06:06.000Z" title="发表于 2022-05-16 15:06:06">2022-05-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 刘英博</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.liuyingbo.com/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.liuyingbo.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/title.js"></script><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true"></div><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script></body></html>