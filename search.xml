<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity-移动平台相关Java语法</title>
      <link href="/posts/fff1.html"/>
      <url>/posts/fff1.html</url>
      
        <content type="html"><![CDATA[<p><strong>简单</strong>了解Java语法</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Java环境：www.baidu.com</p><p>写Java编辑器推荐是IDEA</p><p>但是我们是Unity导出的Android项目所以还是用AndroidStudio</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="Java中的有符号整型"><a href="#Java中的有符号整型" class="headerlink" title="Java中的有符号整型"></a>Java中的有符号整型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.byte(1个字节，8位，-2^7 ~ 2^7 - 1，-128 ~ 127)</span></span><br><span class="line">System.out.println(<span class="string">&quot;byte位数&quot;</span> + Byte.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;byte最大值&quot;</span> + Byte.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;byte最小值&quot;</span> + Byte.MIN_VALUE);</span><br><span class="line"><span class="comment">//2.short(2个字节，16位，-2^15 ~ 2^15 - 1，-32768 ~ 32767)</span></span><br><span class="line">System.out.println(<span class="string">&quot;short位数&quot;</span> + Short.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;short最大值&quot;</span> + Short.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;short最小值&quot;</span> + Short.MIN_VALUE);</span><br><span class="line"><span class="comment">//3.int(4个字节，32位，-2^31 ~ 2^31 - 1，-2,147,483,648 ~ 2,147,483,647)</span></span><br><span class="line">System.out.println(<span class="string">&quot;int位数&quot;</span> + Integer.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;int最大值&quot;</span> + Integer.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;int最小值&quot;</span> + Integer.MIN_VALUE);</span><br><span class="line"><span class="comment">//4.long(8个字节，64位，-2^63 ~ 2^63 - 1，9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)</span></span><br><span class="line">System.out.println(<span class="string">&quot;long位数&quot;</span> + Long.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;long最大值&quot;</span> + Long.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;long最小值&quot;</span> + Long.MIN_VALUE);</span><br><span class="line"><span class="comment">//注意：Java最初设计中没有无符号类型</span></span><br><span class="line"><span class="comment">//Java 8中添加了一些和无符号类型有关的一些方法(但是一般使用较少)</span></span><br></pre></td></tr></table></figure><h3 id="Java中的浮点型"><a href="#Java中的浮点型" class="headerlink" title="Java中的浮点型"></a>Java中的浮点型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.float(4个字节，32位)</span></span><br><span class="line">System.out.println(<span class="string">&quot;float位数&quot;</span> + Float.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;float最大值&quot;</span> + Float.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;float最小值&quot;</span> + Float.MIN_VALUE);</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">.5f</span>;</span><br><span class="line">System.out.println(f);</span><br><span class="line">f = <span class="number">1.f</span>;</span><br><span class="line">System.out.println(f);</span><br><span class="line"><span class="comment">//2.double(8个字节，64位)</span></span><br><span class="line">System.out.println(<span class="string">&quot;double位数&quot;</span> + Double.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;double最大值&quot;</span> + Double.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;double最小值&quot;</span> + Double.MIN_VALUE);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.5</span>;</span><br></pre></td></tr></table></figure><h3 id="Java中的其它类型"><a href="#Java中的其它类型" class="headerlink" title="Java中的其它类型"></a>Java中的其它类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.boolean(单个boolean在编译时使用int类型，这时4个字节；boolean数组时，编译时用字节数组，所以占1个字节)</span></span><br><span class="line"><span class="comment">//默认值是false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b0</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span>[] bs;</span><br><span class="line"><span class="comment">//2.char(2个字节，16位)</span></span><br><span class="line">System.out.println(<span class="string">&quot;char位数&quot;</span> + Character.SIZE);</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(c);</span><br><span class="line"><span class="comment">//3.String(根据字符串长度而定)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><h3 id="Java中的常量"><a href="#Java中的常量" class="headerlink" title="Java中的常量"></a>Java中的常量</h3><p>关键字：final</p><p>特点：必须初始化，不能被修改</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.隐式转换：低级（字节少的）到高级（字节多的）</span></span><br><span class="line"><span class="comment">//记住一句话 大容器 可以装 小容器 不需要我们去处理</span></span><br><span class="line"><span class="comment">//byte——&gt;short——&gt;char——&gt;int——&gt;long——&gt;float——&gt;double</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> b2;</span><br><span class="line"><span class="comment">//2.显示转换：括号强转，高级到低级会丢失精度或者报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">40000</span>;</span><br><span class="line">s2 = (<span class="type">short</span>) i3;</span><br><span class="line">System.out.println(s2);</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">2.5f</span>;</span><br><span class="line">i3 = (<span class="type">int</span>)f2;</span><br><span class="line">System.out.println(i3);</span><br><span class="line"><span class="comment">//3.字符串转数值 包装类中的parse相关方法</span></span><br><span class="line">i3 = Integer.parseInt(<span class="string">&quot;101&quot;</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(i3);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java的变量类型和C#非常的类似</p><p>其中需要注意的是</p><p>1.Java中没有专门的无符号类型</p><p>2.Java中的常量关键字和C#不一样</p><p>3.一些关键字和方法写法不同</p><p>其它的变量相关操作表现和C#中极奇相似</p><h2 id="运算符、条件语句、循环语句、数组"><a href="#运算符、条件语句、循环语句、数组" class="headerlink" title="运算符、条件语句、循环语句、数组"></a>运算符、条件语句、循环语句、数组</h2><p>Java和C#基本一样</p><p>就把它当做C#来写即可</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="Arrays静态类"><a href="#Arrays静态类" class="headerlink" title="Arrays静态类"></a>Arrays静态类</h2><p>Arrays类是什么</p><p>Arrays类是Java提供的一个专门对数组进行操作的类</p><p>它提供了很多静态方法，共我们对数组进行处理</p><p>比如排序、查找、填充等等方法</p><p>使用它 需要导入java.util.Arrays包（类似C#中的命名空间）</p><h3 id="填充替换数组元素"><a href="#填充替换数组元素" class="headerlink" title="填充替换数组元素"></a>填充替换数组元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays.fill 方法可以帮助我们对数组进行填充</span></span><br><span class="line"><span class="comment">//它有两个重载</span></span><br><span class="line"><span class="comment">//1.Arrays.fill(数组,填充值)</span></span><br><span class="line"><span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.fill(arr, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.Arrays.fill(数组,填充起始位置(包括),填充结束位置(不包括),填充值)</span></span><br><span class="line">Arrays.fill(arr, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.fill(arr, <span class="number">1</span>, arr.length, <span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays.sort(数组) 方法可以对数组进行默认的升序排序</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Arrays.copyOf(数组，复制长度) 方法可以赋值指定数组的指定长度</span></span><br><span class="line"><span class="comment">//若长度 小于传入数组，则截取；若长度 大于传入数组，则用默认值填充</span></span><br><span class="line"><span class="type">int</span>[] arr2 = Arrays.copyOf(arr, <span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr2) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Arrays.copyOfRange(数组，开始复制索引（包括），赋值的最后索引位置（不包括）)</span></span><br><span class="line">arr2 = Arrays.copyOfRange(arr, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr2) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询数组"><a href="#查询数组" class="headerlink" title="查询数组"></a>查询数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays.binarySearch(数组，搜索元素)</span></span><br><span class="line"><span class="comment">//注意：由于binarySearch内部是对数组进行二分查找</span></span><br><span class="line"><span class="comment">//所以使用前必须对数组进行排序</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="comment">//一定该记住 使用该API之前 一定概要排序</span></span><br><span class="line"><span class="comment">//如果数组当中没有想要寻找的元素 那么返回值为负数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line">System.out.println(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.binarySearch(数组，开始索引(包括)，结束索引(不包括)，搜索元素)</span></span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Java中如果相对数组进行填充、替换、排序、复制、查询等操作</p><p>我们可以使用Arrays类中的静态方法</p><p>填充替换：fill</p><p>排序：sort</p><p>复制：copyOf、copyOfRange</p><p>查询：binarySearch</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 移动平台 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-移动平台相关Android</title>
      <link href="/posts/1d0254fc.html"/>
      <url>/posts/1d0254fc.html</url>
      
        <content type="html"><![CDATA[<h2 id="Android发布流程"><a href="#Android发布流程" class="headerlink" title="Android发布流程"></a>Android发布流程</h2><h3 id="Unity2019及以上"><a href="#Unity2019及以上" class="headerlink" title="Unity2019及以上"></a>Unity2019及以上</h3><p>发布Android准备工作</p><p>通过UnityHub安装Android平台相关工具</p><p>1.Android构建支持</p><p>2.Android SDK（安卓软件开发工具包）、NDKTools（本地开发工具包）</p><p>3.OpenJDK（Java开发工具包）</p><p>注意：Unity支持Android 5.1及以上版本</p><h3 id="Unity2019以下版本"><a href="#Unity2019以下版本" class="headerlink" title="Unity2019以下版本"></a>Unity2019以下版本</h3><p>1.Android构建支持工具安装（Unity提供下载,安装时需要关闭Unity）</p><p>2.JDK（Java开发工具包）（网络下载） JDK 必须是版本 8</p><p><a href="https://www.oracle.com/java/technologies/downloads/#jdk18-windows">https://www.oracle.com/java/technologies/downloads/#jdk18-windows</a></p><p>3.NDK (本地开发工具包)（网络下载）NDK 版本必须是 Unity2018——r16b, Unity2017——r13d</p><p>注意：NDK是可选的工具，如果之后要发il2cpp的应用程序，那么NDK是必须的，如果是Mono可以不使用它</p><p><a href="https://blog.csdn.net/momo0853/article/details/73898066">https://blog.csdn.net/momo0853/article/details/73898066</a></p><p><a href="https://developer.android.google.cn/ndk/downloads/#lts-downloads">https://developer.android.google.cn/ndk/downloads/#lts-downloads</a></p><p>4.Android SDK（安卓软件开发工具包）（网络下载或通过AndroidStudio下载）</p><p>建议通过AndroidStudio下载</p><p><a href="https://developer.android.com/studio">https://developer.android.com/studio</a></p><p>安装AndroidStudio后 通过它来安装AndroidSDK</p><p>5.Java环境变量配置</p><p>我的电脑——&gt;系统属性——&gt;查找——&gt;系统环境变量——&gt;环境变量</p><p>5-1:JAVA_HOME: 变量值为JDK在你电脑上的安装路径</p><p>安装好后可以利用%JAVA_HOME%作为JDK安装目录的统一引用路径</p><p>5-2:Path: 编辑Path属性，在原变量后追加 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</p><p>5-3:CLASSPATH: 变量值为 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</p><h3 id="发布前必修改的设置"><a href="#发布前必修改的设置" class="headerlink" title="发布前必修改的设置"></a>发布前必修改的设置</h3><p>在File —— Build Setting —— Player Setting中修改</p><p>1.公司名</p><p>2.游戏项目名</p><p>3.版本号</p><p>4.默认图标</p><p>5.Other Settings —— Package Name（必须修改设置）</p><p>6.Other Settings —— Minimum APILevel</p><h2 id="Unity发布参数"><a href="#Unity发布参数" class="headerlink" title="Unity发布参数"></a>Unity发布参数</h2><h3 id="Build-Settings-参数"><a href="#Build-Settings-参数" class="headerlink" title="Build Settings 参数"></a>Build Settings 参数</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133874.png" alt="image-20220901221824489"></p><h4 id="Texture-Compression"><a href="#Texture-Compression" class="headerlink" title="Texture Compression"></a><strong>Texture Compression</strong></h4><p><strong>纹理压缩</strong><br><strong>设置发布后的纹理压缩格式</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133057.png" alt="image-20220901221934763"></p><p>**Use Player Settings: 使用在播放器设置中设置的纹理压缩格式<br>ETC：使用ETC格式<br>ETC2：使用ETC2格式<br>ASTC：使用ASTC格式<br>DXT：使用DXT格式<br>PVRTC：使用PVRTC格式</p><p>了解格式详细信息：<a href="https://docs.unity.cn/cn/2021.3/Manual/class-TextureImporterOverride.html#android">https://docs.unity.cn/cn/2021.3/Manual/class-TextureImporterOverride.html#android</a></p><p>注意：对于安卓ETC2是常用的压缩格式，支持透明通道。但是对于老设备不支持ETC2，可以使用ETC。<br>我们可以统一设置为ETC2，在下方的ETC2 fallback中设置，如果不支持ETC2，使用哪种压缩方式**</p><h4 id="ETC2-fallback"><a href="#ETC2-fallback" class="headerlink" title="ETC2 fallback"></a><strong>ETC2 fallback</strong></h4><p><strong>ETC2回退</strong><br><strong>当Unity用于不支持ETC2的安卓设备时的RGBA纹理格式</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133278.png" alt="image-20220901222221490"></p><p>32-bit：32位<br>以全分辨率存储RGBA纹理，使用32位存储每个像素，质量最高，内存占用最多</p><p>16-bit：16位<br>以全分辨率存储RGBA纹理，使用16位存储每个像素，质量较低，纹理可能会丢失有价值的颜色信息，内存占用相对较少</p><p>32-bit, half resolution：32位，半分辨率<br>以半分辨率存储RGBA纹理，使用32位存储每个像素，由于是半分辨率，纹理会变得模糊，内存占用较小</p><p>注意：如果使用的不是ETC2压缩，大多数压缩格式，使用32-bit备用<br>取决于GPU支持什么</p><h4 id="Export-Project"><a href="#Export-Project" class="headerlink" title="Export Project"></a><strong>Export Project</strong></h4><p><strong>导出项目</strong><br><strong>勾选后，不会发布成apk，而是会将Unity项目导出为可以导入Android Studio的Gradle项目</strong></p><h4 id="Symlink-Sources"><a href="#Symlink-Sources" class="headerlink" title="Symlink Sources"></a>Symlink Sources</h4><p>符号链接源<br>当勾选Exprot Project时，才能勾选此选项。<br>决定是否在Unity和导出的Gradle项目之间共享Java和Kotlin源文件<br>启用后，对于测试和迭代Java和Kotlin代码很有用，如果你重新导出Unity项目，你在导出的项目对之前的Java和Kotlin源文件的任何更改都会保留</p><p>如果你想导出后进行二次开发，建议勾选此选项</p><h4 id="Build-App-Bundle-Google-Play"><a href="#Build-App-Bundle-Google-Play" class="headerlink" title="Build App Bundle (Google Play)"></a>Build App Bundle (Google Play)</h4><p>构建应用捆绑包<br>是否将应用程序作为Android应用捆绑包（AAB）<br>启用，发布出去是一个AAB（可以配合安卓进行二次开发）<br>禁用，发布出去是一个APK（直接就是一个可安装的应用程序）</p><h4 id="Create-symbols-zip"><a href="#Create-symbols-zip" class="headerlink" title="Create symbols.zip"></a><strong>Create symbols.zip</strong></h4><p><strong>创建 符号压缩文件</strong><br><strong>符号文件可以帮助我们调试应用程序</strong><br><strong>Unity会生成一个包含本机Unity库的符号文件的包</strong><br><strong>它包含一个表，将活动内存地址转换为我们可以使用的信息，比如方法名，我们可以利用符号包来检测调试应用程序的信息**</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133225.png" alt="image-20220901222330411"></p><p><strong>Disabled：不生成</strong><br><strong>Public：Unity生成一个公共符号为程序打包</strong><br><strong>公共符号文件包含将函数地址解析为人类可读字符串的信息，包小于调试符号的包</strong><br><strong>Debugging：Unity生成一个调试符号为程序打包</strong><br><strong>包含完整的调试信息和符号表，可以用来解析堆栈、将本机调试器附加到应用程序调试代码</strong></p><h4 id="Run-Device"><a href="#Run-Device" class="headerlink" title="Run Device"></a><strong>Run Device</strong></h4><p><strong>运行的设备</strong><br><strong>指定在哪个附加设备上测试生成</strong><br><strong>如果你连接了新设备或在列表中没有看到连接的设备</strong><br><strong>点击刷新Refresh</strong></p><h4 id="Build-to-Device"><a href="#Build-to-Device" class="headerlink" title="Build to Device"></a><strong>Build to Device</strong></h4><p><strong>构建到设备</strong><br><strong>不创建完整的构建，而是将发生修改的单个文件直接部署到设备上</strong><br><strong>相对来说更加快速，方便调试</strong></p><h4 id="Development-Build"><a href="#Development-Build" class="headerlink" title="Development Build"></a><strong>Development Build</strong></h4><p><strong>开发模式构建</strong><br><strong>是否包含脚本调试符号和性能分析器到你的项目中，如果你想要调试应用程序，请选择该选项</strong></p><h4 id="Autoconnect-Profiler"><a href="#Autoconnect-Profiler" class="headerlink" title="Autoconnect Profiler"></a><strong>Autoconnect Profiler</strong></h4><p><strong>自动连接分析器</strong><br><strong>是否自动将分析器连接到生成的应用程序</strong></p><h4 id="Deep-Profiling"><a href="#Deep-Profiling" class="headerlink" title="Deep Profiling"></a><strong>Deep Profiling</strong></h4><p><strong>深度剖析</strong><br><strong>是否启用深度剖析在分析器中，可以让分析器能够检测应用程序中每个函数调用，从而返回更加详细的分析数据</strong><br><strong>注意：该选项会降低脚本的执行速度</strong></p><h4 id="Script-Debugging"><a href="#Script-Debugging" class="headerlink" title="Script Debugging"></a><strong>Script Debugging</strong></h4><p><strong>是否允许调试应用程序的脚本文件</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133607.png" alt="image-20220901223243427"></p><p><strong>Wait For Managed Debugger</strong><br><strong>是否等待托管调试器</strong><br><strong>程序在运行脚本代码之前是否等待调试器连接</strong></p><h4 id="Compression-Method"><a href="#Compression-Method" class="headerlink" title="Compression Method"></a>Compression Method</h4><p>压缩方法<br>Unity在构建时压缩项目中数据的方式</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134820.png" alt="image-20220901223442983"></p><p>Default：默认使用ZIP，压缩效果略好于LZ4和LZ4HC，但是数据解压速度较慢<br>LZ4：使用LZ4，这时一种快速压缩格式，相对ZIP可以显著提高Unity应用程序的加载时间<br>LZ4HC：LZ4的高压缩版本，构建速度较慢，但是对于发布版本会产生更好的结果，相对ZIP可以显著提高应用程序加载时间</p><h4 id="Max-Texture-Size"><a href="#Max-Texture-Size" class="headerlink" title="Max Texture Size"></a>Max Texture Size</h4><p>最大的纹理大小<br>用于本地开发时导入纹理的最大尺寸<br>减小最大纹理大小可以加快资源导入和平台切换</p><h4 id="Texture-Compression-1"><a href="#Texture-Compression-1" class="headerlink" title="Texture Compression"></a>Texture Compression</h4><p>纹理压缩<br>选择下面两个选项，可以加快资源导入和平台切换</p><p>No Override：使用默认设置<br>Force Fast Compressor：强制快速压缩<br>Force Uncompressed：强制解压缩</p><h3 id="Player-Settings相关"><a href="#Player-Settings相关" class="headerlink" title="Player Settings相关"></a><strong>Player Settings相关</strong></h3><h4 id="Player-基础设置"><a href="#Player-基础设置" class="headerlink" title="Player 基础设置"></a>Player <strong>基础设置</strong></h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134900.png" alt="image-20220901224319232"></p><h4 id="Icon-图标设置"><a href="#Icon-图标设置" class="headerlink" title="Icon 图标设置"></a><strong>Icon 图标设置</strong></h4><p><strong>设置在设备上显示的应用图标</strong></p><p><strong>Adaptive：运行在Android8.0及以上版本上的设备显示的应用图标</strong><br><strong>Round：运行在Android7.1及以上版本上的设备显示的应用图标</strong><br><strong>Legacy icons：运行在Android7.1以下版本上的设备显示的应用图标</strong></p><h4 id="Resolution-and-Presentation-分辨率和演示设置"><a href="#Resolution-and-Presentation-分辨率和演示设置" class="headerlink" title="Resolution and Presentation 分辨率和演示设置"></a><strong>Resolution and Presentation 分辨率和演示设置</strong></h4><h5 id="Fullscreen-Mode"><a href="#Fullscreen-Mode" class="headerlink" title="Fullscreen Mode"></a>Fullscreen Mode</h5><p>全屏模式</p><p>Fullscreen Window：<br>全屏窗口（导航栏始终处于隐藏状态）<br>会缩放应用程序内容，为了匹配纵横比，可能会有黑边</p><p>Windowed：<br>窗口模式，窗口大小取决于应用程序分辨率</p><h5 id="Resizable-Window"><a href="#Resizable-Window" class="headerlink" title="Resizable Window"></a>Resizable Window</h5><p>课调整大小的窗口</p><p>设置用户是否可以调整应用程序窗口的大小</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134540.png" alt="image-20220901225112530"></p><p>此设置可以安卓和平板电脑上的应用程序中启用多窗口功能<br>详情：<a href="https://developer.android.com/guide/topics/ui/multi-window#java">https://developer.android.com/guide/topics/ui/multi-window#java</a></p><h5 id="Hide-Navigation-Bar"><a href="#Hide-Navigation-Bar" class="headerlink" title="Hide Navigation Bar"></a><strong>Hide Navigation Bar</strong></h5><p><strong>是否隐藏顶部显示的导航栏</strong></p><h5 id="Render-outside-safe-area"><a href="#Render-outside-safe-area" class="headerlink" title="Render outside safe area"></a><strong>Render outside safe area</strong></h5><p><strong>是否应使用所有可用的屏幕控件进行渲染</strong><br><strong>包括留海区域</strong></p><h5 id="Optimized-frame-Pacing"><a href="#Optimized-frame-Pacing" class="headerlink" title="Optimized frame Pacing"></a>Optimized frame Pacing</h5><p>是否应均匀分布帧以减小帧速率的方差，启用后体验更流程</p><h4 id="Resolution-Scaling分辨率缩放"><a href="#Resolution-Scaling分辨率缩放" class="headerlink" title="Resolution Scaling分辨率缩放"></a>Resolution Scaling分辨率缩放</h4><h5 id="Resolution-Scaling-Mode"><a href="#Resolution-Scaling-Mode" class="headerlink" title="Resolution Scaling Mode"></a>Resolution Scaling Mode</h5><p>分辨率缩放模式</p><p>Disabled：禁用<br>不应用分辨率缩放，应用程序呈现为设备的本机屏幕分辨率</p><p>Fixed DPI：使用API应用分辨率缩放，使用此选项可优化性能和电池寿命</p><p>Target DPI：如果设备的本机屏幕DPI高于设置的值，Unity将降低应用程序的分辨率以匹配此设置<br>计算方式：<br>Min（Target DPI * Factor / Screen DPI，1）<br>其中Factor是在Quality质量设置中设置的 Resolution Scaling Fixed DPI Factor参数</p><h5 id="Reset-resolution-on-window-resize"><a href="#Reset-resolution-on-window-resize" class="headerlink" title="Reset resolution on window resize:"></a>Reset resolution on window resize:</h5><p>当本机窗口大小更改时，是否将屏幕分辨率设置为新的本机窗口大小<br>如果分辨率缩放模式是Fixed DPI，则将重新计算分辨率</p><h5 id="Blit-Type："><a href="#Blit-Type：" class="headerlink" title="Blit Type："></a>Blit Type：</h5><p>光高类型<br>是否使用Blit将最终图像呈现在屏幕上</p><p>Always：总是让Unity渲染到屏幕外的缓冲区，然后使用Blit将缓冲区的内容复制到设备的帧缓冲区（这和大部分设备兼容，但比不用Blit慢）</p><p>Nerver：Unity将渲染到设备操作系统提供的帧缓冲区，如果失败，会有警告信息打印到日志当中。通常比使用Blit块，但是不兼容所有设备</p><p>Auto：Unity会渲染到设备操作系统提供的帧缓冲区，如果失败，会打印到日志中，并使用Blit将最终图像呈现到屏幕上</p><h4 id="Supported-Aspect-Ratio：支持的纵横比"><a href="#Supported-Aspect-Ratio：支持的纵横比" class="headerlink" title="Supported Aspect Ratio：支持的纵横比"></a>Supported Aspect Ratio：支持的纵横比</h4><p>Orientation：屏幕取向</p><h5 id="Aspect-Ratio-Mode："><a href="#Aspect-Ratio-Mode：" class="headerlink" title="Aspect Ratio Mode："></a>Aspect Ratio Mode：</h5><p>指定应用程序支持的最大纵横比。</p><p>如果设备的纵横比大于此纵横比，Unity会将此纵横比用于应用程序，并添加黑条，使应用程序不会拉伸</p><p>Legacy Wide Screen(1.86):支持android的传统宽屏宽高比</p><p>Native Aspect Ratio:支持Android本机宽高比的宽高比</p><p>Custom:自定义纵横比</p><p>选择自定义纵横比时可以自己设置</p><h5 id="Default-Orientation："><a href="#Default-Orientation：" class="headerlink" title="Default Orientation："></a><strong>Default Orientation：</strong></h5><p><strong>默认取向</strong></p><p><strong>指定应用程序使用的屏幕方向（横屏、竖屏设置）</strong></p><p><strong>Portrait：竖屏（应用程序窗口底部和屏幕底部对齐）</strong><br><strong>Portrait Upside Down：竖屏倒置（应用程序窗口底部和屏幕顶部对齐）</strong><br><strong>Landscape Right：右横屏（应用程序窗口右侧和屏幕底部对齐）</strong><br><strong>Landscape Left：左横屏（应用程序窗口左侧和屏幕底部对齐）</strong><br><strong>Auto Rotation：自动旋转，可以旋转到你允许的任意方向，在下方勾选即可</strong></p><h5 id="Use-32-bit-Display-Buffer："><a href="#Use-32-bit-Display-Buffer：" class="headerlink" title="Use 32-bit Display Buffer："></a>Use 32-bit Display Buffer：</h5><p>显示缓冲区是否保存32位颜色值而不是16位颜色值。</p><p>如果你在后期处理效果中看到了条带效果或者需要Alpha值，请启用此设置，某些后期处理效果需要开其它，因为他们以显示缓冲区相同的格式创建渲染纹理</p><h5 id="Disable-Depth-and-Stencil："><a href="#Disable-Depth-and-Stencil：" class="headerlink" title="Disable Depth and Stencil："></a>Disable Depth and Stencil：</h5><p>是否禁用深度和模板缓冲区</p><h5 id="Render-Over-Native-UI："><a href="#Render-Over-Native-UI：" class="headerlink" title="Render Over Native UI："></a>Render Over Native UI：</h5><p>在本机UI上呈现<br>设置是否在Android或者IOS的本机UI上进行渲染<br>如果要该设置生效，需要把相机的清楚标志设置为使用Alpha值低于1的纯色</p><h5 id="Show-Loading-Indicator："><a href="#Show-Loading-Indicator：" class="headerlink" title="Show Loading Indicator："></a>Show Loading Indicator：</h5><p>显示加载指示器<br>指定加载指示器是否显示以及如何显示</p><p>Don’t Show:不显示加载指示条<br>Large:显示大的加载指示条<br>Inversed Large:显示大的加载指示条，并带有翻转颜色<br>Small:显示小的加载指示条<br>Inversed Small:显示小的加载指示条，并带有翻转颜色</p><h4 id="Splash-Image"><a href="#Splash-Image" class="headerlink" title="Splash Image:"></a>Splash Image:</h4><p>启动图像设置</p><h5 id="Virtual-Reality-Splash-Image"><a href="#Virtual-Reality-Splash-Image" class="headerlink" title="Virtual Reality Splash Image:"></a>Virtual Reality Splash Image:</h5><p>虚拟现实的初始屏幕设置</p><h5 id="Show-Splash-Screen："><a href="#Show-Splash-Screen：" class="headerlink" title="Show Splash Screen："></a>Show Splash Screen：</h5><p>是否显示启动图像（收费版本才能修改，免费版本不能改）</p><h5 id="Preview："><a href="#Preview：" class="headerlink" title="Preview："></a>Preview：</h5><p>预览</p><h5 id="Splash-Style："><a href="#Splash-Style：" class="headerlink" title="Splash Style："></a>Splash Style：</h5><p>启动风格</p><p>Dark on Light: 暗到亮<br>Light on Dark: 亮到暗</p><h5 id="Animation"><a href="#Animation" class="headerlink" title="Animation:"></a>Animation:</h5><p>启动图像动画效果</p><p>Static：静态不动的<br>Dolly：由小变大<br>Custom：自定义</p><p><strong>Draw Mode：绘制模式</strong></p><p><strong>Unity Logo Below：Unity Logo显示在前</strong><br><strong>All Sequential：所有按顺序</strong></p><p><strong>Logos：可以自己添加Logo图片按顺序显示</strong></p><h5 id="BackGround：背景相关"><a href="#BackGround：背景相关" class="headerlink" title="BackGround：背景相关"></a>BackGround：背景相关</h5><p>Overlay Opacity:<br>覆盖不透明度</p><p>Background Color:<br>背景颜色</p><p>Blur Background Image:<br>模糊背景图像</p><p>Background Image:<br>背景图像</p><p>Alternate Portrait Image:<br>备选图像</p><p>Static Splash Image:<br>静态启动图像</p><p>Scaling:<br>缩放比例</p><p>Center：<br>居中（仅缩小）：除非图像太大，否则以原始大小绘制图像，Unity会缩小图像</p><p>Scale to fit：<br>缩放以适应（填充），缩放图像，使较长尺寸完全适合屏幕大小，以黑色填充两侧空白区域</p><p>Scale to fit：<br>缩放以适应（裁剪），缩放图像，使较短的尺寸完全适合屏幕大小，将图像裁剪为较长的维度</p><h3 id="OtherSetting相关"><a href="#OtherSetting相关" class="headerlink" title="OtherSetting相关"></a>OtherSetting相关</h3><h4 id="Rendering渲染设置"><a href="#Rendering渲染设置" class="headerlink" title="Rendering渲染设置"></a>Rendering渲染设置</h4><h5 id="Unity程序员必了解的图形程序接口"><a href="#Unity程序员必了解的图形程序接口" class="headerlink" title="Unity程序员必了解的图形程序接口"></a><strong>Unity程序员必了解的图形程序接口</strong></h5><h6 id="OpenGL（Open-Graphics-Library）"><a href="#OpenGL（Open-Graphics-Library）" class="headerlink" title="OpenGL（Open Graphics Library）"></a><strong>OpenGL（Open Graphics Library）</strong></h6><p>中文翻译过来是<strong>开放图形库</strong>，它定义了一个<strong>跨平台、跨语言</strong>的编程接口规格的专业图形程序接口，可以用于3D、2D图形渲染，是一个功能强大、调用方便的底层图形库。由于它跨平台、跨语言、出现时间早，因此它的应用极其广泛！</p><h6 id="OpenGL-ES（OpenGL-for-Embedded-Systems）"><a href="#OpenGL-ES（OpenGL-for-Embedded-Systems）" class="headerlink" title="OpenGL ES（OpenGL for Embedded Systems）"></a><strong>OpenGL ES（OpenGL for Embedded Systems）</strong></h6><p>中文翻译过来是<strong>用于嵌入式系统的开放图形库</strong>，它是<strong>OpenGL的子级</strong>，<strong>主要针对手机、游戏主机</strong>等嵌入式设备而设计，免授权费、跨平台、功能完善。</p><p>GLES2.0、GLES3.0 指的就是OpenGL ES这套标准，他们也是Android和IOS手机上常用的图形处理标准。</p><p><strong>Unity在移动平台进行图形渲染处理时，就包含了OpenGL ES方案</strong></p><h6 id="Vulkan"><a href="#Vulkan" class="headerlink" title="Vulkan"></a><strong>Vulkan</strong></h6><p>“下一代”开放的图形显示API，是与DX12能够匹敌的GPU API标准。它有一套最新的图形加速API接口，目标是提供更灵活和丰富的底层操作接口，以替代OpenGL 和 OpenGL ES接口，<strong>可**</strong>以把Vulkan看做是OpenGL的升级版<strong>，目前</strong>新版本的Unity支持使用Vulkan方案**。</p><h6 id="Directx（Direct-eXtension）"><a href="#Directx（Direct-eXtension）" class="headerlink" title="Directx（Direct eXtension）"></a><strong>Directx（Direct eXtension）</strong></h6><p>中文翻译过来是直接拓展，简称DX。它是由<strong>微软</strong>公司创建的多媒体编程接口。它<strong>不跨平台</strong>，只针对微软的相关产品，被广泛使用于Windows操作系统、xBox游戏主机的图形应用程序开发中。</p><p>其中的D3D算是DX一部分，是对标OpenGL的图形程序接口</p><h6 id="WebGL（Web-Graphics-Library）"><a href="#WebGL（Web-Graphics-Library）" class="headerlink" title="WebGL（Web Graphics Library）"></a><strong>WebGL（Web Graphics Library）</strong></h6><p>中文翻译过来是网页图形库，它是<strong>针对Web端（\</strong>网页*<em>）的3D绘图协议*</em>，这个标准允许把JavaScript和OpenGL ES 2.0结合在一起，网页开发人员可以借助系统显卡在浏览器里流畅的展示3D场景和模型，可以在网页里进行3D图形开发。</p><h6 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a><strong>Metal</strong></h6><p>中文翻译过来是金属，它是<strong>苹果公司</strong>为游戏开发者提供的图形技术，该技术能够为3D图像提高10倍渲染性能，但是它不支持跨平台，主要针对IOS、macOS苹果自家的操作系统，只有苹果手机、电脑能够使用。</p><p><strong>Windows电脑：DX、OpenGL、Vulkan</strong></p><p><strong>苹果电脑：Metal、OpenGL、Vulkan</strong></p><p><strong>安卓手机：OpenGL ES、Vulkan</strong></p><p><strong>苹果手机：OpenGL ES、Vulkan、Metal</strong></p><p><strong>网站网页：Web GL</strong></p><p>如果不通过游戏引擎，我们想要在这些平台上开发游戏，那么就必须要针对不同平台学习对应的图形程序接口相关的知识。你会发现<strong>OpenGL</strong>的身影在各主流平台中都占有一席之地，由于它<strong>出现早、跨平台、跨语言</strong>，所以也是为什么在学习计算机图形学时，OpenGL是必学的内容。</p><p>我们现在使用游戏引擎开发游戏，在绝大多数情况下，不需要直接和图形程序接口打交道，但是<strong>我们在Unity当中发布应用程序时</strong>，<strong>经常会看到和他们相关的一些设置</strong>，必须要了解了他们的基本概念，才能清楚我们在设置什么。</p><p>这些<strong>图形程序接口</strong>还有不同的版本，比如DX10、DX11、DX12，比如OpenGL ES 2.0、OpenGL ES 3.0。<strong>不同的设备、不同的操作系统他们支持的版本也是不同的</strong>。比如我们进行手机游戏开发时，我们<strong>可以去查询主流移动设备支持的图形程序接口的版本，来决定在发布时，对于图形程序接口版本的兼容选择**</strong>。这样才能保证我们发布的应用程序能够支持更多的移动设备。</p><h5 id="Color-Space：色彩空间"><a href="#Color-Space：色彩空间" class="headerlink" title="Color Space：色彩空间"></a><strong>Color Space：色彩空间</strong></h5><p><strong>可以在此切换Unity中用于渲染的色彩空间</strong><br><strong>Gamman（伽马）和 Linear（线性）</strong></p><p><strong>区别：</strong><br><strong>纹理倾向于保存在伽马颜色空间中，而着色器期望使用线性颜色空间</strong><br><strong>因此，在着色器中对纹理进行采样时，基于伽马的值会导致不准确的结果</strong><br><strong>我们可以选择线性色彩空间，然后通过纹理中的 sRGB选项决定是用伽马还是线性，勾选sRGB是伽马，取消勾选是线性</strong></p><p><strong>如何选择：</strong><br><strong>线性渲染的效果相对较好一些</strong><br><strong>但并不是所有平台都支持线性渲染</strong><br><strong>支持的平台为：</strong><br><strong>Android、IOS、WebGL、Windows、Mac OS X 、Linux</strong><br><strong>当设备不支持线性渲染时，不会退回到伽马控件，而是自动退出</strong></p><p><strong>在 Android 上，线性渲染至少需要 OpenGL ES 3.0 图形 API 和 Android 4.3</strong><br><strong>在 iOS 上，线性渲染需要 Metal 图形 API</strong><br><strong>在 WebGL 上，线性渲染至少需要 WebGL 2.0 图形 API</strong></p><p><strong>确定你的应用程序运行的主流设备是否支持，如果支持则选择线性，不支持选择伽马</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134818.png" alt="image-20220901231129340"></p><p><a href="https://docs.unity.cn/cn/2021.3/Manual/LinearLighting.html">https://docs.unity.cn/cn/2021.3/Manual/LinearLighting.html</a></p><h5 id="什么是Vulkan？"><a href="#什么是Vulkan？" class="headerlink" title="什么是Vulkan？"></a><strong>什么是Vulkan？</strong></h5><p><strong>是一个跨平台的2D和3D绘图应用程序接口</strong><br><strong>在2015年游戏开发者大会（GDC）上发表</strong><br><strong>是OpenGL的下一代版本，旨在提供更低的CPU开销与更直接的GPU控制</strong></p><h5 id="Auto-Graphics-API-自动图形接口（建议选择自动）"><a href="#Auto-Graphics-API-自动图形接口（建议选择自动）" class="headerlink" title="Auto Graphics API:自动图形接口（建议选择自动）"></a><strong>Auto Graphics API:自动图形接口（建议选择自动）</strong></h5><p><strong>勾选：Unity会自动尝试使用对应图形API接口进行图形处理</strong><br><strong>默认使用Vulkan，如果设备不支持Vulkan，Unity会退到GLES3.2、GLES3.1或GLES3.0</strong></p><p><strong>不勾选：可以列表中自己对使用的图形API接口进行排序，设置使用优先级</strong></p><p><strong>下方的副选项ES3.1、ES3.1+AEP、ES3.2是三个额外的用于配置最低OpenGL ES 3.X次要版本的</strong><br><strong>注意：只有当GLES2不在列表中是，Unity才会讲额外的三个选项要求添加到Android应用清单中，在这种情况下，如果你的应用发布到GooglePlay应用商店，它将不会显示在不受支持的设备上</strong></p><h5 id="Color-Gamut-色域"><a href="#Color-Gamut-色域" class="headerlink" title="Color Gamut: 色域"></a>Color Gamut: 色域</h5><p>可以添加或删除 Android 平台用于渲染的色域<br>色域定义了可用于给定设备（如监视器或屏幕）的可能颜色范围。sRGB 色域是默认（也是必需的）色域。当定位具有宽色域显示的设备时，请使用 DisplayP3 来利用完整的显示功能。</p><p>一般的手机使用sRGB即可，如果是PC主机游戏，可以考虑添加DisplayP3</p><h5 id="Multithreaded-Rendering：多线程渲染"><a href="#Multithreaded-Rendering：多线程渲染" class="headerlink" title="Multithreaded Rendering：多线程渲染"></a><strong>Multithreaded Rendering：多线程渲染</strong></h5><p><strong>启用此选项可将图形 API 调用从 Unity 的主线程移动到单独的工作线程。这有助于提高主线程上 CPU 使用率较高的应用程序的性能。</strong></p><h5 id="Static-Batching：静态批处理"><a href="#Static-Batching：静态批处理" class="headerlink" title="Static Batching：静态批处理"></a><strong>Static Batching：静态批处理</strong></h5><p><strong>会将静态物体合并处理DC，提升性能</strong></p><h5 id="Dynamic-Batching：动态批处理"><a href="#Dynamic-Batching：动态批处理" class="headerlink" title="Dynamic Batching：动态批处理"></a><strong>Dynamic Batching：动态批处理</strong></h5><p><strong>可以动态的合并DC，提高性能</strong><br><strong>当可编程渲染管线（SPR）处于活动状态时，也就是启用了URP或者HDRP时，动态批处理不起作用</strong></p><p><strong>在使用FairyGUI时，就需要开启它，FairyGUI的DC将得到优化</strong></p><h5 id="Compute-Skinning：计算蒙皮"><a href="#Compute-Skinning：计算蒙皮" class="headerlink" title="Compute Skinning：计算蒙皮"></a><strong>Compute Skinning：计算蒙皮</strong></h5><p><strong>启用此选项可启用 DX11/ES3 GPU 计算蒙皮，从而释放 CPU 资源</strong></p><p><strong>图形接口的版本要求较高，PC上DX11、移动设备ES3</strong></p><h5 id="Graphics-Jobs-Experimental-：图形作业"><a href="#Graphics-Jobs-Experimental-：图形作业" class="headerlink" title="Graphics Jobs(Experimental)：图形作业"></a>Graphics Jobs(Experimental)：图形作业</h5><h5 id="启用后，Unity将渲染循环的图形任务移到其它CPU内核上运行的工作线程，可以减少在主线程上花费的时间"><a href="#启用后，Unity将渲染循环的图形任务移到其它CPU内核上运行的工作线程，可以减少在主线程上花费的时间" class="headerlink" title="启用后，Unity将渲染循环的图形任务移到其它CPU内核上运行的工作线程，可以减少在主线程上花费的时间"></a>启用后，Unity将渲染循环的图形任务移到其它CPU内核上运行的工作线程，可以减少在主线程上花费的时间</h5><h5 id="Texture-compression-format：纹理压缩格式"><a href="#Texture-compression-format：纹理压缩格式" class="headerlink" title="Texture compression format：纹理压缩格式"></a><strong>Texture compression format：纹理压缩格式</strong></h5><p><strong>可以在ASTC、ETC2、ETC之间进行选择</strong></p><h5 id="Normal-Map-Encoding：法线地图编码"><a href="#Normal-Map-Encoding：法线地图编码" class="headerlink" title="Normal Map Encoding：法线地图编码"></a><strong>Normal Map Encoding：法线地图编码</strong></h5><p><strong>选择 XYZ 或 DXT5nm 样式以设置法线映射编码。这会影响用于法线贴图的编码方案和压缩格式。DXT5nm 样式的法线贴图质量更高，但在着色器中解码成本更高</strong></p><h5 id="Lightmap-Encoding：光照贴图编码"><a href="#Lightmap-Encoding：光照贴图编码" class="headerlink" title="Lightmap Encoding：光照贴图编码"></a><strong>Lightmap Encoding：光照贴图编码</strong></h5><p><strong>选择“正常质量”或“高质量”以设置光照贴图编码。此设置会影响光照贴图的编码方案和压缩格式</strong></p><h5 id="Lightmap-Streaming：光照贴图流"><a href="#Lightmap-Streaming：光照贴图流" class="headerlink" title="Lightmap Streaming：光照贴图流"></a><strong>Lightmap Streaming：光照贴图流</strong></h5><p><strong>是否对光照贴图使用 Mipmap 流式处理</strong></p><h5 id="Frame-Timing-Stats：帧时序统计"><a href="#Frame-Timing-Stats：帧时序统计" class="headerlink" title="Frame Timing Stats：帧时序统计"></a>Frame Timing Stats：帧时序统计</h5><p>启用此属性可收集 CPU 和 GPU 帧时间统计信息</p><p>需要和摄像机上的动态分辨率设置结合使用（Camera组件下的Allow Dynamic Resolution选项），以确定应用程序是受 CPU 还是 GPU 限制。</p><h5 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL:"></a>OpenGL:</h5><p>Profiler GPU Recorders：是否启用OpenGL的探查GPU记录器</p><p>在OpenGL上，探查GPU记录器 会 禁用GPU探查器</p><h5 id="Virtual-Texturing：虚拟纹理"><a href="#Virtual-Texturing：虚拟纹理" class="headerlink" title="Virtual Texturing：虚拟纹理"></a>Virtual Texturing：虚拟纹理</h5><p>可在场景中具有很多高分辨率纹理时减少 GPU 内存使用量和纹理加载时间。它将纹理拆分为瓦片，然后在需要时将这些瓦片逐步上传到 GPU 内存中。</p><p>注意：虚拟纹理和安卓设备不兼容</p><h5 id="Shader-Precision-model：着色器精度模型"><a href="#Shader-Precision-model：着色器精度模型" class="headerlink" title="Shader Precision model：着色器精度模型"></a>Shader Precision model：着色器精度模型</h5><p>控制着色器中使用的采样器的默认精度</p><h5 id="360-Stereo-Capture：360-度立体捕捉"><a href="#360-Stereo-Capture：360-度立体捕捉" class="headerlink" title="360 Stereo Capture：360 度立体捕捉"></a>360 Stereo Capture：360 度立体捕捉</h5><p>Unity 是否可以捕获立体 360 度全景图像和视频</p><p>注意：360 度立体捕捉与 Android 不兼容。</p><h4 id="Vulkan-Setting"><a href="#Vulkan-Setting" class="headerlink" title="Vulkan Setting"></a>Vulkan Setting</h4><p>身份证明设置</p><p>注意：安卓平台时，不要修改这些选项</p><h5 id="SRGB-Write-Mode-SRGB-写入模式"><a href="#SRGB-Write-Mode-SRGB-写入模式" class="headerlink" title="SRGB Write Mode: SRGB 写入模式"></a>SRGB Write Mode: SRGB 写入模式</h5><p>允许呈现器在运行时切换 sRGB 写入模式，如果要暂时关闭线性到 sRGB 写入颜色转换，可以启用该选项</p><p>注意：建议不要为移动设备启用该选项<br>它会增加移动设备GPU的负担，产生负面影响</p><h5 id="Number-of-swapchain-buffers-交换链缓冲区数量"><a href="#Number-of-swapchain-buffers-交换链缓冲区数量" class="headerlink" title="Number of swapchain buffers: 交换链缓冲区数量"></a>Number of swapchain buffers: 交换链缓冲区数量</h5><p>设为2位双缓冲，设为3为三重缓冲可以和Vulkan渲染器一起使用<br>该设置可以帮助解决移动平台上的延迟问题</p><p>注意：一般情况下我们不要修改此选项，保持为3，不要在安卓设备上使用双缓冲，会产生负面影响</p><h5 id="Acquire-swapchain-image-late-as-possible：尽可能晚的获取交换链图像"><a href="#Acquire-swapchain-image-late-as-possible：尽可能晚的获取交换链图像" class="headerlink" title="Acquire swapchain image late as possible：尽可能晚的获取交换链图像"></a>Acquire swapchain image late as possible：尽可能晚的获取交换链图像</h5><p>启用后，Vulkan会延迟获取后缓冲器，直到它将帧渲染为屏幕外图像。Vulkan 使用暂存映像来实现此目的。启用此设置会导致在显示反向缓冲器时产生额外的光圈。此设置与双缓冲相结合，可以提高性能。但是，它也可能导致性能问题，因为额外的 blit 会占用带宽。</p><p>注意：安卓设备上我们不要修改该选项</p><h5 id="Recycle-command-buffers：回收命令缓冲区"><a href="#Recycle-command-buffers：回收命令缓冲区" class="headerlink" title="Recycle command buffers：回收命令缓冲区"></a>Recycle command buffers：回收命令缓冲区</h5><p>Unity 执行命令缓冲区后是回收还是释放命令缓冲区</p><h5 id="Apply-display-rotation-during-rendering："><a href="#Apply-display-rotation-during-rendering：" class="headerlink" title="Apply display rotation during rendering："></a>Apply display rotation during rendering：</h5><p>在渲染期间应用显示旋转启用此选项可在显示的本机方向上执行所有渲染。这在许多设备上具有性能优势，虽然如此，但是使用它会带来一些限制，所以还是建议大家不要修改此选项</p><h4 id="Identification：身份证明"><a href="#Identification：身份证明" class="headerlink" title="Identification：身份证明"></a>Identification：身份证明</h4><p>注意：首次发布时，一定要确保包名的正确性</p><h5 id="Override-Default-Package-Name：是否覆盖默认包名称"><a href="#Override-Default-Package-Name：是否覆盖默认包名称" class="headerlink" title="Override Default Package Name：是否覆盖默认包名称"></a>Override Default Package Name：是否覆盖默认包名称</h5><p>如果你的公司名和游戏名 不是英文，请勾选它自行设置包名</p><h5 id="Package-Name：软件包名"><a href="#Package-Name：软件包名" class="headerlink" title="Package Name：软件包名"></a>Package Name：软件包名</h5><p>相当于应用程序的ID，用于在设备和安卓应用商店中的唯一标识。<br>格式：com.公司名.产品名<br>只能包含字母数字和下划线，每段都必须以字母开头</p><h5 id="Version：版本号"><a href="#Version：版本号" class="headerlink" title="Version：版本号"></a>Version：版本号</h5><p>显示给用户看的<br>用于标识应用程序包的迭代<br>格式：数字.数字.数字。。。<br>比如：1.0、4.3.2、1.2.1等</p><h5 id="Bundle-Version-Code：内部版本号"><a href="#Bundle-Version-Code：内部版本号" class="headerlink" title="Bundle Version Code：内部版本号"></a>Bundle Version Code：内部版本号</h5><p>确定一个版本是否比另一个版本新，数字越大表示版本越新，不会显示给用户看<br>该值为整数，比如每次发布新版本时可以让数字加一</p><h5 id="Minimum-API-Level：最低API级别"><a href="#Minimum-API-Level：最低API级别" class="headerlink" title="Minimum API Level：最低API级别"></a>Minimum API Level：最低API级别</h5><p>决定应用程序运行需要的最低的API级别，如果用户手机的SDK版本低于该设置，Android系统会组织用户安装该应用程序</p><h5 id="Target-API-Level：目标API级别"><a href="#Target-API-Level：目标API级别" class="headerlink" title="Target API Level：目标API级别"></a>Target API Level：目标API级别</h5><p>用于指定应用的目标API级别<br>主要用于通知Android系统，我们已经针对目标版本进行了测试，并且系统不应该通过启用任何兼容性行为，以保持你的应用与目标版本的向前兼容性。应用程序一样可以在较低版本上运行（取决于Minimum API Level）</p><h4 id="Configuration：配置"><a href="#Configuration：配置" class="headerlink" title="Configuration：配置"></a>Configuration：配置</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134547.png" alt="image-20220901232738331"></p><h5 id="Scripting-Backend：脚本后端"><a href="#Scripting-Backend：脚本后端" class="headerlink" title="Scripting Backend：脚本后端"></a><strong>Scripting Backend：脚本后端</strong></h5><p><strong>决定Unity如何在项目中编译和执行C#代码</strong></p><p><strong>Mono：将C#编译为.Net公共中间语言CIL，并使用公共语言运行时执行中间语言</strong></p><p><strong>IL2CPP：将C#编译为CIL，再将CIL转换为C++，再将C++编译为本机代码，</strong></p><p><strong>Mono和IL2CPP的具体区别在 Unity进阶之C#知识补充当中有讲解</strong></p><h5 id="Api-Compatibility-Level：API兼容性级别"><a href="#Api-Compatibility-Level：API兼容性级别" class="headerlink" title="Api Compatibility Level：API兼容性级别"></a><strong>Api Compatibility Level：API兼容性级别</strong></h5><p><strong>决定可以在项目中使用的.Net API。该设置会影响代码和第三方库的兼容性</strong></p><p><strong>.Net Standard 2.1：和.Net Standard 2.1兼容，生成较小的版本，具有完整的跨平台支持</strong></p><p><strong>.Net Framework：和.Net Framework兼容（包含.Net Standard 2.1中的所有的内容），包含更多的API支持，但是会生成更大的包。</strong></p><p><strong>如果在使用C#的一些高级功能时遇到报错或无法使用，可以尝试切换到.Net Framework以便支持这些高级功能的使用，如果有替代方案，建议使用替代方案，尽量使用.Net Standard 2.1可以让包体更小</strong></p><h5 id="C-Compiler-Configuration：C-编译器配置"><a href="#C-Compiler-Configuration：C-编译器配置" class="headerlink" title="C++ Compiler Configuration：C++编译器配置"></a><strong>C++ Compiler Configuration：C++编译器配置</strong></h5><p><strong>只有将Scripting Backend设置为IL2CPP，才能使用该选项</strong></p><p><strong>Debug（调试模式）: 将关闭所有优化，让代码生成速度更快，但运行速度较慢，可以在这种模式下进行调试</strong></p><p><strong>Release（发布模式）：会对代码进行优化，编译后的代码运行会更快，二进制文件大小更小，但编译时间更长</strong></p><p><strong>Master（大师模式）：可实现所有可能的优化，从而压缩每一点可能的优化，发布时间比发布模式还要长，如果接受较长的发布时间，建议在发布最终版本时使用Master模式</strong></p><h5 id="Use-incremental-GC：使用增量GC"><a href="#Use-incremental-GC：使用增量GC" class="headerlink" title="Use incremental GC：使用增量GC"></a><strong>Use incremental GC：使用增量GC</strong></h5><p><strong>启用后可以使用增量垃圾回收器，它会将GC分散到多个帧上执行，可以降低在一帧中进行GC造成的卡顿。</strong></p><h5 id="Assembly-Version-Validation：程序集版本验证"><a href="#Assembly-Version-Validation：程序集版本验证" class="headerlink" title="Assembly Version Validation：程序集版本验证"></a>Assembly Version Validation：程序集版本验证</h5><p>Mono是否验证强名称程序集中的类型</p><p>强名称程序集，是对程序集进行强命名，为程序集创建唯一标识，可以防止程序集冲突</p><h5 id="Mute-Other-Audio-Sources：将其它音频源静音"><a href="#Mute-Other-Audio-Sources：将其它音频源静音" class="headerlink" title="Mute Other Audio Sources：将其它音频源静音"></a><strong>Mute Other Audio Sources：将其它音频源静音</strong></h5><p><strong>如果希望在运行Unity应用程序时停止在后台运行的应用程序中的音频，可以启用该选项，否则后台音频将和Unity中的音频一起播放</strong></p><h5 id="Target-Architectures：目标体系结构"><a href="#Target-Architectures：目标体系结构" class="headerlink" title="Target Architectures：目标体系结构"></a>Target Architectures：目标体系结构</h5><p>允许应用程序运行的CPU<br>64位环境中运行安卓应用具有性能优势<br>64位应用可以处理超过4GB的内存空间</p><p>Mono模式只能选择ARMv7<br>IL2CPP模式可以选择更多的模式</p><p>ARM就是一种微处理器硬件<br>Chrome OS是一款Google开发的基于PC的操作系统</p><p>ARMv7 32位的ARM</p><p>ARM64 64位的ARM</p><p>x86(Chrome OS) 32位</p><p>x86-64(Chrome OS) 64位</p><h5 id="Split-APKs-by-target-architecture：按目标架构拆分APK（实验性功能）"><a href="#Split-APKs-by-target-architecture：按目标架构拆分APK（实验性功能）" class="headerlink" title="Split APKs by target architecture：按目标架构拆分APK（实验性功能）"></a>Split APKs by target architecture：按目标架构拆分APK（实验性功能）</h5><p>启用后，可以为目标体系结构中选择的每个CPU架构创建单独的APK，这样在Google Play中为用户提供下载时，它会根据设备的情况下载对应版本的APK，可以让apk更小，用户下载更小的包。<br>但是主要是针对Google Play，因此面向国内的产品几乎不会使用。</p><h5 id="Target-Devices：目标设备"><a href="#Target-Devices：目标设备" class="headerlink" title="Target Devices：目标设备"></a>Target Devices：目标设备</h5><p>执行允许运行APK的目标设备</p><p>All Devices（所有设备）：允许apk在所有Android和Chrome OS设备上运行<br>Phones，Tablets，and TV Devices Only（手机、平板、电视设备）：允许apk在Android手机和平板电脑、电视上运行，但是不能在Chrome OS设备上运行<br>Chrome OS Devices Only（Chrome OS设备）：允许apk在Chrome OS设备上运行，但是不能在Android手机、平板、电视上运行</p><h5 id="Install-Location：安装位置"><a href="#Install-Location：安装位置" class="headerlink" title="Install Location：安装位置"></a><strong>Install Location：安装位置</strong></h5><p><strong>指定设备上的应用程序安装位置</strong></p><p><strong>Automatic：自动让操作系统决定，用户可以自己移动安装位置</strong></p><p><strong>Prefer External：首选外部安装，如果可以，将应用程序安装到外部存储中（SD卡），如果不能，应用程序安装到手机存储空间中</strong></p><p><strong>Force Internal：强制内部，强制将应用程序安装到手机存储空间中，用户无法将应用程序移动到外部存储中安装</strong></p><h5 id="Internet-Access：互联网接入"><a href="#Internet-Access：互联网接入" class="headerlink" title="Internet Access：互联网接入"></a><strong>Internet Access：互联网接入</strong></h5><p><strong>选择是否始终将网络权限添加到Android清单（即使你没有使用任何网路API）</strong></p><p><strong>Auto：仅当使用了网络API时才会添加互联网访问权限</strong><br><strong>Require：使用添加互联网访问权限</strong></p><h5 id="Write-Permission：写入权限"><a href="#Write-Permission：写入权限" class="headerlink" title="Write Permission：写入权限"></a><strong>Write Permission：写入权限</strong></h5><p><strong>是否启用对外部存储（SD卡）的写入访问权限，并向Android应用清单添加相应的权限</strong></p><p><strong>Internal（内部）：仅授予对内部存储的写入权限</strong><br><strong>External（外置SD卡）：启用对外部存储的写入权限</strong></p><h5 id="Filter-Touches-When-Obscured：遮挡时过滤触摸"><a href="#Filter-Touches-When-Obscured：遮挡时过滤触摸" class="headerlink" title="Filter Touches When Obscured：遮挡时过滤触摸"></a>Filter Touches When Obscured：遮挡时过滤触摸</h5><p>启用后可以丢弃在另一个可见窗口覆盖Unity应用程序时收到的触摸（触屏事件），可以放置窃听劫持</p><h5 id="Sustained-Performance-Mode：持续性能模式"><a href="#Sustained-Performance-Mode：持续性能模式" class="headerlink" title="Sustained Performance Mode：持续性能模式"></a>Sustained Performance Mode：持续性能模式</h5><p>启用此选项可在较长的时间段内设置可预测且一致的设备性能级别，而无需进行热限制。启用此设置时，整体性能可能会降低</p><h5 id="Low-Accuracy-Location：低精度定位"><a href="#Low-Accuracy-Location：低精度定位" class="headerlink" title="Low Accuracy Location：低精度定位"></a>Low Accuracy Location：低精度定位</h5><p>启用后可改为低精度值与Android位置API配合使用</p><h5 id="Chrome-OS-Input-Emulation："><a href="#Chrome-OS-Input-Emulation：" class="headerlink" title="Chrome OS Input Emulation："></a>Chrome OS Input Emulation：</h5><p>Chrome OS 操作系统的默认行为是将鼠标和触摸板输入事件转为触屏输入事件。<br>取消可禁用这个默认行为</p><h5 id="Android-TV-Compatibility：安卓电视兼容性"><a href="#Android-TV-Compatibility：安卓电视兼容性" class="headerlink" title="Android TV Compatibility：安卓电视兼容性"></a>Android TV Compatibility：安卓电视兼容性</h5><p>启用后应用程序标记为兼容Android TV</p><p>启用后出现<br>Android Game：启用后可将输出的apk标记为游戏而不是常规应用<br>Android Gamepad Support Level：安卓游戏输入板支持等级<br>可以选择玩游戏时支持的输入方式</p><h5 id="Warn-about-App-Bundle-size：警告应用程序包的大小"><a href="#Warn-about-App-Bundle-size：警告应用程序包的大小" class="headerlink" title="Warn about App Bundle size：警告应用程序包的大小"></a>Warn about App Bundle size：警告应用程序包的大小</h5><p>只有在Build Settings中勾选了Build App Bundle（Google Play）才有用<br>当应用程序包大小超过这个阈值时会收到警告</p><h5 id="Active-Input-Handling：活动输入处理"><a href="#Active-Input-Handling：活动输入处理" class="headerlink" title="Active Input Handling：活动输入处理"></a><strong>Active Input Handling：活动输入处理</strong></h5><p><strong>选择要如何处理来自用户的输入</strong></p><p><strong>Input Manager：老的输入系统，Input相关</strong><br><strong>Input System Package：新输入系统</strong><br><strong>Both：同时使用</strong></p><h4 id="Script-Compilation：脚本编译"><a href="#Script-Compilation：脚本编译" class="headerlink" title="Script Compilation：脚本编译"></a>Script Compilation：脚本编译</h4><h5 id="Scripting-Define-Symbols：脚本定义符号"><a href="#Scripting-Define-Symbols：脚本定义符号" class="headerlink" title="Scripting Define Symbols：脚本定义符号"></a>Scripting Define Symbols：脚本定义符号</h5><p>可以在此设置自定义编译标志。</p><p>再使用一些第三方内容时有时会在此处添加脚本符号<br>比如：Lua热更相关、FairyGUI相关</p><h6 id="Unity有内置的脚本符号"><a href="#Unity有内置的脚本符号" class="headerlink" title="Unity有内置的脚本符号"></a>Unity有内置的脚本符号</h6><p>这些符号能够帮助我们有选择的在编译中包含或排除部分代码</p><p>这些脚本符号可以配合多路测试 #if 进行使用<br>#if 脚本符号<br>    代码逻辑<br>#elif 脚本符号<br>    代码逻辑<br>#else<br>    代码逻辑<br>#endif</p><h6 id="平台脚本符号"><a href="#平台脚本符号" class="headerlink" title="平台脚本符号"></a>平台脚本符号</h6><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134540.png" alt="image-20220901233443206"></p><h6 id="编辑器版本脚本符号"><a href="#编辑器版本脚本符号" class="headerlink" title="编辑器版本脚本符号"></a>编辑器版本脚本符号</h6><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134858.png" alt="image-20220901233531611"></p><h6 id="其它脚本符号"><a href="#其它脚本符号" class="headerlink" title="其它脚本符号"></a>其它脚本符号</h6><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134723.png" alt="image-20220901233603453"></p><h5 id="Additional-Compiler-Arguments：其它编译器参数"><a href="#Additional-Compiler-Arguments：其它编译器参数" class="headerlink" title="Additional Compiler Arguments：其它编译器参数"></a>Additional Compiler Arguments：其它编译器参数</h5><p>向此列表添加条目以将其他参数传递给 Roslyn 编译器。对每个附加参数使用一个新条目。<br>要创建新条目，请按“+”按钮。要删除条目，请按“-”按钮。<br>添加完所有所需参数后，单击“应用”按钮以在将来的编译中包括其他参数。“还原”按钮将此列表重置为最近应用的状态。</p><h5 id="Suppress-Common-Warnings：禁止显示常见警告"><a href="#Suppress-Common-Warnings：禁止显示常见警告" class="headerlink" title="Suppress Common Warnings：禁止显示常见警告"></a>Suppress Common Warnings：禁止显示常见警告</h5><p>禁用此设置可显示C#警告<br>CS0169：从不使用私有字段，声明了私有变量，但是从没有使用<br>CS0649：编译器检测到从未分配值的未初始化的私有或内部字段声明</p><h5 id="Allow-‘unsafe’-Code：允许使用“不安全”代码"><a href="#Allow-‘unsafe’-Code：允许使用“不安全”代码" class="headerlink" title="Allow ‘unsafe’ Code：允许使用“不安全”代码"></a><strong>Allow ‘unsafe’ Code：允许使用“不安全”代码</strong></h5><p><strong>启用对在预定义程序集中编译“unsafe”C# 代码的支持</strong></p><p><strong>unsafe 关键词的基本概念</strong></p><p>默认情况下，C#是不支持 指针 的，unsafe 关键词用于在C#表示<strong>不安全的上下文</strong>，如果<strong>想要在C#中进行任何和指针相关的操作，就必须配合unsafe关键词使用。</strong></p><p>在公共语言运行时（CLR）中，不安全代码是指无法验证的代码。</p><p>C# 中的不安全代码不一定是危险的，只是 CLR 无法验证该代码的安全性。因此，CLR 将仅执行完全信任的程序集中的不安全代码。</p><p><strong>如果你使用不安全代码，你**</strong>应该负责确保代码不会引发安全风险或指针错误**</p><p><strong>unsafe 关键词的基本使用</strong></p><p>如果想要在Unity中正常使用C#中的unsafe关键词进行程序编写，我们必须在Unity的 Player Settings 中的 Other Settings 中将 Allow unsafe Code 选项勾选上</p><p>勾选该选项后，我们就可以在Unity中使用unsafe关键词了。</p><p><strong>注意：unsafe 的使用虽然能让我们在C#中使用指针，但是会存在安全风险和稳定性风险，如果没有特殊需求，请尽量避免在C#中使用 unsafe。</strong></p><h5 id="Use-Deterministic-Compilation：使用确定性编译"><a href="#Use-Deterministic-Compilation：使用确定性编译" class="headerlink" title="Use Deterministic Compilation：使用确定性编译"></a>Use Deterministic Compilation：使用确定性编译</h5><p>启用此设置后，编译的程序集在每次编译时都是完全相同的。<br>禁用此设置可防止使用 -确定性 C# 标志进行编译</p><p>确定性编译可用于确定二进制文件是否从受信任的源编译</p><h6 id="Enable-Roslyn-Analyzers：启用罗斯林分析器"><a href="#Enable-Roslyn-Analyzers：启用罗斯林分析器" class="headerlink" title="Enable Roslyn Analyzers：启用罗斯林分析器"></a>Enable Roslyn Analyzers：启用罗斯林分析器</h6><p>禁用此设置可编译用户编写的脚本，而无需项目中可能存在的 Roslyn 分析器 DLL（ Roslyn 就是微软的.Net开源编译器，编译器支持 C# 编译，并提供丰富的代码分析 API。）</p><h4 id="Optimization：优化"><a href="#Optimization：优化" class="headerlink" title="Optimization：优化"></a>Optimization：优化</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135478.png" alt="image-20220901234125528"></p><h5 id="Prebake-Collision-Meshes：预烘焙碰撞到网格"><a href="#Prebake-Collision-Meshes：预烘焙碰撞到网格" class="headerlink" title="Prebake Collision Meshes：预烘焙碰撞到网格"></a>Prebake Collision Meshes：预烘焙碰撞到网格</h5><p>启用该选项可以在构建时将碰撞数据添加到网格</p><h5 id="Keep-Loaded-Shaders-Alive：保持加载的着色器的活动状态"><a href="#Keep-Loaded-Shaders-Alive：保持加载的着色器的活动状态" class="headerlink" title="Keep Loaded Shaders Alive：保持加载的着色器的活动状态"></a>Keep Loaded Shaders Alive：保持加载的着色器的活动状态</h5><p>启动后，不能卸载着色器</p><p>着色器加载时会造成性能开销，可能会出现卡顿现象，不允许卸载着色器可以避免卸载后重复加载</p><h4 id="Preloaded-Assets：预装资源"><a href="#Preloaded-Assets：预装资源" class="headerlink" title="Preloaded Assets：预装资源"></a><strong>Preloaded Assets：预装资源</strong></h4><p><strong>设置启动时加载的资源数组</strong><br><strong>将想要预加载的内容拖入框中</strong></p><h5 id="Strip-Engine-Code：剥离引擎代码"><a href="#Strip-Engine-Code：剥离引擎代码" class="headerlink" title="Strip Engine Code：剥离引擎代码"></a><strong>Strip Engine Code：剥离引擎代码</strong></h5><p><strong>选择IL2CPP模式才会出现的字段</strong><br><strong>如果你希望在IL2CPP模式，能够删除Unity引擎功能中没有使用的代码，可以启用该选项，可以有效的减小包体大小</strong></p><h5 id="Managed-Stripping-Level：管理剥离水平"><a href="#Managed-Stripping-Level：管理剥离水平" class="headerlink" title="Managed Stripping Level：管理剥离水平"></a><strong>Managed Stripping Level：管理剥离水平</strong></h5><p><strong>选择Unity如何剥离未使用的C#代码</strong><br><strong>在发布应用程序时，Unity会自动去除掉没有使用的代码，剥离代码可以使生成的执行文件减小，但是有可能会意外删除需要使用的代码</strong></p><p><strong>在Unity进阶之C#知识补充中讲解IL2CPP相关内容时讲解过</strong></p><p><strong>Disabled：不剥离，只有在Mono模式下才能选择</strong></p><p><strong>Minimal：最小剥离，Unity只会搜索Unity引擎未使用的.Net类库，不会删除任何用户编写的代码，该设置基本不会出现意外剥离，在使用IL2CPP模式后，该模式是默认模式</strong></p><p><strong>Low：低级剥离，处理Unity相关，玩家自己编写的代码也会被剥离，会尽量减小意外剥离发生</strong></p><p><strong>Medium：中级剥离，比起Low更多一些剥离</strong></p><p><strong>High：高级剥离，优先考虑打包大小，会最大限度剥离代码。可以采配合link.xml来手动拒绝剥离，或使用[Preserve]特性（在不希望被剥离的函数前加该特性）</strong></p><h5 id="Enable-Internal-Profiler：启用内部探查器，已经弃用的功能"><a href="#Enable-Internal-Profiler：启用内部探查器，已经弃用的功能" class="headerlink" title="Enable Internal Profiler：启用内部探查器，已经弃用的功能"></a>Enable Internal Profiler：启用内部探查器，已经弃用的功能</h5><p>用此选项以从Android SDK的设备中获取profiler数据adblogcat测试项目时输出。这仅在开发版本中可用。</p><h4 id="Vertex-Compression：顶点压缩"><a href="#Vertex-Compression：顶点压缩" class="headerlink" title="Vertex Compression：顶点压缩"></a><strong>Vertex Compression：顶点压缩</strong></h4><p><strong>选择要设置的通道，以便在顶点压缩方法下压缩网格</strong><br><strong>通常，顶点压缩用于减少内存中网格数据的大小，减小文件大小，提高CPU性能。</strong></p><h5 id="Optimize-Mesh-Data：优化网格数据"><a href="#Optimize-Mesh-Data：优化网格数据" class="headerlink" title="Optimize Mesh Data：优化网格数据"></a><strong>Optimize Mesh Data：优化网格数据</strong></h5><p><strong>启用后，构建时会从使用的网格中剥离未使用的顶点属性</strong><br><strong>它可以减少网格中的数量，也可以减小包体大小，可以减小加载时间和运行时的内存使用</strong><br><strong>但是，如果启用了该设置，运行时就不要更改材质或着色器相关设置</strong></p><p><strong>也就是说，如果你游戏会在运行时转换一些对象的着色器，就不能开启该选项。</strong></p><p><strong>比如游戏中某一个对象，如果网格使用简单漫射着色器，那么 Unity 将删除 切线矢量，因为并不需要它们。如果您想要在运行时切换到网格上的凹凸贴图着色器 ，那么您将不会得到正确的切线数据，因为此数据已被删除</strong></p><h5 id="Texture-MipMap-Stripping：贴图纹理剥离"><a href="#Texture-MipMap-Stripping：贴图纹理剥离" class="headerlink" title="Texture MipMap Stripping：贴图纹理剥离"></a><strong>Texture MipMap Stripping：贴图纹理剥离</strong></h5><p><strong>启用后会启用纹理贴图剥离，在构建时会从纹理中剥离没有使用的纹理贴图。</strong><br><strong>会根据你发布平台的质量设置进行比较来确定哪些贴图用不到。</strong><br><strong>mipmap生成的多分辨率图也会被剥离</strong></p><h5 id="Stack-Trace：堆栈跟踪"><a href="#Stack-Trace：堆栈跟踪" class="headerlink" title="Stack Trace：堆栈跟踪"></a><strong>Stack Trace：堆栈跟踪</strong></h5><p><strong>选择在特定的上下文中允许的日志记录类型</strong><br><strong>可以选择日志记录的方式</strong><br><strong>None：不记录</strong><br><strong>ScriptOnly：只在运行脚本时记录信息</strong><br><strong>Full：一直记录</strong></p><p>Error：错误信息<br>Assert：断言（用于检测非法情况的）信息<br>Warning：警告信息<br>Log：打印日志信息<br>Exception：异常信息</p><h5 id="Legacy：以前的内容"><a href="#Legacy：以前的内容" class="headerlink" title="Legacy：以前的内容"></a>Legacy：以前的内容</h5><p>Clamp BlendShapes（Deprecated）：启用 骨骼蒙皮动画中钳制混合形状权重的范围</p><h3 id="Publishing-Settings"><a href="#Publishing-Settings" class="headerlink" title="Publishing Settings"></a>Publishing Settings</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h4><h5 id="Android-中的签名是什么？"><a href="#Android-中的签名是什么？" class="headerlink" title="Android 中的签名是什么？"></a><strong>Android 中的签名是什么？</strong></h5><p>Android要求所有已安装的应用程序都使用数字证书做数字签名，数字证书的私钥由应用开发者持有，<br>Android使用证书作为标示应用程序作者的一种方式，并在应用程序之间建立信任的关系。 证书并不用来控制用户能否安装哪个应用。证书不需要由证书认证中心签名；完全可以使用自制签名证书。</p><p>没有正确签名的应用，Android系统不会安装或运行。此规则适用于在任何地方运行的Android系统，不管是在模拟器还是真实设备上。因为这个原因。在真机或模拟器上运行或者调试应用前，必须为其设置好签名。</p><p><strong>为什么要使用签名？</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135676.png" alt="img"></p><p>上图是我们在Unity中发布Android应用程序时，设置的包名</p><p>开发Android的人这么多，完全有可能把包名命名成同样的名字，这个时候该如何区分？</p><p>这时就需要签名来区分了，由于开发商可能通过使用相同的Package Name（包名）来混淆替换已经安装的程序，签名可以保证相同名字，但是签名不同的包不被替换。</p><p>举例：</p><p>比如应用程序A 和 应用程序B 的包名是相同的，如果没有签名的存在，在同一Android设备上重复安装A和B，就会导致他们之间的彼此覆盖，不能同时拥有，为了避免这种情况出现，就有了签名机制。</p><p><strong>安卓密钥库和密钥，就是用来进行Android签名的。</strong></p><h5 id="Android-应用程序清单是什么？"><a href="#Android-应用程序清单是什么？" class="headerlink" title="Android 应用程序清单是什么？"></a><strong>Android 应用程序清单是什么？</strong></h5><p>Android应用程序工程中，有一个叫做 AndroidManifest.xml 的xml文件，该文件在之后的开发中我们会经常使用和编辑，该配置文件主要用于声明应用程序的组件，并且还有以下的一些重要作用：</p><ol><li><p>确定应用程序要求的用户权限，比如：网络访问、通讯录访问、信息读取等权限</p></li><li><p>声明应用程序要求的最低API Level</p></li><li><p>声明应用程序将要使用的或要求的硬件和软件特性，比如：摄像头访问、蓝牙服务、多点触碰等</p></li><li>等等</li></ol><p>也就是说，如果我们想要在安卓游戏当中使用一些系统功能或硬件访问权限，都需要在该文件当中进行设置。</p><p><strong>Unity中如果引入Android第三方SDK，或者需要和Android进行交互，经常会对该文件进行编辑。如果我们没有这些需求，可以忽略它。</strong></p><h5 id="Gradle-是什么？"><a href="#Gradle-是什么？" class="headerlink" title="Gradle 是什么？"></a><strong>Gradle 是什么？</strong></h5><p>Gradle 是一个自动化构建开源工具，主要面向Java应用为主，也支持其它语言，比如C++、Kotlin、Swift，未来还会支持更多的语言。</p><p>它是一个基于JVM（Java虚拟机）的构建工具，是一款通用灵活的构建工具，也可以用于Android 项目的构建工作，它可以让安卓项目变得更加简洁。</p><p><strong>在Unity中简单理解Gradle，它就是用于帮助我们打包出安卓应用程序 .apk 的一个工具，在Android Studio中也使用Gradle进行应用程序打包。</strong></p><h5 id="ProGuard-和-R8-是什么？"><a href="#ProGuard-和-R8-是什么？" class="headerlink" title="ProGuard 和 R8 是什么？"></a><strong>ProGuard 和 R8 是什么？</strong></h5><p><strong>代码混淆</strong></p><p>代码混淆(Obfuscated code)，是将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式的行为。代码混淆主要用于程序源代码，也可以用于程序编译而成的中间代码。执行代码混淆的程序被称作代码混淆器。已经存在许多种功能各异的代码混淆器。</p><p>将代码中的各种元素，如变量，函数，类的名字改写成无意义的名字。比如改写成单个字母，或是简短的无意义字母组合，甚至改写成“__”这样的符号，使得阅读的人无法根据名字猜测其用途。重写代码中的部分逻辑，将其变成功能上等价，但是更难理解的形式。比如将for循环改写成while循环，将循环改写成递归，精简中间变量，等等。打乱代码的格式。比如删除空格，将多行代码挤到一行中，或者将一行代码断成多行等等。</p><p><strong>代码混淆的主要目的是提升源代码的安全性</strong>，别人反编译你的应用程序代码后，增加他们阅读分析逻辑的难度。</p><p><strong>ProGuard 和 R8 就是两种不同的代码混淆器。</strong></p><p><strong>ProGuard</strong></p><p>ProGuard是一个压缩、优化和混淆<a href="https://baike.baidu.com/item/Java字节码/13025120">J</a>ava字节码（Java源代码通常被编译为字节码）文件的免费的工具，它可以删除无用的类、字段、方法和属性。可以删除没用的注释，最大限度地优化字节码文件。它还可以使用简短的无意义的名称来重命名已经存在的类、字段、方法和属性。常常在Android开发用于混淆最终的项目，增加项目被反编译的难度。</p><p>Unity发布安卓应用程序时，默认使用的就是ProGuard来进行处理最终的代码。</p><p><strong>R8</strong></p><p>R8是相对ProGuard较新的Android混淆编译器，它可以尽可能的减小应用的大小，早期的Android Studio版本中，混淆编译器使用的是ProGuard执行编译时的代码优化，如果我们使用Android Gradle 3.4.0或更高版本构建项目时，不再使用ProGuard进行代码优化，而是采用R8编译器协同工作。</p><p>Android Sutdio 3.3版本开始，就使用R8作为代码压缩器来对代码进行混淆、压缩、优化了。</p><p>R8 相对 ProGuard来说，它可以更快地缩减代码，同时改善输出的大小。</p><p>Unity发布安卓应用程序时，我们可以选择使用R8混淆编译器进行发布处理。</p><p>大概了解了这些基本概念后，才能知道我们是在设置什么内容。</p><h4 id="Keystore-Manager：密钥管理器"><a href="#Keystore-Manager：密钥管理器" class="headerlink" title="Keystore Manager：密钥管理器"></a><strong>Keystore Manager：密钥管理器</strong></h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135085.png" alt="image-20220903120410725"></p><p><strong>可以通过密钥管理器创建、配置和加载密钥和密钥库</strong><br><strong>我们可以在Keystore Manager窗口</strong><br><strong>或</strong><br><strong>Publishing Settings 发布设置中</strong><br><strong>加载现有密钥库和密钥</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135418.png" alt="image-20220903120739100"></p><p>Create New：创建新的密钥库</p><p>Anywhere：任何地方，会打开项目文件夹根目录下的文件资源管理器，这是Unity存储密钥库的默认位置</p><p>In Dedicated Location：专用位置，将密钥库文件保存到计算机中的另一个目录中</p><p>注意：为了协同开发方便，建议大家就把密钥库保存在项目文件夹下，避免其它同事无法访问密钥库</p><p>Select Existing：选择现有密钥库<br>可以指定加载现有密钥库</p><p>Password：密钥库的密码<br>Confirm password：创建密钥库时 需要重复一次密码</p><p>Existing Keys：现有密钥<br>界面的这一部分包含当前密钥库包含的密钥的只读列表</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135636.png" alt="image-20220903120936402"></p><h4 id="Project-Keystore：项目密钥库"><a href="#Project-Keystore：项目密钥库" class="headerlink" title="Project Keystore：项目密钥库"></a><strong>Project Keystore：项目密钥库</strong></h4><p><strong>用于保存签名密钥来实现应用程序安全性的容器</strong><br><strong>如果想要加载和使用现有密钥库，我们需要：</strong></p><ol><li><strong>启动 Custom Keystore</strong></li><li><strong>在 Select 下拉列表中选择Browse，从文件系统中选择密钥库</strong></li><li><strong>输入密钥库密码</strong></li></ol><p>Custom Keystore：启用后，可以指定加载和使用现有密钥库</p><p>Select：启用Custom Keystore后，该按钮可以用来选择要使用的密钥库</p><p>Path：你选择的密钥库所在路径</p><p>Password：输入密钥库密码以加载所选的密钥库</p><h4 id="Project-Key：项目密钥"><a href="#Project-Key：项目密钥" class="headerlink" title="Project Key：项目密钥"></a><strong>Project Key：项目密钥</strong></h4><p><strong>加载密钥库后，Unity会加载该密钥库中的所有密钥</strong><br><strong>我们可以在项目密钥Project Key中设置从该密钥库中选择哪一个密钥用来作为该项目的活动密钥</strong></p><p>Alias：选择用于打开的项目的密钥</p><p>Password：密钥密码</p><h4 id="Build：构建相关"><a href="#Build：构建相关" class="headerlink" title="Build：构建相关"></a><strong>Build：构建相关</strong></h4><p><strong>默认情况下，Unity使用Unity安装提供的清单文件、Gradle模板和文件构建应用程序</strong><br><strong>如果想要自定义这些内容，你需要：</strong></p><ol><li><strong>启用Build下方的这些复选框，文件会出现到复选框的下方</strong></li><li><strong>打开新文件进行更改</strong></li><li><strong>保存修改的文件，Unity下次构建应用程序时会自动使用的文件</strong></li></ol><h5 id="Custom-Main-Manifest：自定义主清单文件"><a href="#Custom-Main-Manifest：自定义主清单文件" class="headerlink" title="Custom Main Manifest：自定义主清单文件"></a><strong>Custom Main Manifest：自定义主清单文件</strong></h5><p><strong>该清单文件是一个xml文件</strong><br><strong>我们可以在此决定一些权限设置（比如：网络、定位、拍照等权限配置），还可以设置是否启用一些安卓功能等等</strong></p><h5 id="Custom-Launcher-Manifest：自定义启动器清单"><a href="#Custom-Launcher-Manifest：自定义启动器清单" class="headerlink" title="Custom Launcher Manifest：自定义启动器清单"></a>Custom Launcher Manifest：自定义启动器清单</h5><p>该清单文件是一个xml文件<br>我们可以在此决定一些应用程序启动之前的外观和行为。（比如：图标、名称、安装位置等等）</p><h5 id="Custom-Main-Gradle-Template：自定义主Gradle构建模板"><a href="#Custom-Main-Gradle-Template：自定义主Gradle构建模板" class="headerlink" title="Custom Main Gradle Template：自定义主Gradle构建模板"></a>Custom Main Gradle Template：自定义主Gradle构建模板</h5><p>Gradle 是一个构建系统，可自动执行许多构建过程并防止许多常见的构建错误。Unity将Gradle用于所有Android版本。您可以在Unity中构建输出包（.apk，.aab），也可以从Unity导出Gradle项目，然后使用Android Studio等外部工具构建它</p><p>是一个gradle文件，包含有关如何将Android应用程序构建为库的信息</p><h5 id="Custom-Launcher-Gradle-Template：自定义启动器Gradle构建模板"><a href="#Custom-Launcher-Gradle-Template：自定义启动器Gradle构建模板" class="headerlink" title="Custom Launcher Gradle Template：自定义启动器Gradle构建模板"></a>Custom Launcher Gradle Template：自定义启动器Gradle构建模板</h5><p>是一个gradle文件，包含有关如何构建Android应用程序的说明</p><h5 id="Custom-Base-Gradle-Template：自定义基础Gradle构建模板"><a href="#Custom-Base-Gradle-Template：自定义基础Gradle构建模板" class="headerlink" title="Custom Base Gradle Template：自定义基础Gradle构建模板"></a>Custom Base Gradle Template：自定义基础Gradle构建模板</h5><p>是一个gradle文件，包含在所有其它模板和Gradle项目之间的共享配置</p><h5 id="Custom-Gradle-Properties-Template：自定义属性Gradle构建模板"><a href="#Custom-Gradle-Properties-Template：自定义属性Gradle构建模板" class="headerlink" title="Custom Gradle Properties Template：自定义属性Gradle构建模板"></a>Custom Gradle Properties Template：自定义属性Gradle构建模板</h5><p>属性文件，包含Gradle生成环境的配置设置<br>比如<br>JVM（Java虚拟机）内存配置<br>允许Gradle使用多个JVM构建的属性<br>用于选择进行缩小的工具的属性<br>构建应用程序包时不压缩本机库的属性等等</p><h5 id="Custom-Proguard-File：自定义Proguard文件"><a href="#Custom-Proguard-File：自定义Proguard文件" class="headerlink" title="Custom Proguard File：自定义Proguard文件"></a>Custom Proguard File：自定义Proguard文件</h5><p>是一个txt文件，包含缩小过程的配置设置<br>如果缩小删除了一些应该保留的Java代码，你可以添加一条规则来将这些代码保留在此文件中</p><h4 id="Minify：代码混淆和缩小相关"><a href="#Minify：代码混淆和缩小相关" class="headerlink" title="Minify：代码混淆和缩小相关"></a><strong>Minify：代码混淆和缩小相关</strong></h4><p><strong>是一种缩减、混淆和优化应用程序代码的过程</strong><br><strong>它可以减小代码大小并使代码更难以反编译</strong><br><strong>使用 Minify 设置可定义 Unity 应何时以及如何将缩小应用于构建</strong></p><p><strong>使用该功能会加长发布时间，并且还会让调试变得复杂，所以一般在最终发布时才会使用，平时发布测试应用时不需要开启。</strong></p><p>Use R8：默认情况下，Unity 使用 Proguard 进行缩小。启用此复选框可改为使用 R8。</p><p><strong>Release：如果希望 Unity 在发布构建中缩小应用程序的代码，请启用此复选框。</strong></p><p>Debug：如果希望 Unity 在调试构建中缩小应用程序的代码，请启用此复选框。</p><h4 id="Split-Application-Binary：拆分应用程序二进制文件"><a href="#Split-Application-Binary：拆分应用程序二进制文件" class="headerlink" title="Split Application Binary：拆分应用程序二进制文件"></a><strong>Split Application Binary：拆分应用程序二进制文件</strong></h4><p><strong>启用 Split Application Binary 选项可将输出包拆分为主包 (APK) 和扩展包 (OBB) 包。如果要发布大于 100 MB 的应用程序，则 Google Play 应用商店需要此功能。</strong></p><h2 id="Unity打包Android"><a href="#Unity打包Android" class="headerlink" title="Unity打包Android"></a>Unity打包Android</h2><h3 id="Unity导出APk"><a href="#Unity导出APk" class="headerlink" title="Unity导出APk"></a>Unity导出APk</h3><p>没什么可说的直接导出就行了</p><h3 id="Unity导出Android-Studio能够打开的工程"><a href="#Unity导出Android-Studio能够打开的工程" class="headerlink" title="Unity导出Android Studio能够打开的工程"></a>Unity导出Android Studio能够打开的工程</h3><p>1.设置导出基本信息：公司名、游戏名、图标、包名等关键信息</p><p>2.在File——&gt;Build Settings中，勾选 Export Project 选项</p><p>3.点击Export 导出按钮</p><h4 id="在Android-Studio中打开Unity导出的工程"><a href="#在Android-Studio中打开Unity导出的工程" class="headerlink" title="在Android Studio中打开Unity导出的工程"></a>在Android Studio中打开Unity导出的工程</h4><p>1.打开Android Studio</p><p>2.新选择 打开工程</p><p>3.选择 之前导出的对应文件夹</p><p>4.弹出提示时，使用Android Studio中的 Android SDK，可以避免打包失败</p><p>5.等待工程加载结束</p><p>6.更新Gradle版本，保证之后打包成功</p><h4 id="使用Android-Studio生成应用程序apk"><a href="#使用Android-Studio生成应用程序apk" class="headerlink" title="使用Android Studio生成应用程序apk"></a>使用Android Studio生成应用程序apk</h4><p>1.在 工具栏——&gt;Build——&gt;Build Bundle…——&gt;Build APK</p><p> 构建一次工程，保证构建成功，根据报错解决问题</p><p> 常见问题：</p><p> 1.The option ‘android.enableR8’ is deprecated 由于新版本Gradle默认使用R8混淆</p><p>   所以不需要这个选项设置了</p><p>   在Project选项中 找到 gradle.properties 删除 android.enableR8</p><p> 2.SDK Tools 版本不匹配</p><p>   更新SDK使用的路径，使用Android Studio自己的路径，或者更新SDK</p><p>2.在 工具栏——&gt;Build——&gt;Build Bundle…——&gt;Generate Signed Bundle</p><p> 发布APK，可以设置密钥库相关内容后进行打包即可</p><p>3.测试生成的apk文件</p><h2 id="Android调试相关"><a href="#Android调试相关" class="headerlink" title="Android调试相关"></a>Android调试相关</h2><h3 id="Unity进行安卓真机调试"><a href="#Unity进行安卓真机调试" class="headerlink" title="Unity进行安卓真机调试"></a>Unity进行安卓真机调试</h3><h4 id="调试指的是什么？"><a href="#调试指的是什么？" class="headerlink" title="调试指的是什么？"></a>调试指的是什么？</h4><p>安卓手机的真机调试</p><p>由于运行环境的改变（开发时在 Windows 或 MacOS，使用时在Android或IOS）</p><p>我们很多时候需要在真机上进行项目的 性能分析 和 bug处理（断点调试修复bug）</p><h4 id="准备测试用安卓手机"><a href="#准备测试用安卓手机" class="headerlink" title="准备测试用安卓手机"></a>准备测试用安卓手机</h4><p>1.安卓手机需要打开开发者模式可以根据自己的手机品牌自行搜索开启方式</p><p> 一般的操作方式：设置——&gt;关于手机——&gt;版本号（点击n次版本号）便可开启</p><p>2.完成第一步后，在手机的开发者选项中 开启 USB调试功能一般开发者选项会在：设置——&gt;系统——&gt;开发者选项中找到USB调试功能 开启它</p><p>3.将手机通过USB接入到你的电脑上，在手机上一般会弹出一个提示选择允许进行USB调试</p><h4 id="在Unity中进行调试相关设置"><a href="#在Unity中进行调试相关设置" class="headerlink" title="在Unity中进行调试相关设置"></a>在Unity中进行调试相关设置</h4><p>在 File ——&gt; Build Settings 中进行调试相关的设置</p><ol><li><p>完成知识点一相关内容后，可以在 Run Device 的设备列表中看到你的安卓设备</p><p>如果Refresh刷新后也无法看到你的设备，证明你的连接有问题，或没有开启USB调试模式</p></li><li><p>调试相关设置</p><p>剖析器 性能问题排查相关（勾选了他们，我们才能在Unity的剖析器中获取完整信息）</p><p>开启 Development Build 开发模式构建</p><p>开启 Autoconnect Profiler 自动连接分析器</p><p>开启 Deep Profiling 深度剖析</p></li></ol><p>  断点 调试相关（勾选了他们，我们才能进行断点调试）</p><p>  开启 Script Debuggins 脚本调试</p><p>  开启 Wait For Managed Debugger 等待托管调试器</p><ol><li><p>项目基本的发布设置相关内容一定要设置正确</p><p>比如：包名、项目名、公司名、密钥库等等</p></li></ol><h4 id="Unity连接安卓真机进行项目调试"><a href="#Unity连接安卓真机进行项目调试" class="headerlink" title="Unity连接安卓真机进行项目调试"></a>Unity连接安卓真机进行项目调试</h4><p>点击Build and Run</p><p>这时Unity会自动发布apk应用该程序，然后安装到设备上自动启动</p><p>这时我们就可以</p><ol><li><p>利用Unity的 剖析器来分析应用程序</p></li><li><p>进行断点调试，排查问题</p></li></ol><p>注意：如果想要断点调试，自动启动应用程序后，弹出的提示窗口 不要点击OK先在VS中 工具栏——&gt;调试——&gt;附加 Unity 调试程序——&gt;选择对应的设备再在运行的应用程序中点击ok</p><h3 id="Unity-Remote"><a href="#Unity-Remote" class="headerlink" title="Unity Remote"></a>Unity Remote</h3><h4 id="Remote是什么？"><a href="#Remote是什么？" class="headerlink" title="Remote是什么？"></a>Remote是什么？</h4><p>Remote翻译过来是远程的意思</p><p>Unity Remote是Unity提供给我们的一个可以安装到移动平台上的应用程序帮助我们进行调试的远程工具</p><p>该应用程序可以安装到 Android、IOS设备上，当我们在Unity编辑器运行项目时，移动设备上安装的Unity Remote会和Unity连接，Unity编辑器中的游戏画面会被发送到移动设备上，移动设备上的输入操作会返回到Unity编辑器运行的项目中</p><p>它的主要作用就是可以让我们省去发布安装包、安装到移动设备上的这一繁琐流程</p><p>可以直接通过Unity Remote远程连接来达到以下目的：</p><p>查看项目在设备上的视觉表现效果</p><p>测试移动设备输入逻辑是否能正常使用</p><p>设备的以下输入会被回传到Unity引擎中用于测试</p><p>触屏输入相关</p><p>GPS</p><p>陀螺仪</p><p>指南针</p><p>加速度计</p><p>相机拍照信息</p><p>等等输入信息</p><p>注意：</p><p>1.Unity引擎传递给移动设备的画面较模糊，帧率较低，我们只能看看大致的表现效果</p><p>2.我们主要通过这种方式，来测试移动设备输入相关的功能</p><p>比如：陀螺仪、GPS、触屏功能等等</p><h4 id="获取和使用Unity-Remote"><a href="#获取和使用Unity-Remote" class="headerlink" title="获取和使用Unity Remote"></a>获取和使用Unity Remote</h4><p>1.下载Unity Remote应用程序,并安装到移动设备上</p><p>2.将移动设备使用USB调试模式和电脑连接</p><p>3.在菜单栏Edit——&gt;Project Setting——&gt;Editor中设置Unity Remote的Device为任意设备</p><p>4.在移动设备运行Unity Remote</p><p>5.在Unity编辑器中启动项目，便可以进行远端调试</p><p>注意：</p><p>1.如果电脑插入多个Android设备，会自动选择第一台设备</p><p>2.Unity Remote存在的主要目的仅仅是为了快速的在设备上测试输入相关功能以及基本表现效果 如果要完整的测试，还是需要发布安装进行调试</p><h3 id="Android-Logcat"><a href="#Android-Logcat" class="headerlink" title="Android Logcat"></a>Android Logcat</h3><h4 id="Android-Logcat是什么？"><a href="#Android-Logcat是什么？" class="headerlink" title="Android Logcat是什么？"></a>Android Logcat是什么？</h4><p>Android Logcat是Unity提供的一个拓展包，引入该拓展包后，我们可以在Unity当中对Android应用程序进行调试</p><p>我们可以通过该工具获取到：</p><p>1.安卓日志打印信息</p><p>2.安卓应用程序内存统计</p><p>3.安卓屏幕截图</p><p>4.安卓屏幕录像</p><p>5.堆栈跟踪</p><p>Unity2019.4及以上版本都可以引入Android Logcat来帮助我们进行调试</p><h4 id="如何使用Android-Logcat工具"><a href="#如何使用Android-Logcat工具" class="headerlink" title="如何使用Android Logcat工具"></a>如何使用Android Logcat工具</h4><p>1.在Unity工程中引入Android Logcat包</p><p>2.连接Android设备</p><p>3.将Android Logcat连接到Android设备上点的应用程序，便可以查看相关信息</p><h4 id="Android-Logcat窗口基础知识"><a href="#Android-Logcat窗口基础知识" class="headerlink" title="Android Logcat窗口基础知识"></a>Android Logcat窗口基础知识</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136422.png" alt="image-20220903135914927"></p><h5 id="A：工具栏"><a href="#A：工具栏" class="headerlink" title="A：工具栏"></a>A：工具栏</h5><h6 id="Auto-Run：自动运行"><a href="#Auto-Run：自动运行" class="headerlink" title="Auto Run：自动运行"></a>Auto Run：自动运行</h6><p>启用后，当你构建和运行应用程序时Android Logcat窗口会连接到应用程序，显示对应的相关信息</p><h6 id="No-device：设备选择器"><a href="#No-device：设备选择器" class="headerlink" title="No device：设备选择器"></a>No device：设备选择器</h6><p>当没有Android设备连接电脑是，显示No Device，有设备时可以在这选择连接的Android设备</p><h6 id="No-Filter：过滤选择器"><a href="#No-Filter：过滤选择器" class="headerlink" title="No Filter：过滤选择器"></a>No Filter：过滤选择器</h6><p>可以指定Android设备上显示消息的应用程序，此处显示的是应用程序的包名</p><h6 id="过滤输入框"><a href="#过滤输入框" class="headerlink" title="过滤输入框"></a>过滤输入框</h6><p>用于过滤搜索消息日志，可以输入内容搜索信息</p><p>消息正文过滤：在输入框输入内容，则会自动筛选消息中存在输入字符的内容</p><p>优先级过滤：在下方点击Priority优先级，选择过滤的内容</p><p>Verbose：冗长的，所有<br>Debug：调试信息<br>Info：信息<br>Warn：警告<br>Error：错误<br>Fatal：致命的</p><p>按标签过滤：在下方点击Tag标签，选择过滤的内容</p><h6 id="Filter-Options：过滤器选项"><a href="#Filter-Options：过滤器选项" class="headerlink" title="Filter Options：过滤器选项"></a>Filter Options：过滤器选项</h6><p>决定如何使用选项过滤器输入过滤消息日志中的消息<br>Use Regular Expressions：使用正则表达式<br>Match Case：区分大小写</p><h6 id="Reconnect：重新连接"><a href="#Reconnect：重新连接" class="headerlink" title="Reconnect：重新连接"></a>Reconnect：重新连接</h6><p>重新连接到应用程序和设备，如果程序不再运行则重新连接到设备</p><h6 id="Disconnect：断开和设备的连接"><a href="#Disconnect：断开和设备的连接" class="headerlink" title="Disconnect：断开和设备的连接"></a>Disconnect：断开和设备的连接</h6><h6 id="Clear：清除消息列表中的消息日志"><a href="#Clear：清除消息列表中的消息日志" class="headerlink" title="Clear：清除消息列表中的消息日志"></a>Clear：清除消息列表中的消息日志</h6><h6 id="Tools：工具相关"><a href="#Tools：工具相关" class="headerlink" title="Tools：工具相关"></a>Tools：工具相关</h6><p>Screen Capture：屏幕捕获<br>从连接的Android设备上捕捉屏幕截图和视频</p><p>Open Terminal：开放终端<br>在Windows上打开命令调试符窗口，在macOS和Linux上打开终端</p><p>Stacktrace Utility：堆栈跟踪应用程序<br>解析自定义堆栈跟踪</p><p>Memory Window：内存窗口<br>跟踪为应用程序分配的内存</p><h5 id="B：消息日志"><a href="#B：消息日志" class="headerlink" title="B：消息日志"></a>B：消息日志</h5><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136658.png" alt="image-20220903140638857"></p><h4 id="屏幕捕获工具"><a href="#屏幕捕获工具" class="headerlink" title="屏幕捕获工具"></a>屏幕捕获工具</h4><p>屏幕捕获工具主要可以帮助我们进行游戏内截图，录屏</p><p>该工具可以帮助我们：</p><p>1.测试人员用来录制bug表现，反馈给程序人员进行解决</p><p>2.获取截屏、录屏信息，获取宣传资料</p><p>优点：直接PC端远程获取，方便快捷，便于记录bug表现效果</p><p>缺点：录制的视频不会捕获声音，录屏功能可以部分设备不支持</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136696.png" alt="image-20220903141016807"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136092.png" alt="image-20220903141109817"></p><h4 id="堆栈跟踪实用工具"><a href="#堆栈跟踪实用工具" class="headerlink" title="堆栈跟踪实用工具"></a>堆栈跟踪实用工具</h4><p>目前我们使用Android Logcat连接真机进行测试时</p><p>打印、警告、报错等等信息都会直接在主窗口中打印出来让我们进行分析</p><p>相当于它帮助我们进行了自动的堆栈跟踪解析</p><p>什么是自动堆栈跟踪解析呢？</p><p>就是我们可以在打印窗口看到具体是哪个脚本的哪行代码</p><p>出现了打印、警告、报错等等信息</p><p>而Tools(工具)中的Stacktrace Utility(堆栈跟踪实用工具)的作用是</p><p>允许我们复制粘贴自定义日志并解析堆栈跟踪</p><p>主要用于没有真机连接设备调试时</p><p>或者之后正式发布版本后</p><p>我们可以获取应用程序日志信息</p><p>将这些日志信息复制到该工具中用于翻译</p><p>(一般项目会在崩溃后，在本地存储一份崩溃日志，我们可以获取该日志)</p><p>因为这种情况下的日志信息中，不会明确指明是哪个脚本哪行代码</p><p>往往是一堆看不懂的符号,我们可以使用该工具进行翻译</p><p>比如：下面这个打印信息就是安卓的原始日志</p><p>E CRASH   :      #01  pc 01c65330  /data/app/com.CrashComp.Crash-J2Z_L0XSsSAZPkt9lab2rQ==/lib/arm/libunity.so</p><p>(DiagnosticsUtils_Bindings::ForceCrash(DiagnosticsUtils_Bindings::ForcedCrashCategory, ScriptingExceptionPtr*)+48)</p><p>这里面都是一堆特殊符号，并没有明确告诉你哪个脚本哪行代码</p><p>通过翻译后堆栈跟踪实用工具翻译后，我们就能够获取到哪个脚本哪行代码打印了输出了该信息</p><p>总而言之它该工具就是用来翻译发布后安卓应用程序的日志信息的</p><h5 id="堆栈跟踪实用工具的使用"><a href="#堆栈跟踪实用工具的使用" class="headerlink" title="堆栈跟踪实用工具的使用"></a>堆栈跟踪实用工具的使用</h5><p>使用堆栈跟踪实用工具的作用是可以翻译自己获取到的安卓日志信息</p><p>使用流程是：</p><p>1.设置项目的 so 文件路径</p><p>2.将日志信息复制到Original（初始）页签中</p><p>3.点击Resolve Stacktraces(解析堆栈跟踪)</p><p>4.在Resolved(已解析的日志)页签中查看翻译结果</p><p>注意：我们在电脑连接安卓设备通过Android Logcat进行调试时一般不使用该功能，只有当非连接调试时，获取了安卓崩溃日志后才会使用该功能</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136417.png" alt="image-20220903141656842"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136849.png" alt="image-20220903141726069"></p><h4 id="内存窗口工具"><a href="#内存窗口工具" class="headerlink" title="内存窗口工具"></a>内存窗口工具</h4><p>首先了解 RAM（运行时内存）对于我们的意义</p><p>如果应用程序出现闪退情况，往往都是因为应用程序运行时内存的使用超出了设备允许的最大内存量，而被手机系统强行关闭</p><p>注意：</p><p>不同品牌、型号的手机配置都是不同的，手机后台运行的程序数量也是不同的，所以要根据实际情况进行测试获取目标设备的内存极限值，可以选取市面上的主流机型来进行测试</p><p><strong>内存窗口工具是用于跟踪应用程序RAM（运行时内存）的分配情况的</strong></p><p>我们可以使用它来分析应用程序可能存在的内存问题</p><p>我们可以使用它 定期自动的 或者 手动的 捕获内存快照</p><p>这里的内存快照就是捕获的这一瞬间应用程序的运行时内存使用情况</p><p>根据内存快照我们可以分析内存问题</p><p>比如：</p><ol><li><p>切换场景前和切换场景后的内存快照比较，判断是否存在内存泄露</p></li><li><p>比如闪退前的内存快照，来分析设备占用多少内存时造成了闪退，确定内存瓶颈</p></li></ol><p>等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136108.png" alt="image-20220903142133235"></p><p>Auto Capture：自动捕获<br>Unity会定期捕获应用程序的内存快照<br>注意：自动捕获，可能会影响性能表现，可能会造成卡顿，如果严重影响测试，建议使用手动捕获</p><p>Manual Capture：手动捕获<br>通过点击按钮，自己手动捕获内存快照</p><p>Disabled：不启用</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136948.png" alt="image-20220903142205592"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136572.png" alt="image-20220903142318882"></p><h3 id="Android-Debug-Brige"><a href="#Android-Debug-Brige" class="headerlink" title="Android Debug Brige"></a>Android Debug Brige</h3><p>ADB是 Android Debug Brige（安卓调试桥）的简称</p><p>它是我们调试Android设备的一套指令集</p><p>它可以让我们通过指令来进行一些操作，来获取日志信息</p><p>比如：</p><p>1.关机、重启</p><p>2.安装、启动、卸载应用程序</p><p>3.删除、移动、复制文件</p><p>4.查看日志信息</p><p>我们最常使用的就是查看日志信息的功能</p><p>之前学习的Android Logcat工具其实就是利用了ADB来获取的信息</p><p>由于Android Logcat工具只能在Unity 2019.4及其以上版本才能使用</p><p>所以对于老版本的Unity来说，我们一般使用ADB来帮助我们进行调试</p><p>注意：</p><p>使用ADB工具的前提是 电脑和安卓设备处于USB调试连接</p><h4 id="如何使用ADB？"><a href="#如何使用ADB？" class="headerlink" title="如何使用ADB？"></a>如何使用ADB？</h4><p>在Android SDK的路径中</p><p>寻找platform-tools文件夹</p><p>在其中可以找到adb.exe文件</p><p>我们需要配合命令调试符窗口（Windows）使用adb指令集</p><p>方法一：</p><p>直接在Android Logcat窗口中使用Tools中的Open Terminal（打开终端）</p><p>Window系统会自动打开命令调试符窗口</p><p>MacOS系统会自动打开终端窗口</p><p>会直接来到SDK文件夹中的platform-tools（平台工具）文件夹</p><p>在后面直接输入指令即可</p><p>adb 指令</p><p>方法二：</p><p>自己打开命令调试符窗口</p><p>输入adb.exe所在文件夹路径</p><p>比如：</p><p>D:\Android\android-sdk\platform-tools\adb 指令</p><h4 id="关键指令"><a href="#关键指令" class="headerlink" title="关键指令"></a>关键指令</h4><p>常用指令</p><p>1.显示日志信息</p><p> adb logcat</p><p>2.获取Unity相关日志信息</p><p> adb logcat -s Unity</p><p>做了解的指令</p><p>1.查看abb相关信息，比如版本号、常用命令等</p><p> adb help</p><p>2.查看adb版本</p><p> adb version</p><p>3.安装apk</p><p> adb install apk路径</p><p>4.覆盖安装</p><p> adb install -r apk路径</p><p>5.卸载应用程序</p><p> adb uninstall 应用程序包名</p><p>6.保留数据卸载应用程序</p><p> adb uninstall -k 应用程序包名</p><p>7.查看连接的主机设备</p><p> adb devices</p><p>8.从电脑上复制文件到手机</p><p> adb push 电脑上文件路径 需要复制到的手机路径</p><p>9.从手机上复制文件到电脑</p><p> adb pull 手机上文件路径 需要复制到的电脑路径</p><p>10.查看手机上安装的所有应用程序包名</p><p> adb shell pm list packages</p><p>11.截图</p><p> adb shell screencap 保存到的手机路径</p><p>12.录屏</p><p> adb shell screenrecord 保存到的手机路径</p><p>等等</p><p>更多信息</p><p><a href="https://developer.android.com/studio/command-line/adb.html">https://developer.android.com/studio/command-line/adb.html</a></p><h3 id="Android-Studio中调试应用程序"><a href="#Android-Studio中调试应用程序" class="headerlink" title="Android Studio中调试应用程序"></a>Android Studio中调试应用程序</h3><h4 id="回顾Unity导出Android-Studio工程"><a href="#回顾Unity导出Android-Studio工程" class="headerlink" title="回顾Unity导出Android Studio工程"></a>回顾Unity导出Android Studio工程</h4><p>Build Settings中进行设置</p><p>1.勾选Export Project</p><p>2.勾选Development Build</p><p>3.导出到指定目录</p><p>4.使用Android Studio打开该工程</p><p>5.更新Gradle版本</p><p>6.删除 android.enableR8</p><p>7.保证构建成功</p><h4 id="在Android-Studio中调试应用程序"><a href="#在Android-Studio中调试应用程序" class="headerlink" title="在Android Studio中调试应用程序"></a>在Android Studio中调试应用程序</h4><p>1.保证Android设备和电脑进行USB调试连接</p><p>2.菜单栏的Run页签中进行调试（若上部分Run置灰，可以重启一次Android Studio）</p><p>3.在下方的Logcat日志窗口和Profiler性能分析器窗口调试应用程序，排查问题</p><p>更多关于Android Studio调试和性能分析内容</p><p>调试：<a href="https://developer.android.google.cn/studio/debug">https://developer.android.google.cn/studio/debug</a></p><p>性能分析：<a href="https://developer.android.google.cn/studio/profile">https://developer.android.google.cn/studio/profile</a></p><p>总结</p><p>Android Studio中调试应用程序和Unity中使用 Android Logcat + Unity Profiler窗口类似</p><p>一般情况下，没有特殊需求，我们都在Unity中进行Android应用程序调试</p><p>相对Android Studio中调试来说更适合我们Unity程序员</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 移动平台 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-网络开发（三）</title>
      <link href="/posts/ba9e7782.html"/>
      <url>/posts/ba9e7782.html</url>
      
        <content type="html"><![CDATA[<h1 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h1><h2 id="什么是大小端模式"><a href="#什么是大小端模式" class="headerlink" title="什么是大小端模式"></a>什么是大小端模式</h2><h3 id="大端模式"><a href="#大端模式" class="headerlink" title="大端模式"></a>大端模式</h3><p>是指数据的高字节保存在内存的低地址中</p><p>而数据的低字节保存在内存的高地址中</p><p>这样的存储模式有点儿类似于把数据当作字符串顺序处理</p><p>地址由小向大增加，数据从高位往低位放</p><p>符合人类的阅读习惯</p><h3 id="小端模式"><a href="#小端模式" class="headerlink" title="小端模式"></a>小端模式</h3><p>是指数据的高字节保存在内存的高地址中</p><p>而数据的低字节保存在内存的低地址中</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>十六进制数据0x11223344</p><h3 id="大端模式存储"><a href="#大端模式存储" class="headerlink" title="大端模式存储"></a>大端模式存储</h3><p>11    22    33    44</p><p>0     1     2     3</p><p>低地址——&gt;高地址</p><h3 id="小端模式存储"><a href="#小端模式存储" class="headerlink" title="小端模式存储"></a>小端模式存储</h3><p>44    33    22    11</p><p>0     1     2     3</p><p>低地址——&gt;高地址</p><h2 id="为什么有大小端模式"><a href="#为什么有大小端模式" class="headerlink" title="为什么有大小端模式"></a>为什么有大小端模式</h2><p>大小端模式其实是计算机硬件的两种存储数据的方式</p><p>我们也可以称大小端模式为 大小端字节序</p><p>对于我们来说，大端字节序阅读起来更加方便，为什么还要有小端字节序呢？</p><p>原因是，计算机电路先处理低位字节，效率比较高</p><p>计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节</p><p>它只知道按顺序读取字节，先读第一个字节，再读第二个字节</p><p>如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节</p><p>小端字节序正好相反</p><p>因为计算机都是从低位开始的</p><p>所以，计算机的内部处理都是小端字节序</p><p>但是，我们人类的读写习惯还是大端字节序</p><p>所以，除了计算机的内部处理</p><p>其它场合几乎都是大端字节序，比如网络传输和文件存储</p><p>一般情况下，操作系统都是小端模式，而通讯协议都是大端模式</p><p>但是具体的模式，还是要根据硬件平台，开发语言来决定</p><p>主机不同，开发语言不同 可能采用的大小端模式也会不一致</p><h2 id="大小端模式对于我们的影响"><a href="#大小端模式对于我们的影响" class="headerlink" title="大小端模式对于我们的影响"></a>大小端模式对于我们的影响</h2><p>只有读取的时候，才必须区分大小端字节序，其它情况都不用考虑</p><p>因此对于我们来说，在网络传输当中我们传输的是字节数组</p><p>那么我们在收到字节数组进行解析时，就需要考虑大小端的问题</p><p>虽然TCP/IP协议规定了在网络上必须采用网络字节顺序（大端模式）</p><p>但是具体传输时采用哪种模式，都是根据前后端语言、设备决定的</p><p>在进行网络通讯时，前后端语言不同时，可能会造成大小端不统一</p><p>一般情况下</p><p>C# 和 Java/Erlang/AS3 通讯需要进行大小端转换 因为C#是小端模式 Java/Erlang/AS3是大端模式</p><p>C# 与 C++通信不需要特殊处理 他们都是小端模式</p><h2 id="大小端转换"><a href="#大小端转换" class="headerlink" title="大小端转换"></a>大小端转换</h2><h3 id="判断是大小端哪种模式"><a href="#判断是大小端哪种模式" class="headerlink" title="判断是大小端哪种模式"></a>判断是大小端哪种模式</h3><p> print(“是否是小端模式:” + BitConverter.IsLittleEndian);</p><h3 id="简单的转换API-只支持几种类型"><a href="#简单的转换API-只支持几种类型" class="headerlink" title="简单的转换API 只支持几种类型"></a>简单的转换API 只支持几种类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换为网络字节序 相当于就是转为大端模式</span></span><br><span class="line"><span class="comment">//1. 本机字节序转网络字节序</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">99</span>;</span><br><span class="line">byte[] bytes = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(i));</span><br><span class="line"><span class="comment">//2. 网络字节序转本机字节序</span></span><br><span class="line"><span class="type">int</span> receI = BitConverter.ToInt32(bytes, <span class="number">0</span>);</span><br><span class="line">receI = IPAddress.NetworkToHostOrder(receI);</span><br></pre></td></tr></table></figure><h3 id="通用的转换方式"><a href="#通用的转换方式" class="headerlink" title="通用的转换方式"></a>通用的转换方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中的倒序API</span></span><br><span class="line"><span class="comment">//如果后端需要用到大端模式 那么我们进行判断</span></span><br><span class="line"><span class="comment">//如果当前是小端模式 就进行一次 大小端转换</span></span><br><span class="line"><span class="keyword">if</span>(BitConverter.IsLittleEndian) Array.Reverse(bytes);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大小端模式会根据主机硬件环境不同、语言不同而有所区别</p><p>当我们前后端是不同语言开发且运行在不同主机上时</p><p>前后端需要对大小端字节序定下统一的规则</p><p>一般让前端迎合后端，因为字节序的转换也是会带来些许性能损耗的</p><p>网络游戏中要尽量减轻后端的负担</p><p>一般情况下</p><p>C# 和 Java/Erlang/AS3 通讯需要进行大小端转换 前端C#从小变大</p><p>C# 与 C++通信不需要特殊处理</p><p>我们不用死记硬背和谁通讯要注意大小端模式</p><p>当开发时，发现后端收到的消息和前端发的不一样</p><p>在协议统一的情况下，往往就是因为大小端造成的</p><p>这时我们再转换模式即可</p><p>注意：</p><p>Protobuf已经帮助我们解决了大小端问题</p><p>即使前后端语言不统一</p><p>使用它也不用过多考虑字节序转换的问题</p><h1 id="消息加密解密"><a href="#消息加密解密" class="headerlink" title="消息加密解密"></a>消息加密解密</h1><h2 id="什么是消息加密解密"><a href="#什么是消息加密解密" class="headerlink" title="什么是消息加密解密"></a>什么是消息加密解密</h2><p>我们在网路传输时，会把数据转换为字节数组以2进制的形式进行传输</p><p>理论上来说，如果有人截取篡改了消息，或者从前端发假消息给后端</p><p>就可能产生作弊行为</p><p>消息的加密解密 可以有效避免作弊行为的产生</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>采用一些方式对数据进行处理后，使数据从表面上看，已经不能表达出原有的意思</p><p>别人就算获取到了你的信息，也无法知道你的内容的含义和规则</p><p>这样可以让我们的数据更加的安全，降低被篡改的可能性</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>通过对加密过的数据采用某些方法，去还原原有数据，从而获取目标数据</p><p>其实就是在</p><p>发消息时，对我们的消息2进制数据进行加密（一般只对消息体加密）</p><p>收到消息时，对2进制数据进行解密（一般只对消息体解密）</p><h2 id="加密是否是100-安全？"><a href="#加密是否是100-安全？" class="headerlink" title="加密是否是100%安全？"></a>加密是否是100%安全？</h2><p>一定记住加密只是提高破解门槛，没有100%保密的数据</p><p>通过各种尝试始终是可以破解加密规则的，只是时间问题</p><p>加密只能提升一定的安全性</p><p>对于大多数情况下已经够用了，除非专门有人针对你们的产品进行破解</p><p>但是遇到这种情况 也证明你的产品已经足够成功了</p><h2 id="加密解密的相关名词解释"><a href="#加密解密的相关名词解释" class="headerlink" title="加密解密的相关名词解释"></a>加密解密的相关名词解释</h2><p>明文：待加密的报文（内容）</p><p>密文：加密后的报文（内容）</p><p>密钥：加密过程中或解密过程中输入的数据</p><p>算法：将明文和密钥相结合进行处理，生成密文的方法，叫加密算法。将密文和密钥相结合进行处理，生成明文的方法，叫解密算法</p><h2 id="了解加密算法分类"><a href="#了解加密算法分类" class="headerlink" title="了解加密算法分类"></a>了解加密算法分类</h2><h3 id="1-单向加密"><a href="#1-单向加密" class="headerlink" title="1.单向加密"></a>1.单向加密</h3><p>​    将数据进行计算变成另一种固定长度的值，这种加密是不可逆的</p><p>​    常用算法</p><p>​    MD5、SHA1、SHA256等</p><p>​    用途：这种加密在网络传输中不会使用，主要用到其它功能当中，比如密码的单向加密</p><h3 id="2-对称加密技术"><a href="#2-对称加密技术" class="headerlink" title="2.对称加密技术"></a>2.对称加密技术</h3><p>​    使用同一个密钥，对数据镜像加密和解密（用密钥对明文加密，用密钥对密文解密）</p><p>​    常用算法</p><p>​    DES、3DES、IDEA、AES等</p><p>​    优点：计算量小，加密速度快、效率高</p><p>​    缺点：如果知道了密钥和算法，就可以进行解密</p><p>​    用途：网路通讯中可以使用对称加密技术，这个密钥可以是由后端下发的，每次建立通讯后都会变化的</p><h3 id="3-非对称加密技术"><a href="#3-非对称加密技术" class="headerlink" title="3.非对称加密技术"></a>3.非对称加密技术</h3><p>​    在加密过程中，需要一对密钥，不公开的密钥称为私钥，公开的那一个密钥称为公钥</p><p>​    也可以称为公开密钥加密</p><p>​    从一对密钥中的任何一个密钥都不能计算出另一个密钥</p><p>​    使用一对密钥中的任何一个加密，只有另一个密钥才能解密。如果截获公钥加密数据，没有私钥也无法解密</p><p>​    常用算法</p><p>​    RSA、DSA等</p><p>​    优点：安全性高，即使获取到了公钥，没有私钥也无法进行解密</p><p>​    缺点：算法复杂，加密速度较慢</p><p>​    用途：对安全性要求较高的场景，并且可以接受较慢的加密速度的需求可以使用非对称加密技术</p><p>​        以后在对接一些支付SDK时经常会看到平台提供的就是非对称加密技术</p><p>关于这些加密算法</p><p>有很多的别人写好的第三发加密算法库</p><p>可以直接获取用于在程序中对数据进行加密</p><p>也可以自己基于加密算法原理来设计自己的规则</p><h2 id="用简单的异或加密感受加密的作用"><a href="#用简单的异或加密感受加密的作用" class="headerlink" title="用简单的异或加密感受加密的作用"></a>用简单的异或加密感受加密的作用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异或加密特点</span></span><br><span class="line"><span class="comment">//密钥为一个整数</span></span><br><span class="line"><span class="comment">//明文 异或 密钥 得到 密文</span></span><br><span class="line"><span class="comment">//密文 异或 密钥 得到 明文</span></span><br><span class="line"></span><br><span class="line">TestMsg msg = new TestMsg();</span><br><span class="line">msg.ListInt.Add(<span class="number">1</span>);</span><br><span class="line">msg.TestBool = <span class="literal">false</span>;</span><br><span class="line">msg.TestD = <span class="number">5.5</span>;</span><br><span class="line">msg.TestInt32 = <span class="number">99</span>;</span><br><span class="line">msg.TestMap.Add(<span class="number">1</span>, <span class="string">&quot;刘英博&quot;</span>);</span><br><span class="line">msg.TestMsg2 = new TestMsg2();</span><br><span class="line">msg.TestMsg2.TestInt32 = <span class="number">88</span>;</span><br><span class="line">msg.TestMsg3 = new TestMsg.Types.TestMsg3();</span><br><span class="line">msg.TestMsg3.TestInt32 = <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">msg.TestHeart = new GameSystemTest.HeartMsg();</span><br><span class="line">msg.TestHeart.Time = <span class="number">7777</span>;</span><br><span class="line"></span><br><span class="line">byte[] bytes = NetTool.GetProtoBytes(msg);</span><br><span class="line"><span class="comment">//异或加密算法</span></span><br><span class="line"><span class="comment">//密钥声明</span></span><br><span class="line">byte s = <span class="number">55</span>;</span><br><span class="line"><span class="comment">//异或加密</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++)</span><br><span class="line">    bytes[i] ^= s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异或解密</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++)</span><br><span class="line">    bytes[i] ^= s;</span><br><span class="line"></span><br><span class="line">TestMsg msg2 = NetTool.GetProtoMsg&lt;TestMsg&gt;(bytes);</span><br><span class="line">print(msg2.TestMsg3.TestInt32);</span><br></pre></td></tr></table></figure><h1 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h1><h2 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h2><p>Protobuf全称是 protocol-buffers（协议缓冲区）</p><p>是谷歌提供给开发者的一个开源的协议生成工具</p><p>它的主要工作原理和我们之前做的自定义协议工具类似</p><p>只不过它更加的完善，可以基于协议配置文件生成</p><p>C++、Java、C#、Objective-C、PHP、Python、Ruby、Go</p><p>等等语言的代码文件</p><p>它是商业游戏开发中常常会选择的协议生成工具</p><p>有很多游戏公司选择它作为协议工具来进行网络游戏开发</p><p>因为它通用性强，稳定性高，可以节约出开发自定义协议工具的时间</p><p>protocol-buffers官网</p><p><a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p><h2 id="Protobuf的使用流程"><a href="#Protobuf的使用流程" class="headerlink" title="Protobuf的使用流程"></a>Protobuf的使用流程</h2><p>在官网中前往下载地址</p><p> protocol-buffers官网</p><p> <a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p><p>下载protobuf-csharp然后有两种方式选择</p><h3 id="在unity中使用源码"><a href="#在unity中使用源码" class="headerlink" title="在unity中使用源码"></a>在unity中使用源码</h3><p>解压后打开csharp\src将Google.Protobuf这个文件夹直接放入到unity中</p><h3 id="在unity中使用Google-Protobuf-dll"><a href="#在unity中使用Google-Protobuf-dll" class="headerlink" title="在unity中使用Google.Protobuf.dll"></a>在unity中使用Google.Protobuf.dll</h3><p>解压后打开csharp\src中的Google.Protobuf.sln</p><p>选择Google.Protobuf右键生成 dll文件</p><p>在csharp\src\Google.Protobuf\bin\Debug路径下找到对应.net版本的Dll文件（我们使用4.5即可）</p><p>将net45中的dll文件导入到Unity工程中的Plugins插件文件夹中</p><h2 id="proto文件"><a href="#proto文件" class="headerlink" title=".proto文件"></a>.proto文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// C#中的namespace</span></span><br><span class="line">package ProtoTest</span><br><span class="line"> </span><br><span class="line">option optimize_for = SPEED;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// java文件路径</span></span><br><span class="line">option java_package = <span class="string">&quot;com.montior.proto&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// java文件名称</span></span><br><span class="line">option java_outer_classname = <span class="string">&quot;MonitorData&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 消息结果。</span></span><br><span class="line">message MsgResult &#123;</span><br><span class="line">    <span class="comment">// 结果码。</span></span><br><span class="line">    int32 code = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 错误消息。</span></span><br><span class="line">    <span class="built_in">string</span> err_msg = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 接收包</span></span><br><span class="line">message TaskProtocol &#123;</span><br><span class="line">    <span class="comment">// 数据类型</span></span><br><span class="line">    int32 packType = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 具体数据</span></span><br><span class="line">    bytes content = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 包的类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PackType</span> &#123;</span></span><br><span class="line">    LOGIN = <span class="number">0</span>;</span><br><span class="line">    CREATE_TASK = <span class="number">2</span>;</span><br><span class="line">    DELETE_TASK = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">message LoginPack&#123;</span><br><span class="line">    <span class="built_in">string</span> username = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">message LoginPack2&#123;</span><br><span class="line">    <span class="built_in">string</span> username = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">message CreateTaskPack&#123;</span><br><span class="line">    <span class="built_in">string</span> taskId = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> taskName = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.message：消息类型，类似于一个类</p><p>2.package：包名，CSharp中的命名空间，用来防止不同消息类型的冲突</p><p>3.enum：枚举，这个需要我说吗？</p><p>4.option：选项，说明下我这边用到的<br>option java_package = “com.example.foo”;// java文件路径<br>option java_outer_classname = “Ponycopter”;// java文件名称<br>option optimize_for = SPEED;//可以被设置为 SPEED, CODE_SIZE,or LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成：</p><p>注：以上选项，CSharp都用不着的，就是写着玩儿….</p><p>5.数据类型</p><div class="table-container"><table><thead><tr><th>protobuf 数据类型</th><th>描述</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td></tr><tr><td>double</td><td>64位浮点数</td></tr><tr><td>float</td><td>32为浮点数</td></tr><tr><td>int32</td><td>32位整数</td></tr><tr><td>uin32</td><td>无符号32位整数</td></tr><tr><td>int64</td><td>64位整数</td></tr><tr><td>uint64</td><td>64为无符号整</td></tr><tr><td>sint32</td><td>32位整数，处理负数效率更高</td></tr><tr><td>sing64</td><td>64位整数 处理负数效率更高</td></tr><tr><td>fixed32</td><td>32位无符号整数</td></tr><tr><td>fixed64</td><td>64位无符号整数</td></tr><tr><td>sfixed32</td><td>32位整数、能以更高的效率处理负数</td></tr><tr><td>sfixed64</td><td>64为整数</td></tr><tr><td>string</td><td>只能处理 ASCII字符</td></tr><tr><td>bytes</td><td>用于处理多字节的语言字符、如中文</td></tr></tbody></table></div><p>6.关键字</p><div class="table-container"><table><thead><tr><th>指定字段</th><th>说明</th></tr></thead><tbody><tr><td>required</td><td>表示是一个必须字段，必须相对于发送方，在发送消息之前必须设置该字段的值，对于接收方，必须能够识别该字段的意思。发送之前没有设置required字段或者无法识别required字段都会引发编解码异常，导致消息被丢弃。</td></tr><tr><td>optional</td><td>表示是一个可选字段，可选对于发送方，在发送消息时，可以有选择性的设置或者不设置该字段的值。对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段，消息中的其它字段正常处理。—-因为optional字段的特性，很多接口在升级版本中都把后来添加的字段都统一的设置为optional字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡。</td></tr><tr><td>repeated</td><td>表示该字段可以包含0~N个元素。其特性和optional一样，但是每一次可以包含多个值。可以看作是在传递一个数组的值。</td></tr></tbody></table></div><h2 id="Protoc"><a href="#Protoc" class="headerlink" title="Protoc"></a>Protoc</h2><p>在官网中前往下载地址</p><p> protocol-buffers官网</p><p> <a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p><p>写好 proto 文件之后用 protoc 编译器将 .proto文件编译成目标语言。</p><h3 id="Unity中protoc使用"><a href="#Unity中protoc使用" class="headerlink" title="Unity中protoc使用"></a>Unity中protoc使用</h3><p>下载Protobuf-Unity插件放入Unity工程<br><code>Protobuf-Unity下载链接</code>：<a href="https://github.com/5argon/protobuf-unity">https://github.com/5argon/protobuf-unity</a></p><p>Unity工程打开<code>Editor/Preferences/Protobuf</code>并将下载的Protoc路径填入Path to protoc中<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242132910.png" alt="在这里插入图片描述">这个插件可以遍历Unity工程目录下的所有proto文件，并生成对应的c#文件。</p><h1 id="网络管理框架"><a href="#网络管理框架" class="headerlink" title="网络管理框架"></a>网络管理框架</h1><p>一个小Demo主要是为了理解网络框架的大概流程，都是基础的C#</p><p><a href="https://github.com/liuyingbor/NetDemo">https://github.com/liuyingbor/NetDemo</a></p><p>如果想深入了解网络框架Unity商城的BestHTTP强烈推荐。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-UniTask</title>
      <link href="/posts/34c3e4a1.html"/>
      <url>/posts/34c3e4a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="UniTask"><a href="#UniTask" class="headerlink" title="UniTask"></a>UniTask</h1><p>为Unity提供一个高性能，0GC的async/await异步方案。</p><ul><li>基于值类型的<code>UniTask&lt;T&gt;</code>和自定义的 AsyncMethodBuilder 来实现0GC</li><li>使所有 Unity 的 AsyncOperations 和 Coroutines 可等待</li><li>基于 PlayerLoop 的任务( <code>UniTask.Yield</code>, <code>UniTask.Delay</code>, <code>UniTask.DelayFrame</code>, etc…) 可以替换所有协程操作</li><li>对MonoBehaviour 消息事件和 uGUI 事件进行 可等待/异步枚举 拓展</li><li>完全在 Unity 的 PlayerLoop 上运行，因此不使用Thread，并且同样能在 WebGL、wasm 等平台上运行。</li><li>带有 Channel 和 AsyncReactiveProperty的异步 LINQ，</li><li>提供一个 TaskTracker EditorWindow 以追踪所有UniTask分配来预防内存泄漏</li><li>与原生 Task/ValueTask/IValueTaskSource 高度兼容的行为</li></ul><p>有关技术细节，请参阅博客文章：<a href="https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd">UniTask v2 — Unity 的0GC async/await 以及 异步LINQ 的使用</a><br>有关高级技巧，请参阅博客文章：<a href="https://medium.com/@neuecc/extends-unitywebrequest-via-async-decorator-pattern-advanced-techniques-of-unitask-ceff9c5ee846">通过异步装饰器模式扩展 UnityWebRequest — UniTask 的高级技术</a></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>通过<a href="https://github.com/Cysharp/UniTask/releases">UniTask/releases</a>页面中提供的<a href="https://github.com/wqaetly/UniTask#upm-package">UPM 包</a>或资产包 ( <code>UniTask.*.*.*.unitypackage</code>)安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 使用UniTask所需的命名空间</span><br><span class="line">using Cysharp.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">// 你可以返回一个形如 UniTask&lt;T&gt;(或 UniTask) 的类型，这种类型事为Unity定制的，作为替代原生Task&lt;T&gt;的轻量级方案</span><br><span class="line">// 为Unity集成的 0GC，快速调用，0消耗的 async/await 方案</span><br><span class="line">async UniTask&lt;string&gt; DemoAsync()</span><br><span class="line">&#123;</span><br><span class="line">    // 你可以等待一个Unity异步对象</span><br><span class="line">    var asset = await Resources.LoadAsync&lt;TextAsset&gt;(&quot;foo&quot;);</span><br><span class="line">    var txt = (await UnityWebRequest.Get(&quot;https://...&quot;).SendWebRequest()).downloadHandler.text;</span><br><span class="line">    await SceneManager.LoadSceneAsync(&quot;scene2&quot;);</span><br><span class="line"></span><br><span class="line">    // .WithCancellation 会启用取消功能，GetCancellationTokenOnDestroy 表示获取一个依赖对象生命周期的Cancel句柄，当对象被销毁时，将会调用这个Cancel句柄，从而实现取消的功能</span><br><span class="line">    var asset2 = await Resources.LoadAsync&lt;TextAsset&gt;(&quot;bar&quot;).WithCancellation(this.GetCancellationTokenOnDestroy());</span><br><span class="line"></span><br><span class="line">    // .ToUniTask 可接收一个 progress 回调以及一些配置参数，Progress.Create是IProgress&lt;T&gt;的轻量级替代方案</span><br><span class="line">    var asset3 = await Resources.LoadAsync&lt;TextAsset&gt;(&quot;baz&quot;).ToUniTask(Progress.Create&lt;float&gt;(x =&gt; Debug.Log(x)));</span><br><span class="line"></span><br><span class="line">    // 等待一个基于帧的延时操作（就像一个协程一样）</span><br><span class="line">    await UniTask.DelayFrame(100); </span><br><span class="line"></span><br><span class="line">    // yield return new WaitForSeconds/WaitForSecondsRealtime 的替代方案</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(10), ignoreTimeScale: false);</span><br><span class="line">    </span><br><span class="line">    // 可以等待任何 playerloop 的生命周期(PreUpdate, Update, LateUpdate, 等...)</span><br><span class="line">    await UniTask.Yield(PlayerLoopTiming.PreLateUpdate);</span><br><span class="line"></span><br><span class="line">    // yield return null 替代方案</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">    await UniTask.NextFrame();</span><br><span class="line"></span><br><span class="line">    // WaitForEndOfFrame 替代方案 (需要 MonoBehaviour(CoroutineRunner))</span><br><span class="line">    await UniTask.WaitForEndOfFrame(this); // this 是一个 MonoBehaviour</span><br><span class="line"></span><br><span class="line">    // yield return new WaitForFixedUpdate 替代方案，(和 UniTask.Yield(PlayerLoopTiming.FixedUpdate) 效果一样)</span><br><span class="line">    await UniTask.WaitForFixedUpdate();</span><br><span class="line">    </span><br><span class="line">    // yield return WaitUntil 替代方案</span><br><span class="line">    await UniTask.WaitUntil(() =&gt; isActive == false);</span><br><span class="line"></span><br><span class="line">    // WaitUntil拓展，指定某个值改变时触发</span><br><span class="line">    await UniTask.WaitUntilValueChanged(this, x =&gt; x.isActive);</span><br><span class="line"></span><br><span class="line">    // 你可以直接 await 一个 IEnumerator 协程</span><br><span class="line">    await FooCoroutineEnumerator();</span><br><span class="line"></span><br><span class="line">    // 你可以直接 await 一个原生 task</span><br><span class="line">    await Task.Run(() =&gt; 100);</span><br><span class="line"></span><br><span class="line">    // 多线程示例，在此行代码后的内容都运行在一个线程池上</span><br><span class="line">    await UniTask.SwitchToThreadPool();</span><br><span class="line"></span><br><span class="line">    /* 工作在线程池上的代码 */</span><br><span class="line"></span><br><span class="line">    // 转回主线程</span><br><span class="line">    await UniTask.SwitchToMainThread();</span><br><span class="line"></span><br><span class="line">    // 获取异步的 webrequest</span><br><span class="line">    async UniTask&lt;string&gt; GetTextAsync(UnityWebRequest req)</span><br><span class="line">    &#123;</span><br><span class="line">        var op = await req.SendWebRequest();</span><br><span class="line">        return op.downloadHandler.text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var task1 = GetTextAsync(UnityWebRequest.Get(&quot;http://google.com&quot;));</span><br><span class="line">    var task2 = GetTextAsync(UnityWebRequest.Get(&quot;http://bing.com&quot;));</span><br><span class="line">    var task3 = GetTextAsync(UnityWebRequest.Get(&quot;http://yahoo.com&quot;));</span><br><span class="line"></span><br><span class="line">    // 构造一个async-wait，并通过元组语义轻松获取所有结果</span><br><span class="line">    var (google, bing, yahoo) = await UniTask.WhenAll(task1, task2, task3);</span><br><span class="line"></span><br><span class="line">    // WhenAll简写形式</span><br><span class="line">    var (google2, bing2, yahoo2) = await (task1, task2, task3);</span><br><span class="line"></span><br><span class="line">    // 返回一个异步值，或者你也可以使用`UniTask`(无结果), `UniTaskVoid`(协程，不可等待)</span><br><span class="line">    return (asset as TextAsset)?.text ?? throw new InvalidOperationException(&quot;Asset not found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UniTask-和-AsyncOperation-基础知识"><a href="#UniTask-和-AsyncOperation-基础知识" class="headerlink" title="UniTask 和 AsyncOperation 基础知识"></a>UniTask 和 AsyncOperation 基础知识</h2><p>UniTask 功能依赖于 C# 7.0( <a href="https://github.com/dotnet/roslyn/blob/master/docs/features/task-types.md">task-like custom async method builder feature</a> ) 所以需要的 Unity 最低版本是<code>Unity 2018.3</code> ，官方支持的最低版本是<code>Unity 2018.4.13f1</code>.</p><p>为什么需要 UniTask（自定义task对象）？因为原生 Task 太重，与 Unity 线程（单线程）相性不好。UniTask 不使用线程和 SynchronizationContext/ExecutionContext，因为 Unity 的异步对象由 Unity 的引擎层自动调度。它实现了更快和更低的分配，并且与Unity完全兼容。</p><p>你可以在使用 <code>using Cysharp.Threading.Tasks;</code>时对 <code>AsyncOperation</code>， <code>ResourceRequest</code>，<code>AssetBundleRequest</code>， <code>AssetBundleCreateRequest</code>， <code>UnityWebRequestAsyncOperation</code>， <code>AsyncGPUReadbackRequest</code>， <code>IEnumerator</code>以及其他的异步操作进行 await</p><p>UniTask 提供了三种模式的扩展方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">* await asyncOperation;</span><br><span class="line">* .WithCancellation(CancellationToken);</span><br><span class="line">* .ToUniTask(IProgress, PlayerLoopTiming, CancellationToken);</span><br></pre></td></tr></table></figure><p><code>WithCancellation</code>是<code>ToUniTask</code>的简化版本，两者都返回<code>UniTask</code>。有关cancellation的详细信息，请参阅：<a href="https://github.com/wqaetly/UniTask#cancellation-and-exception-handling">取消和异常处理</a>部分。</p><blockquote><p>注意：await 会在 PlayerLoop 执行await对象的相应native生命周期方法时返回（如果条件满足的话），而 WithCancellation 和 ToUniTask 是从指定的 PlayerLoop 生命周期执行时返回。有关 PlayLoop生命周期 的详细信息，请参阅：<a href="https://github.com/wqaetly/UniTask#playerloop">PlayerLoop</a>部分。</p><p>注意： AssetBundleRequest 有<code>asset</code>和<code>allAssets</code>，默认 await 返回<code>asset</code>。如果你想得到<code>allAssets</code>，你可以使用<code>AwaitForAllAssets()</code>方法。</p></blockquote><p><code>UniTask</code>可以使用<code>UniTask.WhenAll</code>和<code>UniTask.WhenAny</code>等实用函数。它们就像<code>Task.WhenAll</code>/<code>Task.WhenAny</code>。但它们会返回内容，这很有用。它们会返回值元组，因此您可以传递多种类型并解构每个结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTaskVoid LoadManyAsync()</span><br><span class="line">&#123;</span><br><span class="line">    // 并行加载.</span><br><span class="line">    var (a, b, c) = await UniTask.WhenAll(</span><br><span class="line">        LoadAsSprite(&quot;foo&quot;),</span><br><span class="line">        LoadAsSprite(&quot;bar&quot;),</span><br><span class="line">        LoadAsSprite(&quot;baz&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async UniTask&lt;Sprite&gt; LoadAsSprite(string path)</span><br><span class="line">&#123;</span><br><span class="line">    var resource = await Resources.LoadAsync&lt;Sprite&gt;(path);</span><br><span class="line">    return (resource as Sprite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想转换一个回调逻辑块，让它变成UniTask的话，可以使用 <code>UniTaskCompletionSource&lt;T&gt;</code> （<code>TaskCompletionSource&lt;T&gt;</code>的轻量级魔改版）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public UniTask&lt;int&gt; WrapByUniTaskCompletionSource()</span><br><span class="line">&#123;</span><br><span class="line">    var utcs = new UniTaskCompletionSource&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">    // 当操作完成时，调用 utcs.TrySetResult();</span><br><span class="line">    // 当操作失败时, 调用 utcs.TrySetException();</span><br><span class="line">    // 当操作取消时, 调用 utcs.TrySetCanceled();</span><br><span class="line"></span><br><span class="line">    return utcs.Task; //本质上就是返回了一个UniTask&lt;int&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以进行如下转换</p><ul><li><code>Task</code> -&gt; <code>UniTask</code>: 使用<code>AsUniTask</code></li><li><code>UniTask</code> -&gt; <code>UniTask&lt;AsyncUnit&gt;</code>: 使用 <code>AsAsyncUnitUniTask</code></li><li><code>UniTask&lt;T&gt;</code> -&gt; <code>UniTask</code>: 使用 <code>AsUniTask</code>，这两者的转换是无消耗的</li></ul><p>如果你想将异步转换为协程，你可以使用<code>.ToCoroutine()</code>，如果你只想允许使用协程系统，这很有用。</p><p>UniTask 不能await两次。<a href="http://xn--jhq010dhp3a.net/">这是与.NET</a> Standard 2.1 中引入的<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask-1?view=netcore-3.1">ValueTask/IValueTaskSource</a>相同的约束。</p><blockquote><p>永远不应在 ValueTask 实例上执行以下操作：</p><ul><li>多次await实例。</li><li>多次调用 AsTask。</li><li>在操作尚未完成时调用 .Result 或 .GetAwaiter().GetResult()，多次调用也是不允许的。</li><li>混用上述行为更是不被允许的。</li></ul><p>如果您执行上述任何操作，则结果是未定义。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var task = UniTask.DelayFrame(10);</span><br><span class="line">await task;</span><br><span class="line">await task; // 寄了, 抛出异常</span><br></pre></td></tr></table></figure><p>如果实在需要多次await一个异步操作，可以使用<code>UniTask.Lazy</code>来支持多次调用。<code>.Preserve()</code>同样允许多次调用（由UniTask内部缓存的结果）。这种方法在函数范围内有多个调用时很有用。</p><p>同样的<code>UniTaskCompletionSource</code>可以在同一个地方被await多次，或者在很多不同的地方被await。</p><h2 id="Cancellation-and-Exception-handling"><a href="#Cancellation-and-Exception-handling" class="headerlink" title="Cancellation and Exception handling"></a>Cancellation and Exception handling</h2><p>一些 UniTask 工厂方法有一个<code>CancellationToken cancellationToken = default</code>参数。Unity 的一些异步操作也有<code>WithCancellation(CancellationToken)</code>和<code>ToUniTask(..., CancellationToken cancellation = default)</code>拓展方法。</p><p>可以传递原生<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource"><code>CancellationTokenSource</code></a>给参数CancellationToken</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var cts = new CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">cancelButton.onClick.AddListener(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    cts.Cancel();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">await UnityWebRequest.Get(&quot;http://google.co.jp&quot;).SendWebRequest().WithCancellation(cts.Token);</span><br><span class="line"></span><br><span class="line">await UniTask.DelayFrame(1000, cancellationToken: cts.Token);</span><br></pre></td></tr></table></figure><p>CancellationToken 可以由<code>CancellationTokenSource</code>或 MonoBehaviour 的<code>GetCancellationTokenOnDestroy</code>扩展方法创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 这个CancellationTokenSource和this GameObject生命周期相同，当this GameObject Destroy的时候，就会执行Cancel</span><br><span class="line">await UniTask.DelayFrame(1000, cancellationToken: this.GetCancellationTokenOnDestroy());</span><br></pre></td></tr></table></figure><p>对于链式取消，所有异步方法都建议最后一个参数接受<code>CancellationToken cancellationToken</code>，并将<code>CancellationToken</code>从头传递到尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">await FooAsync(this.GetCancellationTokenOnDestroy());</span><br><span class="line"></span><br><span class="line">// ---</span><br><span class="line"></span><br><span class="line">async UniTask FooAsync(CancellationToken cancellationToken)</span><br><span class="line">&#123;</span><br><span class="line">    await BarAsync(cancellationToken);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async UniTask BarAsync(CancellationToken cancellationToken)</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(3), cancellationToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CancellationToken</code>表示异步的生命周期。您可以使用自定义的生命周期，而不是默认的 CancellationTokenOnDestroy。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class MyBehaviour : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource disableCancellation = new CancellationTokenSource();</span><br><span class="line">    CancellationTokenSource destroyCancellation = new CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    private void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        if (disableCancellation != null)</span><br><span class="line">        &#123;</span><br><span class="line">            disableCancellation.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        disableCancellation = new CancellationTokenSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnDisable()</span><br><span class="line">    &#123;</span><br><span class="line">        disableCancellation.Cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">        destroyCancellation.Cancel();</span><br><span class="line">        destroyCancellation.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当检测到取消时，所有方法都会向上游抛出并传播<code>OperationCanceledException</code>。当异常（不限于<code>OperationCanceledException</code>）没有在异步方法中处理时，它将最终传播到<code>UniTaskScheduler.UnobservedTaskException</code>。接收到的未处理异常的默认行为是将日志写入异常。可以使用<code>UniTaskScheduler.UnobservedExceptionWriteLogType</code>更改日志级别。如果要使用自定义行为，请为<code>UniTaskScheduler.UnobservedTaskException.</code>设置一个委托</p><p>而<code>OperationCanceledException</code>是一个特殊的异常，会被<code>UnobservedTaskException</code>.无视</p><p>如果要取消异步 UniTask 方法中的行为，请手动抛出<code>OperationCanceledException</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTask&lt;int&gt; FooAsync()</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">    throw new OperationCanceledException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您处理异常但想忽略（传播到全局cancellation处理的地方），请使用异常过滤器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTask&lt;int&gt; BarAsync()</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        var x = await FooAsync();</span><br><span class="line">        return x * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex) when (!(ex is OperationCanceledException)) // when (ex is not OperationCanceledException) at C# 9.0</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws/catch<code>OperationCanceledException</code>有点重，所以如果性能是一个问题，请使用<code>UniTask.SuppressCancellationThrow</code>以避免 OperationCanceledException 抛出。它将返回<code>(bool IsCanceled, T Result)</code>而不是抛出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var (isCanceled, _) = await UniTask.DelayFrame(10, cancellationToken: cts.Token).SuppressCancellationThrow();</span><br><span class="line">if (isCanceled)</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：仅当您在原方法直接调用SuppressCancellationThrow时才会抑制异常抛出。否则，返回值将被转换，且整个管道不会抑制 throws。</p><h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><p>超时是取消的一种变体。您可以通过<code>CancellationTokenSouce.CancelAfterSlim(TimeSpan)</code>设置超时并将 CancellationToken 传递给异步方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var cts = new CancellationTokenSource();</span><br><span class="line">cts.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.</span><br><span class="line"></span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest().WithCancellation(cts.Token);</span><br><span class="line">&#125;</span><br><span class="line">catch (OperationCanceledException ex)</span><br><span class="line">&#123;</span><br><span class="line">    if (ex.CancellationToken == cts.Token)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(&quot;Timeout&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p><code>CancellationTokenSouce.CancelAfter</code>是一个原生的api。但是在 Unity 中你不应该使用它，因为它依赖于线程计时器。<code>CancelAfterSlim</code>是 UniTask 的扩展方法，它使用 PlayerLoop 代替。</p></blockquote><p>如果您想将超时与其他cancellation一起使用，请使用<code>CancellationTokenSource.CreateLinkedTokenSource</code>.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var cancelToken = new CancellationTokenSource();</span><br><span class="line">cancelButton.onClick.AddListener(()=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    cancelToken.Cancel(); // 点击按钮后取消</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var timeoutToken = new CancellationTokenSource();</span><br><span class="line">timeoutToken.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 设置5s超时</span><br><span class="line"></span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    // 链接token</span><br><span class="line">    var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken.Token, timeoutToken.Token);</span><br><span class="line"></span><br><span class="line">    await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest().WithCancellation(linkedTokenSource.Token);</span><br><span class="line">&#125;</span><br><span class="line">catch (OperationCanceledException ex)</span><br><span class="line">&#123;</span><br><span class="line">    if (timeoutToken.IsCancellationRequested)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(&quot;Timeout.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (cancelToken.IsCancellationRequested)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(&quot;Cancel clicked.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为优化减少每个调用异步方法超时的 CancellationTokenSource 分配，您可以使用 UniTask 的<code>TimeoutController</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">TimeoutController timeoutController = new TimeoutController(); // 复用timeoutController</span><br><span class="line"></span><br><span class="line">async UniTask FooAsync()</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        // 你可以通过 timeoutController.Timeout(TimeSpan) 传递到 cancellationToken.</span><br><span class="line">        await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest()</span><br><span class="line">            .WithCancellation(timeoutController.Timeout(TimeSpan.FromSeconds(5)));</span><br><span class="line">        timeoutController.Reset(); // 当await完成后调用Reset（停止超时计时器，并准备下一次复用）</span><br><span class="line">    &#125;</span><br><span class="line">    catch (OperationCanceledException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (timeoutController.IsTimeout())</span><br><span class="line">        &#123;</span><br><span class="line">            UnityEngine.Debug.Log(&quot;timeout&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想将超时与其他取消源一起使用，请使用<code>new TimeoutController(CancellationToken)</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">TimeoutController timeoutController;</span><br><span class="line">CancellationTokenSource clickCancelSource;</span><br><span class="line"></span><br><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">    this.clickCancelSource = new CancellationTokenSource();</span><br><span class="line">    this.timeoutController = new TimeoutController(clickCancelSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：UniTask 有<code>.Timeout</code>,<code>.TimeoutWithoutException</code>方法，但是，如果可能，不要使用这些，请通过<code>CancellationToken</code>. 由于<code>.Timeout</code>作用在task外部，无法停止超时任务。<code>.Timeout</code>表示超时时忽略结果。如果您将一个<code>CancellationToken</code>传递给该方法，它将从任务内部执行，因此可以停止正在运行的任务。</p><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>一些Unity的异步操作具有<code>ToUniTask(IProgress&lt;float&gt; progress = null, ...)</code>扩展方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var progress = Progress.Create&lt;float&gt;(x =&gt; Debug.Log(x));</span><br><span class="line"></span><br><span class="line">var request = await UnityWebRequest.Get(&quot;http://google.co.jp&quot;)</span><br><span class="line">    .SendWebRequest()</span><br><span class="line">    .ToUniTask(progress: progress);</span><br></pre></td></tr></table></figure><p>您不应该使用原生的<code>new System.Progress&lt;T&gt;</code>，因为它每次都会导致GC分配。改为使用<code>Cysharp.Threading.Tasks.Progress</code>。这个 progress factory 有两个方法，<code>Create</code>和<code>CreateOnlyValueChanged</code>. <code>CreateOnlyValueChanged</code>仅在进度值更新时调用。</p><p>为调用者实现 IProgress 接口会更好，因为这样可以没有 lambda 分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class Foo : MonoBehaviour, IProgress&lt;float&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void Report(float value)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public async UniTaskVoid WebRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        var request = await UnityWebRequest.Get(&quot;http://google.co.jp&quot;)</span><br><span class="line">            .SendWebRequest()</span><br><span class="line">            .ToUniTask(progress: this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PlayerLoop"><a href="#PlayerLoop" class="headerlink" title="PlayerLoop"></a>PlayerLoop</h2><p>UniTask 在自定义<a href="https://docs.unity3d.com/ScriptReference/LowLevel.PlayerLoop.html">PlayerLoop</a>上运行。UniTask 的基于 playerloop 的方法（例如<code>Delay</code>、<code>DelayFrame</code>、<code>asyncOperation.ToUniTask</code>等）接受这个<code>PlayerLoopTiming</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public enum PlayerLoopTiming</span><br><span class="line">&#123;</span><br><span class="line">    Initialization = 0,</span><br><span class="line">    LastInitialization = 1,</span><br><span class="line"></span><br><span class="line">    EarlyUpdate = 2,</span><br><span class="line">    LastEarlyUpdate = 3,</span><br><span class="line"></span><br><span class="line">    FixedUpdate = 4,</span><br><span class="line">    LastFixedUpdate = 5,</span><br><span class="line"></span><br><span class="line">    PreUpdate = 6,</span><br><span class="line">    LastPreUpdate = 7,</span><br><span class="line"></span><br><span class="line">    Update = 8,</span><br><span class="line">    LastUpdate = 9,</span><br><span class="line"></span><br><span class="line">    PreLateUpdate = 10,</span><br><span class="line">    LastPreLateUpdate = 11,</span><br><span class="line"></span><br><span class="line">    PostLateUpdate = 12,</span><br><span class="line">    LastPostLateUpdate = 13</span><br><span class="line">    </span><br><span class="line">#if UNITY_2020_2_OR_NEWER</span><br><span class="line">    TimeUpdate = 14,</span><br><span class="line">    LastTimeUpdate = 15,</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它表示何时运行，您可以检查<a href="https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae">PlayerLoopList.md</a>到 Unity 的默认 playerloop 并注入 UniTask 的自定义循环。</p><p><code>PlayerLoopTiming.Update</code>与协程中的<code>yield return null</code>类似，但在 Update(Update 和 uGUI 事件(button.onClick, etc…) 前被调用（在<code>ScriptRunBehaviourUpdate</code>时被调用），yield return null 在<code>ScriptRunDelayedDynamicFrameRate</code>时被调用。<code>PlayerLoopTiming.FixedUpdate</code>类似于<code>WaitForFixedUpdate</code>。</p><blockquote><p><code>PlayerLoopTiming.LastPostLateUpdate</code>不等同于协程的<code>yield return new WaitForEndOfFrame()</code>. 协程的 WaitForEndOfFrame 似乎在 PlayerLoop 完成后运行。一些需要协程结束帧(<code>Texture2D.ReadPixels</code>, <code>ScreenCapture.CaptureScreenshotAsTexture</code>, <code>CommandBuffer</code>, 等) 的方法在 async/await 时无法正常工作。在这些情况下，请将 MonoBehaviour(coroutine runner) 传递给<code>UniTask.WaitForEndOfFrame</code>. 例如，<code>await UniTask.WaitForEndOfFrame(this);</code>是<code>yield return new WaitForEndOfFrame()</code>轻量级0GC的替代方案。</p></blockquote><p><code>yield return null</code>和<code>UniTask.Yield</code>相似但不同。<code>yield return null</code>总是返回下一帧但<code>UniTask.Yield</code>返回下一个调用。也就是说，<code>UniTask.Yield(PlayerLoopTiming.Update)</code>在 <code>PreUpdate</code>上调用，它返回相同的帧。<code>UniTask.NextFrame()</code>保证返回下一帧，您可以认为它的行为与<code>yield return null</code>一致.</p><blockquote><p>UniTask.Yield(without CancellationToken) 是一种特殊类型，返回<code>YieldAwaitable</code>并在 YieldRunner 上运行。它是最轻量和最快的。</p></blockquote><p><code>AsyncOperation</code>在原生生命周期返回。例如，await <code>SceneManager.LoadSceneAsync</code>在<code>EarlyUpdate.UpdatePreloading</code>时返回，在此之后，加载的场景的<code>Start</code>方法调用自<code>EarlyUpdate.ScriptRunDelayedStartupFrame</code>。同样的，<code>await UnityWebRequest</code>在<code>EarlyUpdate.ExecuteMainThreadJobs</code>时返回.</p><p>在 UniTask 中，await 直接使用原生生命周期，<code>WithCancellation</code>和<code>ToUniTask</code>可以指定使用的原生生命周期。这通常不会有问题，但是<code>LoadSceneAsync</code>在等待之后，它会导致开始和继续的不同顺序。所以建议不要使用<code>LoadSceneAsync.ToUniTask</code>。</p><p>在堆栈跟踪中，您可以检查它在 playerloop 中的运行位置。</p><p><a href="https://user-images.githubusercontent.com/46207/83735571-83caea80-a68b-11ea-8d22-5e22864f0d24.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025464.png" alt="image"></a></p><p>默认情况下，UniTask 的 PlayerLoop 初始化在<code>[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]</code>.</p><p>在 BeforeSceneLoad 中调用方法的顺序是不确定的，所以如果你想在其他 BeforeSceneLoad 方法中使用 UniTask，你应该尝试在此之前初始化它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// AfterAssembliesLoaded 表示将会在 BeforeSceneLoad之前调用</span><br><span class="line">[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]</span><br><span class="line">public static void InitUniTaskLoop()</span><br><span class="line">&#123;</span><br><span class="line">    var loop = PlayerLoop.GetCurrentPlayerLoop();</span><br><span class="line">    Cysharp.Threading.Tasks.PlayerLoopHelper.Initialize(ref loop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您导入 Unity 的<code>Entities</code>包，则会将自定义playerloop重置为默认值<code>BeforeSceneLoad</code>并注入 ECS 的循环。当 Unity 在 UniTask 的 initialize 方法之后调用 ECS 的 inject 方法时，UniTask 将不再工作。</p><p>为了解决这个问题，您可以在 ECS 初始化后重新初始化 UniTask PlayerLoop。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 获取ECS Loop.</span><br><span class="line">var playerLoop = ScriptBehaviourUpdateOrder.CurrentPlayerLoop;</span><br><span class="line"></span><br><span class="line">// 设置UniTask PlayerLoop</span><br><span class="line">PlayerLoopHelper.Initialize(ref playerLoop);</span><br></pre></td></tr></table></figure><p>您可以通过调用<code>PlayerLoopHelper.IsInjectedUniTaskPlayerLoop()</code>来诊断 UniTask 的PlayerLoop是否准备就绪。并且<code>PlayerLoopHelper.DumpCurrentPlayerLoop</code>还会将所有当前PlayerLoop记录到控制台。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">    UnityEngine.Debug.Log(&quot;UniTaskPlayerLoop ready? &quot; + PlayerLoopHelper.IsInjectedUniTaskPlayerLoop());</span><br><span class="line">    PlayerLoopHelper.DumpCurrentPlayerLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以通过删除未使用的 PlayerLoopTiming 注入来稍微优化循环成本。您可以在初始化时调用<code>PlayerLoopHelper.Initialize(InjectPlayerLoopTimings)</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var loop = PlayerLoop.GetCurrentPlayerLoop();</span><br><span class="line">PlayerLoopHelper.Initialize(ref loop, InjectPlayerLoopTimings.Minimum); // 最小化 is Update | FixedUpdate | LastPostLateUpdate</span><br></pre></td></tr></table></figure><p><code>InjectPlayerLoopTimings</code>有三个预设，<code>All</code>，<code>Standard</code>（除 LastPostLateUpdate 外），<code>Minimum</code>（<code>Update | FixedUpdate | LastPostLateUpdate</code>）。默认为全部，您可以组合自定义注入时间，例如<code>InjectPlayerLoopTimings.Update | InjectPlayerLoopTimings.FixedUpdate | InjectPlayerLoopTimings.PreLateUpdate</code>.</p><p>使用未注入<code>PlayerLoopTiming</code>的<a href="https://github.com/dotnet/roslyn-analyzers/blob/master/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">Microsoft.CodeAnalysis.BannedApiAnalyzers</a>可能会出错。例如，您可以为<code>InjectPlayerLoopTimings.Minimum</code>设置<code>BannedSymbols.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TXT</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.Initialization; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastInitialization; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.EarlyUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastEarlyUpdate; Isn&#x27;t injected this PlayerLoop in this project.d</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastFixedUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreLateUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreLateUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.PostLateUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.TimeUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastTimeUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br></pre></td></tr></table></figure><p>您可以将<code>RS0030</code>严重性配置为错误。</p><p><a href="https://user-images.githubusercontent.com/46207/109150837-bb933880-77ac-11eb-85ba-4fd15819dbd0.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025420.png" alt="image"></a></p><p>image</p><h2 id="async-void-与-async-UniTaskVoid-对比"><a href="#async-void-与-async-UniTaskVoid-对比" class="headerlink" title="async void 与 async UniTaskVoid 对比"></a>async void 与 async UniTaskVoid 对比</h2><p><code>async void</code>是一个原生的 C# 任务系统，因此它不能在 UniTask 系统上运行。也最好不要使用它。<code>async UniTaskVoid</code>是<code>async UniTask</code>的轻量级版本，因为它没有等待完成并立即向<code>UniTaskScheduler.UnobservedTaskException</code>报告错误. 如果您不需要等待（即发即弃），那么使用<code>UniTaskVoid</code>会更好。不幸的是，要解除警告，您需要在尾部添加<code>Forget()</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTaskVoid FireAndForgetMethod()</span><br><span class="line">&#123;</span><br><span class="line">    // do anything...</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Caller()</span><br><span class="line">&#123;</span><br><span class="line">    FireAndForgetMethod().Forget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UniTask 也有<code>Forget</code>方法，类似<code>UniTaskVoid</code>且效果相同。但是如果你完全不需要使用<code>await</code>，<code>UniTaskVoid</code>会更高效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTask DoAsync()</span><br><span class="line">&#123;</span><br><span class="line">    // do anything...</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Caller()</span><br><span class="line">&#123;</span><br><span class="line">    DoAsync().Forget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用注册到事件的异步 lambda，请不要使用<code>async void</code>. 相反，您可以使用<code>UniTask.Action</code> 或 <code>UniTask.UnityAction</code>，两者都通过<code>async UniTaskVoid</code> lambda 创建委托。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">Action actEvent;</span><br><span class="line">UnityAction unityEvent; // UGUI特供</span><br><span class="line"></span><br><span class="line">// 这样是不好的: async void</span><br><span class="line">actEvent += async () =&gt; &#123; &#125;;</span><br><span class="line">unityEvent += async () =&gt; &#123; &#125;;</span><br><span class="line"></span><br><span class="line">// 这样是可以的: 通过lamada创建Action</span><br><span class="line">actEvent += UniTask.Action(async () =&gt; &#123; await UniTask.Yield(); &#125;);</span><br><span class="line">unityEvent += UniTask.UnityAction(async () =&gt; &#123; await UniTask.Yield(); &#125;);</span><br></pre></td></tr></table></figure><p><code>UniTaskVoid</code>也可以用在 MonoBehaviour 的<code>Start</code>方法中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">class Sample : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    async UniTaskVoid Start()</span><br><span class="line">    &#123;</span><br><span class="line">        // async init code.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UniTaskTracker"><a href="#UniTaskTracker" class="headerlink" title="UniTaskTracker"></a>UniTaskTracker</h2><p>对于检查（泄露的）UniTasks 很有用。您可以在<code>Window -&gt; UniTask Tracker</code>中打开跟踪器窗口。</p><p><a href="https://user-images.githubusercontent.com/46207/83527073-4434bf00-a522-11ea-86e9-3b3975b26266.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025674.png" alt="image"></a></p><ul><li>Enable AutoReload(Toggle) - 自动重新加载。</li><li>Reload - 重新加载视图（重新扫描内存中UniTask实例，并刷新界面）。</li><li>GC.Collect - 调用 GC.Collect。</li><li>Enable Tracking(Toggle) - 开始跟踪异步/等待 UniTask。性能影响：低。</li><li>Enable StackTrace(Toggle) - 在任务启动时捕获 StackTrace。性能影响：高。</li></ul><p>UniTaskTracker 仅用于调试用途，因为启用跟踪和捕获堆栈跟踪很有用，但会对性能产生重大影响。推荐的用法是启用跟踪和堆栈跟踪以查找任务泄漏并在完成时禁用它们。</p><h2 id="外部拓展"><a href="#外部拓展" class="headerlink" title="外部拓展"></a>外部拓展</h2><p>默认情况下，UniTask 支持 TextMeshPro（<code>BindTo(TMP_Text)</code>和<code>TMP_InputField</code>，并且TMP_InputField有同原生uGUI <code>InputField</code>类似的事件扩展）、DOTween（<code>Tween</code>作为等待）和Addressables（<code>AsyncOperationHandle``AsyncOperationHandle&lt;T&gt;</code>作为等待）。</p><p>在单独的 asmdef 中定义，如<code>UniTask.TextMeshPro</code>, <code>UniTask.DOTween</code>, <code>UniTask.Addressables</code>.</p><p>从包管理器导入包时，会自动启用 TextMeshPro 和 Addressables 支持。但是对于 DOTween 支持，需要<code>com.demigiant.dotween</code>从<a href="https://openupm.com/packages/com.demigiant.dotween/">OpenUPM</a>导入或定义<code>UNITASK_DOTWEEN_SUPPORT</code>以启用它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 动画序列</span><br><span class="line">await transform.DOMoveX(2, 10);</span><br><span class="line">await transform.DOMoveZ(5, 20);</span><br><span class="line"></span><br><span class="line">// 并行，并传递cancellation用于取消</span><br><span class="line">var ct = this.GetCancellationTokenOnDestroy();</span><br><span class="line"></span><br><span class="line">await UniTask.WhenAll(</span><br><span class="line">    transform.DOMoveX(10, 3).WithCancellation(ct),</span><br><span class="line">    transform.DOScale(10, 3).WithCancellation(ct));</span><br></pre></td></tr></table></figure><p>DOTween 支持的默认行为( <code>await</code>, <code>WithCancellation</code>, <code>ToUniTask</code>) await tween 被终止。它适用于 Complete(true/false) 和 Kill(true/false)。但是如果你想重用tweens ( <code>SetAutoKill(false)</code>)，它就不能按预期工作。如果您想等待另一个时间点，Tween 中存在以下扩展方法，<code>AwaitForComplete</code>, <code>AwaitForPause</code>, <code>AwaitForPlay</code>, <code>AwaitForRewind</code>, <code>AwaitForStepComplete</code>。</p><h2 id="AsyncEnumerable-和-Async-LINQ"><a href="#AsyncEnumerable-和-Async-LINQ" class="headerlink" title="AsyncEnumerable 和 Async LINQ"></a>AsyncEnumerable 和 Async LINQ</h2><p>Unity 2020.2 支持 C# 8.0，因此您可以使用<code>await foreach</code>. 这是异步时代的新更新符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// Unity 2020.2, C# 8.0</span><br><span class="line">await foreach (var _ in UniTaskAsyncEnumerable.EveryUpdate(token))</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(&quot;Update() &quot; + Time.frameCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C# 7.3 环境中，您可以使用该<code>ForEachAsync</code>方法以几乎相同的方式工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// C# 7.3(Unity 2018.3~)</span><br><span class="line">await UniTaskAsyncEnumerable.EveryUpdate(token).ForEachAsync(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(&quot;Update() &quot; + Time.frameCount);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>UniTaskAsyncEnumerable 实现异步 LINQ，类似于 LINQ 的<code>IEnumerable&lt;T&gt;</code>或 Rx 的 <code>IObservable&lt;T&gt;</code>。所有标准 LINQ 查询运算符都可以应用于异步流。例如，以下代码表示如何将 Where 过滤器应用于每两次单击运行一次的按钮单击异步流。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">await okButton.OnClickAsAsyncEnumerable().Where((x, i) =&gt; i % 2 == 0).ForEachAsync(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Fire and Forget 风格（例如，事件处理），你也可以使用<code>Subscribe</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">okButton.OnClickAsAsyncEnumerable().Where((x, i) =&gt; i % 2 == 0).Subscribe(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Async LINQ 在 时启用<code>using Cysharp.Threading.Tasks.Linq;</code>，并且<code>UniTaskAsyncEnumerable</code>在<code>UniTask.Linq</code>asmdef 中定义。</p><p>它更接近 UniRx（Reactive Extensions），但 UniTaskAsyncEnumerable 是pull-base的异步流，而 Rx 是基于push-base异步流。请注意，尽管相似，但特征不同，并且细节的行为也随之不同。</p><p><code>UniTaskAsyncEnumerable</code>是类似的入口点<code>Enumerable</code>。除了标准查询运算符之外，还有其他 Unity 生成器，例如<code>EveryUpdate</code>、<code>Timer</code>、<code>TimerFrame</code>、<code>Interval</code>、<code>IntervalFrame</code>和<code>EveryValueChanged</code>。并且还添加了额外的 UniTask 原始查询运算符，如<code>Append</code>, <code>Prepend</code>, <code>DistinctUntilChanged</code>, <code>ToHashSet</code>, <code>Buffer</code>, <code>CombineLatest</code>, <code>Do</code>, <code>Never</code>, <code>ForEachAsync</code>, <code>Pairwise</code>, <code>Publish</code>, <code>Queue</code>, <code>Return</code>, <code>SkipUntil</code>, <code>TakeUntil</code>, <code>SkipUntilCanceled</code>, <code>TakeUntilCanceled</code>, <code>TakeLast</code>, <code>Subscribe</code>。</p><p>以 Func 作为参数的方法具有三个额外的重载，<code>***Await</code>, <code>***AwaitWithCancellation</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">Select(Func&lt;T, TR&gt; selector)</span><br><span class="line">SelectAwait(Func&lt;T, UniTask&lt;TR&gt;&gt; selector)</span><br><span class="line">SelectAwaitWithCancellation(Func&lt;T, CancellationToken, UniTask&lt;TR&gt;&gt; selector)</span><br></pre></td></tr></table></figure><p>如果在 func 方法内部使用<code>async</code>，请使用<strong><em>Awaitor `</em></strong>AwaitWithCancellation`。</p><p>如何创建异步迭代器：C# 8.0 支持异步迭代器（<code>async yield return</code>），但它只允许<code>IAsyncEnumerable&lt;T&gt;</code>并且当然需要 C# 8.0。UniTask 支持<code>UniTaskAsyncEnumerable.Create</code>创建自定义异步迭代器的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// IAsyncEnumerable, C# 8.0 异步迭代器. ( 不要这样用，因为IAsyncEnumerable不被UniTask控制).</span><br><span class="line">public async IAsyncEnumerable&lt;int&gt; MyEveryUpdate([EnumeratorCancellation]CancellationToken cancelationToken = default)</span><br><span class="line">&#123;</span><br><span class="line">    var frameCount = 0;</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">    while (!token.IsCancellationRequested)</span><br><span class="line">    &#123;</span><br><span class="line">        yield return frameCount++;</span><br><span class="line">        await UniTask.Yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UniTaskAsyncEnumerable.Create 并用 `await writer.YieldAsync` 代替 `yield return`.</span><br><span class="line">public IUniTaskAsyncEnumerable&lt;int&gt; MyEveryUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    // writer(IAsyncWriter&lt;T&gt;) has `YieldAsync(value)` method.</span><br><span class="line">    return UniTaskAsyncEnumerable.Create&lt;int&gt;(async (writer, token) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        var frameCount = 0;</span><br><span class="line">        await UniTask.Yield();</span><br><span class="line">        while (!token.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            await writer.YieldAsync(frameCount++); // instead of `yield return`</span><br><span class="line">            await UniTask.Yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可等待事件"><a href="#可等待事件" class="headerlink" title="可等待事件"></a>可等待事件</h2><p>所有 uGUI 组件都实现<code>***AsAsyncEnumerable</code>了异步事件流的转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">async UniTask TripleClick()</span><br><span class="line">&#123;</span><br><span class="line">    // 默认情况下，使用了button.GetCancellationTokenOnDestroy 来管理异步生命周期</span><br><span class="line">    await button.OnClickAsync();</span><br><span class="line">    await button.OnClickAsync();</span><br><span class="line">    await button.OnClickAsync();</span><br><span class="line">    Debug.Log(&quot;Three times clicked&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更高效的方法</span><br><span class="line">async UniTask TripleClick()</span><br><span class="line">&#123;</span><br><span class="line">    using (var handler = button.GetAsyncClickEventHandler())</span><br><span class="line">    &#123;</span><br><span class="line">        await handler.OnClickAsync();</span><br><span class="line">        await handler.OnClickAsync();</span><br><span class="line">        await handler.OnClickAsync();</span><br><span class="line">        Debug.Log(&quot;Three times clicked&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用异步LINQ</span><br><span class="line">async UniTask TripleClick(CancellationToken token)</span><br><span class="line">&#123;</span><br><span class="line">    await button.OnClickAsAsyncEnumerable().Take(3).Last();</span><br><span class="line">    Debug.Log(&quot;Three times clicked&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用异步LINQ</span><br><span class="line">async UniTask TripleClick(CancellationToken token)</span><br><span class="line">&#123;</span><br><span class="line">    await button.OnClickAsAsyncEnumerable().Take(3).ForEachAsync(_ =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Every clicked&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Debug.Log(&quot;Three times clicked, complete.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有 MonoBehaviour 消息事件都可以转换异步流<code>AsyncTriggers</code>，可以通过<code>using Cysharp.Threading.Tasks.Triggers;</code>进行启用，.AsyncTrigger 可以使用 UniTaskAsyncEnumerable 来创建，通过<code>GetAsync***Trigger</code>触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var trigger = this.GetOnCollisionEnterAsyncHandler();</span><br><span class="line">await trigger.OnCollisionEnterAsync();</span><br><span class="line">await trigger.OnCollisionEnterAsync();</span><br><span class="line">await trigger.OnCollisionEnterAsync();</span><br><span class="line"></span><br><span class="line">// every moves.</span><br><span class="line">await this.GetAsyncMoveTrigger().ForEachAsync(axisEventData =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>AsyncReactiveProperty</code>,<code>AsyncReadOnlyReactiveProperty</code>是 UniTask 的 ReactiveProperty 版本。将异步流值绑定到 Unity 组件（Text/Selectable/TMP/Text）<code>BindTo</code>的<code>IUniTaskAsyncEnumerable&lt;T&gt;</code>扩展方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var rp = new AsyncReactiveProperty&lt;int&gt;(99);</span><br><span class="line"></span><br><span class="line">// AsyncReactiveProperty 本身是 IUniTaskAsyncEnumerable, 可以通过LINQ进行查询</span><br><span class="line">rp.ForEachAsync(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(x);</span><br><span class="line">&#125;, this.GetCancellationTokenOnDestroy()).Forget();</span><br><span class="line"></span><br><span class="line">rp.Value = 10; // 推送10给所有订阅者</span><br><span class="line">rp.Value = 11; // 推送11给所有订阅者</span><br><span class="line"></span><br><span class="line">// WithoutCurrent 忽略初始值</span><br><span class="line">// BindTo 绑定 stream value 到 unity 组件.</span><br><span class="line">rp.WithoutCurrent().BindTo(this.textComponent);</span><br><span class="line"></span><br><span class="line">await rp.WaitAsync(); // 一直等待，直到下一个值被设置</span><br><span class="line"></span><br><span class="line">// 同样支持ToReadOnlyAsyncReactiveProperty</span><br><span class="line">var rp2 = new AsyncReactiveProperty&lt;int&gt;(99);</span><br><span class="line">var rorp = rp.CombineLatest(rp2, (x, y) =&gt; (x, y)).ToReadOnlyAsyncReactiveProperty(CancellationToken.None);</span><br></pre></td></tr></table></figure><p>在序列中的异步处理完成之前，pull-based异步流不会获取下一个值。这可能会从按钮等推送类型的事件中溢出数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 在3s完成前，无法获取event</span><br><span class="line">await button.OnClickAsAsyncEnumerable().ForEachAwaitAsync(async x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(3));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它很有用（防止双击），但有时没用。</p><p>使用该<code>Queue()</code>方法还将在异步处理期间对事件进行排队。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 异步处理中对message进行排队</span><br><span class="line">await button.OnClickAsAsyncEnumerable().Queue().ForEachAwaitAsync(async x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(3));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或使用<code>Subscribe</code>, fire and forget 风格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">button.OnClickAsAsyncEnumerable().Subscribe(async x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(3));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><code>Channel</code>与<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.channels?view=netcore-3.1">System.Threading.Tasks.Channels</a>相同，类似于 GoLang Channel。</p><p>目前只支持多生产者、单消费者无界渠道。它可以由<code>Channel.CreateSingleConsumerUnbounded&lt;T&gt;()</code>.</p><p>对于 producer(<code>.Writer</code>)，用<code>TryWrite</code>推送值和<code>TryComplete</code>完成通道。对于 consumer(<code>.Reader</code>)，使用<code>TryRead</code>、<code>WaitToReadAsync</code>、<code>ReadAsync</code>和<code>Completion</code>，<code>ReadAllAsync</code>来读取队列的消息。</p><p><code>ReadAllAsync</code>返回<code>IUniTaskAsyncEnumerable&lt;T&gt;</code> 查询 LINQ 运算符。Reader 只允许单消费者，但使用<code>.Publish()</code>查询运算符来启用多播消息。例如，制作 pub/sub 实用程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class AsyncMessageBroker&lt;T&gt; : IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    Channel&lt;T&gt; channel;</span><br><span class="line"></span><br><span class="line">    IConnectableUniTaskAsyncEnumerable&lt;T&gt; multicastSource;</span><br><span class="line">    IDisposable connection;</span><br><span class="line"></span><br><span class="line">    public AsyncMessageBroker()</span><br><span class="line">    &#123;</span><br><span class="line">        channel = Channel.CreateSingleConsumerUnbounded&lt;T&gt;();</span><br><span class="line">        multicastSource = channel.Reader.ReadAllAsync().Publish();</span><br><span class="line">        connection = multicastSource.Connect(); // Publish returns IConnectableUniTaskAsyncEnumerable.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Publish(T value)</span><br><span class="line">    &#123;</span><br><span class="line">        channel.Writer.TryWrite(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IUniTaskAsyncEnumerable&lt;T&gt; Subscribe()</span><br><span class="line">    &#123;</span><br><span class="line">        return multicastSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Dispose()</span><br><span class="line">    &#123;</span><br><span class="line">        channel.Writer.TryComplete();</span><br><span class="line">        connection.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Unity 的<code>[UnityTest]</code>属性可以测试协程（IEnumerator）但不能测试异步。<code>UniTask.ToCoroutine</code>将 async/await 桥接到协程，以便您可以测试异步方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">[UnityTest]</span><br><span class="line">public IEnumerator DelayIgnore() =&gt; UniTask.ToCoroutine(async () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var time = Time.realtimeSinceStartup;</span><br><span class="line"></span><br><span class="line">    Time.timeScale = 0.5f;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        await UniTask.Delay(TimeSpan.FromSeconds(3), ignoreTimeScale: true);</span><br><span class="line"></span><br><span class="line">        var elapsed = Time.realtimeSinceStartup - time;</span><br><span class="line">        Assert.AreEqual(3, (int)Math.Round(TimeSpan.FromSeconds(elapsed).TotalSeconds, MidpointRounding.ToEven));</span><br><span class="line">    &#125;</span><br><span class="line">    finally</span><br><span class="line">    &#123;</span><br><span class="line">        Time.timeScale = 1.0f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>UniTask 自己的单元测试是使用 Unity Test Runner 和<a href="https://github.com/Cysharp/RuntimeUnitTestToolkit">Cysharp/RuntimeUnitTestToolkit</a>编写的，以与 CI 集成并检查 IL2CPP 是否正常工作。</p><h2 id="线程池限制"><a href="#线程池限制" class="headerlink" title="线程池限制"></a>线程池限制</h2><p>大多数 UniTask 方法在单个线程 (PlayerLoop) 上运行，只有<code>UniTask.Run</code>（<code>Task.Run</code>等效）和<code>UniTask.SwitchToThreadPool</code>在线程池上运行。如果您使用线程池，它将无法与 WebGL 等平台兼容。</p><p><code>UniTask.Run</code>现在已弃用。你可以改用<code>UniTask.RunOnThreadPool</code>。并且还要考虑是否可以使用<code>UniTask.Create</code>或<code>UniTask.Void</code>。</p><h2 id="IEnumerator-ToUniTask-限制"><a href="#IEnumerator-ToUniTask-限制" class="headerlink" title="IEnumerator.ToUniTask 限制"></a>IEnumerator.ToUniTask 限制</h2><p>您可以将协程（IEnumerator）转换为 UniTask（或直接等待），但它有一些限制。</p><ul><li>不支持<code>WaitForEndOfFrame</code>，<code>WaitForFixedUpdate</code>，<code>Coroutine</code></li><li>Loop生命周期与<code>StartCoroutine</code>不一样，它使用指定<code>PlayerLoopTiming</code>的并且默认情况下，<code>PlayerLoopTiming.Update</code>在 MonoBehaviour<code>Update</code>和<code>StartCoroutine</code>的循环之前运行。</li></ul><p>如果您想要从协程到异步的完全兼容转换，请使用<code>IEnumerator.ToUniTask(MonoBehaviour coroutineRunner)</code>重载。它在参数 MonoBehaviour 的实例上执行 StartCoroutine 并等待它在 UniTask 中完成。</p><h2 id="关于UnityEditor"><a href="#关于UnityEditor" class="headerlink" title="关于UnityEditor"></a>关于UnityEditor</h2><p>UniTask 可以像编辑器协程一样在 Unity 编辑器上运行。但是，有一些限制。</p><ul><li>UniTask.Delay 的 DelayType.DeltaTime、UnscaledDeltaTime 无法正常工作，因为它们无法在编辑器中获取 deltaTime。因此在 EditMode 上运行，会自动将 DelayType 更改为<code>DelayType.Realtime</code>等待正确的时间。</li><li>所有 PlayerLoopTiming 都在<code>EditorApplication.update</code>生命周期上运行。</li><li>带<code>-quit</code>的<code>-batchmode</code>带不起作用，因为 Unity<code>EditorApplication.update</code>在单帧后不会运行并退出。相反，不要使用<code>-quit</code>并手动退出<code>EditorApplication.Exit(0)</code>.</li></ul><h2 id="与原生Task-API对比"><a href="#与原生Task-API对比" class="headerlink" title="与原生Task API对比"></a>与原生Task API对比</h2><p>UniTask 有许多原生的 Task-like API。此表显示了一一对应的 API 是什么。</p><p>使用原生类型。</p><div class="table-container"><table><thead><tr><th>.NET Type</th><th>UniTask Type</th></tr></thead><tbody><tr><td><code>IProgress&lt;T&gt;</code></td><td>—</td></tr><tr><td><code>CancellationToken</code></td><td>—</td></tr><tr><td><code>CancellationTokenSource</code></td><td>—</td></tr></tbody></table></div><p>使用 UniTask 类型.</p><div class="table-container"><table><thead><tr><th>.NET Type</th><th>UniTask Type</th></tr></thead><tbody><tr><td><code>Task</code>/<code>ValueTask</code></td><td><code>UniTask</code></td></tr><tr><td><code>Task&lt;T&gt;</code>/<code>ValueTask&lt;T&gt;</code></td><td><code>UniTask&lt;T&gt;</code></td></tr><tr><td><code>async void</code></td><td><code>async UniTaskVoid</code></td></tr><tr><td><code>+= async () =&gt; &#123; &#125;</code></td><td><code>UniTask.Void</code>, <code>UniTask.Action</code>, <code>UniTask.UnityAction</code></td></tr><tr><td>—</td><td><code>UniTaskCompletionSource</code></td></tr><tr><td><code>TaskCompletionSource&lt;T&gt;</code></td><td><code>UniTaskCompletionSource&lt;T&gt;</code>/<code>AutoResetUniTaskCompletionSource&lt;T&gt;</code></td></tr><tr><td><code>ManualResetValueTaskSourceCore&lt;T&gt;</code></td><td><code>UniTaskCompletionSourceCore&lt;T&gt;</code></td></tr><tr><td><code>IValueTaskSource</code></td><td><code>IUniTaskSource</code></td></tr><tr><td><code>IValueTaskSource&lt;T&gt;</code></td><td><code>IUniTaskSource&lt;T&gt;</code></td></tr><tr><td><code>ValueTask.IsCompleted</code></td><td><code>UniTask.Status.IsCompleted()</code></td></tr><tr><td><code>ValueTask&lt;T&gt;.IsCompleted</code></td><td><code>UniTask&lt;T&gt;.Status.IsCompleted()</code></td></tr><tr><td><code>new Progress&lt;T&gt;</code></td><td><code>Progress.Create&lt;T&gt;</code></td></tr><tr><td><code>CancellationToken.Register(UnsafeRegister)</code></td><td><code>CancellationToken.RegisterWithoutCaptureExecutionContext</code></td></tr><tr><td><code>CancellationTokenSource.CancelAfter</code></td><td><code>CancellationTokenSource.CancelAfterSlim</code></td></tr><tr><td><code>Channel.CreateUnbounded&lt;T&gt;(false)&#123; SingleReader = true &#125;</code></td><td><code>Channel.CreateSingleConsumerUnbounded&lt;T&gt;</code></td></tr><tr><td><code>IAsyncEnumerable&lt;T&gt;</code></td><td><code>IUniTaskAsyncEnumerable&lt;T&gt;</code></td></tr><tr><td><code>IAsyncEnumerator&lt;T&gt;</code></td><td><code>IUniTaskAsyncEnumerator&lt;T&gt;</code></td></tr><tr><td><code>IAsyncDisposable</code></td><td><code>IUniTaskAsyncDisposable</code></td></tr><tr><td><code>Task.Delay</code></td><td><code>UniTask.Delay</code></td></tr><tr><td><code>Task.Yield</code></td><td><code>UniTask.Yield</code></td></tr><tr><td><code>Task.Run</code></td><td><code>UniTask.RunOnThreadPool</code></td></tr><tr><td><code>Task.WhenAll</code></td><td><code>UniTask.WhenAll</code></td></tr><tr><td><code>Task.WhenAny</code></td><td><code>UniTask.WhenAny</code></td></tr><tr><td><code>Task.CompletedTask</code></td><td><code>UniTask.CompletedTask</code></td></tr><tr><td><code>Task.FromException</code></td><td><code>UniTask.FromException</code></td></tr><tr><td><code>Task.FromResult</code></td><td><code>UniTask.FromResult</code></td></tr><tr><td><code>Task.FromCanceled</code></td><td><code>UniTask.FromCanceled</code></td></tr><tr><td><code>Task.ContinueWith</code></td><td><code>UniTask.ContinueWith</code></td></tr><tr><td><code>TaskScheduler.UnobservedTaskException</code></td><td><code>UniTaskScheduler.UnobservedTaskException</code></td></tr></tbody></table></div><h2 id="池化配置"><a href="#池化配置" class="headerlink" title="池化配置"></a>池化配置</h2><p>UniTask 积极缓存异步promise对象以实现零分配（有关技术细节，请参阅博客文章<a href="https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd">UniTask v2 — Unity 的零分配异步/等待，使用异步 LINQ</a>）。默认情况下，它缓存所有promise ，但您可以配置<code>TaskPool.SetMaxPoolSize</code>为您的值，该值表示每种类型的缓存大小。<code>TaskPool.GetCacheSizeInfo</code>返回池中当前缓存的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">foreach (var (type, size) in TaskPool.GetCacheSizeInfo())</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(type + &quot;:&quot; + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Profiler下的分配"><a href="#Profiler下的分配" class="headerlink" title="Profiler下的分配"></a>Profiler下的分配</h2><p>在 UnityEditor 中，分析器显示编译器生成的 AsyncStateMachine 的分配，但它只发生在调试（开发）构建中。C# 编译器将 AsyncStateMachine 生成为 Debug 构建的类和 Release 构建的结构。</p><p>Unity 从 2020.1 开始支持代码优化选项（右，页脚）。</p><p><a href="https://user-images.githubusercontent.com/46207/89967342-2f944600-dc8c-11ea-99fc-0b74527a16f6.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025362.png" alt="img"></a></p><p>您可以将 C# 编译器优化更改为 release 以删除开发版本中的 AsyncStateMachine 分配。此优化选项也可以通过设置<code>Compilation.CompilationPipeline-codeOptimization</code>和<code>Compilation.CodeOptimization</code>。</p><h2 id="UniTaskSynchronizationContext"><a href="#UniTaskSynchronizationContext" class="headerlink" title="UniTaskSynchronizationContext"></a>UniTaskSynchronizationContext</h2><p>Unity 的默认 SynchronizationContext( <code>UnitySynchronizationContext</code>) 在性能方面表现不佳。UniTask 绕过<code>SynchronizationContext</code>(和<code>ExecutionContext</code>) 因此它不使用它，但如果存在<code>async Task</code>，则仍然使用它。<code>UniTaskSynchronizationContext</code>是<code>UnitySynchronizationContext</code>性能更好的替代品。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class SyncContextInjecter</span><br><span class="line">&#123;</span><br><span class="line">    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]</span><br><span class="line">    public static void Inject()</span><br><span class="line">    &#123;</span><br><span class="line">        SynchronizationContext.SetSynchronizationContext(new UniTaskSynchronizationContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个可选的选择，并不总是推荐；<code>UniTaskSynchronizationContext</code>性能不如<code>async UniTask</code>，并且不是完整的 UniTask 替代品。它也不保证与<code>UnitySynchronizationContext</code>完全兼容</p><h2 id="API-References"><a href="#API-References" class="headerlink" title="API References"></a>API References</h2><p>UniTask 的 API 参考由<a href="https://dotnet.github.io/docfx/">DocFX</a>和<a href="https://github.com/Cysharp/DocfxTemplate">Cysharp/DocfXTemplate托管在</a><a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.html">cysharp.github.io/UniTask</a>上。</p><p>例如，UniTask 的工厂方法可以在<a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.UniTask.html#methods-1">UniTask#methods</a>中看到。UniTaskAsyncEnumerable 的工厂/扩展方法可以在<a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable.html#methods-1">UniTaskAsyncEnumerable#methods</a>中看到。</p><h2 id="UPM-Package"><a href="#UPM-Package" class="headerlink" title="UPM Package"></a>UPM Package</h2><h3 id="通过-git-URL-安装"><a href="#通过-git-URL-安装" class="headerlink" title="通过 git URL 安装"></a>通过 git URL 安装</h3><p>需要支持 git 包路径查询参数的 unity 版本（Unity &gt;= 2019.3.4f1，Unity &gt;= 2020.1a21）。您可以添加<code>https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask</code>到包管理器</p><p><strong><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025718.png" alt="img"></strong></p><p><a href="https://user-images.githubusercontent.com/46207/83702872-e0f17c80-a648-11ea-8183-7469dcd4f810.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025621.png" alt="image"></a></p><p>或添加<code>&quot;com.cysharp.unitask&quot;: &quot;https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask&quot;</code>到<code>Packages/manifest.json</code>.</p><p>如果要设置目标版本，UniTask 使用<code>*.*.*</code>发布标签，因此您可以指定一个版本，如<code>#2.1.0</code>. 例如<code>https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask#2.1.0</code>.</p><h3 id="通过-OpenUPM-安装"><a href="#通过-OpenUPM-安装" class="headerlink" title="通过 OpenUPM 安装"></a>通过 OpenUPM 安装</h3><p>该软件包在<a href="https://openupm.com/">openupm 注册表</a>中可用。建议通过<a href="https://github.com/openupm/openupm-cli">openupm-cli</a>安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CODE</span><br><span class="line">openupm add com.cysharp.unitask</span><br></pre></td></tr></table></figure><h2 id="NET-Core"><a href="#NET-Core" class="headerlink" title=".NET Core"></a>.NET Core</h2><p>对于 .NET Core，请使用 NuGet。</p><blockquote><p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/UniTask">UniTask</a></p></blockquote><p>.NET Core 版本的 UniTask 是 Unity UniTask 的子集，移除了 PlayerLoop 依赖的方法。</p><p>它以比标准 Task/ValueTask 更高的性能运行，但在使用时应注意忽略 ExecutionContext/SynchronizationContext。<code>AysncLocal</code>也不起作用，因为它忽略了 ExecutionContext。</p><p>如果您在内部使用 UniTask，但将 ValueTask 作为外部 API 提供，您可以编写如下（受<a href="https://github.com/mgravell/PooledAwait">PooledAwait</a>启发）代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class ZeroAllocAsyncAwaitInDotNetCore</span><br><span class="line">&#123;</span><br><span class="line">    public ValueTask&lt;int&gt; DoAsync(int x, int y)</span><br><span class="line">    &#123;</span><br><span class="line">        return Core(this, x, y);</span><br><span class="line"></span><br><span class="line">        static async UniTask&lt;int&gt; Core(ZeroAllocAsyncAwaitInDotNetCore self, int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            // do anything...</span><br><span class="line">            await Task.Delay(TimeSpan.FromSeconds(x + y));</span><br><span class="line">            await UniTask.Yield();</span><br><span class="line"></span><br><span class="line">            return 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UniTask 不会返回到原生 SynchronizationContext，但可以使用 `ReturnToCurrentSynchronizationContext`来让他返回</span><br><span class="line">public ValueTask TestAsync()</span><br><span class="line">&#123;</span><br><span class="line">    await using (UniTask.ReturnToCurrentSynchronizationContext())</span><br><span class="line">    &#123;</span><br><span class="line">        await UniTask.SwitchToThreadPool();</span><br><span class="line">        // do anything..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.NET Core 版本允许用户在与Unity共享代码时（例如<a href="https://github.com/Cysharp/MagicOnion/">CysharpOnion</a>），像使用接口一样使用UniTask。.NET Core 版本的 UniTask 可以提供丝滑的代码共享体验。</p><p>WhenAll 等实用方法作为 UniTask 的补充，由<a href="https://github.com/Cysharp/ValueTaskSupplement">Cysharp/ValueTaskSupplement</a>提供。</p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>此仓库基于MIT协议</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-网络开发（一）</title>
      <link href="/posts/c7963808.html"/>
      <url>/posts/c7963808.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络基本概念"><a href="#网络基本概念" class="headerlink" title="网络基本概念"></a>网络基本概念</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络的作用"><a href="#网络的作用" class="headerlink" title="网络的作用"></a>网络的作用</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108375.png" alt="image-20220516152347078"></p><p>在没有网络之前，每个人的设备（电脑等）都是彼此孤立的，网络的出现让设备之间可以相互通信</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108998.png" alt="image-20220516152329903"></p><p>网络是由若干设备和连接这些设备的链路构成，各种设备 间接或者直接通过介质相连</p><p>设备之间想要进行信息传递时，将想要传递的数据编码为2进制数值便可以被有效的传输。这些数据是以电脉冲的形式进行传输的</p><p>线缆中的电压是在高低状态之间进行变化的，因而</p><p>二进制中1是通过产生一个正电压来传输的，二进制中0是通过产生一个负电压来传输的</p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108704.png" alt="image-20220516165921984"></p><p>局域网（Local Area Network，简称LAN）</p><p>是按照范围划分而来的名称，是指在某一个小区域内由多台设备互联成的计算机组，可以是家里的两台设备组成</p><p>也可以是学校、公司里的上千台设备组成，特点是分布地区范围有限，覆盖范围一般是方圆几千米之内</p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>以太网是一种计算机局域网技术，是目前应用最普遍的局域网技术</p><p>IEEE组织（电气与电子工程师协会）的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容</p><p>说人话：</p><p>局域网中设备的连接规范，数据的传输规范等等规则，都是基于以太网的技术标准来完成的</p><p>所以，简单理解以太网就是网络连接的一种规则（协议）</p><h3 id="以太网-网络拓扑结构"><a href="#以太网-网络拓扑结构" class="headerlink" title="以太网 网络拓扑结构"></a>以太网 网络拓扑结构</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108930.png" alt="image-20220516165946400"></p><p>概念：</p><p>用传输媒体把计算机等各种设备互相连接起来的物理布局，是指设备互连过程中构成的几何形状</p><h3 id="局域网-1"><a href="#局域网-1" class="headerlink" title="局域网"></a>局域网</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108975.png" alt="image-20220516160851306"></p><p>城域网（Metropolitan Area Network，简称MAN）</p><p>是在一个城市范围内所建立的网络通常覆盖一个城市，从几十公里到一百公里不等，可能会有多种介质用户的数量也比局域网更多</p><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108468.png" alt="image-20220516160917725"></p><p>广域网（Wide Area Network，简称WAN）</p><p>又称外网、公网，是连接不同地区局域网或城域网设备通信的远程网，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，形成国际性的远程网络</p><p>注意：广域网并不等同于互联网</p><h3 id="互联网（因特网）"><a href="#互联网（因特网）" class="headerlink" title="互联网（因特网）"></a>互联网（因特网）</h3><p>互联网，如果作为名词理解的话，就是互相联网，让各种设备处于同一网络环境下，只要设备互相连接网络了，那么设备之间就可以进行通信</p><p>它一般泛指彼此能够通信的设备组成的网络，但是目前我们往往提到的互联网，大部分时候都是指代的因特网，你可以把互联网作为名词理解，也可以将互联网理解为因特网的代称</p><p>互联网（internet，音译为因特网）</p><p>又称国际网络，指的是网络与网络之间所串连成的庞大网络，这些网络以一组通用的协议（规则）相连，形成逻辑上的单一巨大国际网络。</p><p>互联网目前已经把200多个国家和地区的大部分设备连接了起来，形成了一个遍布全世界的网络。所以在一定程度上也可以说，互联网等同于广域网，广域网包含了互联网。互联网使用的技术，在广域网上一定有，但是某些广域网的技术，互联网上不一定有比如军用的广域网，普通老百姓是不会使用的</p><p>互联网（因特网）的本质就是人为定义的一系列协议（规则）总称为“互联网协议”</p><p>主要功能：</p><p>定义计算机如何接入互联网，以及接入互联网的计算机的通信标准，也就是为我们的设备定义连入标准，并且为传输的2进制数据定义一些传输规则，只要遵守这些规则来进行网络连接和数据传输，我们的各种设备就可以通过网络进行通讯，进行信息的交换</p><p>简单理解因特网：</p><p>它是国际上最大的互联网，所以当我们提到互联网时一般都代指因特网</p><p>它是指当前全球最大的、开放的、有众多网络互相连接而成的特定的计算机网络</p><p>它采用TCP/IP协议簇作为通信的规则，提供了包括万维网（WWW）、文件传输（FTP）、电子邮件（E-mail）、远程登录（Telnet）等等服务</p><p>只要我们的设备和应用程序遵守这套因特网的互联网规则，那么我们就可以在这个庞大的网络体系当中畅游</p><h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><p>万维网（World Wide Web，简称WWW，也称Web、3W等）</p><p>它是存储在因特网的计算机当中，数量巨大的文档（页面）的集合</p><p>它是无数个网络站点和网页的集合，是构成因特网的主要部分</p><p>我们平时用浏览器看到的内容就属于万维网，他们本质上就是一个个的文档（页面）</p><p>如果把因特网看做是网络的基础，那么万维网就可以被看做是对因特网的应用，是利用因特网规则的一种信息传递和呈现的手段，可以认为万维网就是网站和页面的统称</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>网络：由若干设备和连接这些设备的链路构成，设备间可以相互通信</p></li><li><p>局域网：指某一个小区域内由多台设备互联成的计算机组</p></li><li><p>以太网：网络连接的一种规则，定义了连接传输规范</p></li><li><p>城域网：是在一个城市范围内所建立的网络，几十到一百公里</p></li><li><p>广域网：是连接不同地区、城市、国家的远程网络，几十到几千公里</p></li><li><p>互联网（因特网）：是目前国际上最大的互联网，定义了通信规则等</p></li><li><p>万维网：是基于因特网的网站和网页的统称</p></li></ol><h2 id="IP、端口、Mac地址"><a href="#IP、端口、Mac地址" class="headerlink" title="IP、端口、Mac地址"></a>IP、端口、Mac地址</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>只要通过网络连接，我们的设备之间就可以进行信息的传递</p><p>当传递消息时，如何准确的将信息传递到目标设备？</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108598.png" alt="image-20220516165747856"></p><p>基本概念：</p><p>IP地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址</p><p>IP地址是IP协议提供的一种统一的地址格式，IP地址是设备在网络中的具体地址</p><p>IP地址就像是设备的家庭住址一样，被用来给互联网上的电脑一个编号，用于定位</p><p>我们可以用打电话举例子，IP地址就好像是电话号码，我们需要知道对方设备的电话号码，才能联系到对方</p><h4 id="按协议分类（目前常用的还是IPv4的规则）："><a href="#按协议分类（目前常用的还是IPv4的规则）：" class="headerlink" title="按协议分类（目前常用的还是IPv4的规则）："></a>按协议分类（目前常用的还是IPv4的规则）：</h4><h5 id="1-IPv4："><a href="#1-IPv4：" class="headerlink" title="1.IPv4："></a>1.IPv4：</h5><p>互联网协议第四版，由四个数组成，每个数取值范围是0~255</p><p>每个数用 . 来分隔，它的数量是有限的 0.0.0.0~255.255.255.255</p><p>相当于是由4个字节表示，一个字节八位，255的2进制数则是 1111 1111</p><p>A类：0.x.x.x~127.x.x.x （32位2进制最高位为0，适用于网内主机数达1600万台的大型网络）</p><p>B类：128.x.x.x~191.x.x.x（32位2进制最高2位为10，适用于中等规模网络，每个网络能容纳6万台设备）</p><p>C类：192.x.x.x~223.x.x.x（32位2进制最高3位为110，适用小规模局域网，每个网内最多只包含254台设备）</p><p>D类：224.x.x.x~239.x.x.x（32位2进制最高4位为1110，属于特殊类型IP，一般为广播地址）</p><p>E类：240.x.x.x~255.x.x.x（32位2进制最高5位为11110，作为特殊使用）</p><h5 id="2-IPv6："><a href="#2-IPv6：" class="headerlink" title="2.IPv6："></a>2.IPv6：</h5><p>互联网协议第六版，由八个数组成，每个数取值范围是0~65535</p><p>每个数用 : 来分隔，它是为了解决IPv4的有限性而设计的（几乎无限）</p><p>0:0:0:0:0:0:0:0~65535:65535:65535:65535:65535:65535:65535:65535</p><h4 id="按使用范围分类："><a href="#按使用范围分类：" class="headerlink" title="按使用范围分类："></a>按使用范围分类：</h4><h5 id="1-公网IP："><a href="#1-公网IP：" class="headerlink" title="1.公网IP："></a>1.公网IP：</h5><p>用于连接外网，想要和远程设备进行通信时使用的IP地址</p><p>查看方式：百度搜索IP地址查询 便可以查看到公网IP</p><h5 id="2-私网IP："><a href="#2-私网IP：" class="headerlink" title="2.私网IP："></a>2.私网IP：</h5><p>也称局域网IP，私网IP不能上网，只用于局域网内通信</p><p>查看方式：1.在windows操作系统中打开命令提示符窗口</p><p>然后输入指令ipconfig查看本机的IP地址信息</p><p>快捷方式：运行窗口（win+R）-&gt; 打开cmd -&gt; ipconfig</p><p>2.在mac操作系统中打开终端窗口</p><p>然后输入指令ifconfig查看本机的IP地址信息</p><p>也可以在网络设置窗口上直接查看IP地址</p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>通过IP地址我们可以在网络上找到一台设备，但是我们想要和设备通信，本质上是和运行在设备上的某一个应用程序进行通信，而一台设备上可能运行n个应用程序，而端口号就是用来区分这些应用程序的，让我们可以明确到底是和哪一个应用程序进行通信</p><p>基本概念：</p><p>IP地址决定了设备在网络中的具体地址，而端口是不同应用程序在该设备上的门牌号码，一台设备上不同的应用程序想要进行通信就必须对应一个唯一的端口号</p><p>使用规则：</p><p>端口号的取值范围是0~65535</p><p>我们在进行网络程序开发时，需要自己为应用程序设置端口号，端口号不能和其它应用程序相同，避免产生冲突一般选择1024以上的端口进行使用，1024以下的一般由IANA互联网数字分配机构管理</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108935.png" alt="image-20220516170203510"></p><h3 id="Mac地址"><a href="#Mac地址" class="headerlink" title="Mac地址"></a>Mac地址</h3><p>基本概念：Mac地址（Media Access Control Address）</p><p>直译为媒体存取控制地址，也称局域网地址，Mac地址，以太网地址，物理地址</p><p>它是用来确认网络设备位置的地址，在OSI模型中，第三层网络层负责IP地址，第二层数据链路层，则负责Mac地址，Mac地址是用于在网络中唯一标识一个网卡的，一台设备可以有多个网卡，每个网卡都会有一个唯一的Mac地址</p><p>在早期的网络中，只用Mac地址便可以实现两台设备间的通信，但随着设备的增多，Mac地址虽然具备唯一性但是并不携带位置信息，如果通过广播方式查找设备，会给网络造成巨大负担。所以才有了IP地址来定位网络中的设备</p><p>MAC地址就像身份证号，IP地址就好像你的住址。</p><p>MAC地址是物理层面上通信的基础，IP地址是逻辑层面上通信的基础</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109437.png" alt="image-20220516170335933"></p><p>总结：</p><p>在互联中寻找一台指定设备就好像在现实世界中去找朋友串门</p><p>你必须要知道朋友的地址在哪里</p><p>IP地址 = 朋友的住址（某街某小区某栋楼）</p><p>端口 = 朋友住所具体的门牌号 （具体哪个应用程序）</p><p>在网络通信中</p><p>我们通过IP地址 以及 端口号定位想要通信的远端计算机中的某一个应用程序</p><p>IP地址 = 设备在外网中位置</p><p>端口 = 运行在该设备上的应用程序位置</p><p>Mac地址 = 设备进行网络通信的唯一标识，设备真正进行物理信息传输用来定位的标识</p><h2 id="客户端和服务端"><a href="#客户端和服务端" class="headerlink" title="客户端和服务端"></a>客户端和服务端</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>名词角度解释含义</p><p>客户端：</p><p>用户使用的设备（计算机、手机、平板等等）</p><p>客户端应用程序：</p><p>用户使用的设备上安装的应用程序，用户会直接使用操作的内容</p><p>比如各种游戏、聊天软件、外卖软件等等</p><p>往往提到客户端都泛指的是客户端应用程序</p><p>基本概念：</p><p>客户端（Client，或称为用户端、前端）是指与服务端相对应，为客户提供本地服务的应用程序</p><p>我们在设备上（计算机、手机等）使用的所有软件和应用几乎都是客户端应用程序</p><p>比如：</p><p>各种浏览器，游戏，外卖应用程序（美团，饿了么），通讯软件（QQ、微信、陌陌）等等</p><p>他们都可以统称为客户端应用程序（简称客户端）</p><p>说人话：</p><p>用户在设备上（计算机、手机、平板）运行使用的应用程序就是客户端应用程序（简称客户端）</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>名词角度解释含义</p><p>服务端：</p><p>为客户端提供服务的设备，一般是一台性能较好的计算机</p><p>服务端应用程序：</p><p>为客户端提供服务的应用程序，该应用程序是运行在服务端设备上的</p><p>往往在软件开发中提到的服务端或服务器都是泛指服务端应用程序</p><p>基本概念：</p><p>服务端（Server，或称为服务器、后端）是为客户端服务的，服务的内容诸如向客户端提供资源，保存客户端数据等等</p><p>它是一种有针对性的服务程序，往往一个服务端都是针对性的为某类客户端提供服务</p><p>它往往是一台运行在远端的计算机，客户端和服务端通过网络进行通信</p><p>比如：</p><p>某游戏服务端它只为该游戏的客户端提供服务（消息转发、信息保存、逻辑处理等等）</p><p>某外卖服务端它只为该外卖的客户端提供服务（分派订单、查看订单、查看配送进度等等）</p><p>说人话：服务端应用程序运行在远端的一台计算机上，客户端通过网络和服务端进行通讯</p><p>服务端为客户端提供各种服务</p><h3 id="网络游戏开发中的客户端和服务端"><a href="#网络游戏开发中的客户端和服务端" class="headerlink" title="网络游戏开发中的客户端和服务端"></a>网络游戏开发中的客户端和服务端</h3><p>单机游戏：</p><p>只有客户端，没有服务端，不存在玩家之间的交互，数据存储在本地</p><p>网络游戏：</p><p>有客户端和服务端，玩家之间可以进行交互（信息同步，信息交换），静态（不变的）数据存储在客户端，动态（要变的）数据存储在服务端</p><p>网络游戏开发中的客户端：</p><p>Unity、UE、Cocos、Egret、Laya、Flash等等游戏引擎开发的游戏都属于客户端应用程序，他们都是被用户直接操作的，主要功能就是游戏玩法、UI交互、美术表现、本地数据保存等等</p><p>网络游戏开发中的服务端：</p><p>C++、Java、C#、Go等等语言开发的运行在远端计算机上为游戏客户端提供服务的软件都属于服务端应用程序，它的主要功能就是消息转发、数据保存、逻辑处理等等</p><p>总结：</p><ol><li>客户端</li></ol><p>用户在设备上（计算机、手机、平板）运行使用的应用程序就是客户端应用程序（简称客户端）</p><ol><li>服务端</li></ol><p>服务端应用程序运行在远端的一台计算机上，客户端通过网络和服务端进行通讯，服务端为客户端</p><p>提供各种服务</p><ol><li>网络游戏开发中的客户端和服务端</li></ol><p>我们用Unity开发的应用程序就是游戏客户端应用程序</p><p>后端程序员可以使用C++、C#、Java、Go等等语言进行服务端程序开发，为游戏客户端提供服务</p><p>客户端和服务端之前通过互联网进行信息交换</p><h2 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h2><h3 id="数据通信模型-1"><a href="#数据通信模型-1" class="headerlink" title="数据通信模型"></a>数据通信模型</h3><p>在早期的计算机网络中，为了有效的利用计算机，一般将数据通信模型分为</p><p>分散式（Decentralized）</p><p>集中式（Centralized）</p><p>分布式（Distributed）</p><p>这三种方式决定了数据在网络环境中的管理方式</p><h4 id="分散式"><a href="#分散式" class="headerlink" title="分散式"></a>分散式</h4><p>在分散式系统中，用户只负责管理自己的计算机系统，各自独立的系统之间没有资源或信息的交换和共享。就类似一台台没有联网的设备</p><p>这种模式由于存在大量共享数据的重复存储，除了引起数据冗余之外，也容易导致一个组织内各部门数据的不一致性。</p><p>同时还会造成硬件、支持和运营维护等成本的大量增加，因此早被淘汰</p><h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><p>在集中式环境中，用一台主计算机保存一个组织的全部数据，而用户则通过设备连接到这台计算机系统并和它通信，从而达到访问数据的目的</p><p>优点：方便数据共享、消除了数据的冗余和不一致性</p><p>缺点：可靠性不如分散式，主机出现故障所有系统全部瘫痪</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>分布式是分散式和集中式的混合，类似我们学习过的计算机网络，是分散式的水平交互和集中式的垂直控制相结合的一种模式，它兼具了分散式和集中式的优点</p><p>方便数据共享、消除了数据的冗余和不一致性，同样也加强了容错性</p><p>例如：</p><p>比如一般的企业管理系统就是一个典型的集中式和分布式的综合体现</p><p>所有数据用专用的数据库集中存储，属于集中式</p><p>而对数据的处理则由各个部门的软件分别控制，属于分布式</p><h3 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h3><p>C/S(Client/Server)模型也叫C/S模式</p><p>就是我们上节课学习的客户端和服务端模式，它是目前大多数网络通信采用的模型</p><p>从程序的角度来说，客户端和服务端打交道，相当于是两个应用程序（进程）在打交道</p><h3 id="B-S模型"><a href="#B-S模型" class="headerlink" title="B/S模型"></a>B/S模型</h3><p>B/S(Browse/Server)模型也叫B/S模式</p><p>它是一种基于Web的通信模型，使用HTTP超文本传送协议通信，B/S是一种特殊的C/S模型，特殊之处就是这种模型的客户端不需要我们自己开发，一般是某种浏览器，比如IE、Chrome、QQ浏览器、360浏览器等等，B/S模型的优点就是单台计算机可以访问任何一个Web服务器</p><p>简单的说就是Web服务端可以随意变，但是客户端是通用的，我们不需要针对不同的服务端专门提供客户端应用程序了</p><h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><p>P2P(Peer-to-Peer)模型也叫对等互联</p><p>每个联网的设备同时运行一个应用程序的客户端（Client）和服务端（Server）部分，也就是说一个应用程序同时作为客户端和服务端</p><p>优点是通信方便，成本低，缺点是可靠性不如C/S模型</p><p>总结</p><p>对于网络游戏开发来说，我们采用C/S模型来进行前后端开发，在服务端的布局上往往使用的是分布式的形式进行管理</p><p>比如服务端的用户数据使用集中式进行管理，玩家的数据都存储在数据库应用（SQL Server、MySQL）中，服务端应用程序使用分布式进行管理，账号服务器、游戏服务器、聊天服务器、跨服PVP服务器等分布式管理，这些服务端应用程序都使用数据库中的数据分别进行逻辑处理</p><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h2 id="网络协议概述"><a href="#网络协议概述" class="headerlink" title="网络协议概述"></a>网络协议概述</h2><h3 id="网络协议概述-1"><a href="#网络协议概述-1" class="headerlink" title="网络协议概述"></a>网络协议概述</h3><p>协议的字面意思：</p><p>经过谈判、协商而制定的共同承认、共同遵守的文件</p><p>网络协议的基本概念：</p><p>网络协议是计算机网络中进行数据交换而建立的规则、标准或约定的集合</p><p>指的是计算机网络中互相通信的对等实体之间交换信息时所必须遵守的规则的集合</p><p>说人话：</p><p>如果你想要在网络环境中进行通信，那么网络协议就是你必须遵守的规则</p><p>OSI模型是网络通信的基本规则</p><p>TCP/IP协议是基于OSI模型的工业实现</p><p>说人话：</p><p>OSI模型是国际组织定义的一套理论基础，主要用于定义网络通信的规则</p><p>TCP/IP协议是基于这套理论基础真正实现的通信规则</p><p>网络通信API底层都是基于TCP/IP协议的</p><p>总结：</p><p>2进制数据应该如何加工，如何准确</p><p>的传递到目标设备当中，在数据传递过程中具体的规则标准是什么</p><p>而这些规则标准都是由网络协议制定的</p><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><h3 id="OSI模型是什么"><a href="#OSI模型是什么" class="headerlink" title="OSI模型是什么"></a>OSI模型是什么</h3><p>OSI（Open System Interconnection Reference Model）开放式系统互联通信参考模型，简称OSI模型</p><p>它是一种概念模型</p><p>由ISO（International Organization for Standardization）国际标准化组织提出，是一个试图使各种设备在世界范围内互联为网络的标准框架，不同公司都按照统一的标准来控制网络互联通信，那么各设备之间就能够达到真正的互联通信了</p><p>说人话：</p><p>OSI模型是人为定义的一个标准（规范），它制定了设备之间相互连接相互通信的标准（规范）</p><p>各公司按照这个标准设计的规则（协议），就可以让不同设备利用互联网进行互联通信</p><h3 id="OSI模型的规则"><a href="#OSI模型的规则" class="headerlink" title="OSI模型的规则"></a>OSI模型的规则</h3><p>由于互联网协议（规则）很庞大，很复杂，所以OSI模型采用了分而治之的设计方法，把网络的功能划分为不同的多个模块，以分层的形式有机地组合在了一起</p><p>OSI模型将复杂的互联网实现 分成了好几层（部分），每一层都有自己的功能，就好像建筑物一样，从上到下有很多层构成，每一层都要靠下一层的支持用户接触到的都只是最上面的一层，感受不到下面层级的复杂性</p><p>OSI模型把互联通信的过程抽象的分成了七个层级</p><p>1.应用层</p><p>2.表示层</p><p>3.会话层</p><p>4.传输层</p><p>5.网络层</p><p>6.数据链路层</p><p>7.物理层</p><p>不同层级的职能各有不同，这7个层级就是在两台计算机互联通信时必经的7个步骤</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109287.png" alt="image-20220516172955696"></p><h3 id="OSI模型每层的职能"><a href="#OSI模型每层的职能" class="headerlink" title="OSI模型每层的职能"></a>OSI模型每层的职能</h3><p>第一部分：从地基开始</p><p>物理层—&gt;数据链路层—&gt;网络层—&gt;传输层</p><p>第二部分：从屋顶开始</p><p>应用层—&gt;表示层—&gt;会话层</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109922.png" alt="image-20220516173120258"></p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>电脑要联网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p>功能：</p><p>它就是把电脑连接起来的物理手段，它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。物理层将2进制数据利用电脉冲，在物理媒介上实现比特流的传输，它的主要功能是，定义传输模式、定义传输速率、比特同步、比特编码等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109896.png" alt="image-20220516173248105"></p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>物理层用物理硬件来传输0和1，但是单纯的0和1没有任何意义</p><p>必须规定解读方式，比如多少个电信号算一组？每个信号位的意义？</p><p>这就是数据链路层的意义，它在物理层的上方确定0和1的分组方式，并且明确信息是发送给哪台计算机的网卡（Mac地址）</p><p>功能：</p><p>将想要发送的信息构成一个数据包，叫做“帧”，每一个帧分为两个部分：标头Head+数据Data，标头包含数据包的一些说明项</p><p>比如：发送方和接收方的Mac地址，数据类型等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109712.png" alt="image-20220516173306909"></p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>通过Mac地址定位一台计算机，理论上是可行的，但是效率非常低下，我们之前学习过IP地址、端口、Mac地址，我们知道我们是通过IP地址，快速的定位网络上的设备的，而网络层的主要功能就和IP地址有关系</p><p>功能：</p><p>IP选址、路由选择</p><p>在网络环境中，两台设备之间可能会经过很多个数据链路，也可能还要经过很多通信子网</p><p>网络层的主要作用就是选择一条合适的路径用于通信。它会在上一层的数据基础上添加标头</p><p>包含信息：IP地址、版本、长度等等信息</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109490.png" alt="image-20220516173416163"></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>有了Mac地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信了，但是如果没有端口号，我们无法准确的在应用程序之间进行通信。传输层的功能，就是建立端口到端口的通信</p><p>功能：</p><p>建立、管理和维护端到端的连接</p><p>传输层也称运输层，传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务。它也会在上一层的数据基础上添加标头</p><p>包含信息：发送方接收方的端口信息、协议信息等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109795.png" alt="image-20220516173509663"></p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层为最上层，和用户直接打交道的可以联网的应用程序就属于这一层，比如浏览器，游戏等等</p><p>功能：</p><p>为应用程序提供服务，我们可以根据自己要传递的信息，决定使用哪一种协议（规则）来处理数据，进行传输</p><p>我们程序员主要开发的也是这一层，它会在原始数据的基础上添加标头</p><p>包含信息：协议信息等等</p><p>常用的协议（规则）：</p><p>FTP，HTTP，SMTP等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109710.png" alt="image-20220516173623087"></p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>不同操作系统的应用层代码和数据可能规范都不一样，为了让信息可以在各操作系统和设备中通用，表示层做的事情就很重要了</p><p>功能：</p><p>数据格式转化、代码转换、数据加密</p><p>为了让不同设备之间能够有统一的规则，表示层会把数据转换为能与各系统格式，兼容并且适合传输的格式，表示层就像是个翻译，会把数据相关信息，翻译成国际通用的规则</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109213.png" alt="image-20220516173637261"></p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>有了准备好的上层数据，那么这些数据最终就是希望被传递的内容，那么在信息传递时我们需要对其进行管理，比如消息是否发送完毕，对方是否收到，是否断开连接等等，会话层的主要工作就是完成这些内容</p><p>功能：</p><p>建立、管理和维护会话，它主要负责数据传输中设置和维护，网络中两台设备之间的通信连接。它不参与具体的传输，主要提供包括访问验证和会话管理，在内的建立和维护应用之间通信的机制</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109808.png" alt="image-20220516173855746"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109012.png" alt="image-20220516173905252"></p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><h3 id="TCP-IP协议是什么"><a href="#TCP-IP协议是什么" class="headerlink" title="TCP/IP协议是什么"></a>TCP/IP协议是什么</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol）</p><p>TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议，是指能够在多个不同网络间实现信息传输的协议簇，它是一个工业标准（就是实际会使用的标准）</p><p>TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等等协议构成的协议簇 ，只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议，用于互联网的通信协议（规则）</p><p>说人话：</p><p>TCP/IP协议是一系列规则（协议）的统称，他们定义了消息在网络间进行传输的规则，是供已连接互联网的设备进行通信的通信规则</p><p>比如：在传输文件时我们使用其中的FTP文件传输协议；在传输电子邮件时我们使用其中的SMTP邮件传输协议；在定位远端计算机位置时我们使用其中的IP互联网协议地址</p><h3 id="TCP-IP协议的规则"><a href="#TCP-IP协议的规则" class="headerlink" title="TCP/IP协议的规则"></a>TCP/IP协议的规则</h3><p>TCP/IP网络结构体系实际上是基于OSI七层模型设计出来的。</p><p>OSI七层模型只是一个概念模型，它主要用于描述、讨论和理解单个网络功能，而TCP/IP协议是为了解决一组特定的问题而设计的，它是基于互联网开发的标准协议（规则）</p><p>说人话：</p><p>OSI模型只是一个基本概念，而TCP/IP协议是基于这个概念的具体实现</p><p>TCP/IP协议把互联通信的过程抽象的分成了四个层级</p><p>1.应用层</p><p>2.传输层</p><p>3.网络层</p><p>4.网络接口层（数据链路层）</p><p>这四层是基于OSI七层模型进行设计的</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242110763.png" alt="image-20220516182605652"></p><h3 id="TCP-IP协议每层的职能"><a href="#TCP-IP协议每层的职能" class="headerlink" title="TCP/IP协议每层的职能"></a>TCP/IP协议每层的职能</h3><p>应用层头：</p><p>协议头（FTP、HTTP等协议）</p><p>一般决定传输信息的类型</p><p>传输层头：</p><p>协议端口头（TCP或UDP协议）</p><p>一般决定传输信息的规则以及端口</p><p>网路层头：</p><p>IP头，决定传输路线</p><p>网络接口层头尾：</p><p>产生帧（消息分段），决定最终路线</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122503.png" alt="image-20221124212209466"></p><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><h3 id="TCP-IP协议中的重要协议"><a href="#TCP-IP协议中的重要协议" class="headerlink" title="TCP/IP协议中的重要协议"></a>TCP/IP协议中的重要协议</h3><p>应用层协议：</p><p>HTTP协议：超文本传输协议</p><p>HTTPS协议：加密的超文本传输协议</p><p>FTP协议：文件传输协议</p><p>DNS：域名系统</p><p>传输层协议：</p><p>TCP协议：传输控制协议</p><p>UDP协议：用户数据报协议</p><p>网络层协议：</p><p>IP协议</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242110419.png" alt="image-20220516182904884"></p><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP：传输控制协议</p><p>UDP：用户数据报协议</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122969.png" alt="image-20220516182924119"></p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接，并且在消息传送过程中是有顺序的，并且是不会丢包（丢弃消息）的，如果某一条消息在传送过程中失败了，会重新发送消息，直到成功</p><p>它的特点是：</p><p>1.面向连接 —— 两者之间必须建立可靠的连接</p><p>2.一对一 —— 只能是1对1的建立连接</p><p>3.可靠性高 —— 消息传送失败会重新发送，不允许丢包</p><p>4.有序的 —— 是按照顺序进行消息发送的</p><h4 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h4><p>TCP协议中有一个重要概念：三次握手，四次挥手</p><p>三次握手建立连接</p><p>第一次握手（C—&gt;S）</p><p>TCP连接请求，告诉服务器我要和你建立连接</p><p>第二次握手（S—&gt;C）</p><p>TCP授予连接，告诉客户端准了，来吧</p><p>第三次握手（C—&gt;S）</p><p>TCP确认连接，告诉服务器，来就来</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122311.png" alt="image-20220516183057213"></p><p>四次挥手断开连接</p><p>第一次挥手（C—&gt;S）</p><p>告诉服务器我数据发完了，你如果还有消息就快发完</p><p>第二次挥手（S—&gt;C）</p><p>告诉客户端我知道了，请继续等待我的消息</p><p>第三次挥手（S—&gt;C）</p><p>告诉客户端消息发完了，你可以正式断开连接了</p><p>第四次挥手（C—&gt;S）</p><p>告诉服务器我等一会如果没有收到你回复我就断开了</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122681.png" alt="image-20220516183152714"></p><p>TCP有了这三次握手，四次挥手的规则，可以提供可靠的服务，通过TCP连接传送的数据，可以做到无差错、不丢失、不重复、且按顺序到达，它让服务器和客户端之间的数据传递变得更加的可靠</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP（User Datagram Protocol，用户数据报协议）是一种无需建立连接就可以发送封装的IP数据包的方法，提供面向事务的简单不可靠信息传送服务</p><p>它的特点是：</p><p>1.无连接 —— 两者之间无需建立连接</p><p>2.可靠性低 —— 消息可能在传送过程中丢失，丢失后不会重发</p><p>3.传输效率高 —— 由于它的可靠性低并且也无需建立连接，所以传输效率上更高一些</p><p>4.n对n —— TCP只能1对1连接进行消息传递，而UDP由于无连接所以可以n对n</p><p>UDP协议不像TCP协议需要建立连接有三次握手和四次挥手，当使用UDP协议发送信息时会直接把信息数据扔到网络上，所以也就造成了UDP的不可靠性，信息在这个传递过程中是有可能丢失的，虽然UDP是一个不靠谱的协议，但是由于它不需要建立连接，也不会像TCP协议那样携带更多的信息，所以它具有更好的传输效率</p><p>它具有资源消耗小，处理速度快的特点</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122739.png" alt="image-20220516183402307"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP：</p><p>更可靠，保证数据的正确性和有序性（三次握手四次挥手）</p><p>适合对信息准确性要求高，效率要求较低的使用场景</p><p>比如：游戏开发，文件传输，远程登录等等</p><p>UDP：</p><p>更效率，传输更快，资源消耗更少</p><p>适合对实时性要求高的使用场景</p><p>比如：直播，即时通讯，游戏开发等等</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-网络开发（二）</title>
      <link href="/posts/f780d4d0.html"/>
      <url>/posts/f780d4d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><h2 id="网络游戏通信方案概述"><a href="#网络游戏通信方案概述" class="headerlink" title="网络游戏通信方案概述"></a>网络游戏通信方案概述</h2><h3 id="弱联网和强联网游戏"><a href="#弱联网和强联网游戏" class="headerlink" title="弱联网和强联网游戏"></a>弱联网和强联网游戏</h3><p>网络游戏是以C/S模型为基础进行开发的由客户端和服务端组成</p><p>弱联网游戏：</p><p>这种游戏不会频繁的进行数据通信，客户端和服务端之间每次连接只处理一次请求，服务端处理完客户端的请求后返回数据后就断开连接了</p><p>强联网游戏：</p><p>这种游戏会频繁的和服务端进行通信，会一直和服务端保持连接状态，不停的和服务器之间交换数据通过之前的知识我们知道，网络游戏是以C/S模型为基础进行开发的由客户端和服务端组成</p><p>弱联网游戏代表：</p><p>一般的三消类休闲游戏、卡牌游戏等都会是弱联网游戏，这些游戏的核心玩法都由客户端完成，客户端处理完成后只是告诉服务端一个结果，服务端验证结果即可，不需要随时通信</p><p>比如：开心消消乐、刀塔传奇、我叫MT等等</p><p>强联网游戏代表：</p><p>一般的MMORPG（角色扮演）、MOBA（多人在线竞技游戏）、ACT（动作游戏）等等都会是强联网游戏，这些游戏的部分核心逻辑是由服务端进行处理，客户端和服务端之间不停的在同步信息</p><p>比如：王者荣耀、守望先锋、和平精英等等</p><h3 id="长连接和短连接游戏"><a href="#长连接和短连接游戏" class="headerlink" title="长连接和短连接游戏"></a>长连接和短连接游戏</h3><p>长连接和短连接游戏是按照网络游戏通信特点来划分的</p><p>弱联网游戏——&gt;短连接游戏</p><p>强联网游戏——&gt;长连接游戏</p><p>短连接游戏：</p><p>需要传输数据时，建立连接，传输数据，获得响应，断开连接</p><p>通信特点：需要通信时再连接，通信完毕断开连接</p><p>通信方式：HTTP超文本传输协议、HTTPS安全的超文本传输协议（他们本质上是TCP协议）</p><p>长连接游戏：不管是否需要传输数据，客户端与服务器一直处于连接状态，除非一端主动断开，或</p><p>者出现意外情况（客户端关闭或服务端崩溃等）</p><p>通信特点：连接一直建立，可以实时的传输数据</p><p>通信方式：TCP传输控制协议 或 UDP用户数据报协议</p><h3 id="Socket、HTTP、FTP"><a href="#Socket、HTTP、FTP" class="headerlink" title="Socket、HTTP、FTP"></a>Socket、HTTP、FTP</h3><p>Socket：网络套接字，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制</p><p>主要用于制作长连接游戏（强联网游戏）</p><p>Http/Https：(安全的)超文本传输协议，是一个简单的请求-响应协议，它通常运行在TCP协议之上，它指定了客户端可能发送给服务端什么样的信息以及得到什么样的响应。</p><p>主要用于制作短连接游戏（弱联网游戏），也可以用来进行资源下载</p><p>FTP：文件传输协议，是用于在网络上进行文件传输的一套标准协议，可以利用它来进行网络上资源的下载和上传。它也是基于TCP的传输，是面向连接的，为文件传输提供了可靠的保证</p><h2 id="网络通信基础"><a href="#网络通信基础" class="headerlink" title="网络通信基础"></a>网络通信基础</h2><h3 id="IP地址和端口类"><a href="#IP地址和端口类" class="headerlink" title="IP地址和端口类"></a>IP地址和端口类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region IPAddress类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net;</span></span><br><span class="line"><span class="comment">//类名：IPAddress</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化IP信息的方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.用byte数组进行初始化</span></span><br><span class="line">byte[] ipAddress = <span class="keyword">new</span> byte[] &#123; <span class="number">118</span>, <span class="number">102</span>, <span class="number">111</span>, <span class="number">11</span> &#125;;</span><br><span class="line">IPAddress ip1 = <span class="keyword">new</span> <span class="built_in">IPAddress</span>(ipAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.用long长整型进行初始化</span></span><br><span class="line"><span class="comment">//4字节对应的长整型 一般不建议大家使用</span></span><br><span class="line">IPAddress ip2 = <span class="keyword">new</span> <span class="built_in">IPAddress</span>(<span class="number">0x79666F0B</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.推荐使用的方式 使用字符串转换</span></span><br><span class="line">IPAddress ip3 = IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;118.102.111.11&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊IP地址</span></span><br><span class="line"><span class="comment">//127.0.0.1代表本机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一些静态成员</span></span><br><span class="line"><span class="comment">//获取可用的IPv6地址</span></span><br><span class="line"><span class="comment">//IPAddress.IPv6Any</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region IPEndPoint类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net;</span></span><br><span class="line"><span class="comment">//类名：IPEndPoint</span></span><br><span class="line"><span class="comment">//IPEndPoint类将网络端点表示为IP地址和端口号，表现为IP地址和端口号的组合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(<span class="number">0x79666F0B</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">IPEndPoint ipPoint2 = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;118.102.111.11&quot;</span>), <span class="number">8080</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//程序表示IP信息</span></span><br><span class="line">IPAddress ip = IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;IPv4地址&quot;</span>);</span><br><span class="line"><span class="comment">//程序表示通信目标</span></span><br><span class="line">IPEndPoint point = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(ip, <span class="number">8080</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>域名解析也叫域名指向、服务器设置、域名配置以及反向IP登记等等，说得简单点就是将好记的域名解析成IP，IP地址是网络上标识站点的数字地址，但是IP地址相对来说记忆困难，所以为了方便记忆，采用域名来代替IP地址标识站点地址。</p><p>比如 我们要登录一个网页 www.baidu.com 这个就是域名 我们可以通过记忆域名来记忆一个远端服务器的地址，而不是记录一个复杂的IP地址</p><p>域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成，我们在进行通信时有时会有需求通过域名获取IP</p><p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务，它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网，是因特网上解决网上机器命名的一种系统，因为IP地址记忆不方便，就采用了域名系统来管理名字和IP的对应关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region IPHostEntry类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//类名：IPHostEntry</span></span><br><span class="line"><span class="comment">//主要作用：域名解析后的返回值 可以通过该对象获取IP地址、主机名等等信息</span></span><br><span class="line"><span class="comment">//该类不会自己声明，都是作为某些方法的返回值返回信息，我们主要通过该类对象获取返回的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取关联IP       成员变量:AddressList</span></span><br><span class="line"><span class="comment">//获取主机别名列表  成员变量:Aliases</span></span><br><span class="line"><span class="comment">//获取DNS名称      成员变量:HostName</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region Dns类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//类名：Dns</span></span><br><span class="line"><span class="comment">//主要作用：Dns是一个静态类，提供了很多静态方法，可以使用它来根据域名获取IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//1.获取本地系统的主机名</span></span><br><span class="line"><span class="built_in">print</span>(Dns.<span class="built_in">GetHostName</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取指定域名的IP信息</span></span><br><span class="line"><span class="comment">//根据域名获取</span></span><br><span class="line"><span class="comment">//同步获取</span></span><br><span class="line"><span class="comment">//注意：由于获取远程主机信息是需要进行网路通信，所以可能会阻塞主线程</span></span><br><span class="line">IPHostEntry entry = Dns.<span class="built_in">GetHostEntry</span>(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entry.AddressList.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;IP地址：&quot;</span> + entry.AddressList[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entry.Aliases.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;主机别名&quot;</span> + entry.Aliases[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;DNS服务器名称&quot;</span> + entry.HostName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步获取</span></span><br><span class="line"><span class="built_in">GetHostEntry</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><p>如果不知道对方的IP地址，想通过域名和对方进行通信，可以通过Dns类通过域名得到IP地址后再和对方建立连接并通信</p><h3 id="序列化和反序列化2进制数据"><a href="#序列化和反序列化2进制数据" class="headerlink" title="序列化和反序列化2进制数据"></a>序列化和反序列化2进制数据</h3><h4 id="网络通信中传输的数据"><a href="#网络通信中传输的数据" class="headerlink" title="网络通信中传输的数据"></a>网络通信中传输的数据</h4><p>在网络通信中</p><p>把想要传递的类对象信息序列化为2进制数据（一般为byte字节数组）</p><p>再将该2进制数据通过网络传输给远端设备</p><p>远端设备获取到该2进制数据后再将其反序列化为对应的类对象</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122585.png" alt="image-20220518003846852"></p><p>序列化：</p><p>将类对象信息转换为可保存或传输的格式的过程</p><p>反序列化：</p><p>与序列化相对，将保存或传输过来的格式转换为类对象的过程</p><p>比如</p><p>将C#类对象序列化为xml、json、2进制三种格式的数据保存在本地，达到持久化的目的，再将保存在本地的持久化数据文件反序列化为C#类对象</p><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>字符编码（英语：Character encoding）也称字集码</p><p>是把字符集中的字符，编码为指定集合中某一对象，以便文本在计算机中存储或通过网络进行传递。</p><p><strong>说人话：计算机里只能存数字（2机制），所以如果文字字符想要进行存储的话，就需要把对应的文字字符转换为数字才能进行处理，而字符编码就是文字字符在计算机中和数值的对应关系，是人为定义的一种映射规则。</strong>比如</p><p>ASCII码（一种字符编码规则）中 数值65 用来映射 字符A</p><p>我们存储 A 这个字符，本质上存在内存中的是数值65对应的2进制是0100 0001</p><p>常见的一些字符编码规则有</p><p><strong>每个国家针对自己国家语言制定的编码规则（因为语言文字的数量各不相同）</strong></p><p><strong>ASCII码（美国）、GB2312编码（中国）、Shift_JIS编码（日本）、Euc-kr（韩国）等等</strong></p><p>世界通用的编码规则（把所有语言统一到一套编码里）</p><p><strong>Unicode编码 以及 基于Unicode实现的编码规则</strong></p><p><strong>UTF-8、UTF-16、UTF-32</strong></p><h4 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h4><p>假设我们的一个文件是采用中国制定的GB2312编码进行编辑存储的，而此时我们并不使用GB2312这个编码规则去读取文件，而是采用其它的规则，比如日本制定的Shift_JIS编码读取该文件，那么<strong>由于编码格式的存读不统一就会造成乱码的出现。因为不同的编码规则，字符和数值的映射关系是不同的。</strong></p><p>比如：130这个数值在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)，在中文编码中又会代表另一个符号。</p><h4 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a><strong>ASCII码</strong></h4><p>在计算机内部，所有的信息最终都是一个二进制值。</p><p>一个二进制数就是一位（bit），有0和1两种状态。一个字节（byte）是8个二进制数组成的，所以1 byte = 8 bit。</p><p>也就是说一个字节一共可以用来表示256种不同的状态，从00000000到11111111。如果每一个状态都代表一个符号的话，那么一个字节可以用来表示256个符号。</p><p>上个世界60年代，美国制定了一套算是最早的字符编码，制定了一套基于英文字符与二进制位之间的对应关系。这套标准被称为ASCII码，一直使用到今天。</p><p>ASCII码一共规定了128个字符的编码。比如：</p><p>字符 A = 65（十进制数）= 0100 0001（二进制数）</p><p>字符 1 = 49（十进制数）= 0011 0001（二进制数）等等</p><p>下图为ASCII码的对照表</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123917.png" alt="img"></p><p>这128个字符的编码规则，只占用了一个字节的后面7位，最前面的一位统一规定为0。  </p><p>英文国家使用128个字符编码就足够了，但是如果用来表示其它国家的语言，128个符号是远远不够的，于是乎就出现了非ASCII码们。</p><h4 id="非ASCII码"><a href="#非ASCII码" class="headerlink" title="非ASCII码"></a><strong>非ASCII码</strong></h4><p>非ASCII码基本都是基于ASCII码进行的扩充，他们都保留了ASCII码0~127这段编码的规范。也就是说非ASCII码的前面部分往往是和ASCII码的规则是相同的。</p><p>对于一些欧洲国家，他们使用一个字节便可以表示完自己所有的文字，他们利用了字节中闲置的最高位编入新的符号，因为我们知道ASCII码的编码规则是：一个字节中的8位，只占用了一个字节的后面7位，最前面的一位统一规定为0。所以这些语言系统中文字较少的国家让最前面的一位可以为1，他们就可以为自己的文字在128~255这一段加入新的对应规则。</p><p>比如：130这个数值在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)</p><p>这种一个字节就把字符表示完的做法只适用于语言系统中文字较少的国家，因为他们的语言的字母是有限的。</p><p>对于使用象形文字的国家来说，一个字节完全不够用！比如中国，我们的汉字多达10万左右，一个字节最多也只能表示256种符号，是远远不够的。所以必须使用多个字节来表示一个符号。比如我们前面提到的中国的简体中文GB2312编码，是使用两个字节表示一个汉字，所以理论上来说可以表示256x256=65536个符号。</p><p>所以所谓的非ASCII码，就是指的除了ASCII码以外的编码格式，每个国家都至少有1种针对自己语言文字的编码格式，每一个编码格式中 数值和字符的对应关系都可能不相同。这也就造成了前面说到的乱码问题。在全世界范围内进行网络通信时，如果每个国家都使用不统一的编码格式，那么出现乱码的情况将随处可见。</p><p>因此随着互联网的发展，人们决定要制定一套全世界统一的的编码规则，将世界上所有的符号都纳入其中，为每一个符号赋予独一无二的编码（2进制数值）。那么这样就不会出现乱码问题，影响信息的传递了。</p><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><strong>Unicode</strong></h4><p>Unicode可以理解为是 Unique Code 的简写，翻译过来是“唯一的编码”。</p><p>它出现的主要原因就是用来解决乱码问题的，它将世界上所有的符号都纳入其中，每一个符号都为其分配一个独一无二的二进制数表示它，那么乱码问题就会消失。</p><p>Unicode是一个很大的集合，现在的规模可以容纳100多万个符号，每个符号对应的二进制数都不一样。这样就确保了不同语言的字符不会再有冲突。</p><p>那么这样可能就存在一个问题，就是有的符号用1个字节8位就可以表示了，有的符号可能需要使用2个字节16位甚至3个字节24位才能表示。就比如说ASCII码，它的存储规则就是一个字节存储一个字符，那么当我们使用Unicode编码时，到底用几个字节来存储字符呢？</p><p>因此我们需要注意：<strong>Unicode编码只是一个符号集，它只规定符号和二进制的对应关系，并没有规定这个二进制数值应该如何存储。</strong></p><p><strong>而UTF-8、UTF-16、UTF-32三种编码格式才是基于Unicode实现的具体编码方案</strong></p><p>UTF-8编码：可变字节编码方案，可以根据实际情况使用1个、2个、3个、4个字节来存储字符</p><p>UTF-16编码：可变字节编码方案，可以根据实际情况使用2个、4个字节来存储字符</p><p>UTF-32编码：固定字节编码方案，用4个字节来存储字符</p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><strong>UTF-8</strong></h4><p>UTF-8是Unicode的实现方式之一，它的最大特点是：它是一种变长的编码方式，可以使用1~4个字节表示一个字符，根据不同的符号而变化字节的长度。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123273.png" alt="img"></p><p><strong>Unicode是世界上所有符号对应二进制数据的关系集合</strong></p><p><strong>UTF-8是Unicode的实现方式之一：UTF-8 = Unicode符号集 + 变长的编码规则</strong></p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region 非字符串类型转字节数组</span></span><br><span class="line"><span class="comment">//关键类：BitConverter</span></span><br><span class="line"><span class="comment">//所在命名空间：System</span></span><br><span class="line"><span class="comment">//主要作用：除字符串的其它常用类型和字节数组相互转换</span></span><br><span class="line"></span><br><span class="line">byte[] bytes = BitConverter.<span class="built_in">GetBytes</span>(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 字符串类型转字节数组</span></span><br><span class="line"><span class="comment">//关键类：Encoding</span></span><br><span class="line"><span class="comment">//所在命名空间：System.Text</span></span><br><span class="line"><span class="comment">//主要作用：将字符串类型和字节数组相互转换，并且决定转换时使用的字符编码类型，网络通信时建议大家使用UTF-8类型</span></span><br><span class="line">byte[] byte2 = Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;的卡萨福利卡决胜巅峰卡视角的副驾驶的&quot;</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 如何将一个类对象转换为二进制</span></span><br><span class="line"><span class="comment">//注意：网络通信中我们不能直接使用数据持久化2进制知识点中的</span></span><br><span class="line"><span class="comment">//BinaryFormatter 2进制格式化类</span></span><br><span class="line"><span class="comment">//因为客户端和服务器使用的语言可能不一样，BinaryFormatter是C#的序列化规则，和其它语言之间的兼容性不好</span></span><br><span class="line"><span class="comment">//如果使用它，那么其它语言开发的服务器无法对其进行反序列化</span></span><br><span class="line"><span class="comment">//我们需要自己来处理将类对象数据序列化为字节数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单纯的转换一个变量为字节数组非常的简单</span></span><br><span class="line"><span class="comment">//但是我们如何将一个类对象携带的所有信息放入到一个字节数组中呢</span></span><br><span class="line"><span class="comment">//我们需要做以下几步</span></span><br><span class="line"><span class="comment">//1.明确字节数组的容量（注意：在确定字符串字节长度时要考虑解析时如何处理）</span></span><br><span class="line">PlayerInfo info = <span class="keyword">new</span> <span class="built_in">PlayerInfo</span>();</span><br><span class="line">info.lev = <span class="number">10</span>;</span><br><span class="line">info.name = <span class="string">&quot;刘英博&quot;</span>;</span><br><span class="line">info.atk = <span class="number">88</span>;</span><br><span class="line">info.sex = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//得到的 这个Info数据 如果转换成 字节数组 那么字节数组容器需要的容量</span></span><br><span class="line"><span class="type">int</span> indexNum = <span class="built_in">sizeof</span>(<span class="type">int</span>) + <span class="comment">//lev int类型  4</span></span><br><span class="line">               <span class="built_in">sizeof</span>(<span class="type">int</span>) + <span class="comment">//代表 name字符串转换成字节数组后 数组的长度 4</span></span><br><span class="line">               Encoding.UTF8.<span class="built_in">GetBytes</span>(info.name).Length + <span class="comment">//字符串具体字节数组的长度</span></span><br><span class="line">               <span class="built_in">sizeof</span>(<span class="type">short</span>) + <span class="comment">//atk short类型 2</span></span><br><span class="line">               <span class="built_in">sizeof</span>(<span class="type">bool</span>); <span class="comment">//sex bool类型 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.申明一个装载信息的字节数组容器</span></span><br><span class="line">byte[] playerBytes = <span class="keyword">new</span> byte[indexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将对象中的所有信息转为字节数组并放入该容器当中（可以利用数组中的CopeTo方法转存字节数组）</span></span><br><span class="line"><span class="comment">//CopyTo方法的第二个参数代表 从容器的第几个位置开始存储</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;<span class="comment">//从 playerBytes数组中的第几个位置去存储数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等级</span></span><br><span class="line">BitConverter.<span class="built_in">GetBytes</span>(info.lev).<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//姓名</span></span><br><span class="line">byte[] strBytes = Encoding.UTF8.<span class="built_in">GetBytes</span>(info.name);</span><br><span class="line"><span class="type">int</span> num = strBytes.Length;</span><br><span class="line"><span class="comment">//存储的是姓名转换成字节数组后 字节数组的长度</span></span><br><span class="line">BitConverter.<span class="built_in">GetBytes</span>(num).<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="comment">//存储字符串的字节数组</span></span><br><span class="line">strBytes.<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//攻击力</span></span><br><span class="line">BitConverter.<span class="built_in">GetBytes</span>(info.atk).<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += <span class="built_in">sizeof</span>(<span class="type">short</span>);</span><br><span class="line"><span class="comment">//性别</span></span><br><span class="line">BitConverter.<span class="built_in">GetBytes</span>(info.sex).<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += <span class="built_in">sizeof</span>(<span class="type">bool</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><p>BitConverter转换非字符串的类型的变量为字节数组</p><p>Encoding.UTF8转换字符串类型的变量为字节数组（注意：为了考虑反序列化，我们在转存2进制，序列化字符串之前，先序列化字符串字节数组的长度）</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region 字节数组转非字符串类型</span></span><br><span class="line"><span class="comment">//关键类：BitConverter</span></span><br><span class="line"><span class="comment">//所在命名空间：System</span></span><br><span class="line"><span class="comment">//主要作用：除字符串的其它常用类型和字节数组相互转换</span></span><br><span class="line">byte[] bytes = BitConverter.<span class="built_in">GetBytes</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> i = BitConverter.<span class="built_in">ToInt32</span>(bytes, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">print</span>(i);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 字节数组转字符串类型</span></span><br><span class="line"><span class="comment">//关键类：Encoding</span></span><br><span class="line"><span class="comment">//所在命名空间：System.Text</span></span><br><span class="line"><span class="comment">//主要作用：将字符串类型和字节数组相互转换，并且决定转换时使用的字符编码类型，网络通信时建议大家使用UTF-8类型</span></span><br><span class="line">byte[] bytes2 = Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;123123空间大撒了房间阿斯利康放大镜&quot;</span>);</span><br><span class="line">string str = Encoding.UTF8.<span class="built_in">GetString</span>(bytes2, <span class="number">0</span>, bytes2.Length);</span><br><span class="line"><span class="built_in">print</span>(str);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 如何将二进制数据转为一个类对象</span></span><br><span class="line"><span class="comment">//1.获取到对应的字节数组</span></span><br><span class="line">PlayerInfo info = <span class="keyword">new</span> <span class="built_in">PlayerInfo</span>();</span><br><span class="line">info.lev = <span class="number">10</span>;</span><br><span class="line">info.name = <span class="string">&quot;刘英博&quot;</span>;</span><br><span class="line">info.atk = <span class="number">88</span>;</span><br><span class="line">info.sex = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">byte[] playerBytes = info.<span class="built_in">GetBytes</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.将字节数组按照序列化时的顺序进行反序列化(将对应字节分组转换为对应类型变量)</span></span><br><span class="line">PlayerInfo info2 = <span class="keyword">new</span> <span class="built_in">PlayerInfo</span>();</span><br><span class="line"><span class="comment">//等级</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">info2.lev = BitConverter.<span class="built_in">ToInt32</span>(playerBytes, index);</span><br><span class="line">index += <span class="number">4</span>;</span><br><span class="line"><span class="built_in">print</span>(info2.lev);</span><br><span class="line"><span class="comment">//姓名的长度</span></span><br><span class="line"><span class="type">int</span> length = BitConverter.<span class="built_in">ToInt32</span>(playerBytes, index);</span><br><span class="line">index += <span class="number">4</span>;</span><br><span class="line"><span class="comment">//姓名字符串</span></span><br><span class="line">info2.name = Encoding.UTF8.<span class="built_in">GetString</span>(playerBytes, index, length);</span><br><span class="line">index += length;</span><br><span class="line"><span class="built_in">print</span>(info2.name);</span><br><span class="line"><span class="comment">//攻击力</span></span><br><span class="line">info2.atk = BitConverter.<span class="built_in">ToInt16</span>(playerBytes, index);</span><br><span class="line">index += <span class="number">2</span>;</span><br><span class="line"><span class="built_in">print</span>(info2.atk);</span><br><span class="line"><span class="comment">//性别</span></span><br><span class="line">info2.sex = BitConverter.<span class="built_in">ToBoolean</span>(playerBytes, index);</span><br><span class="line">index += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print</span>(info2.sex);</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><p>BitConverter转换字节数组为非字符串的类型的变量</p><p>Encoding.UTF8转换字节数组为字符串类型的变量（注意：先读长度，再读字符串）</p><h2 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h2><h3 id="Socket概述"><a href="#Socket概述" class="headerlink" title="Socket概述"></a>Socket概述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region Socket套接字的作用</span></span><br><span class="line"><span class="comment">//它是C#提供给我们用于网络通信的一个类（在其它语言当中也有对应的Socket类）</span></span><br><span class="line"><span class="comment">//类名：Socket</span></span><br><span class="line"><span class="comment">//命名空间：System.Net.Sockets</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Socket套接字是支持TCP/IP网络通信的基本操作单位</span></span><br><span class="line"><span class="comment">//一个套接字对象包含以下关键信息</span></span><br><span class="line"><span class="comment">//1.本机的IP地址和端口</span></span><br><span class="line"><span class="comment">//2.对方主机的IP地址和端口</span></span><br><span class="line"><span class="comment">//3.双方通信的协议信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个Sccket对象表示一个本地或者远程套接字信息</span></span><br><span class="line"><span class="comment">//它可以被视为一个数据通道</span></span><br><span class="line"><span class="comment">//这个通道连接与客户端和服务端之间</span></span><br><span class="line"><span class="comment">//数据的发送和接受均通过这个通道进行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般在制作长连接游戏时，我们会使用Socket套接字作为我们的通信方案</span></span><br><span class="line"><span class="comment">//我们通过它连接客户端和服务端，通过它来收发消息</span></span><br><span class="line"><span class="comment">//你可以把它抽象的想象成一根管子，插在客户端和服务端应用程序上，通过这个管子来传递交换信息</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region Socket的类型</span></span><br><span class="line"><span class="comment">//Socket套接字有3种不同的类型</span></span><br><span class="line"><span class="comment">//1.流套接字</span></span><br><span class="line"><span class="comment">//  主要用于实现TCP通信，提供了面向连接、可靠的、有序的、数据无差错且无重复的数据传输服务</span></span><br><span class="line"><span class="comment">//2.数据报套接字</span></span><br><span class="line"><span class="comment">//  主要用于实现UDP通信，提供了无连接的通信服务，数据包的长度不能大于32KB，不提供正确性检查，不保证顺序，可能出现重发、丢失等情况</span></span><br><span class="line"><span class="comment">//3.原始套接字（不常用，不深入讲解）</span></span><br><span class="line"><span class="comment">//  主要用于实现IP数据包通信，用于直接访问协议的较低层，常用于侦听和分析数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Socket的构造函数 我们可以申明不同类型的套接字</span></span><br><span class="line"><span class="comment">//Socket s = new Socket()</span></span><br><span class="line"><span class="comment">//参数一：AddressFamily 网络寻址 枚举类型，决定寻址方案</span></span><br><span class="line"><span class="comment">//  常用：</span></span><br><span class="line"><span class="comment">//  1.InterNetwork  IPv4寻址</span></span><br><span class="line"><span class="comment">//  2.InterNetwork6 IPv6寻址</span></span><br><span class="line"><span class="comment">//  做了解：</span></span><br><span class="line"><span class="comment">//  1.UNIX          UNIX本地到主机地址 </span></span><br><span class="line"><span class="comment">//  2.ImpLink       ARPANETIMP地址</span></span><br><span class="line"><span class="comment">//  3.Ipx           IPX或SPX地址</span></span><br><span class="line"><span class="comment">//  4.Iso           ISO协议的地址</span></span><br><span class="line"><span class="comment">//  5.Osi           OSI协议的地址</span></span><br><span class="line"><span class="comment">//  7.NetBios       NetBios地址</span></span><br><span class="line"><span class="comment">//  9.Atm           本机ATM服务地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数二：SocketType 套接字枚举类型，决定使用的套接字类型</span></span><br><span class="line"><span class="comment">//  常用：</span></span><br><span class="line"><span class="comment">//  1.Dgram         支持数据报，最大长度固定的无连接、不可靠的消息(主要用于UDP通信)</span></span><br><span class="line"><span class="comment">//  2.Stream        支持可靠、双向、基于连接的字节流（主要用于TCP通信）</span></span><br><span class="line"><span class="comment">//  做了解：</span></span><br><span class="line"><span class="comment">//  1.Raw           支持对基础传输协议的访问</span></span><br><span class="line"><span class="comment">//  2.Rdm           支持无连接、面向消息、以可靠方式发送的消息</span></span><br><span class="line"><span class="comment">//  3.Seqpacket     提供排序字节流的面向连接且可靠的双向传输</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数三：ProtocolType 协议类型枚举类型，决定套接字使用的通信协议</span></span><br><span class="line"><span class="comment">//  常用：</span></span><br><span class="line"><span class="comment">//  1.TCP           TCP传输控制协议</span></span><br><span class="line"><span class="comment">//  2.UDP           UDP用户数据报协议</span></span><br><span class="line"><span class="comment">//  做了解：</span></span><br><span class="line"><span class="comment">//  1.IP            IP网际协议</span></span><br><span class="line"><span class="comment">//  2.Icmp          Icmp网际消息控制协议</span></span><br><span class="line"><span class="comment">//  3.Igmp          Igmp网际组管理协议</span></span><br><span class="line"><span class="comment">//  4.Ggp           网关到网关协议</span></span><br><span class="line"><span class="comment">//  5.IPv4          Internet协议版本4</span></span><br><span class="line"><span class="comment">//  6.Pup           PARC通用数据包协议</span></span><br><span class="line"><span class="comment">//  7.Idp           Internet数据报协议</span></span><br><span class="line"><span class="comment">//  8.Raw           原始IP数据包协议</span></span><br><span class="line"><span class="comment">//  9.Ipx           Internet数据包交换协议</span></span><br><span class="line"><span class="comment">//  10.Spx          顺序包交换协议</span></span><br><span class="line"><span class="comment">//  11.IcmpV6       用于IPv6的Internet控制消息协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、3参数的常用搭配：</span></span><br><span class="line"><span class="comment">//       SocketType.Dgram  +  ProtocolType.Udp  = UDP协议通信（常用，主要学习）</span></span><br><span class="line"><span class="comment">//       SocketType.Stream  +  ProtocolType.Tcp  = TCP协议通信（常用，主要学习）</span></span><br><span class="line"><span class="comment">//       SocketType.Raw  +  ProtocolType.Icmp  = Internet控制报文协议（了解）</span></span><br><span class="line"><span class="comment">//       SocketType.Raw  +  ProtocolType.Raw  = 简单的IP包通信（了解）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们必须掌握的</span></span><br><span class="line"><span class="comment">//TCP流套接字</span></span><br><span class="line">Socket socketTcp = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//UDP数据报套接字</span></span><br><span class="line">Socket socketUdp = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region Socket的常用属性</span></span><br><span class="line"><span class="comment">//1.套接字的连接状态</span></span><br><span class="line"><span class="keyword">if</span>(socketTcp.Connected)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取套接字的类型</span></span><br><span class="line"><span class="built_in">print</span>(socketTcp.SocketType);</span><br><span class="line"><span class="comment">//3.获取套接字的协议类型</span></span><br><span class="line"><span class="built_in">print</span>(socketTcp.ProtocolType);</span><br><span class="line"><span class="comment">//4.获取套接字的寻址方案</span></span><br><span class="line"><span class="built_in">print</span>(socketTcp.AddressFamily);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.从网络中获取准备读取的数据数据量</span></span><br><span class="line"><span class="built_in">print</span>(socketTcp.Available);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.获取本机EndPoint对象(注意 ：IPEndPoint继承EndPoint)</span></span><br><span class="line"><span class="comment">//socketTcp.LocalEndPoint as IPEndPoint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.获取远程EndPoint对象</span></span><br><span class="line"><span class="comment">//socketTcp.RemoteEndPoint as IPEndPoint</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region Socket的常用方法</span></span><br><span class="line"><span class="comment">//1.主要用于服务端</span></span><br><span class="line"><span class="comment">//  1-1:绑定IP和端口</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>);</span><br><span class="line">socketTcp.<span class="built_in">Bind</span>(ipPoint);</span><br><span class="line"><span class="comment">//  1-2:设置客户端连接的最大数量</span></span><br><span class="line">socketTcp.<span class="built_in">Listen</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//  1-3:等待客户端连入</span></span><br><span class="line">socketTcp.<span class="built_in">Accept</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.主要用于客户端</span></span><br><span class="line"><span class="comment">//  1-1:连接远程服务端</span></span><br><span class="line">socketTcp.<span class="built_in">Connect</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;118.12.123.11&quot;</span>), <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.客户端服务端都会用的</span></span><br><span class="line"><span class="comment">//  1-1:同步发送和接收数据</span></span><br><span class="line"><span class="comment">//  1-2:异步发送和接收数据</span></span><br><span class="line"><span class="comment">//  1-3:释放连接并关闭Socket，先与Close调用</span></span><br><span class="line">socketTcp.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line"><span class="comment">//  1-4:关闭连接，释放所有Socket关联资源</span></span><br><span class="line">socketTcp.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><h4 id="服务端和客户端需要做什么"><a href="#服务端和客户端需要做什么" class="headerlink" title="服务端和客户端需要做什么"></a>服务端和客户端需要做什么</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123242.png" alt="image-20220521151533548"></p><h4 id="TCP协议三次握手的体现"><a href="#TCP协议三次握手的体现" class="headerlink" title="TCP协议三次握手的体现"></a>TCP协议三次握手的体现</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123581.png" alt="image-20220521151638515"></p><h4 id="TCP协议四次挥手的体现"><a href="#TCP协议四次挥手的体现" class="headerlink" title="TCP协议四次挥手的体现"></a>TCP协议四次挥手的体现</h4><p><img src="/Users/liuyingbo/Library/Application Support/typora-user-images/image-20220521151714969.png" alt="image-20220521151714969"></p><h4 id="TCP基本API"><a href="#TCP基本API" class="headerlink" title="TCP基本API"></a>TCP基本API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region 实现服务端基本逻辑</span></span><br><span class="line"><span class="comment">//1.创建套接字Socket（TCP）</span></span><br><span class="line">Socket socketTcp = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line"><span class="comment">//2.用Bind方法将套接字与本地地址绑定</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>);</span><br><span class="line">    socketTcp.<span class="built_in">Bind</span>(ipPoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;绑定报错&quot;</span> + e.Message);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.用Listen方法监听</span></span><br><span class="line">socketTcp.<span class="built_in">Listen</span>(<span class="number">1024</span>);</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;服务端绑定监听结束，等待客户端连入&quot;</span>);</span><br><span class="line"><span class="comment">//4.用Accept方法等待客户端连接</span></span><br><span class="line"><span class="comment">//5.建立连接，Accept返回新套接字</span></span><br><span class="line">Socket socketClient = socketTcp.<span class="built_in">Accept</span>();</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;有客户端连入了&quot;</span>);</span><br><span class="line"><span class="comment">//6.用Send和Receive相关方法收发数据</span></span><br><span class="line"><span class="comment">//发送</span></span><br><span class="line">socketClient.<span class="built_in">Send</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;欢迎连入服务端&quot;</span>));</span><br><span class="line"><span class="comment">//接受</span></span><br><span class="line">byte[] result = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//返回值为接受到的字节数</span></span><br><span class="line"><span class="type">int</span> receiveNum = socketClient.<span class="built_in">Receive</span>(result);</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;接受到了&#123;0&#125;发来的消息：&#123;1&#125;&quot;</span>,</span><br><span class="line">    socketClient.RemoteEndPoint.<span class="built_in">ToString</span>(),</span><br><span class="line">    Encoding.UTF8.<span class="built_in">GetString</span>(result, <span class="number">0</span>, receiveNum));</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.用Shutdown方法释放连接</span></span><br><span class="line">socketClient.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line"><span class="comment">//8.关闭套接字</span></span><br><span class="line">socketClient.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 实现客户端基本逻辑</span></span><br><span class="line"><span class="comment">//1.创建套接字Socket</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line"><span class="comment">//2.用Connect方法与服务端相连</span></span><br><span class="line"><span class="comment">//确定服务端的IP和端口</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    socket.<span class="built_in">Connect</span>(ipPoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (SocketException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.ErrorCode == <span class="number">10061</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;服务器拒绝连接&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;连接服务器失败&quot;</span> + e.ErrorCode);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.用Send和Receive相关方法收发数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">byte[] receiveBytes = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> receiveNum = socket.<span class="built_in">Receive</span>(receiveBytes);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;收到服务端发来的消息：&quot;</span> + Encoding.UTF8.<span class="built_in">GetString</span>(receiveBytes, <span class="number">0</span>, receiveNum));</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">socket.<span class="built_in">Send</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;你好，我是客户端&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.用Shutdown方法释放连接</span></span><br><span class="line">socket.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line"><span class="comment">//5.关闭套接字</span></span><br><span class="line">socket.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h4 id="如何区分消息"><a href="#如何区分消息" class="headerlink" title="如何区分消息"></a>如何区分消息</h4><p>为发送的信息添加标识，比如添加消息ID</p><p>在所有发送的消息的头部加上消息ID(int、short、byte、long都可以，根据实际情况选择)</p><p>举例说明：</p><p>如果选用int类型作为消息ID的类型</p><p>前4个字节为消息ID</p><p>后面的字节为数据类的内容</p><p>####<strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></p><p>这样每次收到消息时，先把前4个字节取出来解析为消息ID</p><p>再根据ID进行消息反序列化即可</p><h4 id="分包、黏包"><a href="#分包、黏包" class="headerlink" title="分包、黏包"></a>分包、黏包</h4><h5 id="什么是分包、黏包？"><a href="#什么是分包、黏包？" class="headerlink" title="什么是分包、黏包？"></a>什么是分包、黏包？</h5><p>分包、黏包指在网络通信中由于各种因素（网络环境、API规则等）造成的消息与消息之间出现的两种状态</p><p>分包：一个消息分成了多个消息进行发送</p><p>黏包：一个消息和另一个消息黏在了一起</p><p>注意：分包和黏包可能同时发生</p><h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><p>为消息添加头部，头部记录消息的长度</p><p>当我们接收到消息时，通过消息长度来判断是否分包、黏包</p><p>对消息进行拆分处理、合并处理</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123236.png" alt="分包黏包解决方案图"></p><h4 id="心跳消息"><a href="#心跳消息" class="headerlink" title="心跳消息"></a>心跳消息</h4><p>客户端主动断开连接会调用socket的 ShutDown和Close方法，但是通过调用这两个方法后 服务器端无法得知客户端已经主动断开</p><p>客户端尝试使用Disconnect方法主动断开连接，Socket当中有一个专门在客户端使用的方法，客户端调用该方法和服务器端断开连接</p><p>服务器端可以通过Conected属性判断连接状态决定是否释放Socket</p><p>但是由于服务器端Conected变量表示的是上一次收发消息是否成功，所以服务器端无法准确判断客户端的连接状态，因此 我们需要自定义一条退出消息 用于准确断开和客户端之间的连接</p><h5 id="什么是心跳消息？"><a href="#什么是心跳消息？" class="headerlink" title="什么是心跳消息？"></a>什么是心跳消息？</h5><p>所谓心跳消息，就是在长连接中，客户端和服务端之间定期发送的一种特殊的数据包，用于通知对方自己还在线，以确保长连接的有效性</p><p>由于其发送的时间间隔往往是固定的持续的，就像是心跳一样一直存在，所以我们称之为心跳消息</p><h5 id="为什么需要心跳消息？"><a href="#为什么需要心跳消息？" class="headerlink" title="为什么需要心跳消息？"></a>为什么需要心跳消息？</h5><p>1.避免非正常关闭客户端时，服务器无法正常收到关闭连接消息，通过心跳消息我们可以自定义超时判断，如果超时没有收到客户端消息，证明客户端已经断开连接</p><p>2.避免客户端长期不发送消息，防火墙或者路由器会断开连接，我们可以通过心跳消息一直保持活跃状态</p><h5 id="实现心跳消息"><a href="#实现心跳消息" class="headerlink" title="实现心跳消息"></a>实现心跳消息</h5><p>客户端：定时发送消息</p><p>服务器：不停检测上次收到某客户端消息的时间，如果超时则认为连接已经断开</p><p>心跳消息是长连接项目中必备的一套逻辑规则，通过它可以帮助我们在服务器端及时的释放掉失效的socket，可以有效避免当客户端非正常关闭时，服务器端不能及时判断连接已断开</p><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><h4 id="服务端和客户端需要做什么-1"><a href="#服务端和客户端需要做什么-1" class="headerlink" title="服务端和客户端需要做什么"></a>服务端和客户端需要做什么</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123022.png" alt="image-20220521160007101"></p><h4 id="UDP相对TCP的区别"><a href="#UDP相对TCP的区别" class="headerlink" title="UDP相对TCP的区别"></a>UDP相对TCP的区别</h4><p><img src="/Users/liuyingbo/Library/Application Support/typora-user-images/image-20220521160026008.png" alt="image-20220521160026008"></p><h4 id="UDP的分包、黏包问题"><a href="#UDP的分包、黏包问题" class="headerlink" title="UDP的分包、黏包问题"></a>UDP的分包、黏包问题</h4><h5 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h5><p>UDP本身作为无连接的不可靠的传输协议（适合频繁发送较小的数据包），不会对数据包进行合并发送，一端发送什么数据，直接就发出去了，他不会对数据合并，因此在UDP当中不会出现黏包问题（除非你手动进行黏包）</p><h5 id="分包问题"><a href="#分包问题" class="headerlink" title="分包问题"></a>分包问题</h5><p>由于UDP是不可靠的连接，消息传递过程中可能出现无序、丢包等情况，所以如果允许UDP进行分包，那后果将会是灾难性的，比如分包的后半段丢包或者比上半段先发来，我们在处理消息时将会非常困难，因此为了避免其分包，我们建议在发送UDP消息时控制消息的大小在MTU（最大传输单元）范围内</p><p>MTU（Maximum Transmission Unit）最大传输单元，用来通知对方所能接受数据服务单元的最大尺寸</p><p>不同操作系统会提供用户一个默认值</p><p>以太网和802.3对数据帧的长度限制，其最大值分别是1500字节和1492字节</p><p>由于UDP包本身带有一些信息，因此建议：</p><p>1.局域网环境下：1472字节以内（1500减去UDP头部28为1472）</p><p>2.互联网环境下：548字节以内（老的ISP拨号网络的标准值为576减去UDP头部28为548）</p><p>只要遵守这个规则，就不会出现自动分包的情况</p><p>如果想要发送的消息确实比较大，要大于548字节或1472字节这个限制呢？比如我们要发一个5000字节的数据，他是一条完整消息，我们可以进行手动分包，将5000拆分成多个消息，每个消息不超过限制，但是手动分包的前提是要解决UDP的丢包和无序问题，我们可以将不可靠的UDP通信实现为可靠的UDP通信</p><p>比如：在消息中加入序号、消息总包数、自己的包ID、长度等等信息，并且实现消息确认、消息重发等功能</p><h4 id="UDP基本API"><a href="#UDP基本API" class="headerlink" title="UDP基本API"></a>UDP基本API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region 实现UDP服务端通信 收发字符串</span></span><br><span class="line"><span class="comment">//1.创建套接字</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line"><span class="comment">//2.绑定本机地址</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8081</span>);</span><br><span class="line">socket.<span class="built_in">Bind</span>(ipPoint);</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;服务器开启&quot;</span>);</span><br><span class="line"><span class="comment">//3.接受消息</span></span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[<span class="number">512</span>];</span><br><span class="line"><span class="comment">//这个变量主要是用来记录 谁发的信息给你 传入函数后 在内部 它会帮助我们进行赋值</span></span><br><span class="line">EndPoint remoteIpPoint2 = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.Any, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> length = socket.<span class="built_in">ReceiveFrom</span>(bytes, ref remoteIpPoint2);</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;IP:&quot;</span> + (remoteIpPoint2 as IPEndPoint).Address.<span class="built_in">ToString</span>() +</span><br><span class="line">    <span class="string">&quot;port:&quot;</span> + (remoteIpPoint2 as IPEndPoint).Port +</span><br><span class="line">    <span class="string">&quot;发来了&quot;</span> +</span><br><span class="line">    Encoding.UTF8.<span class="built_in">GetString</span>(bytes, <span class="number">0</span>, length));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.发送到指定目标</span></span><br><span class="line"><span class="comment">//由于我们先收 所以 我们已经知道谁发了消息给我 我直接发给它就行了</span></span><br><span class="line">socket.<span class="built_in">SendTo</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;欢迎发送消息给服务器&quot;</span>), remoteIpPoint2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.释放关闭</span></span><br><span class="line">socket.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line">socket.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 实现UDP客户端通信 收发字符串</span></span><br><span class="line"><span class="comment">//1.创建套接字</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.绑定本机地址</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>);</span><br><span class="line">socket.<span class="built_in">Bind</span>(ipPoint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.发送到指定目标</span></span><br><span class="line">IPEndPoint remoteIpPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8081</span>);</span><br><span class="line"><span class="comment">//指定要发送的字节数 和 远程计算机的 IP和端口</span></span><br><span class="line">socket.<span class="built_in">SendTo</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;我来了&quot;</span>), remoteIpPoint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.接受消息</span></span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[<span class="number">512</span>];</span><br><span class="line"><span class="comment">//这个变量主要是用来记录 谁发的信息给你 传入函数后 在内部 它会帮助我们进行赋值</span></span><br><span class="line">EndPoint remoteIpPoint2 = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.Any, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> length = socket.<span class="built_in">ReceiveFrom</span>(bytes, ref remoteIpPoint2);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;IP:&quot;</span> + (remoteIpPoint2 as IPEndPoint).Address.<span class="built_in">ToString</span>() +</span><br><span class="line">    <span class="string">&quot;port:&quot;</span> + (remoteIpPoint2 as IPEndPoint).Port +</span><br><span class="line">    <span class="string">&quot;发来了&quot;</span> +</span><br><span class="line">    Encoding.UTF8.<span class="built_in">GetString</span>(bytes, <span class="number">0</span>, length));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.释放关闭</span></span><br><span class="line">socket.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line">socket.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h2 id="文件传输FTP"><a href="#文件传输FTP" class="headerlink" title="文件传输FTP"></a>文件传输FTP</h2><h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3><h4 id="FTP是什么"><a href="#FTP是什么" class="headerlink" title="FTP是什么"></a>FTP是什么</h4><p>FTP（File Transfer Protocol）</p><p>文件传输协议，是支持Internet文件传输的各种规则所组成的集合，这些规则使Internet用户可以把文件从一台主机拷贝到另一台主机上，</p><p>除此之外，FTP还提供登录、目录查询以及其他会话控制等功能</p><p>说人话：FTP文件传输协议就是一个在网络中上传下载文件的一套规则</p><h4 id="FTP的工作原理"><a href="#FTP的工作原理" class="headerlink" title="FTP的工作原理"></a>FTP的工作原理</h4><p>划重点：FTP的本质是TCP通信</p><p>通过FTP传输文件，双发至少需要建立两个TCP连接</p><p>一个称为控制连接，用于传输FTP命令</p><p>一个称为数据连接，用于传输文件数据</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123585.png" alt="image-20220521174749538"></p><p>FTP的数据连接和控制连接方向一般是相反的</p><p>举例说明：</p><p>用户使用FTP客户端连接FTP服务区请求下载文件</p><p>控制连接方向：客户端主动连接服务器告知其下载命令</p><p>数据连接方向：服务端主动连接客户端下发数据</p><p>当客户端和FTP服务器建立控制连接后</p><p>需要告诉服务器采用那种传输模式</p><p>1.主动模式(Port模式)：服务器主动连接客户端，然后传输文件</p><p>2.被动模式(Passive模式)：客户端主动连接服务器，即控制连接和数据连接都由客户端发起</p><p>一般情况下主动模式会受到客户端防火墙影响，所以被动模式使用较多</p><p>在使用FTP进行数据传输时，有两种数据传输方式</p><p>1.ASCII传输方式</p><p>以ASCII编码方式传输数据，适用于传输，仅包含英文的命令和参数或者英文文本文件</p><p>2.二进制传输方式（建议使用该方式）</p><p>可以指定采用哪种编码传输命令和文件数据，如果传输的文件不是英文文件则应该采用该方式</p><p>一般情况下，使用FTP传输文件时，客户端必须先登录服务器，获得相应权限后才能上传或下载文件</p><p>服务器也可以允许用户匿名登录FTP，不需要都拥有一个合法账号</p><p>在实际学习过程中，我们并不需要利用FTP原理来实现FTP通信，FTP工作原理相关知识点，主要做了解</p><p>C#中实现了FTP通信需要用到的相关类</p><p>FtpWebRequest、FtpWebResponse、NetworkCredential</p><h3 id="搭建FTP服务器"><a href="#搭建FTP服务器" class="headerlink" title="搭建FTP服务器"></a>搭建FTP服务器</h3><p>在实际商业项目开发当中，如果需要用FTP来进行文件传输，那么FTP服务器的解决方案都是由后端程序员来完成的，不管它使用哪种方式来搭建FTP服务器，只要能正常上传下载内容并且保证安全性即可</p><p>可以使用Serv-U，具体方式自行百度</p><h3 id="FTP相关API"><a href="#FTP相关API" class="headerlink" title="FTP相关API"></a>FTP相关API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region NetworkCredential类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//NetworkCredential通信凭证类</span></span><br><span class="line"><span class="comment">//用于在Ftp文件传输时，设置账号密码</span></span><br><span class="line">NetworkCredential n = <span class="keyword">new</span> <span class="built_in">NetworkCredential</span>(<span class="string">&quot;liuyingbo&quot;</span>, <span class="string">&quot;liuyingbo123&quot;</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region FtpWebRequest类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//Ftp文件传输协议客户端操作类</span></span><br><span class="line"><span class="comment">//主要用于：上传、下载、删除服务器上的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要方法</span></span><br><span class="line"><span class="comment">//1.Create 创建新的WebRequest，用于进行Ftp相关操作</span></span><br><span class="line">FtpWebRequest req = FtpWebRequest.<span class="built_in">Create</span>(<span class="keyword">new</span> <span class="built_in">Uri</span>(<span class="string">&quot;ftp://127.0.0.1/Test.txt&quot;</span>)) as FtpWebRequest;</span><br><span class="line"><span class="comment">//2.Abort  如果正在进行文件传输，用此方法可以终止传输</span></span><br><span class="line">req.<span class="built_in">Abort</span>();</span><br><span class="line"><span class="comment">//3.GetRequestStream  获取用于上传的流</span></span><br><span class="line">Stream s = req.<span class="built_in">GetRequestStream</span>();</span><br><span class="line"><span class="comment">//4.GetResponse  返回FTP服务器响应</span></span><br><span class="line"><span class="comment">//FtpWebResponse res = req.GetResponse() as FtpWebResponse;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要成员</span></span><br><span class="line"><span class="comment">//1.Credentials 通信凭证，设置为NetworkCredential对象</span></span><br><span class="line">req.Credentials = n;</span><br><span class="line"><span class="comment">//2.KeepAlive bool值，当完成请求时是否关闭到FTP服务器的控制连接（默认为true，不关闭）</span></span><br><span class="line">req.KeepAlive = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//3.Method  操作命令设置</span></span><br><span class="line"><span class="comment">//  WebRequestMethods.Ftp类中的操作命令属性</span></span><br><span class="line"><span class="comment">//  DeleteFile  删除文件</span></span><br><span class="line"><span class="comment">//  DownloadFile    下载文件    </span></span><br><span class="line"><span class="comment">//  ListDirectory   获取文件简短列表</span></span><br><span class="line"><span class="comment">//  ListDirectoryDetails    获取文件详细列表</span></span><br><span class="line"><span class="comment">//  MakeDirectory   创建目录</span></span><br><span class="line"><span class="comment">//  RemoveDirectory 删除目录</span></span><br><span class="line"><span class="comment">//  UploadFile  上传文件</span></span><br><span class="line">req.Method = WebRequestMethods.Ftp.DownloadFile;</span><br><span class="line"><span class="comment">//4.UseBinary 是否使用2进制传输</span></span><br><span class="line">req.UseBinary = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//5.RenameTo    重命名</span></span><br><span class="line"><span class="comment">//req.RenameTo = &quot;myTest.txt&quot;;</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region FtpWebResponse类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//它是用于封装FTP服务器对请求的响应</span></span><br><span class="line"><span class="comment">//它提供操作状态以及从服务器下载数据</span></span><br><span class="line"><span class="comment">//我们可以通过FtpWebRequest对象中的GetResponse()方法获取</span></span><br><span class="line"><span class="comment">//当使用完毕时，要使用Close释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过它来真正的从服务器获取内容</span></span><br><span class="line">FtpWebResponse res = req.<span class="built_in">GetResponse</span>() as FtpWebResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重要方法：</span></span><br><span class="line"><span class="comment">//1.Close:释放所有资源</span></span><br><span class="line">res.<span class="built_in">Close</span>();</span><br><span class="line"><span class="comment">//2.GetResponseStream：返回从FTP服务器下载数据的流</span></span><br><span class="line">Stream stream = res.<span class="built_in">GetResponseStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//重要成员：</span></span><br><span class="line"><span class="comment">//1.ContentLength:接受到数据的长度</span></span><br><span class="line"><span class="built_in">print</span>(res.ContentLength);</span><br><span class="line"><span class="comment">//2.ContentType：接受数据的类型</span></span><br><span class="line"><span class="built_in">print</span>(res.ContentType);</span><br><span class="line"><span class="comment">//3.StatusCode:FTP服务器下发的最新状态码</span></span><br><span class="line"><span class="built_in">print</span>(res.StatusCode);</span><br><span class="line"><span class="comment">//4.StatusDescription:FTP服务器下发的状态代码的文本</span></span><br><span class="line"><span class="built_in">print</span>(res.StatusDescription);</span><br><span class="line"><span class="comment">//5.BannerMessage:登录前建立连接时FTP服务器发送的消息</span></span><br><span class="line"><span class="built_in">print</span>(res.BannerMessage);</span><br><span class="line"><span class="comment">//6.ExitMessage:FTP会话结束时服务器发送的消息</span></span><br><span class="line"><span class="comment">//7.LastModified:FTP服务器上的文件的上次修改日期和时间</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//通过C#提供的这3个类</span></span><br><span class="line"><span class="comment">//我们便可以完成客户端向FTP服务器</span></span><br><span class="line"><span class="comment">//操作文件的需求，比如</span></span><br><span class="line"><span class="comment">//上传、下载、删除文件</span></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><h4 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h4><p>HTTP（HyperText Transfer Protocol）</p><p>超文本传输协议，是因特网上应用最为广泛的一种网络传输协议。最初设计HTTP的，目的是为了提供一种发布和接收由文本文件组成的HTML页面的方法，后来发展到除了文本数据外，还可以传输图片、音频、视频、压缩文件以及各种程序文件等。</p><p>HTTP主要用于超文本传输，因此相对FTP显得更简单一些，目前常见的HTTP标准是HTTP/1.1.</p><p>说人话：HTTP超文本传输协议就是一个在网络中上传下载文件的一套规则</p><h4 id="HTTP的工作原理"><a href="#HTTP的工作原理" class="headerlink" title="HTTP的工作原理"></a>HTTP的工作原理</h4><p>划重点：HTTP的本质也是TCP通信</p><p>HTTP定义了Web客户端（一般指浏览器）如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。</p><p>HTTP客户端首先与服务器建立TCP连接，然后客户端通过套接字发送HTTP请求，并通过套接字接收HTTP响应，由于HTTP采用TCP传输数据，因此不会丢包、不会乱序。</p><p>HTTP的工作原理主要有以下三个特点</p><h5 id="HTTP是以TCP方式工作"><a href="#HTTP是以TCP方式工作" class="headerlink" title="HTTP是以TCP方式工作"></a>HTTP是以TCP方式工作</h5><p>在HTTP/1.0中，客户端和服务器建立TCP连接后，发送一个请求到服务器，服务器发送一个应答给客户端，然后立即断开TCP连接，他们的主要步骤为：</p><p>1.客户端与服务端建立TCP连接</p><p>2.客户端向服务端发出请求</p><p>3.若服务端接受请求，则回送响应码和所需的信息</p><p>4.客户端与服务端断开TCP连接</p><p>需要注意，HTTP/1.1 支持持久连接，即客户端和服务端建立连接后，可以发送请求和接收应答，然后迅速地发送另一个请求和接收另一个应答。</p><p>持久连接也使得在得到上一个请求的应答之前能够发送多个请求，这就是HTTP/1.1与HTTP/1.0的明显不同之处，除此之外，HTTP/1.1可以发送的请求类型也比HTTP/1.0多。</p><p>目前市面上的Web服务器软件和浏览器软件基本都是支持HTTP/1.1版本的，目前使用的基本上都是HTTP/1.1版本</p><h5 id="HTTP是无状态的"><a href="#HTTP是无状态的" class="headerlink" title="HTTP是无状态的"></a>HTTP是无状态的</h5><p>无状态指：客户端发送一次请求后，服务端并没有存储关于该客户端的任何状态信息，即使客户端再次请求同一个对象，服务端仍会重新发送这个对象，不会在意之前是否已经向客户端发送过这个对象</p><p>说人话：HTTP通信就是客户端要什么来什么，想要多少来多少，服务端不会因为你要过了而不给你，不会记录你要过的状态</p><h5 id="HTTP使用元信息作为标头"><a href="#HTTP使用元信息作为标头" class="headerlink" title="HTTP使用元信息作为标头"></a>HTTP使用元信息作为标头</h5><p>HTTP通过添加标头（header）的方式向服务端提供本次HTTP请求的相关信息，即在主要数据前添加一部分额外信息，称为元信息（metainformation）元信息里主要包含：传送的对象属于哪种类型，采用的是哪种编码等等</p><p>说人话：HTTP的元信息标头，类似我们讲解Socket通信时用于区分消息类型、处理分包黏包时，在消息体前方加的自定义信息。在HTTP协议中，它也定义了类似的规则，在头部包含了一些额外信息</p><h4 id="HTTP协议的请求类型和响应状态码"><a href="#HTTP协议的请求类型和响应状态码" class="headerlink" title="HTTP协议的请求类型和响应状态码"></a>HTTP协议的请求类型和响应状态码</h4><p>请求类型：</p><p>HTTP/1.0中：</p><p>GET、POST、HEAD</p><p>HTTP/1.1中：</p><p>GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</p><p>响应状态码：</p><p>1xx、2xx、3xx、4xx、5xx</p><div class="table-container"><table><thead><tr><th>请求方法名说明</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>请求获取特定的资源，比如请求一个Web页面或请求获取一个资源</td></tr><tr><td>POST</td><td>请求提交数据进行处理，比如请求上传一个文件</td></tr><tr><td>HEAD</td><td>请求获取和GET一致的内容，但是不会返回具体内容，只会返回消息头</td></tr><tr><td>PUT</td><td>向指定位置上传最新内容</td></tr><tr><td>DELETE</td><td>删除指定资源</td></tr><tr><td>OPTIONS</td><td>返回服务器针对特定资源支持的HTTP请求方法</td></tr><tr><td>TRACE</td><td>回显服务端收到的请求</td></tr><tr><td>CONNECT</td><td>预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table></div><p>每一种请求方法，其实就是在HTTP请求的头部信息包含的内容不同而已内容发送的格式为：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242131363.png" alt="image-20221124213110318"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242131974.png" alt="image-20221124213118941"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242131611.png" alt="image-20221124213123578"></p><p>客户端向服务端发送请求后，服务端会返回HTTP响应</p><p>HTTP响应的一般格式为：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242131203.png" alt="image-20221124213152161"></p><p>状态行中主要内容有：</p><p>\1. HTTP版本号</p><p>\2. 3位数字组成的状态码</p><p>1xx消息：请求已被服务端接收，继续处理</p><p>2xx成功：请求已成功被服务端理解并接收</p><p>3xx重定向：需要后续操作才能完成这一请求</p><p>4xx请求错误：请求含有语法错误或者无法被执行</p><p>5xx服务器错误：服务端在处理某个正确请求时发生错误</p><div class="table-container"><table><thead><tr><th>编号</th><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>找到资源，一切正常</td></tr><tr><td>304</td><td>NOT MODIFIED</td><td>资源在上次请求后没有任何修改（常用语缓存机制）</td></tr><tr><td>401</td><td>UNAUTHORIZED</td><td>客户端无权访问该资源，通常需要输入用户名和密码</td></tr><tr><td>403</td><td>FORBIDDEN</td><td>客户端未授权，通常是401后输入了错误用户名密码</td></tr><tr><td>404</td><td>NOT FOUND</td><td>指定位置不存在申请的资源</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>不支持请求的方法</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不能识别请求或者没有实现指定的请求</td></tr></tbody></table></div><h3 id="搭建HTTP服务器"><a href="#搭建HTTP服务器" class="headerlink" title="搭建HTTP服务器"></a>搭建HTTP服务器</h3><p>www.baidu.com</p><h3 id="C-中HTTP类"><a href="#C-中HTTP类" class="headerlink" title="C#中HTTP类"></a>C#中HTTP类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region HttpWebRequest类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//HttpWebRequest是主要用于发送客户端请求的类</span></span><br><span class="line"><span class="comment">//主要用于：发送HTTP客户端请求给服务器，可以进行消息通信、上传、下载等等操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要方法</span></span><br><span class="line"><span class="comment">//1.Create 创建新的WebRequest，用于进行HTTP相关操作</span></span><br><span class="line">HttpWebRequest req = HttpWebRequest.<span class="built_in">Create</span>(<span class="keyword">new</span> <span class="built_in">Uri</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/&quot;</span>)) as HttpWebRequest;</span><br><span class="line"><span class="comment">//2.Abort  如果正在进行文件传输，用此方法可以终止传输 </span></span><br><span class="line">req.<span class="built_in">Abort</span>();</span><br><span class="line"><span class="comment">//3.GetRequestStream  获取用于上传的流</span></span><br><span class="line">Stream s = req.<span class="built_in">GetRequestStream</span>();</span><br><span class="line"><span class="comment">//4.GetResponse  返回HTTP服务器响应</span></span><br><span class="line">HttpWebResponse res = req.<span class="built_in">GetResponse</span>() as HttpWebResponse;</span><br><span class="line"><span class="comment">//5.Begin/EndGetRequestStream 异步获取用于上传的流</span></span><br><span class="line"><span class="comment">//req.BeginGetRequestStream()</span></span><br><span class="line"><span class="comment">//6.Begin/EndGetResponse 异步获取返回的HTTP服务器响应</span></span><br><span class="line"><span class="comment">//req.BeginGetResponse()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要成员</span></span><br><span class="line"><span class="comment">//1.Credentials 通信凭证，设置为NetworkCredential对象</span></span><br><span class="line">req.Credentials = <span class="keyword">new</span> <span class="built_in">NetworkCredential</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//2.PreAuthenticate 是否随请求发送一个身份验证标头,一般需要进行身份验证时需要将其设置为true</span></span><br><span class="line">req.PreAuthenticate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Headers 构成标头的名称/值对的集合</span></span><br><span class="line"><span class="comment">//req.Headers</span></span><br><span class="line"><span class="comment">//4.ContentLength 发送信息的字节数 上传信息时需要先设置该内容长度</span></span><br><span class="line">req.ContentLength = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//5.ContentType 在进行POST请求时，需要对发送的内容进行内容类型的设置</span></span><br><span class="line"><span class="comment">//6.Method  操作命令设置</span></span><br><span class="line"><span class="comment">//  WebRequestMethods.Http类中的操作命令属性</span></span><br><span class="line"><span class="comment">//  Get     获取请求，一般用于获取数据</span></span><br><span class="line"><span class="comment">//  Post    提交请求，一般用于上传数据，同时可以获取</span></span><br><span class="line"><span class="comment">//  Head    获取和Get一致的内容，只是只会返回消息头，不会返回具体内容</span></span><br><span class="line"><span class="comment">//  Put     向指定位置上传最新内容</span></span><br><span class="line"><span class="comment">//  Connect 表示与代理一起使用的 HTTP CONNECT 协议方法，该代理可以动态切换到隧道</span></span><br><span class="line"><span class="comment">//  MkCol   请求在请求 URI（统一资源标识符）指定的位置新建集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//了解该类的更多信息</span></span><br><span class="line"><span class="comment">//https://docs.microsoft.com/zh-cn/dotnet/api/system.net.httpwebrequest?view=net-6.0</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region HttpWebResponse类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//它主要用于获取服务器反馈信息的类</span></span><br><span class="line"><span class="comment">//我们可以通过HttpWebRequest对象中的GetResponse()方法获取</span></span><br><span class="line"><span class="comment">//当使用完毕时，要使用Close释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要方法：</span></span><br><span class="line"><span class="comment">//1.Close:释放所有资源</span></span><br><span class="line"><span class="comment">//2.GetResponseStream：返回从FTP服务器下载数据的流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要成员：</span></span><br><span class="line"><span class="comment">//1.ContentLength:接受到数据的长度</span></span><br><span class="line"><span class="comment">//2.ContentType：接受数据的类型</span></span><br><span class="line"><span class="comment">//3.StatusCode:HTTP服务器下发的最新状态码</span></span><br><span class="line"><span class="comment">//4.StatusDescription:HTTP服务器下发的状态代码的文本</span></span><br><span class="line"><span class="comment">//5.BannerMessage:登录前建立连接时HTTP服务器发送的消息</span></span><br><span class="line"><span class="comment">//6.ExitMessage:HTTP会话结束时服务器发送的消息</span></span><br><span class="line"><span class="comment">//7.LastModified:HTTP服务器上的文件的上次修改日期和时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//了解该类的更多信息</span></span><br><span class="line"><span class="comment">//https://docs.microsoft.com/zh-cn/dotnet/api/system.net.httpwebresponse?view=net-6.0</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region NetworkCredential、Uri、Stream、FileStream类</span></span><br><span class="line"><span class="comment">//这些类我们在学习Ftp时已经使用过了</span></span><br><span class="line"><span class="comment">//在HTTP通讯时使用方式不变</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//Http相关通讯类的使用和Ftp非常类似</span></span><br><span class="line"><span class="comment">//只有一些细节上的区别</span></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h4 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h4><p>Get — 一般从指定的资源请求数据,主要用于获取数据</p><p>Post — 一般向指定的资源提交想要被处理的数据，主要用于上传数据</p><p>相同点:</p><p>Get和Post都可以传递一些额外的参数数据给服务端</p><p>不同点:</p><p>1.在传递参数时，Post相对Get更加的安全，因为Post看不到参数<br>    Get传递的参数都包含在连接中（URL资源定位地址），是暴露式的 ?参数名=参数值&amp;参数名=参数值<br>    Post传递的参数放在请求数据中，不会出现在URL中，是隐藏式的</p><p>2.Get在传递数据时有大小的限制，因为它主要是在连接中拼接参数，而URL的长度是有限制的（最大长度一般为2048个字符）<br>    Post在传递数据时没有限制</p><p>3.在浏览器中Get请求能被缓存，Post不能缓存</p><p>4.传输次数可能不同<br>    Get:  建立连接——&gt;请求行、请求头、请求数据一次传输——&gt;获取响应——&gt;断开连接<br>    Post: 建立连接——&gt;传输可能分两次——&gt;请求行，请求头第一次传输——&gt;请求数据第二次传输——&gt;获取响应——&gt;断开</p><p>但是由于他们的这些特点<br>我们在实际使用时建议Get用于获取，Post用于上传<br>如果想要传递一些不想暴露在外部的参数信息，建议使用Post，它更加的安全</p><h4 id="Post如何携带额外参数"><a href="#Post如何携带额外参数" class="headerlink" title="Post如何携带额外参数"></a>Post如何携带额外参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region Post如何携带额外参数</span></span><br><span class="line"><span class="comment">//关键点：将Content-Type设置为 application/x-www-form-urlencoded 键值对类型</span></span><br><span class="line">HttpWebRequest req = HttpWebRequest.<span class="built_in">Create</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/&quot;</span>) as HttpWebRequest;</span><br><span class="line">req.Method = WebRequestMethods.Http.Post;</span><br><span class="line">req.Timeout = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//设置上传的内容的类型</span></span><br><span class="line">req.ContentType = <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们要上传的数据</span></span><br><span class="line">string str = <span class="string">&quot;Name=liuyingbo&amp;ID=2&quot;</span>;</span><br><span class="line">byte[] bytes = Encoding.UTF8.<span class="built_in">GetBytes</span>(str);</span><br><span class="line"><span class="comment">//我们在上传之前一定要设置内容的长度</span></span><br><span class="line">req.ContentLength = bytes.Length;</span><br><span class="line"><span class="comment">//上传数据</span></span><br><span class="line">Stream stream = req.<span class="built_in">GetRequestStream</span>();</span><br><span class="line">stream.<span class="built_in">Write</span>(bytes, <span class="number">0</span>, bytes.Length);</span><br><span class="line">stream.<span class="built_in">Close</span>();</span><br><span class="line"><span class="comment">//发送数据 得到响应结果</span></span><br><span class="line">HttpWebResponse res = req.<span class="built_in">GetResponse</span>() as HttpWebResponse;</span><br><span class="line"><span class="built_in">print</span>(res.StatusCode);</span><br><span class="line"></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h4 id="ContentType类型"><a href="#ContentType类型" class="headerlink" title="ContentType类型"></a>ContentType类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region ContentType的常用类型</span></span><br><span class="line"><span class="comment">//ContentType的构成：</span></span><br><span class="line"><span class="comment">//内容类型;charset=编码格式;boundary=边界字符串</span></span><br><span class="line"><span class="comment">//text/html;charset=utf-8;boundary=自定义字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中内容类型有：</span></span><br><span class="line"><span class="comment">//文本类型text：</span></span><br><span class="line"><span class="comment">//text/plain 没有特定子类型就是它（重要）</span></span><br><span class="line"><span class="comment">//text/html</span></span><br><span class="line"><span class="comment">//text/css</span></span><br><span class="line"><span class="comment">//text/javascript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图片类型image：</span></span><br><span class="line"><span class="comment">//image/gif</span></span><br><span class="line"><span class="comment">//image/png</span></span><br><span class="line"><span class="comment">//image/jpeg</span></span><br><span class="line"><span class="comment">//image/bm</span></span><br><span class="line"><span class="comment">//image/webp</span></span><br><span class="line"><span class="comment">//image/x-icon</span></span><br><span class="line"><span class="comment">//image/vnd.microsoft.icon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//音频类型audio：</span></span><br><span class="line"><span class="comment">//audio/midi</span></span><br><span class="line"><span class="comment">//audio/mpeg</span></span><br><span class="line"><span class="comment">//audio/webm</span></span><br><span class="line"><span class="comment">//audio/ogg</span></span><br><span class="line"><span class="comment">//audio/wav</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视频类型video:</span></span><br><span class="line"><span class="comment">//video/webm</span></span><br><span class="line"><span class="comment">//video/ogg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制类型application:</span></span><br><span class="line"><span class="comment">//application/octet-stream 没有特定子类型就是它（重要）</span></span><br><span class="line"><span class="comment">//application/x-www-form-urlencoded 传递参数时使用键值对形式（重要）</span></span><br><span class="line"><span class="comment">//application/pkcs12</span></span><br><span class="line"><span class="comment">//application/xhtml+xml</span></span><br><span class="line"><span class="comment">//application/xml</span></span><br><span class="line"><span class="comment">//application/pdf</span></span><br><span class="line"><span class="comment">//application/vnd.mspowerpoint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复合内容multipart:</span></span><br><span class="line"><span class="comment">//multipart/form-data  复合内容，有多种内容组合（重要）</span></span><br><span class="line"><span class="comment">//multipart/byteranges  特殊的复合文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关于ContentType更多内容可以前往</span></span><br><span class="line"><span class="comment">//https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type</span></span><br><span class="line"><span class="comment">//关于媒体类型可以前往</span></span><br><span class="line"><span class="comment">//https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region ContentType中对于我们来说重要的类型</span></span><br><span class="line"><span class="comment">//1.通用2进制类型</span></span><br><span class="line"><span class="comment">//application/octet-stream</span></span><br><span class="line"><span class="comment">//2.通用文本类型</span></span><br><span class="line"><span class="comment">//text/plain </span></span><br><span class="line"><span class="comment">//3.键值对参数</span></span><br><span class="line"><span class="comment">//application/x-www-form-urlencoded</span></span><br><span class="line"><span class="comment">//4.复合类型（传递的信息有多种类型组成,比如有键值对参数,有文件信息等等,上传资源服务器时需要用该类型）</span></span><br><span class="line"><span class="comment">//multipart/form-data</span></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h3 id="Unity中的HTTP类"><a href="#Unity中的HTTP类" class="headerlink" title="Unity中的HTTP类"></a>Unity中的HTTP类</h3><h4 id="WWW类"><a href="#WWW类" class="headerlink" title="WWW类"></a>WWW类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region WWW类的作用</span></span><br><span class="line"><span class="comment">//WWW是Unity提供给我们简单的访问网页的类</span></span><br><span class="line"><span class="comment">//我们可以通过该类下载和上传一些数据</span></span><br><span class="line"><span class="comment">//在使用http协议时，默认的请求类型是Get，如果想要Post上传，需要配合下节课学习的WWWFrom类使用</span></span><br><span class="line"><span class="comment">//它主要支持的协议</span></span><br><span class="line"><span class="comment">//1.http://和https:// 超文本传输协议</span></span><br><span class="line"><span class="comment">//2.ftp:// 文件传输协议（但仅限于匿名下载）</span></span><br><span class="line"><span class="comment">//3.file:// 本地文件传输协议，可以使用该协议异步加载本地文件（PC、IOS、Android都支持）</span></span><br><span class="line"><span class="comment">//我们本节课主要学习利用WWW来进行数据的下载或加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//1.该类一般配合协同程序使用</span></span><br><span class="line"><span class="comment">//2.该类在较新Unity版本中会提示过时，但是仍可以使用，新版本将其功能整合进了UnityWebRequest类（之后讲解）</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region WWW类的常用方法和变量</span></span><br><span class="line"><span class="meta">#region 常用方法</span></span><br><span class="line"><span class="comment">//1.WWW：构造函数，用于创建一个WWW请求</span></span><br><span class="line">WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/test.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//2.GetAudioClip：从下载数据返回一个音效切片AudioClip对象</span></span><br><span class="line"><span class="comment">//www.GetAudioClip()</span></span><br><span class="line"><span class="comment">//3.LoadImageIntoTexture：用下载数据中的图像来替换现有的一个Texture2D对象</span></span><br><span class="line"><span class="comment">//Texture2D tex = new Texture2D(100, 100);</span></span><br><span class="line"><span class="comment">//www.LoadImageIntoTexture(tex);</span></span><br><span class="line"><span class="comment">//4.LoadFromCacheOrDownload：从缓存加载AB包对象，如果该包不在缓存则自动下载存储到缓存中，以便以后直接从本地缓存中加载</span></span><br><span class="line"><span class="comment">//WWW.LoadFromCacheOrDownload(&quot;http://192.168.50.109:8000/Http_Server/test.assetbundle&quot;, 1);</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 常用变量</span></span><br><span class="line"><span class="comment">//1.assetBundle：如果加载的数据是AB包，可以通过该变量直接获取加载结果</span></span><br><span class="line"><span class="comment">//www.assetBundle</span></span><br><span class="line"><span class="comment">//2.audioClip：如果加载的数据是音效切片文件，可以通过该变量直接获取加载结果</span></span><br><span class="line"><span class="comment">//www.GetAudioClip</span></span><br><span class="line"><span class="comment">//3.bytes：以字节数组的形式获取加载到的内容</span></span><br><span class="line"><span class="comment">//www.bytes</span></span><br><span class="line"><span class="comment">//4.bytesDownloaded：过去已下载的字节数</span></span><br><span class="line"><span class="comment">//www.bytesDownloaded</span></span><br><span class="line"><span class="comment">//5.error：返回一个错误消息，如果下载期间出现错误，可以通过它获取错误信息</span></span><br><span class="line"><span class="comment">//www.error != null</span></span><br><span class="line"><span class="comment">//6.isDone：判断下载是否已经完成</span></span><br><span class="line"><span class="comment">//www.isDone</span></span><br><span class="line"><span class="comment">//7.movie：如果下载的视频，可以获取一个MovieTexture类型结果</span></span><br><span class="line"><span class="comment">//www.GetMovieTexture()</span></span><br><span class="line"><span class="comment">//8.progress:下载进度</span></span><br><span class="line"><span class="comment">//www.progress</span></span><br><span class="line"><span class="comment">//9.text：如果下载的数据是字符串，以字符串的形式返回内容</span></span><br><span class="line"><span class="comment">//www.text</span></span><br><span class="line"><span class="comment">//10.texture：如果下载的数据是图片，以Texture2D的形式返回加载结果</span></span><br><span class="line"><span class="comment">//www.texture</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 利用WWW类来异步下载或加载文件</span></span><br><span class="line"><span class="meta">#region 1.下载HTTP服务器上的内容</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadHttp</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 2.下载FTP服务器上的内容（FTP服务器一定要支持匿名账户）</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadFtp</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 3.本地内容加载（一般移动平台加载数据都会使用该方式）</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadLocal</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//Unity中的WWW类比使用C#中的Http相关类更加的方便</span></span><br><span class="line"><span class="comment">//建议大家使用Unity当中为我们封装好的类来处理下载、加载相关逻辑</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">DownLoadHttp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建WWW对象</span></span><br><span class="line">    WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F8cc2b9a7868b266800f98d42fc5d257021e75103.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1654745686&amp;t=b7691b6e546367610e4331039d1a10ec&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.就是等待加载结束</span></span><br><span class="line">    <span class="keyword">while</span> (!www.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">        <span class="built_in">print</span>(www.progress);</span><br><span class="line">        yield <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">    <span class="built_in">print</span>(www.progress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用加载结束后的资源</span></span><br><span class="line">    <span class="keyword">if</span> (www.error == null)</span><br><span class="line">    &#123;</span><br><span class="line">        image.texture = www.texture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(www.error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">DownLoadFtp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建WWW对象</span></span><br><span class="line">    WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;ftp://127.0.0.1/test.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.就是等待加载结束</span></span><br><span class="line">    <span class="keyword">while</span> (!www.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">        <span class="built_in">print</span>(www.progress);</span><br><span class="line">        yield <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">    <span class="built_in">print</span>(www.progress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用加载结束后的资源</span></span><br><span class="line">    <span class="keyword">if</span> (www.error == null)</span><br><span class="line">    &#123;</span><br><span class="line">        image.texture = www.texture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(www.error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">DownLoadLocal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建WWW对象</span></span><br><span class="line">    WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;file://&quot;</span> + Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.就是等待加载结束</span></span><br><span class="line">    <span class="keyword">while</span> (!www.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">        <span class="built_in">print</span>(www.progress);</span><br><span class="line">        yield <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">    <span class="built_in">print</span>(www.progress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用加载结束后的资源</span></span><br><span class="line">    <span class="keyword">if</span> (www.error == null)</span><br><span class="line">    &#123;</span><br><span class="line">        image.texture = www.texture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(www.error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WWWForm类"><a href="#WWWForm类" class="headerlink" title="WWWForm类"></a>WWWForm类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region WWWFrom类的作用</span></span><br><span class="line"><span class="comment">//上节课学习了使用WWW类来下载数据</span></span><br><span class="line"><span class="comment">//如果想要使用WWW上传数据时，就需要配合WWWFrom类进行使用了</span></span><br><span class="line"><span class="comment">//而WWWFrom主要就是用于集成数据的，我们可以设置上传的参数或者2进制数据</span></span><br><span class="line"><span class="comment">//当结合WWWFrom上传数据时</span></span><br><span class="line"><span class="comment">//它主要用到的请求类型是Post</span></span><br><span class="line"><span class="comment">//它使用Http协议进行上传处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//使用WWW结合WWWFrom上传数据一般需要配合后端程序制定上传规则</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region WWWFrom类的常用方法和变量</span></span><br><span class="line"><span class="comment">//该类当中我们主要就使用方法，相关变量很少使用，我们主要就着重讲解方法</span></span><br><span class="line"><span class="comment">//1.WWWForm：构造函数</span></span><br><span class="line">WWWForm data = <span class="keyword">new</span> <span class="built_in">WWWForm</span>();</span><br><span class="line"><span class="comment">//2.AddBinaryData：添加二进制数据</span></span><br><span class="line"><span class="comment">//data.AddBinaryData()</span></span><br><span class="line"><span class="comment">//3.AddField：添加字段</span></span><br><span class="line"><span class="comment">//data.AddField()</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region WWW结合WWWFrom对象来异步上传数据</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">UpLoadData</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//WWW结合WWWFrom上传数据</span></span><br><span class="line"><span class="comment">//需要配合后端服务器来指定上传规则</span></span><br><span class="line"><span class="comment">//也就是说我们上传的数据，后端需要知道收到数据后应该如何处理</span></span><br><span class="line"><span class="comment">//通过这种方式我们没办法像C#类当中完成文件的上传</span></span><br><span class="line"><span class="comment">//但是该方式非常适合用于制作短连接游戏的前端网络层</span></span><br><span class="line"><span class="comment">//我们可以对WWW进行二次封装，专门用于上传自定义消息给对应的Web服务器</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">UpLoadData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WWWForm data = <span class="keyword">new</span> <span class="built_in">WWWForm</span>();</span><br><span class="line">        <span class="comment">//上传的数据 对应的后端程序 必须要有处理的规则 才能生效</span></span><br><span class="line">        data.<span class="built_in">AddField</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;liuyingbo&quot;</span>, Encoding.UTF8);</span><br><span class="line">        data.<span class="built_in">AddField</span>(<span class="string">&quot;Age&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        data.<span class="built_in">AddBinaryData</span>(<span class="string">&quot;file&quot;</span>, File.<span class="built_in">ReadAllBytes</span>(Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>), <span class="string">&quot;testtest.png&quot;</span>, <span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line">        WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">        yield <span class="keyword">return</span> www;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (www.error == null)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">            <span class="comment">//www.bytes</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;上传失败&quot;</span> + www.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region UnityWebRequest是什么？</span></span><br><span class="line"><span class="comment">//UnityWebRequest是一个Unity提供的一个模块化的系统类</span></span><br><span class="line"><span class="comment">//用于构成HTTP请求和处理HTTP响应</span></span><br><span class="line"><span class="comment">//它主要目标是让Unity游戏和Web服务端进行交互</span></span><br><span class="line"><span class="comment">//它将之前WWW的相关功能都集成在了其中</span></span><br><span class="line"><span class="comment">//所以新版本中都建议使用UnityWebRequest类来代替WWW类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//它在使用上和WWW很类似</span></span><br><span class="line"><span class="comment">//主要的区别就是UnityWebRequest把下载下来的数据处理单独提取出来了</span></span><br><span class="line"><span class="comment">//我们可以根据自己的需求选择对应的数据处理对象来获取数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//1.UnityWebRequest和WWW一样，需要配合协同程序使用</span></span><br><span class="line"><span class="comment">//2.UnityWebRequest和WWW一样，支持http、ftp、file协议下载或加载资源</span></span><br><span class="line"><span class="comment">//3.UnityWebRequest能够上传文件到HTTP资源服务器</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region UnityWebRequest类的常用操作</span></span><br><span class="line"><span class="comment">//1.使用Get请求获取文本或二进制数据</span></span><br><span class="line"><span class="comment">//2.使用Get请求获取纹理数据</span></span><br><span class="line"><span class="comment">//3.使用Get请求获取AB包数据</span></span><br><span class="line"><span class="comment">//4.使用Post请求发送数据</span></span><br><span class="line"><span class="comment">//5.使用Put请求上传数据</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnityWebRequest req = UnityWebRequest.<span class="built_in">Get</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//就会等待 服务器端响应后 断开连接后 再继续执行后面的内容</span></span><br><span class="line">    yield <span class="keyword">return</span> req.<span class="built_in">SendWebRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果处理成功 结果就是成功枚举</span></span><br><span class="line">    <span class="keyword">if</span>(req.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文本 字符串</span></span><br><span class="line">        <span class="built_in">print</span>(req.downloadHandler.text);</span><br><span class="line">        <span class="comment">//字节数组</span></span><br><span class="line">        byte[] bytes = req.downloadHandler.data;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;字节数组长度&quot;</span> + bytes.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;获取失败:&quot;</span> + req.result + req.error + req.responseCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结 </span></span><br><span class="line"><span class="comment">//UnityWebRequest使用上和WWW类很类似</span></span><br><span class="line"><span class="comment">//我们需要注意的是</span></span><br><span class="line"><span class="comment">//1.获取文本或二进制数据时</span></span><br><span class="line"><span class="comment">//  使用UnityWebRequest.Get</span></span><br><span class="line"><span class="comment">//2.获取纹理图片数据时</span></span><br><span class="line"><span class="comment">//  使用UnityWebRequestTexture.GetTexture</span></span><br><span class="line"><span class="comment">//  以及DownloadHandlerTexture.GetContent</span></span><br><span class="line"><span class="comment">//3.获取AB包数据时</span></span><br><span class="line"><span class="comment">//  使用UnityWebRequestAssetBundle.GetAssetBundle</span></span><br><span class="line"><span class="comment">//  以及DownloadHandlerAssetBundle.GetContent</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 上传相关数据类</span></span><br><span class="line"><span class="comment">//父接口</span></span><br><span class="line"><span class="comment">//IMultipartFormSection</span></span><br><span class="line"><span class="comment">//数据相关类都继承该接口</span></span><br><span class="line"><span class="comment">//我们可以用父类装子类</span></span><br><span class="line">List&lt;IMultipartFormSection&gt; dataList = <span class="keyword">new</span> <span class="built_in">List</span>&lt;IMultipartFormSection&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类数据</span></span><br><span class="line"><span class="comment">//MultipartFormDataSection</span></span><br><span class="line"><span class="comment">//1.二进制字节数组</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;123123123123123&quot;</span>)));</span><br><span class="line"><span class="comment">//2.字符串</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(<span class="string">&quot;12312312312312312dsfasdf&quot;</span>));</span><br><span class="line"><span class="comment">//3.参数名，参数值（字节数组，字符串），编码类型，资源类型（常用）</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;liuyingbo&quot;</span>, Encoding.UTF8, <span class="string">&quot;application/....&quot;</span>));</span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(<span class="string">&quot;Msg&quot;</span>, <span class="keyword">new</span> byte[<span class="number">1024</span>], <span class="string">&quot;appl.....&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipartFormFileSection</span></span><br><span class="line"><span class="comment">//1.字节数组</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(File.<span class="built_in">ReadAllBytes</span>(Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.文件名，字节数组（常用）</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;上传的文件.png&quot;</span>, File.<span class="built_in">ReadAllBytes</span>(Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>)));</span><br><span class="line"><span class="comment">//3.字符串数据，文件名（常用）</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;12312313212312&quot;</span>, <span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="comment">//4.字符串数据，编码格式，文件名（常用）</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;12312313212312&quot;</span>, Encoding.UTF8, <span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.表单名，字节数组，文件名，文件类型</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;file&quot;</span>, <span class="keyword">new</span> byte[<span class="number">1024</span>], <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//6.表单名，字符串数据，编码格式，文件名</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;123123123&quot;</span>, Encoding.UTF8, <span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 知识点二 Post发送相关</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">Upload</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 知识点三 Put上传相关</span></span><br><span class="line"><span class="comment">//注意：Put请求类型不是所有的web服务器都认，必须要服务器处理该请求类型那么才能有相应</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//我们可以利用Post上传数据或上传文件</span></span><br><span class="line"><span class="comment">//Put主要用于上传文件，但是必须资源服务器支持Put请求类型</span></span><br><span class="line"><span class="comment">//为了通用性，我们可以统一使用Post请求类型进行数据和资源的上传</span></span><br><span class="line"><span class="comment">//它的使用和之前的WWW类似，只要前后端制定好规则就可以相互通信了</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">Upload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//准备上传的数据 </span></span><br><span class="line">    List&lt;IMultipartFormSection&gt; data = <span class="keyword">new</span> <span class="built_in">List</span>&lt;IMultipartFormSection&gt;();</span><br><span class="line">    <span class="comment">//键值对相关的 信息 字段数据</span></span><br><span class="line">    data.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;liuyingbo&quot;</span>));</span><br><span class="line">    <span class="comment">//PlayerMsg msg = new PlayerMsg();</span></span><br><span class="line">    <span class="comment">//data.Add(new MultipartFormDataSection(&quot;Msg&quot;, msg.Writing()));</span></span><br><span class="line">    <span class="comment">//添加一些文件上传文件</span></span><br><span class="line">    <span class="comment">//传2进制文件</span></span><br><span class="line">    data.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;TestTest123.png&quot;</span>, File.<span class="built_in">ReadAllBytes</span>(Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>)));</span><br><span class="line">    <span class="comment">//传文本文件</span></span><br><span class="line">    data.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;123123123123123&quot;</span>, <span class="string">&quot;Test123.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    UnityWebRequest req = UnityWebRequest.<span class="built_in">Post</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    req.<span class="built_in">SendWebRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!req.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(req.uploadProgress);</span><br><span class="line">        <span class="built_in">print</span>(req.uploadedBytes);</span><br><span class="line">        yield <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(req.uploadProgress);</span><br><span class="line">    <span class="built_in">print</span>(req.uploadedBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (req.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        <span class="comment">//req.downloadHandler.data</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;上传失败&quot;</span> + req.error + req.responseCode + req.result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#region 高级操作指什么？</span></span><br><span class="line"><span class="comment">//在常用操作中我们使用的是Unity为我们封装好的一些方法</span></span><br><span class="line"><span class="comment">//我们可以方便的进行一些指定类型的数据获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如</span></span><br><span class="line"><span class="comment">//下载数据时：</span></span><br><span class="line"><span class="comment">//1.文本和2进制</span></span><br><span class="line"><span class="comment">//2.图片</span></span><br><span class="line"><span class="comment">//3.AB包</span></span><br><span class="line"><span class="comment">//如果我们想要获取其它类型的数据应该如何处理呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上传数据时：</span></span><br><span class="line"><span class="comment">//1.可以指定参数和值</span></span><br><span class="line"><span class="comment">//2.可以上传文件</span></span><br><span class="line"><span class="comment">//如果想要上传一些基于HTTP规则的其它数据应该如何处理呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//高级操作就是用来处理 常用操作不能完成的需求的</span></span><br><span class="line"><span class="comment">//它的核心思想就是：UnityWebRequest中可以将数据处理分离开</span></span><br><span class="line"><span class="comment">//比如常规操作中我们用到的</span></span><br><span class="line"><span class="comment">//DownloadHandlerTexture 和 DownloadHandlerAssetBundle两个类</span></span><br><span class="line"><span class="comment">//就是用来将2进制字节数组转换成对应类型进行处理的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以高级操作时指 让你按照规则来实现更多的数据获取、上传等功能</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region UnityWebRequest类的更多内容</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequest.Get(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequestTexture.GetTexture(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequestAssetBundle.GetAssetBundle(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequest.Put()</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequest.Post</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//req.isDone</span></span><br><span class="line"><span class="comment">//req.downloadProgress;</span></span><br><span class="line"><span class="comment">//req.downloadedBytes;</span></span><br><span class="line"><span class="comment">//req.uploadProgress;</span></span><br><span class="line"><span class="comment">//req.uploadedBytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//req.SendWebRequest()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更多内容</span></span><br><span class="line"><span class="comment">//1.构造函数</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = new UnityWebRequest();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.请求地址</span></span><br><span class="line"><span class="comment">//req.url = &quot;服务器地址&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.请求类型</span></span><br><span class="line"><span class="comment">//req.method = UnityWebRequest.kHttpVerbPOST;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.进度</span></span><br><span class="line"><span class="comment">//req.downloadProgress</span></span><br><span class="line"><span class="comment">//req.uploadProgress</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.超时设置</span></span><br><span class="line"><span class="comment">//req.timeout = 2000;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.上传、下载的字节数</span></span><br><span class="line"><span class="comment">//req.downloadedBytes</span></span><br><span class="line"><span class="comment">//req.uploadedBytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.重定向次数 设置为0表示不进行重定向 可以设置次数</span></span><br><span class="line"><span class="comment">//req.redirectLimit = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8.状态码、结果、错误内容</span></span><br><span class="line"><span class="comment">//req.result</span></span><br><span class="line"><span class="comment">//req.error</span></span><br><span class="line"><span class="comment">//req.responseCode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//9.下载、上传处理对象</span></span><br><span class="line"><span class="comment">//req.downloadHandler</span></span><br><span class="line"><span class="comment">//req.uploadHandler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更多内容</span></span><br><span class="line"><span class="comment">//https://docs.unity.cn/cn/2020.3/ScriptReference/Networking.UnityWebRequest.html</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 自定义获取数据DownloadHandler相关类</span></span><br><span class="line"><span class="comment">//关键类：</span></span><br><span class="line"><span class="comment">//1.DownloadHandlerBuffer 用于简单的数据存储，得到对应的2进制数据。</span></span><br><span class="line"><span class="comment">//2.DownloadHandlerFile 用于下载文件并将文件保存到磁盘（内存占用少）。</span></span><br><span class="line"><span class="comment">//3.DownloadHandlerTexture 用于下载图像。</span></span><br><span class="line"><span class="comment">//4.DownloadHandlerAssetBundle 用于提取 AssetBundle。</span></span><br><span class="line"><span class="comment">//5.DownloadHandlerAudioClip 用于下载音频文件。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadTex</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadAB</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上的这些类，其实就是Unity帮助我们实现好的，用于解析下载下来的数据的类</span></span><br><span class="line"><span class="comment">//使用对应的类处理下载数据，他们就会在内部将下载的数据处理为对应的类型，方便我们使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DownloadHandlerScript 是一个特殊类。就其本身而言，不会执行任何操作。</span></span><br><span class="line"><span class="comment">//但是，此类可由用户定义的类继承。此类接收来自 UnityWebRequest 系统的回调，</span></span><br><span class="line"><span class="comment">//然后可以使用这些回调在数据从网络到达时执行完全自定义的数据处理。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadCustomHandler</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//我们可以自己设置UnityWebRequest当中的下载处理对象</span></span><br><span class="line"><span class="comment">//当设置后，下载数据后它会使用该对象中对应的函数处理数据</span></span><br><span class="line"><span class="comment">//让我们更方便的获取我们想要的数据</span></span><br><span class="line"><span class="comment">//方便我们对数据下载或获取进行拓展</span></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-中英对照汉化</title>
      <link href="/posts/430e30ec.html"/>
      <url>/posts/430e30ec.html</url>
      
        <content type="html"><![CDATA[<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192014911.png" alt="在这里插入图片描述"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>把汉化包zh-cn.po用记事本打开，复制内容到word编辑</p><p>word软件主窗口<br>编辑–替换，打开查找替换窗口</p><p>点击高级，选中使用通配符</p><p>查找内容：<code>(msgid\ &quot;)(*)(&quot;^13msgstr &quot;)(*)(&quot;^13)</code></p><p>替换为：<code>\1\2\3\2 \4\5</code></p><p>全部替换完之后，复制全部内容到记事本<br>记事本中文件–另存为zh-cn.po就OK了</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h3 id="汉化包中的一段内容"><a href="#汉化包中的一段内容" class="headerlink" title="汉化包中的一段内容"></a>汉化包中的一段内容</h3><p>#: Editor/Mono/Inspector/AudioMixerControllerInspector.cs:1<br>msgid “ Threshold Volume”<br>msgstr “阈值音量”</p><p>查找内容<br>msgid “ Threshold Volume”<br>msgstr “阈值音量”<br>替换为<br>msgid “ Threshold Volume”<br>msgstr “ Threshold Volume阈值音量”</p><h3 id="拆分解释"><a href="#拆分解释" class="headerlink" title="拆分解释"></a>拆分解释</h3><p>(msgid\ “)(<em>)(“13)(msgstr “)(\</em>)(“13)<br>（）括号内为需要查找的文本内容，一个括号对应一个替换文本的元素即，<br>第一个(msgid\ “)对应替换\1<br>第二个(*)对应\2<br>(”^13)对应\3<br>以此类推</p><p>(msgid\ “)这一段在查找中会找到第二行的msgid “<br>需要查找的msgid “之中有个空格，需要用\来避免编译</p><p>(msgid\ “)(<em>)(“^13)这一段有三个元素<br>(</em>)代表所有文本<br>(”^13)代表”加上一个换行<br>这一段就表示找到msgid “开头，然后到”行末端结尾的一整行<br>并且分为了3个元素，在替换的时候用\序号调用</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Addressable</title>
      <link href="/posts/e4c6c43a.html"/>
      <url>/posts/e4c6c43a.html</url>
      
        <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Profile-概述窗口配置"><a href="#Profile-概述窗口配置" class="headerlink" title="Profile 概述窗口配置"></a>Profile 概述窗口配置</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144110.png" alt="image-20220512235308487"></p><p>BuildTarget：构建目标，可以在这里设置是哪个平台，默认是你激活哪个平台就是哪个平台<br>LocalBuildPath：本地构建路径，默认在项目的Library库文件夹中<br>LocalLoadPath：本地加载路径，在哪里加载本地已有的资源<br>RemoteBuildPath：远程构建路径<br>RemoteLoadPath：远程加载路径，在哪里下载远程内容和目录</p><p>注意：<br>1.一般情况下，不要去修改本地构建和加载路径默认值<br>2.当我们针对不同平台远程分发内容时，通过多个配置文件最方便。如果你想要最终的发布包包含所有内容，那么一个默认配置就够了</p><h3 id="AddressableAssetSettings-可寻址资源数据设置"><a href="#AddressableAssetSettings-可寻址资源数据设置" class="headerlink" title="AddressableAssetSettings 可寻址资源数据设置"></a>AddressableAssetSettings 可寻址资源数据设置</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144015.png" alt="image-20220512235703317"></p><p>概述配置<br>Profile In Use：可以在这选择使用的是哪一套配置文件<br>Manage Profiles：点击它会打开管理配置文件窗口</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144370.png" alt="image-20220512235744419"></p><p>Diagnostics:诊断<br>Send Profiler Events：启用分析器事件，启用它后我们可以在Event Viewer窗口查看Addressable相关信息<br>Log Runtime Exceptions：记录运行时加载相关的异常</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144647.png" alt="image-20220512235758863"></p><p>目录相关设置，将资源的地址映射到其物理位置<br>Player Version Override：重写用于制定远程目录名称的时间戳<br>如果不设置默认使用时间戳作为远程目录命名</p><p>Compress Local Catalog：在压缩的AssetBundle文件中生成目录。可以压缩大小，但是会增加生成和加载的时间</p><p>Optimize Catalog Size：通过为内部ID创建查找表来减小目录的大小。会增加加载目录所需的时间</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144208.png" alt="image-20220512235829322"></p><p>Content Update：内容更新</p><p>Disable Catalog Update on Startup：当可寻址系统在运行时初始化时，禁用自动检查更新的远程目录。您可以手动检查更新的目录。</p><p>Content State Build Path：在何处生成由默认生成脚本生成的内容状态文件。</p><p>Build Remote Catalog：构建远程目录<br>勾选后会出现新选项</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144960.png" alt="image-20220512235843681"></p><p>Build &amp; Load Paths：<br>在何处生成和加载远程目录。从列表中选择一个配置文件路径，如果要分别设置生成路径和加载路径，请选择<custom>。<br>仅在启用生成远程目录时可见。</p><p>Build Path：远程构建路径，在何处构建远程目录。通常，应该使用RemoteBuildPath配置文件变量。<br>仅当将生成和加载路径设置为<custom>时显示。</p><p>Load Path：远程加载路径，用于访问远程目录的URL。通常，应该使用RemoteLoadPath配置文件变量。<br>仅当将生成和加载路径设置为<custom>时显示。</p><p>Path Preview：路径预览</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144880.png" alt="image-20220512235907623"></p><p>Custom Certificeate handle：用于自定义证书处理的类。该列表包含项目中扩展UnityEngine的所有类。网络。证书管理员。</p><p>Max Concurrent Web Requests：系统对超过此限制的任何请求进行队列处理</p><p>Catalog Download Timeout：等待目录文件下载的时间为多少秒。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144501.png" alt="image-20220513000829808"></p><p>生成构建相关设置</p><p>Ignore Invalid/Unsupported Files in Build：忽略生成中无效不受支持的文件，如果启用，Addressable生成脚本将排除无效或不受支持的文件，而不是中止生成</p><p>Unique Bundle IDs：唯一约束ID，是否为每个构建中的包生成一个唯一的名称</p><p>Contiguous Bundles：连续捆绑，生成更高效的捆绑包布局。如果您有Addressables 1.12.1或更早版本生成的捆绑包，请禁用此选项以最小化捆绑包更改</p><p>Non-Recursive Dependency Calculation：非递归依赖计算，不使用递归计算依赖项</p><p>Shader Bundle Naming Prefix：着色器包命名前缀</p><p>MonoScript Bundle Naming Prefix：Mono脚本包命名前缀</p><p>Strip Unity Version From AssetBundles：从AssetBUndles中剥离Unity版本，决定是否从包头中删除版本信息</p><p>Disable Visible Sub Asset Representations：禁用可见子资源，如果您不直接使用子对象(Sprite、子网格等)，则启用此选项可以提高构建时间</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144022.png" alt="image-20220513000001837"></p><p>构建和编辑器模式脚本<br>在编辑器中进入播放模式时，选择Addressable系统如何加载资产<br>这些脚本处理默认的构建进程，并提供不同的方式在编辑模式下访问数据<br>我们可以在AddressableAssetData/DataBuilders文件夹中找到这些脚本<br>如果要为他们自定义脚本，那么对应的脚本需要时BuildScriptBase的子类，并且继承IDataBuilder<br>Use Asset Database：使用资源数据库<br>Simulate Groups：模拟组<br>Use Existing Build：使用现有版本<br>Default Build Scripts:默认生成脚本</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144527.png" alt="image-20220513000018046"></p><p>资源组模板</p><p>Packed Asset：打包资源<br>定义可用于创建新组的模板列表<br>创建新模板时，必须先将其添加到此列表中，然后才能使用它</p><p>Addressables包包含一个模板<br>其中包含默认构建脚本使用的模式。您可以在AddressableAssetData/AssetGroupTemplates文件夹中找到该模板。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144161.png" alt="image-20220513000041149"></p><p>初始化对象列表<br>配置初始化对象</p><p>可以在Project右键Create&gt;Addressables&gt;Initialization(初始化)&gt;Cache Initialization Setting（缓存初始化设置）</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144224.png" alt="image-20220513000924257"></p><p>Compress Bundles：是否压缩包<br>Cache Directory Override：缓存目录覆盖<br>[Obsolete]Expiration Delay：过期延迟（过时了）<br>Limit Cache Size：限制缓存的大小<br>Maximum Cache Size：最大缓存大小</p><h3 id="Packed-Assets-打包资源数据配置"><a href="#Packed-Assets-打包资源数据配置" class="headerlink" title="Packed Assets 打包资源数据配置"></a>Packed Assets 打包资源数据配置</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144296.png" alt="image-20220513001009620"></p><p>Build &amp; Load Paths：配置文件路径对，定义可寻址构建系统在哪个路径为此组创建内容，以及可寻址系统在运行时在何处加载这些内容</p><p>Build Path：打包路径<br>LocalBuildPath-本地路径<br>RemoteBuildPath-远程路径</p><p>Load Path：加载路径<br>LocalLoadPath-本地路径<br>RemoteLoadPath-远程路径</p><p>Path Preview：路径预览</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242145809.png" alt="image-20220513001032183"></p><p>Asset Bundle Compression：AB包的压缩方式，默认为LZ4，它通常是最有效的选项，建议使用</p><p>Uncompressed：不压缩，包较大，不推荐</p><p>LZ4：压缩，相对LZMA大一点点，建议使用，用什么解压什么，内存占用低</p><p>LZMA：压缩最小，解压慢，用一个资源要解压所有</p><p>Include In Build：包含在构建中，是否在内容生成中包含此组中的资源。如果取消勾选，那么在选择打包时，不会打包该组内容</p><p>Force Unique Provider：强制唯一提供者，Addressable是否对此组使用资源提供程序类的唯一实例。如果您有此组中的资产类型的自定义提供程序实现，并且这些提供程序的实例不能在组之间共享，则启用此选项。</p><p>Use Asset Bundle Cache：使用AB包缓存，是否缓存远程分发的包</p><p>Asset Bundle CRC：是否在加载前验证AB包的完整性</p><p>Disabled：永远不检查完整性<br>Enabled，Including Cached：检查完整性，包括缓存也检查<br>Enabled，Excluding Cached：检查完整性，但是不检查缓存的包</p><p>Use UnityWebRequest for Local Asset Bundle：<br>加载AB包时，使用UnityWebRequestAssetBundle.GetAssetBundle而不是AssetBundle.LoadFromFileAsync</p><p>Request Timeout：下载远程包时超时的间隔时间</p><p>Use Http Chunked Transfer：下载包时是否使用HTTP/1.1块传输编码方法。<br>在2019.3+中被废弃和忽略</p><p>Http Redirect Limit：下载包时允许重定向的次数。无限制设置为-1</p><p>Retry Count：重试失败下载的次数</p><p>Include Addresses in Catalog：是否将地址字符串包括在目录中。如果不使用地址字符串在组中加载资产，则可以通过不包括它们来减小目录的大小。</p><p>Include GUIDs in Catalog：是否在目录中包含GUID字符串。您必须包含guid字符串才能使用资产参考。如果不使用AssetReferences或GUID字符串在组中加载资产，则可以通过不包括它们来减小目录的大小。</p><p>Include Labels in Catalog：是否在目录中包含标签字符串。如果不使用标签在组中加载资产，则可以通过不包括这些资产来缩小目录的大小。</p><p>Internal Asset Naming Mode：如何在内部命名目录中的资源</p><p>Full Path：全路径<br>FileName：文件名<br>GUID：资源的Guid字符串<br>Dynamic：Addressables根据组中的资源选择最小的内部名称</p><p>Internal Bundle Id Mode    ：确定如何构造资产绑定的内部ID。例如，当您设置群GUID选项，Addressables通过将组名与包guid字符串组合来创建包ID。</p><p>Group Guid：组的Guid<br>Group Guid Project Id Hash：组的ID和工程ID的哈希<br>Group Guid Project Id Entries Hash：组的ID和工程ID项的哈希</p><p>Cache Clear Behavior：确定安装的应用程序何时从缓存中清除AB包</p><p>Clear When Space Is Needed In Cache：在缓存中需要空间时清除<br>Clear When When new Version Loaded：加载新版本时清楚</p><p>Bundle Mode：打包模式，如何将此组中的资产打包到包中</p><p>Pack Together：创建包含所有资产的单个包<br>Pack Separately：为组中的每个主要资产创建一个包。如精灵图片中的精灵图片被包装在一起。添加到组中的文件夹中的资产也打包在一起<br>Pack Together by Label：为共享相同标签组合的资产创建一个包</p><p>Bundle Naming Mode：如何构造AB包的文件名</p><p>Filename：文件名<br>Append Hash to Filename：将哈希附加到文件名<br>Use Hash of AssetBundle：使用AB包的哈希<br>Use Hash of FileName：使用文件名的哈希</p><p>Asset Load Mode：资源加载模式</p><p>Requested Asset And Dependencies：请求的资源和依赖项<br>All Packed Assets And Dependencies：所有包中的资源和依赖项</p><p>Asset Provider：资源提供者<br>定义提供程序类Addressable用于从该组生成的AssetBundles加载资产。将此选项设置为Bundles供应商的资产除非您有一个自定义提供程序实现来从资产绑定中提供资产。</p><p>Asset Bundle Provider：AB包提供器<br>定义由该组生成的提供程序类Addressable用于加载AssetBundles。将此选项设置为资产束提供者除非您有一个自定义提供程序实现来提供资产绑定。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242145042.png" alt="image-20220513001612615"></p><p>内容更新限制</p><p>Add Schema（添加模式）<br>你可以将任意数量的架构模式分配给一个组</p><p>Content Packing Loading：内容打包加载相关<br>Content Update Restriction：内容更新限制<br>Resources and Built In Scenes：在内置数据中显示哪些类型的内置资源，可以选择是否显示 资源和内置场景</p><p>我们甚至可以通过继承AddressableAssetGroupSchema<br>定义自己的架构模式</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242145113.png" alt="image-20220513001644897"></p><p>Can Change Post Release：可以改变发行后内容，该模式不移动任何资源，如果包中的任何资源发生了更改，则重新构建整个包</p><p>Cannot Change Post Release：无法改变发布后内容，如果包中任何资源已经改变，则[检查内容更新限制]工具会将其移动到为更新创建的新组中。在进行更新构建时，从这个新组创建的AssetBundles中的资产将覆盖现有包中的版本。</p><h2 id="异步资源加载方式"><a href="#异步资源加载方式" class="headerlink" title="异步资源加载方式"></a>异步资源加载方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;GameObject&gt; handle;</span><br><span class="line">   <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="meta">#region 知识点一 回顾目前动态异步加载的使用方式</span></span><br><span class="line">       <span class="comment">//handle = Addressables.LoadAssetAsync&lt;GameObject&gt;(&quot;Cube&quot;);</span></span><br><span class="line">       <span class="comment">//通过事件监听的方式 结束时使用资源</span></span><br><span class="line">       <span class="comment">//handle.Completed += (obj) =&gt;</span></span><br><span class="line">       <span class="comment">//&#123;</span></span><br><span class="line">       <span class="comment">//    if (handle.Status == AsyncOperationStatus.Succeeded)</span></span><br><span class="line">       <span class="comment">//    &#123;</span></span><br><span class="line">       <span class="comment">//        print(&quot;事件创建对象&quot;);</span></span><br><span class="line">       <span class="comment">//        Instantiate(obj.Result);</span></span><br><span class="line">       <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//&#125;;</span></span><br><span class="line">       <span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">#region 知识点二 3种使用异步加载资源的方式</span></span><br><span class="line">       <span class="comment">//1.事件监听（目前学习过的）</span></span><br><span class="line">       <span class="comment">//2.协同程序</span></span><br><span class="line">       <span class="comment">//3.异步函数（async和await ）</span></span><br><span class="line">       <span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">#region 知识点三 通过协程使用异步加载</span></span><br><span class="line">       <span class="comment">//StartCoroutine(LoadAsset());</span></span><br><span class="line">       <span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">#region 知识点四 通过异步函数async和await加载</span></span><br><span class="line">       <span class="comment">//注意：WebGL平台不支持异步函数语法</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//单任务等待</span></span><br><span class="line">       <span class="built_in">Load</span>();</span><br><span class="line">       <span class="comment">//多任务等待</span></span><br><span class="line">       <span class="meta">#endregion</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">IEnumerator <span class="title">LoadAsset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       handle = Addressables.<span class="built_in">LoadAssetAsync</span>&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">       <span class="comment">//一定是没有加载成功 再去 yield return</span></span><br><span class="line">       <span class="keyword">if</span>(!handle.IsDone)</span><br><span class="line">           yield <span class="keyword">return</span> handle;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//加载成功 那么久可以使用了</span></span><br><span class="line">       <span class="keyword">if</span> (handle.Status == AsyncOperationStatus.Succeeded)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;协同程序创建对象&quot;</span>);</span><br><span class="line">           <span class="built_in">Instantiate</span>(handle.Result);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           Addressables.<span class="built_in">Release</span>(handle);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">async <span class="type">void</span> <span class="title">Load</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       handle = Addressables.<span class="built_in">LoadAssetAsync</span>&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line"></span><br><span class="line">       AsyncOperationHandle&lt;GameObject&gt; handle2 = Addressables.<span class="built_in">LoadAssetAsync</span>&lt;GameObject&gt;(<span class="string">&quot;Sphere&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//单任务等待</span></span><br><span class="line">       <span class="comment">//await handle.Task;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//多任务等待</span></span><br><span class="line">       await Task.<span class="built_in">WhenAll</span>(handle.Task, handle2.Task);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;异步函数的形式加载的资源&quot;</span>);</span><br><span class="line">       <span class="built_in">Instantiate</span>(handle.Result);</span><br><span class="line">       <span class="built_in">Instantiate</span>(handle2.Result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Addressables资源管理器"><a href="#Addressables资源管理器" class="headerlink" title="Addressables资源管理器"></a>Addressables资源管理器</h2><p>```c++<br>using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEngine.AddressableAssets;<br>using UnityEngine.ResourceManagement.AsyncOperations;</p><p>//可寻址资源 信息<br>public class AddressablesInfo<br>{<br>    //记录 异步操作句柄<br>    public AsyncOperationHandle handle;<br>    //记录 引用计数<br>    public uint count;</p><pre><code>public AddressablesInfo(AsyncOperationHandle handle)&#123;    this.handle = handle;    count += 1;&#125;</code></pre><p>}</p><p>public class AddressablesMgr<br>{<br>    private static AddressablesMgr instance = new AddressablesMgr();<br>    public static AddressablesMgr Instance =&gt; instance;</p><pre><code>//有一个容器 帮助我们存储 异步加载的返回值public Dictionary&lt;string, AddressablesInfo&gt; resDic = new Dictionary&lt;string, AddressablesInfo&gt;();private AddressablesMgr() &#123; &#125;//异步加载资源的方法public void LoadAssetAsync&lt;T&gt;(string name, Action&lt;AsyncOperationHandle&lt;T&gt;&gt; callBack)&#123;    //由于存在同名 不同类型资源的区分加载    //所以我们通过名字和类型拼接作为 key    string keyName = name + &quot;_&quot; + typeof(T).Name;    AsyncOperationHandle&lt;T&gt; handle;    //如果已经加载过该资源    if (resDic.ContainsKey(keyName))    &#123;        //获取异步加载返回的操作内容        handle = resDic[keyName].handle.Convert&lt;T&gt;();        //要使用资源了 那么引用计数+1        resDic[keyName].count += 1;        //判断 这个异步加载是否结束        if(handle.IsDone)        &#123;            //如果成功 就不需要异步了 直接相当于同步调用了 这个委托函数 传入对应的返回值            callBack(handle);        &#125;        //还没有加载完成        else        &#123;            //如果这个时候 还没有异步加载完成 那么我们只需要 告诉它 完成时做什么就行了            handle.Completed += (obj) =&gt; &#123;                if (obj.Status == AsyncOperationStatus.Succeeded)                    callBack(obj);            &#125;;        &#125;        return;    &#125;    //如果没有加载过该资源    //直接进行异步加载 并且记录    handle = Addressables.LoadAssetAsync&lt;T&gt;(name);    handle.Completed += (obj)=&gt; &#123;        if (obj.Status == AsyncOperationStatus.Succeeded)            callBack(obj);        else        &#123;            Debug.LogWarning(keyName + &quot;资源加载失败&quot;);            if(resDic.ContainsKey(keyName))                resDic.Remove(keyName);        &#125;    &#125;;    AddressablesInfo info = new AddressablesInfo(handle);    resDic.Add(keyName, info);&#125;//释放资源的方法 public void Release&lt;T&gt;(string name)&#123;    //由于存在同名 不同类型资源的区分加载    //所以我们通过名字和类型拼接作为 key    string keyName = name + &quot;_&quot; + typeof(T).Name;    if(resDic.ContainsKey(keyName))    &#123;        //释放时 引用计数-1        resDic[keyName].count -= 1;        //如果引用计数为0  才真正的释放        if(resDic[keyName].count == 0)        &#123;            //取出对象 移除资源 并且从字典里面移除            AsyncOperationHandle&lt;T&gt; handle = resDic[keyName].handle.Convert&lt;T&gt;();            Addressables.Release(handle);            resDic.Remove(keyName);        &#125;    &#125;&#125;//异步加载多个资源 或者 加载指定资源public void LoadAssetAsync&lt;T&gt;(Addressables.MergeMode mode, Action&lt;T&gt; callBack, params string[] keys)&#123;    //1.构建一个keyName  之后用于存入到字典中    List&lt;string&gt; list = new List&lt;string&gt;(keys);    string keyName = &quot;&quot;;    foreach (string key in list)        keyName += key + &quot;_&quot;;    keyName += typeof(T).Name;    //2.判断是否存在已经加载过的内容     //存在做什么    AsyncOperationHandle&lt;IList&lt;T&gt;&gt; handle;    if (resDic.ContainsKey(keyName))    &#123;        handle = resDic[keyName].handle.Convert&lt;IList&lt;T&gt;&gt;();        //要使用资源了 那么引用计数+1        resDic[keyName].count += 1;        //异步加载是否结束        if (handle.IsDone)        &#123;            foreach (T item in handle.Result)                callBack(item);        &#125;        else        &#123;            handle.Completed += (obj) =&gt;            &#123;                //加载成功才调用外部传入的委托函数                if(obj.Status == AsyncOperationStatus.Succeeded)                &#123;                    foreach (T item in handle.Result)                        callBack(item);                &#125;            &#125;;        &#125;        return;    &#125;    //不存在做什么    handle = Addressables.LoadAssetsAsync&lt;T&gt;(list, callBack, mode);    handle.Completed += (obj) =&gt;    &#123;        if(obj.Status == AsyncOperationStatus.Failed)        &#123;            Debug.LogError(&quot;资源加载失败&quot; + keyName);            if (resDic.ContainsKey(keyName))                resDic.Remove(keyName);        &#125;    &#125;;    AddressablesInfo info = new AddressablesInfo(handle);    resDic.Add(keyName, info);&#125;public void LoadAssetAsync&lt;T&gt;(Addressables.MergeMode mode, Action&lt;AsyncOperationHandle&lt;IList&lt;T&gt;&gt;&gt; callBack, params string[] keys)&#123;&#125;public void Release&lt;T&gt;(params string[] keys)&#123;    //1.构建一个keyName  之后用于存入到字典中    List&lt;string&gt; list = new List&lt;string&gt;(keys);    string keyName = &quot;&quot;;    foreach (string key in list)        keyName += key + &quot;_&quot;;    keyName += typeof(T).Name;    if(resDic.ContainsKey(keyName))    &#123;        resDic[keyName].count -= 1;        if(resDic[keyName].count == 0)        &#123;            //取出字典里面的对象            AsyncOperationHandle&lt;IList&lt;T&gt;&gt; handle = resDic[keyName].handle.Convert&lt;IList&lt;T&gt;&gt;();            Addressables.Release(handle);            resDic.Remove(keyName);        &#125;    &#125;&#125;//清空资源public void Clear()&#123;    foreach (var item in resDic.Values)    &#123;        Addressables.Release(item.handle);    &#125;    resDic.Clear();    AssetBundle.UnloadAllAssetBundles(true);    Resources.UnloadUnusedAssets();    GC.Collect();&#125;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Camera</title>
      <link href="/posts/cd157359.html"/>
      <url>/posts/cd157359.html</url>
      
        <content type="html"><![CDATA[<h2 id="摄像机组件"><a href="#摄像机组件" class="headerlink" title="摄像机组件"></a>摄像机组件</h2><p>照相机是玩家观察世界的装置，屏幕空间点按像素定义，屏幕的左下为（0,0）；右上是（pixelwidth，pixelHeight），z位置在照相机的世界单位中。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192033981" alt="img"></p><p>相机组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Clear Flags ：</span><br><span class="line">清除标识：确定了屏幕哪些部分将被清除，方便多个摄像机画不同的游戏元素</span><br><span class="line">Background:背景色</span><br><span class="line">Culling Mask:包含或省略要由相机呈现的对象层。在检查器中将图层分配给您的对象。</span><br><span class="line">Projection:  切换相机的功能来模拟透视。</span><br><span class="line">    Perspective(透视):  相机将完整地呈现透视物体。拍摄角度为0-180°（最高）</span><br><span class="line">Field of View: 设置为“正交”时，“相机”的视口大小。</span><br><span class="line">Orthographic(正交):  相机将统一渲染对象，没有视角。注：正交模式下不支持延迟渲染。正向渲染总是被使用。</span><br><span class="line">Size:设置为“正交”时，“相机”的视口大小。</span><br><span class="line">Cliping Planes:从相机到开始和停止渲染的距离。</span><br><span class="line">     Near ：相对于相机的最近点将出现绘图。</span><br><span class="line">     Far  ：相对于相机的最远点将出现绘图。</span><br><span class="line">ViewportRect：视口矩形 四个值指示屏幕上的相机视图将被绘制的位置。在视口坐标中测量（值为0-1）。</span><br><span class="line">Depth:相机的位置按照画图顺序。具有较大值的相机将被绘制在具有较小值的相机之上。</span><br><span class="line">Rendering Path:用于定义相机将使用什么渲染方法的选项</span><br><span class="line">    渲染路径 ：定义什么绘制方法被用于相机的选项</span><br><span class="line">    Use Graphics Settings 使用玩家设置：在玩家设置（Player Settings.）相机使用哪个渲染路径。 </span><br><span class="line">     Forward 正向渲染：所有对象每材质渲染只渲染一次,快速渲染</span><br><span class="line">     Deferred 延迟照明：所有物体将在无光照的环境渲染一次，然后在渲染队列尾部将物体的光照一起渲染出来。</span><br><span class="line">    Legacy Vertex Lit 顶点光照 ：所有被这个相机渲染的物体都将渲染成Vertex-Lit物体。</span><br><span class="line">    Legacy Deferred : 旧的延迟光照 </span><br><span class="line">Target Texture : 目标纹理:渲染纹理 （Render Texture）包含相机视图输出。这会使相机渲染在屏幕上的能力被禁止。可用于实现画中画或者画面特效。</span><br><span class="line">Occlusion Culling : 是否剔除物体背向摄像机的部分</span><br><span class="line">Allow HDR:高动态光照渲染，启动相机高动态范围渲染功能。让场景更真实。</span><br><span class="line">Allow MSAA: 这台相机应该使用MSAA渲染目标吗？如果当前质量设置MSAA级别支持，将只使用MSAA。</span><br><span class="line">Allow Dynamic Resolution：动态分辨率缩放。</span><br><span class="line">如果相机使用动态分辨率渲染，则为<span class="literal">true</span>，否则为<span class="literal">false</span>。即使此属性为<span class="literal">true</span>，动态分辨率也只能在当前图形设备支持的情况下使用。</span><br><span class="line">Target Display:设置此摄像机的目标显示。</span><br><span class="line">此设置使摄像机呈现在指定的显示中。显示器（例如监视器）支持的最大数目是8. </span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192033445" alt="img"></p><h3 id="Clear-Flags"><a href="#Clear-Flags" class="headerlink" title="Clear Flags"></a>Clear Flags</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Clear Flags ：</span><br><span class="line">清除标识：确定了屏幕哪些部分将被清除，方便多个摄像机画不同的游戏元素</span><br><span class="line">Skybox  ：</span><br><span class="line">天空盒：这是默认设置。屏幕上的任何空的部分将显示当前相机的天空盒。</span><br><span class="line">如果当前的相机没有设置天空盒，它会默认在渲染设置（Render Settings ）选择天空盒</span><br><span class="line">Solid Color ：</span><br><span class="line">纯色，屏幕上的空白部分将显示当前摄像机的背景色</span><br><span class="line">Depth Only ：</span><br><span class="line">深度相机，只渲染采集到的画面</span><br><span class="line">如果你想绘制一个玩家的枪，又不让它内部环境被裁剪，你会设置深度为<span class="number">0</span>的相机绘制环境，</span><br><span class="line">和另一个深度为<span class="number">1</span>的相机单独绘制武器。武器相机的清除标志（Clear Flags ）应设置 为depth only。</span><br><span class="line">Don<span class="symbol">&#x27;t</span> Clear ：</span><br><span class="line">不清除，此模式不清除颜色或深度缓存。每帧的渲染画面叠加在上一帧画面之上。</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192032367" alt="img"></p><h3 id="Culling-Mask"><a href="#Culling-Mask" class="headerlink" title="Culling Mask"></a>Culling Mask</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Culling Mask:包含或省略要由相机呈现的对象层。在检查器中将图层分配给您的对象。</span><br><span class="line"><span class="built_in">Nothing</span>:什么层都不剔除</span><br><span class="line">Everything:什么层都剔除</span><br><span class="line">Default:默认层剔除</span><br><span class="line">TransparentFX:隐形层,系统不会渲染贴图和模型</span><br><span class="line">Ignore Raycast:射线层剔除</span><br><span class="line">Water:水层剔除</span><br><span class="line">UI：UI层剔除</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192032199" alt="img"></p><h3 id="Rendering-Path"><a href="#Rendering-Path" class="headerlink" title="Rendering Path"></a>Rendering Path</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Rendering Path:用于定义相机将使用什么渲染方法的选项</span><br><span class="line">渲染路径 ：定义什么绘制方法被用于相机的选项</span><br><span class="line">Use Graphics Settings 使用玩家设置：在玩家设置（Player Settings.）相机使用哪个渲染路径。 </span><br><span class="line">  Forward 正向渲染：所有对象每材质渲染只渲染一次,快速渲染</span><br><span class="line">  Deferred 延迟照明：所有物体将在无光照的环境渲染一次，然后在渲染队列尾部将物体的光照一起渲染出来。</span><br><span class="line">Legacy Vertex Lit 顶点光照 ：所有被这个相机渲染的物体都将渲染成Vertex-Lit物体。</span><br><span class="line">Legacy Deferred : 旧的延迟光照 </span><br><span class="line">Traget Texture 目标纹理:渲染纹理 （Render Texture）包含相机视图输出。</span><br><span class="line">这会使相机渲染在屏幕上的能力被禁止。可用于实现画中画或者画面特效与</span><br><span class="line">Occlusion Culling : 是否剔除物体背向摄像机的部分</span><br><span class="line">Allow HDR:高动态光照渲染，启动相机高动态范围渲染功能。让场景更真实。</span><br><span class="line">Allow MSAA: 这台相机应该使用MSAA渲染目标吗？如果当前质量设置MSAA级别支持，将只使用MSAA。</span><br><span class="line">Allow Dynamic Resolution：动态分辨率缩放。</span><br><span class="line">如果相机使用动态分辨率渲染，则为<span class="literal">true</span>，否则为<span class="literal">false</span>。即使此属性为<span class="literal">true</span>，动态分辨率也只能在当前图形设备支持的情况下使用。</span><br><span class="line">Target Display:设置此摄像机的目标显示。</span><br><span class="line">此设置使摄像机呈现在指定的显示中。显示器（例如监视器）支持的最大数目是8. </span><br></pre></td></tr></table></figure><h2 id="Camera实例"><a href="#Camera实例" class="headerlink" title="Camera实例"></a>Camera实例</h2><ul><li>aspect ： 获取或者设置Camera视口的宽高比例值。例如：camera.aspect =2.0f,则视口的宽度、高度 = 2.0f，当硬件显示器屏幕的宽度与高度比例不为2.0f时,视图的显示将会发生变形。aspect只处理摄像机camera可以看到的视图的宽高比例，而硬件显示屏的作用只是把摄像机camera看到的内容显示出来，当硬件显示屏的宽高比例与aspect的比例值不同时，视图将发生变形。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">aspect</span> : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;默认值&quot;</span> + Camera.main.aspect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">10f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 1.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetAspect</span>();</span><br><span class="line">            Camera.main.aspect = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">60f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 2.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetAspect</span>();</span><br><span class="line">            Camera.main.aspect = <span class="number">2.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">110f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 3.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetAspect</span>();</span><br><span class="line">            Camera.main.aspect = <span class="number">3.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">160f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 0.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetAspect</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cameraToWorldMatrix : 变换矩阵</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cameratoworldmatrix</span> : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Camera旋转前位置&quot;</span> + transform.position);</span><br><span class="line">        Matrix4x4 m = Camera.main.cameraToWorldMatrix;</span><br><span class="line">        <span class="comment">// 向量的位置转换为世界坐标中的位置</span></span><br><span class="line">        <span class="comment">//v3 的值为沿着Camera局部坐标系的-z轴方向前移5个单位的位置在世界坐标系中的位置</span></span><br><span class="line">        Vector3 v3 = m.<span class="built_in">MultiplyPoint</span>(Vector3.forward * <span class="number">5.0f</span>);</span><br><span class="line">        <span class="comment">//v4 的值为沿着Camera世界坐标系的-z轴方向前移5个单位的位置在世界坐标系中的位置</span></span><br><span class="line">        Vector3 v4 = m.<span class="built_in">MultiplyPoint</span>(transform.forward * <span class="number">5.0f</span>);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;旋转前，V3坐标值：&quot;</span>+v3);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;旋转前，V4坐标值：&quot;</span>+v4);</span><br><span class="line">        <span class="comment">// 将摄像机沿着Y轴正向旋转90度（此时摄像机局部坐标系的z轴方向和世界坐标的X轴方向一致），</span></span><br><span class="line">        transform.<span class="built_in">Rotate</span>(Vector3.up * <span class="number">90f</span>);</span><br><span class="line">        m = Camera.main.cameraToWorldMatrix;</span><br><span class="line">        v3 = m.<span class="built_in">MultiplyPoint</span>(Vector3.forward * <span class="number">5.0f</span>);</span><br><span class="line">        v4 = m.<span class="built_in">MultiplyPoint</span>(transform.forward * <span class="number">5.0f</span>);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;旋转后， v3坐标值&quot;</span>+v3);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;旋转后， v4坐标值&quot;</span>+v4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CullingMask 按层渲染，此属性用于按层（GameObject.layer）有选择性地渲染场景中的物体。通过cullingMask可以使得当前摄像机有选择性地渲染场景中的部分物体，默认cullingMask =-1即渲染场景中的任何物体，cullingMask = 0时不渲染场景中的任何物体。若只渲染2,3,4，可以使用cullingMask = （1&lt;&lt;2）+ (1&lt;&lt;3)+(1&lt;&lt;4)来进行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cullingMask</span> : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;默认值&quot;</span> + Camera.main.aspect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">10f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;CullingMask = -1&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.cullingMask = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">60f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;CullingMask = 0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">           Camera.main.cullingMask = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">110f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 3.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.cullingMask =<span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">160f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 1&lt;&lt;8&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.cullingMask =<span class="number">1</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//渲染第8层与第0层</span></span><br><span class="line">       <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">160f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 0&amp;&amp;8&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 注意运算符优先排序</span></span><br><span class="line">            Camera.main.cullingMask =<span class="number">1</span>+（<span class="number">1</span> &lt;&lt; <span class="number">8</span>）;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>eventMask属性：按层响应事件，选择哪个层（layer）的物体可以响应鼠标事件</li></ul><blockquote><p>1.必须满足两个条件：</p><ul><li>1.物体在摄像机的视野范围内。</li><li>2.在2的layer次方的值与eventMask进行运算（&amp;）后结果仍为2的layer次方的值，如：defalult ,layer值为0，2的0次方=1，如果1与eventMask进行与运算后扔为1，则此物体响应鼠标事件。由于EventMask为奇数时，与1的与运算结果都为1，所以若物体层为defalut并且eventMask为奇数时物体会响应鼠标事件。</li></ul><p>2.如果想要多个不同层的物体响应鼠标事件，则需要把所有层的2的layer次方值相加，再与eventMask做与运算。例如，2个物体，layer值分贝为1,3，当event与9进行与运算后结果仍为9，则这两个物体都会响应鼠标事件。</p><p>3.此属性有一个特殊情况，但固体layer选择IgnoreRaycast(其为系统内置，值为2)时，无论EventMask值为多少，物体都无法响应鼠标事件。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventMask_ts</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> is_rotate = <span class="literal">false</span>;<span class="comment">//控制物体旋转</span></span><br><span class="line">    <span class="keyword">public</span> Camera c;<span class="comment">//指向场景中摄像机</span></span><br><span class="line">    <span class="comment">//记录摄像机的eventMask值，可以在程序运行时在Inspector面板中修改其值的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> eventMask_now = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//记录当前物体的层</span></span><br><span class="line">    <span class="built_in">int</span> layer_now;</span><br><span class="line">    <span class="built_in">int</span> layerTemp;<span class="comment">//记录2的layer次方的值</span></span><br><span class="line">    <span class="built_in">int</span> ad;<span class="comment">//记录与运算（&amp;）的结果</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录当前对象的层，可以在程序运行时在Inspector面板中选择不同的层</span></span><br><span class="line">        layer_now = gameObject.layer;</span><br><span class="line">        <span class="comment">//求2的layer_now次方的值</span></span><br><span class="line">        layerTemp= (<span class="built_in">int</span>)Mathf.Pow(<span class="number">2.0f</span>, layer_now);</span><br><span class="line">        <span class="comment">//与运算（&amp;）</span></span><br><span class="line">        ad = eventMask_now &amp; layerTemp;</span><br><span class="line">        c.eventMask = eventMask_now;</span><br><span class="line">        <span class="comment">//当is_rotate为true时旋转物体</span></span><br><span class="line">        <span class="keyword">if</span> (is_rotate)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.Rotate(Vector3.up * <span class="number">15.0f</span> * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当鼠标左键按下时，物体开始旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnMouseDown</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        is_rotate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当鼠标左键抬起时，物体结束旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnMouseUp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        is_rotate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;当前对象的layer值为：&quot;</span> + layer_now + <span class="string">&quot; , 2的layer次方的值为&quot;</span> + layerTemp);</span><br><span class="line">        GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;当前摄像机eventMask的值为：&quot;</span> + eventMask_now);</span><br><span class="line">        GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">500.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;根据算法，当eventMask的值与&quot;</span> + layerTemp+ <span class="string">&quot;进行与运算（&amp;）后， 若结果为&quot;</span> + tp + <span class="string">&quot;，则物体相应OnMousexxx方法，否则不响应！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ad == tp)</span><br><span class="line">        &#123;</span><br><span class="line">            str = <span class="string">&quot; ,所以物体会相应OnMouseDown方法！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str = <span class="string">&quot; ,所以物体不会相应OnMouseDown方法！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10.0f</span>, <span class="number">160.0f</span>, <span class="number">500.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;而当前eventMask与&quot;</span> + layerTemp+ <span class="string">&quot;进行与运算（&amp;）的结果为&quot;</span> + ad + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LayerCullDistances:层消隐的距离</li></ul><blockquote><p>摄像机可以通过基于层（GameObject.layer）的方式来设置不同层物体的消隐距离，但这个距离必须小于或者等于摄像机的farClipPlane才有效。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LayerCullDistances</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 拿到要消除的物体</span></span><br><span class="line">    <span class="keyword">public</span> Transform obj;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义大小为32的一维数组，用来存储所有层的剔除距离</span></span><br><span class="line">        <span class="type">float</span>[] distances = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">//设置第12层的剔除距离</span></span><br><span class="line">        distances[<span class="number">11</span>] = Vector3.<span class="built_in">Distance</span>(transform.position,obj.position);</span><br><span class="line">        <span class="comment">//将数组赋给摄像机的layerCullDistances，首先这个获取的是layer所有的层距离</span></span><br><span class="line">        Camera.main.layerCullDistances = distances;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//摄像机远离物体,会发现设置了蹭的</span></span><br><span class="line">        transform.<span class="built_in">Translate</span>(transform.right * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>layerCullSpherical:基于球面距离剔除</li></ul><blockquote><p>基于球面距离的剔除方式。属性默认为false，即不使用球面剔除，表示只要有一点没有超出物体所在层的远视口平面，物体就是可见的。当设置此属性为True时，只要物体的世界坐标点Position与摄像机的距离大于所在层的剔除距离，物体就不可见。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">layerCullSpherical</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform cb1, cb2, cb3;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义大小为32的一维数组，用来存储所有层的剔除距离</span></span><br><span class="line">        <span class="type">float</span>[] distances = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">//设置第9层的剔除距离</span></span><br><span class="line">        distances[<span class="number">8</span>] = Vector3.<span class="built_in">Distance</span>(transform.position, cb1.position);</span><br><span class="line">        <span class="comment">//将数组赋给摄像机的layerCullDistances</span></span><br><span class="line">        Camera.main.layerCullDistances = distances;</span><br><span class="line">        <span class="comment">//打印出三个物体距离摄像机的距离</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Cube1距离摄像机的距离：&quot;</span> + Vector3.<span class="built_in">Distance</span>(transform.position, cb1.position));</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Cube2距离摄像机的距离：&quot;</span> + Vector3.<span class="built_in">Distance</span>(transform.position, cb2.position));</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Cube3距离摄像机的距离：&quot;</span> + Vector3.<span class="built_in">Distance</span>(transform.position, cb3.position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//使用球形距离剔除</span></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">20.0f</span>, <span class="number">180.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;使用球形距离剔除&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.layerCullSpherical = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取消球形距离剔除</span></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">70.0f</span>, <span class="number">180.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;取消球形距离剔除&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.layerCullSpherical = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>orthographic :摄像机投影模式</li></ul><blockquote><p>用来设置相机投影模式， 模式有两种：正交投影（orthographic）,与透视投影模式（perspective）若值为true,正交模式，反之投影模式。正交模式下：物体在视口的代销至于正交视口的大小有关，与摄像机到物体的距离无关，主要呈现2D效果。透视模式下，有远小近大的效果。呈现3D效果</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class orthographic : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    float <span class="built_in">len</span> = <span class="number">5.5</span>f;</span><br><span class="line">    void OnGUI()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.Button(<span class="built_in">new</span> Rect(<span class="number">10.0</span>f, <span class="number">10.0</span>f, <span class="number">120.0</span>f, <span class="number">45.0</span>f), <span class="string">&quot;正交投影&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.orthographic = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">len</span> = <span class="number">4.5</span>f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.Button(<span class="built_in">new</span> Rect(<span class="number">150.0</span>f, <span class="number">10.0</span>f, <span class="number">120.0</span>f, <span class="number">45.0</span>f), <span class="string">&quot;透视投影&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.orthographic = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">len</span> = <span class="number">60.0</span>f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Camera.main.orthographic)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//正交投影模式下，物体没有远大近小的效果，</span></span><br><span class="line">            <span class="comment">//orthographicSize的大小无限制，当orthographicSize为负数时视口的内容会颠倒，</span></span><br><span class="line">            <span class="comment">//orthographicSize的绝对值为摄像机视口的高度值，即上下两条边之间的距离</span></span><br><span class="line">            <span class="built_in">len</span> = GUI.HorizontalSlider(<span class="built_in">new</span> Rect(<span class="number">10.0</span>f, <span class="number">60.0</span>f, <span class="number">300.0</span>f, <span class="number">45.0</span>f), <span class="built_in">len</span>, <span class="number">-20.0</span>f, <span class="number">20.0</span>f);</span><br><span class="line">            Camera.main.orthographicSize = <span class="built_in">len</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//透视投影模式下，物体有远大近小的效果，</span></span><br><span class="line">            <span class="comment">//fieldOfViewd的取值范围为1.0-179.0</span></span><br><span class="line">            <span class="built_in">len</span> = GUI.HorizontalSlider(<span class="built_in">new</span> Rect(<span class="number">10.0</span>f, <span class="number">60.0</span>f, <span class="number">300.0</span>f, <span class="number">45.0</span>f), <span class="built_in">len</span>, <span class="number">1.0</span>f, <span class="number">179.0</span>f);</span><br><span class="line">            Camera.main.fieldOfView = <span class="built_in">len</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实时显示len大小</span></span><br><span class="line">        GUI.Label(<span class="built_in">new</span> Rect(<span class="number">320.0</span>f, <span class="number">60.0</span>f, <span class="number">120.0</span>f, <span class="number">45.0</span>f), <span class="built_in">len</span>.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>pixelRect：摄像机渲染区间<br> 设置Camera被渲染到屏幕中的坐标位置。以实际像素大小来设置显示视口的位置。如下图：A为原始平面大小，B为变换后的视口大小，则X0的值为视口右移的像素大小，Y0的值为视口上移的像素大小，w为Camera.pixelWidth,h的值为Camera.pixelHeight。这里要注意：Screen.width和Screen.height为模拟硬件屏幕的宽高值，不随Camera.pixelWidth和Camera.pixelHeight的改变而改变。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192032327" alt="img"></p><p>pixelRect</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PixelRect</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> which_change = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">float</span> temp_x = <span class="number">0.0f</span>, temp_y = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Screen.width和Screen.height为模拟硬件屏幕的宽高值,</span></span><br><span class="line">        <span class="comment">//其返回值不随camera.pixelWidth和camera.pixelHeight的改变而改变</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Screen.width:&quot;</span> + Screen.width);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Screen.height:&quot;</span> + Screen.height);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;pixelWidth:&quot;</span> + Camera.main.pixelWidth);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;pixelHeight:&quot;</span> + Camera.main.pixelHeight);</span><br><span class="line">        <span class="comment">//通过改变Camera的坐标位置而改变视口的区间</span></span><br><span class="line">        <span class="keyword">if</span> (which_change == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.pixelWidth &gt; <span class="number">1.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_x += Time.deltaTime * <span class="number">20.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取消以下注释察看平移状况</span></span><br><span class="line">            <span class="comment">//if (Camera.main.pixelHeight &gt; 1.0f)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    temp_y += Time.deltaTime * 20.0f;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            Camera.main.pixelRect = <span class="keyword">new</span> <span class="built_in">Rect</span>(temp_x, temp_y, Camera.main.pixelWidth, Camera.main.pixelHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过改变Camera的视口宽度和高度来改变视口的区间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (which_change == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.pixelWidth &gt; <span class="number">1.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_x = Camera.main.pixelWidth - Time.deltaTime * <span class="number">20.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取消以下注释察看平移状况</span></span><br><span class="line">            <span class="comment">//if (camera.pixelHeight &gt; 1.0f)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    temp_y = camera.pixelHeight - Time.deltaTime * 20.0f;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            Camera.main.pixelRect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, temp_x, temp_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口改变方式1&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">0</span>;</span><br><span class="line">            temp_x = <span class="number">0.0f</span>;</span><br><span class="line">            temp_y = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口改变方式2&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">1</span>;</span><br><span class="line">            temp_x = <span class="number">0.0f</span>;</span><br><span class="line">            temp_y = Camera.main.pixelHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口还原&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>projectionMatrix属性：自定义投影矩阵<br> 此属性的功能是设置摄像机的自定义投影矩阵。此属性常在一些特效场景下用到，在切换变换矩阵是通常需要先用Camera.ResetProjectionMatrix()重置Camera的变换矩阵。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectionMatrix</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform sp, cb;</span><br><span class="line">    <span class="keyword">public</span> Matrix4x4 originalProjection;</span><br><span class="line">    <span class="type">float</span> q=<span class="number">0.1f</span>;<span class="comment">//晃动振幅</span></span><br><span class="line">    <span class="type">float</span> p=<span class="number">1.5f</span>;<span class="comment">//晃动频率</span></span><br><span class="line">    <span class="type">int</span> which_change = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//记录原始投影矩阵</span></span><br><span class="line">        originalProjection = Camera.main.projectionMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sp.<span class="built_in">RotateAround</span>(cb.position, cb.up, <span class="number">45.0f</span> * Time.deltaTime);</span><br><span class="line">        Matrix4x4 pr = originalProjection;</span><br><span class="line">        <span class="keyword">switch</span> (which_change)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment">//绕摄像机X轴晃动</span></span><br><span class="line">                pr.m11 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">//绕摄像机Y轴晃动</span></span><br><span class="line">                pr.m01 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="comment">//绕摄像机Z轴晃动</span></span><br><span class="line">                pr.m10 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="comment">//绕摄像机左右移动</span></span><br><span class="line">                pr.m02 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="comment">//摄像机视口放缩运动</span></span><br><span class="line">                pr.m00 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置Camera的变换矩阵</span></span><br><span class="line">        Camera.main.projectionMatrix = pr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;绕摄像机X轴晃动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;绕摄像机Y轴晃动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;绕摄像机Z轴晃动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">160.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;绕摄像机左右移动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">210.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口放缩运动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Rect属性：摄像机视图的位置和大小</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rect</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> which_change = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">float</span> temp_x = <span class="number">0.0f</span>, temp_y = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//视口平移</span></span><br><span class="line">        <span class="keyword">if</span> (which_change == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.rect.x &lt; <span class="number">1.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//沿着X轴平移</span></span><br><span class="line">                temp_x = Camera.main.rect.x + Time.deltaTime * <span class="number">0.2f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取消下面注释察看平移的变化</span></span><br><span class="line">            <span class="comment">//if (camera.rect.y&lt; 1.0f)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//沿着Y轴平移</span></span><br><span class="line">            <span class="comment">//    temp_y = camera.rect.y + Time.deltaTime * 0.2f;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(temp_x, temp_y, Camera.main.rect.width, Camera.main.rect.height);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//视口放缩</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (which_change == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.rect.width &gt; <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//沿着X轴放缩</span></span><br><span class="line">                temp_x = Camera.main.rect.width - Time.deltaTime * <span class="number">0.2f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.rect.height &gt; <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//沿着Y轴放缩</span></span><br><span class="line">                temp_y = Camera.main.rect.height - Time.deltaTime * <span class="number">0.2f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(Camera.main.rect.x, Camera.main.rect.y, temp_x, temp_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口平移&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//重置视口</span></span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">0</span>;</span><br><span class="line">            temp_y = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口放缩&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口还原&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>RenderingPath : 渲染路径</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192033051" alt="img"></p><h3 id="RenderingPath"><a href="#RenderingPath" class="headerlink" title="RenderingPath"></a>RenderingPath</h3></li></ul><blockquote><p>用于获取和设置摄像机渲染路径。Unity中渲染路径RenderingPath为枚举类型<br> VertexLit:使用顶点光照。最低消耗的渲染路径，不支持实时阴影，适用于移动及老式设备。<br> forward:使用正向光照，基于着色器的渲染路径。支持逐像素计算光照（包括法线贴图和灯光Cookies）和来自一个平行光的实时阴影。<br> DeferredLighting:使用延迟光照，支持实时阴影，计算消耗大，对硬件要求高，不支持移动设备，仅专业版可用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">renderingPath</span>: MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">120.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;UsePlayerSettings&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.renderingPath = RenderingPath.UsePlayerSettings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">120.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;VertexLit&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.renderingPath = RenderingPath.VertexLit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">120.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;Forward&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.renderingPath = RenderingPath.Forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">160.0f</span>, <span class="number">120.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;DeferredLighting&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.renderingPath = RenderingPath.DeferredLighting;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>WorldToCameramatrix：变换矩阵</li></ul><blockquote><p>返回或设置当前从世界坐标系到当前Camera自身坐标系的变换矩阵。重设矩阵时，摄像机的Transform组件数据不会同步更新。如果想回到Transform的可控状态，需要调用ResetWorldToCameraMatrix方法重置摄像机旋转矩阵。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldToCameraMatrix</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Camera c_test;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;更改变换矩阵&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用c_test的变换矩阵</span></span><br><span class="line">            Camera.main.worldToCameraMatrix = c_test.worldToCameraMatrix;</span><br><span class="line">            <span class="comment">//也可使用如下代码实现同样功能</span></span><br><span class="line">            <span class="comment">// camera.CopyFrom(c_test);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;重置变换矩阵&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetWorldToCameraMatrix</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RenderToCubMap：生成Cubemap静态贴图。</li><li>RenderWithShader:使用其他shader渲染<br> 使用指定shader来代替当前物体的shader渲染一帧。当replacementTag为空时会替换视口中所有物体的shader</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RenderWithShader</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> is_use = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_use)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用高光shader：Specular来渲染Camera</span></span><br><span class="line">            Camera.main.<span class="built_in">RenderWithShader</span>(Shader.<span class="built_in">Find</span>(<span class="string">&quot;Specular&quot;</span>), <span class="string">&quot;RenderType&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;使用RenderWithShader启用高光&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//RenderWithShader每调用一次只渲染一帧，所以不可将其直接放到这儿</span></span><br><span class="line">            <span class="comment">//camera.RenderWithShader(Shader.Find(&quot;Specular&quot;), &quot;RenderType&quot;);</span></span><br><span class="line">            is_use = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;使用SetReplacementShader启用高光&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//SetReplacementShader方法用来替换已有shader，调用一次即可</span></span><br><span class="line">            Camera.main.<span class="built_in">SetReplacementShader</span>(Shader.<span class="built_in">Find</span>(<span class="string">&quot;Specular&quot;</span>), <span class="string">&quot;RenderType&quot;</span>);</span><br><span class="line">            is_use = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;关闭高光&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetReplacementShader</span>();</span><br><span class="line">            is_use = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SetReplacementShader 使用指定的shader来替换物体当前的shader,被替换后每一帧都会替换shader来渲染物体,与上面的方法刚好不同。</li><li>ScreenPointToRay:近视口到屏幕的射线</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScreenPointToRay_ts</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Ray ray;</span><br><span class="line">    RaycastHit hit;</span><br><span class="line">    Vector3 v3 = <span class="keyword">new</span> Vector3(Screen.width / <span class="number">2.0f</span>, Screen.height / <span class="number">2.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    Vector3 hitpoint = Vector3.zero;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//射线沿着屏幕X轴从左向右循环扫描</span></span><br><span class="line">        v3.x = v3.x &gt;= Screen.width ? <span class="number">0.0f</span> : v3.x + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="comment">//生成射线</span></span><br><span class="line">        ray = Camera.main.ScreenPointToRay(v3);</span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(ray, <span class="keyword">out</span> hit, <span class="number">100.0f</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//绘制线，在Scene视图中可见</span></span><br><span class="line">            Debug.DrawLine(ray.origin, hit.point, Color.green);</span><br><span class="line">            <span class="comment">//输出射线探测到的物体的名称</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;射线探测到的物体名称：&quot;</span> + hit.transform.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ScreenToViewPortPoint 坐标系转换<br> 实现坐标点从屏幕坐标系向摄像机视口的单元化坐标系转换。但是是像素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScreenToViewportPoint_ts</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        transform.position = <span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        transform.rotation = Quaternion.identity;</span><br><span class="line">        <span class="comment">//从屏幕的实际坐标点向视口的单位化比例值转换</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;1:&quot;</span> + Camera.main.<span class="built_in">ScreenToViewportPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(Screen.width / <span class="number">2.0f</span>, Screen.height / <span class="number">2.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//从视口的单位化比例值向屏幕的实际坐标点转换</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;2:&quot;</span> + Camera.main.<span class="built_in">ViewportToScreenPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;屏幕宽：&quot;</span> + Screen.width + <span class="string">&quot;  屏幕高：&quot;</span> + Screen.height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ScreenToworldPoint : 坐标系转换，从屏幕坐标系到世界坐标系，实际单位像素组值，而非比例值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScreenToWorldPoint_ts</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        transform.position = <span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        Camera.main.fieldOfView = <span class="number">60.0f</span>;</span><br><span class="line">        Camera.main.aspect = <span class="number">16.0f</span> / <span class="number">10.0f</span>;</span><br><span class="line">        <span class="comment">//Z轴前方100处对应的屏幕的左下角的世界坐标值</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;1:&quot;</span> + Camera.main.<span class="built_in">ScreenToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//Z轴前方100处对应的屏幕的中间的世界坐标值</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;2:&quot;</span> + Camera.main.<span class="built_in">ScreenToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(Screen.width / <span class="number">2.0f</span>, Screen.height / <span class="number">2.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//Z轴前方100处对应的屏幕的右上角的世界坐标值</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;3:&quot;</span> + Camera.main.<span class="built_in">ScreenToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(Screen.width, Screen.height, <span class="number">100.0f</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ViewPortToWorldpoint 视口坐标点向世界坐标点转换。</li></ul><blockquote><p>此方法的返回值受当前摄像机在世界坐标系的位置Camera的FieldOfView的值以及Position的共同影响</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">ViewportToWorldPoint</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        transform.position = <span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        Camera.main.fieldOfView = <span class="number">60.0f</span>;</span><br><span class="line">        Camera.main.aspect = <span class="number">16.0f</span> / <span class="number">10.0f</span>;</span><br><span class="line">        <span class="comment">//屏幕左下角</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;1:&quot;</span> + Camera.main.<span class="built_in">ViewportToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//屏幕中间</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;2:&quot;</span> + Camera.main.<span class="built_in">ViewportToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//屏幕右上角</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;3:&quot;</span> + Camera.main.<span class="built_in">ViewportToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>WorldToScreenPoint：世界坐标转成屏幕坐标。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldToScreenPoint</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform cb, sp;</span><br><span class="line">    <span class="keyword">public</span> Texture2D t2;</span><br><span class="line">    Vector3 v3 = Vector3.zero;</span><br><span class="line">    <span class="type">float</span> sg;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//记录屏幕高度</span></span><br><span class="line">        sg = Screen.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//sp绕着cb的Y轴旋转</span></span><br><span class="line">        sp.<span class="built_in">RotateAround</span>(cb.position, cb.up, <span class="number">30.0f</span> * Time.deltaTime);</span><br><span class="line">        <span class="comment">//获取sp在屏幕上的坐标点</span></span><br><span class="line">        v3 = Camera.main.<span class="built_in">WorldToScreenPoint</span>(sp.position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//绘制纹理</span></span><br><span class="line">        GUI.<span class="built_in">DrawTexture</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, sg - v3.y, v3.x, sg), t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>WorldToViewPoint：从世界坐标转换屏幕单位化坐标中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldToViewportPoint</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform cb, sp;</span><br><span class="line">    <span class="keyword">public</span> Texture2D t2;</span><br><span class="line">    Vector3 v3 = Vector3.zero;</span><br><span class="line">    <span class="type">float</span> sw, sh;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//记录屏幕的宽度和高度</span></span><br><span class="line">        sw = Screen.width;</span><br><span class="line">        sh = Screen.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//物体sp始终绕cb的Y轴旋转</span></span><br><span class="line">        sp.<span class="built_in">RotateAround</span>(cb.position, cb.up, <span class="number">30.0f</span> * Time.deltaTime);</span><br><span class="line">        <span class="comment">//记录sp映射到屏幕上的比例值</span></span><br><span class="line">        v3 = Camera.main.<span class="built_in">WorldToViewportPoint</span>(sp.position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//绘制纹理，由于方法WorldToViewportPoint的返回值的y分量是从屏幕下方向上方递增的，</span></span><br><span class="line">        <span class="comment">//所以需要先计算1.0f - v3.y的值，然后再和sh相乘。</span></span><br><span class="line">        GUI.<span class="built_in">DrawTexture</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, sh * (<span class="number">1.0f</span> - v3.y), sw * v3.x, sh), t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SetTargetBuffers:重设摄像机到TargetTexture的渲染</li></ul><blockquote><p>SetTargetBuffers(RenderBuffer colorBuffer,RenderBuffer depthBuffer)其中参数ColorBuffer为纹理颜色缓存，depthBuffer为纹理的深度缓存。</p><p>SetTargetBuffers(RenderBuffer [] colorBuffer,RenderBuffer depthBuffer)其中参数ColorBuffer为纹理颜色缓存，depthBuffer为纹理的深度缓存,这个方法可以将摄像机的渲染一次赋给多个colorBuffer.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTargetBuffers</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明两个RendererTexture变量</span></span><br><span class="line">    <span class="keyword">public</span> RenderTexture RT_1, RT_2;</span><br><span class="line">    <span class="keyword">public</span> Camera c;<span class="comment">//指定Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//设置RT_1的buffer为摄像机c的渲染</span></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">180.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;set target buffers&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            c.<span class="built_in">SetTargetBuffers</span>(RT_1.colorBuffer, RT_1.depthBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置RT_2的buffer为摄像机c的渲染，此时RT_1的buffer变为场景中Camera1的渲染</span></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">180.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;Reset target buffers&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            c.<span class="built_in">SetTargetBuffers</span>(RT_2.colorBuffer, RT_2.depthBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><img src="/Users/liuyingbo/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_f4c33210-6f3a-4c09-b711-e773ec9f2ba6.png" alt="企业微信截图_f4c33210-6f3a-4c09-b711-e773ec9f2ba6"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192034641.png" alt="image-20220329232239750"></p><p>通过两个相机组合，一个透视相机一个正交相机，设置遮挡剔除实现3D麻将牌桌效果。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity解析Json</title>
      <link href="/posts/fa97511a.html"/>
      <url>/posts/fa97511a.html</url>
      
        <content type="html"><![CDATA[<h2 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h2><h3 id="一、Unity自带的Json库"><a href="#一、Unity自带的Json库" class="headerlink" title="一、Unity自带的Json库"></a>一、Unity自带的Json库</h3><p>官方API：<a href="https://docs.unity3d.com/ScriptReference/JsonUtility.html">https://docs.unity3d.com/ScriptReference/JsonUtility.html</a></p><p>在Unity中使用JsonUtility类对Json进行解析，此类包含三个重要方法，下面进行详解。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023677.png" alt="img"></p><h3 id="二、FromJson方法（反序列化）"><a href="#二、FromJson方法（反序列化）" class="headerlink" title="二、FromJson方法（反序列化）"></a>二、FromJson方法（反序列化）</h3><p>将Json转换为object</p><p>返回值是一个Object，<strong>需要在对应的类或结构体前标记Serializable属性（没标记好像也行 序列化不成功可能就是因为没有标记）</strong>。object类型必须支持序列化，其中的字段也必须支持序列化（比如私有类型、标记了NonSerialized属性的类型等不可序列化字段会被忽视）。</p><p>只有普通的类/结构体才行， 继承自UnityEngine.Object (比如 MonoBehaviour 或 ScriptableObject)的类则不行。</p><p>使用string的此函数可以在后台线程调用，但使用TextAsset的此函数只可以在主线程调用。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[System.Serializable]</span><br><span class="line">public class PlayerInfo</span><br><span class="line">&#123;</span><br><span class="line">    public string name;</span><br><span class="line">    public int lives;</span><br><span class="line">    public float health;</span><br><span class="line"></span><br><span class="line">    public static PlayerInfo CreateFromJSON(string jsonString)</span><br><span class="line">    &#123;</span><br><span class="line">        return JsonUtility.FromJson&lt;PlayerInfo&gt;(jsonString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Given JSON input:</span><br><span class="line">    // &#123;&quot;name&quot;:&quot;Dr Charles&quot;,&quot;lives&quot;:3,&quot;health&quot;:0.8&#125;</span><br><span class="line">    // this example will return a PlayerInfo object with</span><br><span class="line">    // name == &quot;Dr Charles&quot;, lives == 3, and health == 0.8f.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、ToJson（序列化）"><a href="#三、ToJson（序列化）" class="headerlink" title="三、ToJson（序列化）"></a>三、ToJson（序列化）</h3><p>将object转换为Json</p><div class="table-container"><table><thead><tr><th>obj</th><th>要转换为Json的object</th></tr></thead><tbody><tr><td>prettyPrint</td><td>如果为true，则格式化输出以确保可读性。如果为false，则将输出格式化为最小大小。默认值为false。</td></tr></tbody></table></div><p>　　</p><p>　　返回值是json格式的string。</p><p>　　传入的object必须是支持序列化的：这个object必须继承自MonoBehaviour、ScriptableObject（其他引擎类型使用<a href="https://docs.unity3d.com/ScriptReference/EditorJsonUtility.ToJson.html">EditorJsonUtility.Tojson</a>）,或者是标记Serializable属性的普通类/结构体。想要包含的字段也必须是支持序列化的，不支持序列化的字段如private、static以及标记了NonSerialized属性的字段等会被忽略。</p><p>　　传入的object不能是基本数据类型如int,float，也不能为数组。想要序列化基本数据类型或者数组，就需要将它们写入一个类或结构体中，再将类/结构体实例化的对象传入即可。</p><div class="table-container"><table><thead><tr><th>直接传入一个数组，序列化失败</th><th><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023012.png" alt="img"></th><th><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/2275552-20210408124909857-1652065208.png" alt="img"></th></tr></thead><tbody><tr><td>将数组写进类中，将类实例化对象传入，序列化成功</td><td><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023104.png" alt="img"> <img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023165.png" alt="img"></td><td><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/2275552-20210408125022417-1750796703.png" alt="img"></td></tr></tbody></table></div><p>　　此函数可以在后台线程中执行，但此函数执行过程中不要去修改传入的object的值。</p><h3 id="四、FromJsonOverwrite"><a href="#四、FromJsonOverwrite" class="headerlink" title="四、FromJsonOverwrite"></a>四、FromJsonOverwrite</h3><p>　　此函数和FromJson非常类似，只有一点不同：此函数要把Json中的数据读入一个已经存在的对象中，覆盖该对象原来的数据。（FromJson是返回一个新创建的对象）</p><h3 id="五、遇到不支持序列化的类型怎么办？"><a href="#五、遇到不支持序列化的类型怎么办？" class="headerlink" title="五、遇到不支持序列化的类型怎么办？"></a>五、遇到不支持序列化的类型怎么办？</h3><p>　　JsonUtilty类能力有限，并不能序列化/反序列化所有类型的数据，比如字典类型。这个时候就要实现Unity提供给我们的一个接口：ISerializationCallbackReceiver</p><p>具体说明见官方文档：<a href="https://docs.unity3d.com/cn/current/ScriptReference/ISerializationCallbackReceiver.html">https://docs.unity3d.com/cn/current/ScriptReference/ISerializationCallbackReceiver.html</a></p><h2 id="Unity中Json库性能对比测试"><a href="#Unity中Json库性能对比测试" class="headerlink" title="Unity中Json库性能对比测试"></a>Unity中Json库性能对比测试</h2><h3 id="类库大小对比"><a href="#类库大小对比" class="headerlink" title="类库大小对比:"></a><strong>类库大小对比:</strong></h3><div class="table-container"><table><thead><tr><th>类库</th><th style="text-align:center">文件类型</th><th style="text-align:right">大小</th></tr></thead><tbody><tr><td>NewtonsoftJson</td><td style="text-align:center">.dll</td><td style="text-align:right">353KB</td></tr><tr><td>LitJson</td><td style="text-align:center">.dll</td><td style="text-align:right">56KB</td></tr><tr><td>SimpleJSON</td><td style="text-align:center">.cs</td><td style="text-align:right">68KB</td></tr></tbody></table></div><h3 id="解析时间对比："><a href="#解析时间对比：" class="headerlink" title="解析时间对比："></a><strong>解析时间对比：</strong></h3><p>执行次数：10000次</p><div class="table-container"><table><thead><tr><th>测试方法</th><th style="text-align:center">NewtonsoftJson</th><th style="text-align:center">LitJson</th><th style="text-align:right">SimpleJSON</th></tr></thead><tbody><tr><td>测试1</td><td style="text-align:center">114ms</td><td style="text-align:center">158ms</td><td style="text-align:right">52ms</td></tr><tr><td>测试2</td><td style="text-align:center">136ms</td><td style="text-align:center">288ms</td><td style="text-align:right">126ms</td></tr><tr><td>测试3</td><td style="text-align:center">263ms</td><td style="text-align:center">542ms</td><td style="text-align:right">169ms</td></tr><tr><td>测试4</td><td style="text-align:center">333ms</td><td style="text-align:center">747ms</td><td style="text-align:right">200ms</td></tr></tbody></table></div><h3 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a><strong>测试代码：</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> LitJson;</span><br><span class="line"><span class="keyword">using</span> SimpleJSON;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json.Linq;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> JsonTest</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ZhangYu 2019-07-11</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;para&gt;</span>Blog：https://segmentfault.com/a/1190000019731298<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JsonTest</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> count = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> Stopwatch watch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        watch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> json1 = <span class="string">&quot;&#123;\&quot;id\&quot;:10001,\&quot;name\&quot;:\&quot;test\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> json2 = <span class="string">&quot;[1,2,3,4,5,6,7,8,9,10]&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> json3 = <span class="string">&quot;&#123;\&quot;id\&quot;:10000,\&quot;username\&quot;:\&quot;zhangyu\&quot;,\&quot;password\&quot;:\&quot;123456\&quot;,\&quot;nickname\&quot;:\&quot;冰封百度\&quot;,\&quot;age\&quot;:20,\&quot;gender\&quot;:1,\&quot;phone\&quot;:12345678910,\&quot;email\&quot;:\&quot;zhangyu@xx.com\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> json4 = <span class="string">&quot;[\&quot;test2\&quot;,[[\&quot;key1\&quot;,    \&quot;id\&quot;],[\&quot;key2\&quot;,    \&quot;hp\&quot;],[\&quot;key3\&quot;,    \&quot;mp\&quot;],[\&quot;key4\&quot;,    \&quot;exp\&quot;],[\&quot;key5\&quot;,    \&quot;money\&quot;],[\&quot;key6\&quot;,    \&quot;point\&quot;],[\&quot;key7\&quot;,    \&quot;age\&quot;],[\&quot;key8\&quot;,    \&quot;sex\&quot;]]]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        JsonParseTest(json1);</span><br><span class="line">        JsonParseTest(json2);</span><br><span class="line">        JsonParseTest(json3);</span><br><span class="line">        JsonParseTest(json4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">JsonParseTest</span>(<span class="params"><span class="built_in">string</span> json</span>)</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;json:&quot;</span> + json);</span><br><span class="line">        <span class="built_in">bool</span> isArray = json[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        NewtonsoftJsonTest(json, isArray);</span><br><span class="line">        LiteJsonTest(json);</span><br><span class="line">        SimpleJsonTest(json);</span><br><span class="line">        print(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NewtonsoftJsonTest</span>(<span class="params"><span class="built_in">string</span> json, <span class="built_in">bool</span> isArray</span>)</span> &#123;</span><br><span class="line">        watch.Reset();</span><br><span class="line">        watch.Start();</span><br><span class="line">        <span class="keyword">if</span> (isArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                JArray jArray = JArray.Parse(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                JObject jObj = JObject.Parse(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        watch.Stop();</span><br><span class="line">        print(<span class="string">&quot;NewtonsoftJson Parse Time(ms):&quot;</span> + watch.ElapsedMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LiteJsonTest</span>(<span class="params"><span class="built_in">string</span> json</span>)</span> &#123;</span><br><span class="line">        watch.Reset();</span><br><span class="line">        watch.Start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            JsonData jData = JsonMapper.ToObject(json);</span><br><span class="line">        &#125;</span><br><span class="line">        watch.Stop();</span><br><span class="line">        print(<span class="string">&quot;LiteJson Parse Time(ms):&quot;</span> + watch.ElapsedMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SimpleJsonTest</span>(<span class="params"><span class="built_in">string</span> json</span>)</span> &#123;</span><br><span class="line">        watch.Reset();</span><br><span class="line">        watch.Start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            JSONNode jNode = JSON.Parse(json);</span><br><span class="line">        &#125;</span><br><span class="line">        watch.Stop();</span><br><span class="line">        print(<span class="string">&quot;SimpleJson Parse Time(ms):&quot;</span> + watch.ElapsedMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023414.png" alt="解析时间对比"></p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h3><p>SimpleJSON获胜!<br>SimpleJSON以体积最小，速度最快，集成最容易的优势胜出<br>SimpleJSON针对Unity在持续优化，更新较快，而且体积小，速度快，有源码，推荐SimpleJSON<br>NewtonsoftJson因为体积太大被淘汰，按理来说，这么大的类库肯定支持更多功能，可惜现有的项目并没有太过复杂的json，无法检验。<br>LitJson体积也小巧，使用也很方便，可惜速度完全没有优势。</p><h2 id="NewtonsoftJson使用"><a href="#NewtonsoftJson使用" class="headerlink" title="NewtonsoftJson使用"></a>NewtonsoftJson使用</h2><p>正好项目中用到了所以就以Newtonsoft.Json为例子，更多功能看官方文档吧。</p><p>官方文档：<a href="https://www.newtonsoft.com/json。">https://www.newtonsoft.com/json。</a></p><p>对于要在 JSON 字符串之间进行转换的简单场景， <a href="https://www.newtonsoft.com/json/help/html/Overload_Newtonsoft_Json_JsonConvert_SerializeObject.htm">SerializeObject</a>和 <a href="https://www.newtonsoft.com/json/help/html/Overload_Newtonsoft_Json_JsonConvert_DeserializeObject.htm">反序列化对象</a> JsonConvert 上的方法为 JsonSerializer 提供了一个易于使用的包装器。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">product.Name = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">product.ExpiryDate = <span class="keyword">new</span> DateTime(<span class="number">2008</span>, <span class="number">12</span>, <span class="number">28</span>);</span><br><span class="line">product.Price = <span class="number">3.99</span>M;</span><br><span class="line">product.Sizes = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Small&quot;</span>, <span class="string">&quot;Medium&quot;</span>, <span class="string">&quot;Large&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> output = JsonConvert.SerializeObject(product);</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  &quot;Name&quot;: &quot;Apple&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;ExpiryDate&quot;: &quot;2008-12-28T00:00:00&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;Price&quot;: 3.99,</span></span><br><span class="line"><span class="comment">//  &quot;Sizes&quot;: [</span></span><br><span class="line"><span class="comment">//    &quot;Small&quot;,</span></span><br><span class="line"><span class="comment">//    &quot;Medium&quot;,</span></span><br><span class="line"><span class="comment">//    &quot;Large&quot;</span></span><br><span class="line"><span class="comment">//  ]</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">Product deserializedProduct = JsonConvert.DeserializeObject&lt;Product&gt;(output);</span><br></pre></td></tr></table></figure><p>SerializeObject 和 DeserializeObject 都具有采用<a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_JsonSerializerSettings.htm">JsonSerializerSettings</a>对象的重载。JsonSerializerSettings 允许您使用下面列出的许多 JsonSerializer 设置，同时仍然使用简单的序列化方法。</p><p>为了更好地控制对象的序列化方式，可以直接使用<a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_JsonSerializer.htm">JsonSerializer 。</a><a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_JsonTextReader.htm">JsonSerializer 能够通过JsonTextReader</a> 和<a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_JsonTextWriter.htm">JsonTextWriter</a>直接读取 JSON 文本并将其写入流。也可以使用其他类型的 JsonWriters，例如 <a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Linq_JTokenReader.htm">JTokenReader</a> / <a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Linq_JTokenWriter.htm">JTokenWriter</a>将您的对象与 LINQ 对象转换为 JSON 对象，或 <a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Bson_BsonReader.htm">BsonReader</a> / <a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Bson_BsonWriter.htm">BsonWriter</a>用于与 BSON 进行转换。</p><p>使用 JsonSerializer 将 JSON 序列化为流</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Product product = <span class="keyword">new</span> Product();</span><br><span class="line">product.ExpiryDate = <span class="keyword">new</span> DateTime(<span class="number">2008</span>, <span class="number">12</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">JsonSerializer serializer = <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">serializer.Converters.Add(<span class="keyword">new</span> JavaScriptDateTimeConverter());</span><br><span class="line">serializer.NullValueHandling = NullValueHandling.Ignore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(<span class="string">@&quot;c:\json.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (JsonWriter writer = <span class="keyword">new</span> JsonTextWriter(sw))</span><br><span class="line">&#123;</span><br><span class="line">    serializer.Serialize(writer, product);</span><br><span class="line">    <span class="comment">// &#123;&quot;ExpiryDate&quot;:new Date(1230375600000),&quot;Price&quot;:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JsonSerializer 上有许多属性来自定义它如何序列化 JSON。这些也可以通过 JsonSerializerSettings 重载与 JsonConvert 上的方法一起使用。</p><h3 id="反序列化部分Json"><a href="#反序列化部分Json" class="headerlink" title="反序列化部分Json"></a>反序列化部分Json</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SearchResult</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> googleSearchText = <span class="string">@&quot;&#123;</span></span><br><span class="line"><span class="string">  &#x27;responseData&#x27;: &#123;</span></span><br><span class="line"><span class="string">    &#x27;results&#x27;: [</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        &#x27;GsearchResultClass&#x27;: &#x27;GwebSearch&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;unescapedUrl&#x27;: &#x27;http://en.wikipedia.org/wiki/Paris_Hilton&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;url&#x27;: &#x27;http://en.wikipedia.org/wiki/Paris_Hilton&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;visibleUrl&#x27;: &#x27;en.wikipedia.org&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;cacheUrl&#x27;: &#x27;http://www.google.com/search?q=cache:TwrPfhd22hYJ:en.wikipedia.org&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;title&#x27;: &#x27;&lt;b&gt;Paris Hilton&lt;/b&gt; - Wikipedia, the free encyclopedia&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;titleNoFormatting&#x27;: &#x27;Paris Hilton - Wikipedia, the free encyclopedia&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;content&#x27;: &#x27;[1] In 2006, she released her debut album...&#x27;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        &#x27;GsearchResultClass&#x27;: &#x27;GwebSearch&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;unescapedUrl&#x27;: &#x27;http://www.imdb.com/name/nm0385296/&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;url&#x27;: &#x27;http://www.imdb.com/name/nm0385296/&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;visibleUrl&#x27;: &#x27;www.imdb.com&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;cacheUrl&#x27;: &#x27;http://www.google.com/search?q=cache:1i34KkqnsooJ:www.imdb.com&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;title&#x27;: &#x27;&lt;b&gt;Paris Hilton&lt;/b&gt;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;titleNoFormatting&#x27;: &#x27;Paris Hilton&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;content&#x27;: &#x27;Self: Zoolander. Socialite &lt;b&gt;Paris Hilton&lt;/b&gt;...&#x27;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &#x27;cursor&#x27;: &#123;</span></span><br><span class="line"><span class="string">      &#x27;pages&#x27;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &#x27;start&#x27;: &#x27;0&#x27;,</span></span><br><span class="line"><span class="string">          &#x27;label&#x27;: 1</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &#x27;start&#x27;: &#x27;4&#x27;,</span></span><br><span class="line"><span class="string">          &#x27;label&#x27;: 2</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &#x27;start&#x27;: &#x27;8&#x27;,</span></span><br><span class="line"><span class="string">          &#x27;label&#x27;: 3</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &#x27;start&#x27;: &#x27;12&#x27;,</span></span><br><span class="line"><span class="string">          &#x27;label&#x27;: 4</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ],</span></span><br><span class="line"><span class="string">      &#x27;estimatedResultCount&#x27;: &#x27;59600000&#x27;,</span></span><br><span class="line"><span class="string">      &#x27;currentPageIndex&#x27;: 0,</span></span><br><span class="line"><span class="string">      &#x27;moreResultsUrl&#x27;: &#x27;http://www.google.com/search?oe=utf8&amp;ie=utf8...&#x27;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &#x27;responseDetails&#x27;: null,</span></span><br><span class="line"><span class="string">  &#x27;responseStatus&#x27;: 200</span></span><br><span class="line"><span class="string">&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">JObject googleSearch = JObject.Parse(googleSearchText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get JSON result objects into a list</span></span><br><span class="line">IList&lt;JToken&gt; results = googleSearch[<span class="string">&quot;responseData&quot;</span>][<span class="string">&quot;results&quot;</span>].Children().ToList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// serialize JSON results into .NET objects</span></span><br><span class="line">IList&lt;SearchResult&gt; searchResults = <span class="keyword">new</span> List&lt;SearchResult&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (JToken result <span class="keyword">in</span> results)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// JToken.ToObject is a helper method that uses JsonSerializer internally</span></span><br><span class="line">    SearchResult searchResult = result.ToObject&lt;SearchResult&gt;();</span><br><span class="line">    searchResults.Add(searchResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Title = &lt;b&gt;Paris Hilton&lt;/b&gt; - Wikipedia, the free encyclopedia</span></span><br><span class="line"><span class="comment">// Content = [1] In 2006, she released her debut album...</span></span><br><span class="line"><span class="comment">// Url = http://en.wikipedia.org/wiki/Paris_Hilton</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Title = &lt;b&gt;Paris Hilton&lt;/b&gt;</span></span><br><span class="line"><span class="comment">// Content = Self: Zoolander. Socialite &lt;b&gt;Paris Hilton&lt;/b&gt;...</span></span><br><span class="line"><span class="comment">// Url = http://www.imdb.com/name/nm0385296/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-全局屏幕点击特效</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192050977.gif" alt="img"></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先canvas的设置调为camera模式</p><p><strong>Screen Space -OverLay</strong>:只显示所创建的canvas中的内容，即只渲染画布。</p><p><strong>Screen Space-Camera</strong>：只显示相机所渲染的区域，当保证camera的projection是perspective（透视模式）而不是（orthogonality）正交模式的时候通过调整canvas中image或其他物体的Rotation可以制作3D立体效果的UI，但是这种模式下不可以更改Canvas的ReactTransform,只能通过相机来调整canvas的显示位置和显示大小。</p><p><strong>World Space</strong>：canvas的ReacTransform完全可以编辑并且把canvas完全当成一个普通的类似于Cube的物体在场景中进行渲染，仔细考虑一下这种模式，如果你把canvas赋给游戏人物，那么你会发现这种模式适合给人物做血条或者在场景中一直在游戏人物的头顶显示人物名称。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192050747.png" alt="image-20220314231710281"></p><h2 id="Unity坐标"><a href="#Unity坐标" class="headerlink" title="Unity坐标"></a>Unity坐标</h2><h3 id="世界坐标："><a href="#世界坐标：" class="headerlink" title="世界坐标："></a>世界坐标：</h3><p>场景中非子物体的transform组件的坐标。Unity中的通过transform.position获取到的坐标即为世界坐标，注意:Inspector上点击子物体显示的transform上的坐标值是局部坐标，通过transform.localposition获取。</p><h3 id="屏幕坐标："><a href="#屏幕坐标：" class="headerlink" title="屏幕坐标："></a>屏幕坐标：</h3><p>屏幕坐标即当前整个游戏画面分辨率为主创建的坐标系，画面左下角为原点(0,0)，宽高根据分辨率而定，如分辨率为1920X1080，则宽Screen.width = 1920，Screen.height = 1080.</p><h3 id="视口坐标："><a href="#视口坐标：" class="headerlink" title="视口坐标："></a>视口坐标：</h3><p>将屏幕坐标normalized化，x值 = 1/Screen.width,y值 = 1/Screen.height。，即原点变不变依然为(0,0),宽高则为(1,1)。</p><h3 id="UI坐标："><a href="#UI坐标：" class="headerlink" title="UI坐标："></a>UI坐标：</h3><p>以UI上的RectTransform的width和height为宽高，根据锚点不同，原点也不一样。</p><h3 id="转换："><a href="#转换：" class="headerlink" title="转换："></a>转换：</h3><blockquote><p>1.屏幕转世界坐标<br> Vector3 Camera.main.ScreenToWorldPoint(newVector3(screenPos.x,screenPos.y,zInfo));</p><p>2.世界转屏幕坐标<br> Vector3 Camera.main.WorldToScreenPoint(newVector3(worldPos.x,worldPos.y,worldPos.z));</p><p>3.世界转视口坐标<br> Vector3 Camera.main.WorldToViewportPoint();</p><p>4.视口转世界坐标<br> Vector3 Camera.main.ViewportToWorldPoint(newVector3(viewPortPos.x,viewPortPos.y,zInfo));</p><p>5.视口转屏幕坐标<br> Vector3 Camera.main.ViewportToScreenPoint();</p><p>6.屏幕转视口坐标<br> Vector3 Camera.main.ScreenToViewportPoint();</p><p>7.屏幕转UI坐标:这个比较特殊，如果UI宽高和屏幕宽高一样，那么可以不用转换，直接通过屏幕坐标根据锚点赋值即可。其他情况下：<br> RectTransformUtility.ScreenPointToLocalPointInRectangle<br> (RectTransform rect,<br> Vector2 screenPoint,<br> Camera cam,<br> outVector2 localPoint);</p></blockquote><p>rect表示该UI的父物体的组件，<br> screenPoint表示屏幕坐标，<br> cam表示当前使用的相机(如果Canvas是Screen Space-overlay模式，cam参数应为null),<br> localPoint则是输出的UI的局部坐标。<br> 这个函数是根据父物体的坐标系来计算出当面屏幕坐标应该转换为的值，该值是相对父物体而言的局部坐标。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FXContainer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Vector2 point;</span><br><span class="line">    <span class="keyword">public</span> Transform parent;</span><br><span class="line">    <span class="keyword">public</span> GameObject effect;</span><br><span class="line">    <span class="keyword">public</span> Canvas UICanvas; <span class="comment">//你所使用的UICanvas</span></span><br><span class="line">    [<span class="meta">Range(0, 5.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> desTime = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//将鼠标点击的屏幕坐标转换为UI坐标，最后一个输出参数为转换的点</span></span><br><span class="line">            RectTransformUtility.ScreenPointToLocalPointInRectangle(UICanvas.transform <span class="keyword">as</span> RectTransform,Input.mousePosition, UICanvas.worldCamera, <span class="keyword">out</span> point);</span><br><span class="line"></span><br><span class="line">            GameObject go = Instantiate(effect, parent);</span><br><span class="line">            go.GetComponent&lt;RectTransform&gt;().anchoredPosition = point;</span><br><span class="line">            Destroy(go, desTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是靠RectTransformUtility.ScreenPointToLocalPointInRectangle获取鼠标点击的UI坐标，如果想优化的话可以写个对象池，扩展可以实现粒子效果跟随鼠标,图片跟随鼠标等</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-底层原理</title>
      <link href="/posts/b6d0915c.html"/>
      <url>/posts/b6d0915c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Unity是如何实现跨平台的"><a href="#Unity是如何实现跨平台的" class="headerlink" title="Unity是如何实现跨平台的"></a>Unity是如何实现跨平台的</h2><p>首先，我们要知道Unity,Mono,.Net 三者的关系。需要简单说一下.Net。</p><p>.Net拥有跨语言，跨平台性。</p><p>跨语言：就是只要是面向.Net平台的编程语言，用其中一种语言编写的类型就可以无缝的在另外一种语言编写的应用程序中互操作。</p><p>跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意在.Net实现的平台上跑，即代码不依赖于操作系统，也不依赖硬件环境。一个.Net程序运行的核心在于.Net</p><p>CLR(公共语言运行时，或者称为.Net 虚拟机，类似java虚拟机的概念)，为了让.Net程序在其他平台（目前只能在.Net 平台,windows系统）上跑,微软官方还推出了在其他平台上(MacOs,Linux)跑的</p><p>.Net的实现，就推出了.Net Core。</p><p>然而，Unity引擎需求也是需要跨平台，支持多语言（C#，Js，Boo）。就参考微软开发.Net Core的概念，于是，推出了Mono.</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049788.png" alt="img"></p><p>到这里，基本说明了.Net 与Mono和Unity的联系关系，其实没啥关系。做游戏都知道，肯定需要跨平台，不能只支持一种平台，不然每个对应的平台做出一种对应的编译器，那真的会累死。所以对于跨平台的需求，对于游戏开发而言，很重要。Unity的架构需求设计当然也需要这个特性。参考.Net依托CLR来实现设计思路，于是Mono就出来了。</p><h2 id="Mono介绍"><a href="#Mono介绍" class="headerlink" title="Mono介绍"></a>Mono介绍</h2><p><strong>Mono</strong>是一个由<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/Xamarin">Xamarin</a>公司所主持的自由开放源码项目。<br>Mono的目标是在尽可能多的平台上使.net标准的东西能正常运行的一套工具，核心在于“跨平台的让.net代码能运行起来“。<br>Mono组成组件：C# 编译器，CLI虚拟机，以及核心类别程序库。<br>Mono的编译器<strong>负责生成符合公共语言规范的映射代码</strong>，即公共中间语言（Common Intermediate Language，<strong>CIL</strong>），我的理解就是工厂方法实现不同解析。<br>IL的全称是 Intermediate Language，很多时候还会看到<strong>CIL</strong>（特指在.Net平台下的IL标准）。翻译过来就是中间语言。<br>它是一种属于通用语言架构和.NET框架的低阶的人类可读的编程语言。<br>CIL类似一个面向对象的汇编语言，并且它是完全基于堆栈的，它运行在虚拟机上（.Net Framework, Mono VM）的语言。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049879.png" alt="img"></p><h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a><strong>工作流程：</strong></h3><ol><li>通过C#编译器mcs，将C#编译为IL（中间语言，byte code）</li><li>通过Mono运行时中的编译器将IL编译成对应平台的原生码</li></ol><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a><strong>编译器</strong></h3><blockquote><p>C#编译器mcs：将C#编译为<strong>IL</strong><br>Mono Runtime编译器：将IL转移为<strong>原生码</strong>。</p></blockquote><h3 id="三种转译方式："><a href="#三种转译方式：" class="headerlink" title="三种转译方式："></a><strong>三种转译方式：</strong></h3><p><strong>即时编译（Just in time,JIT）</strong>：程序运行过程中，将CIL的byte code转译为目标平台的原生码。<br><strong>提前编译（Ahead of time,AOT）</strong>：程序运行之前，将.exe或.dll文件中的CIL的byte code部分转译为目标平台的原生码并且存储，程序运行中仍有部分CIL的byte code需要JIT编译。<br><strong>完全静态编译（Full ahead of time,Full-AOT）</strong>：程序运行前，将所有源码编译成目标平台的原生码。</p><h3 id="Unity跨平台的原理"><a href="#Unity跨平台的原理" class="headerlink" title="Unity跨平台的原理"></a>Unity跨平台的原理</h3><blockquote><p>Mono运行时编译器支持将IL代码转为对应平台原生码<br>IL可以在任何支持CLI,通用语言环境结构)中运行，IL的运行是依托于Mono运行时。</p></blockquote><h3 id="IOS不支持jit编译原因："><a href="#IOS不支持jit编译原因：" class="headerlink" title="IOS不支持jit编译原因："></a>IOS不支持jit编译原因：</h3><blockquote><p>机器码被禁止映射到内存，即封存了内存的可执行权限，变相的封锁了jit编译方式。</p></blockquote><h3 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a><strong>JIT编译</strong></h3><blockquote><p>将IL代码转为对应平台原生码并且将原生码映射到虚拟内存中执行。JIT编译的时候IL是在依托Mono运行时，转为对应的原生码后在依托本地运行。</p></blockquote><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049905.png" alt="img"></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>构建应用非常快</li><li>由于Mono的JIT(Just In Time compilation ) 机制, 所以支持更多托管类库</li><li>支持运行时代码执行</li><li>必须将代码发布成托管程序集(.dll 文件 , 由mono或者.net 生成 )</li><li>Mono VM在各个平台移植异常麻烦，有几个平台就得移植几个VM（WebGL和UWP这两个平台只支持 IL2CPP）</li><li>Mono版本授权受限，C#很多新特性无法使用</li><li>iOS仍然支持Mono , 但是不再允许Mono(32位)应用提交到Apple Store</li></ol><h2 id="IL2CPP介绍"><a href="#IL2CPP介绍" class="headerlink" title="IL2CPP介绍"></a>IL2CPP介绍</h2><p>IL2CPP 是 Unity一种新的脚本后处理(Scripting Backend)方式，针对.Net平台编译输出的IL（中间语言）进行处理。</p><h3 id="IL2CPP主要由两部分组成"><a href="#IL2CPP主要由两部分组成" class="headerlink" title="IL2CPP主要由两部分组成"></a>IL2CPP主要由两部分组成</h3><p>AOT静态编译编译器（il2cpp.exe），把IL中间语言转换成CPP文件</p><p>运行时库（libil2cpp）<br>其中AOT将 IL转换为C++源码，再交给各平台的C++编译器进行编译，达到平台兼容的目的；运行时库则会提供诸如 垃圾回收、线程/文件获取、内部调用直接修改托管数据结构的原生代码 的服务与抽象。</p><h4 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h4><blockquote><p>IL2CPP AOT编译器名为il2cpp.exe。<br>在Windows上，您可以在<code>Editor \ Data \ il2cpp</code>目录中找到它。<br>在OSX上，它位于Unity安装的<code>Contents / Frameworks / il2cpp / build</code>目录中<br>il2cpp.exe 是由C#编写的受托管的可执行程序，它接受我们在Unity中通过Mono编译器生成的托管程序集，并生成指定平台下的C++代码。</p></blockquote><h4 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a><strong>运行时库</strong></h4><blockquote><p>IL2CPP技术的另一部分是运行时库（libil2cpp），用于支持IL2CPP虚拟机的运行。<br>这个简单且可移植的运行时库是IL2CPP技术的主要优势之一！<br>通过查看我们随Unity一起提供的libil2cpp的头文件，您可以找到有关libil2cpp代码组织方式的一些线索<br>您可以在Windows的<code>Editor \ Data \ PlaybackEngines \ webglsupport \ BuildTools \ Libraries \ libil2cpp \ include</code>目录中找到它们<br>或OSX上的<code>Contents / Frameworks / il2cpp / libil2cpp</code>目录。</p></blockquote><h3 id="为何要转成CPP"><a href="#为何要转成CPP" class="headerlink" title="为何要转成CPP"></a>为何要转成CPP</h3><ul><li>运行效率快</li></ul><blockquote><p>根据官方的实验数据，换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。</p></blockquote><ul><li>Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成</li></ul><blockquote><p>Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，像Unity这样支持多平台的引擎，Mono官方的VM肯定是不能满足需求的。所以针对不同的新平台，Unity的项目组就要把VM给移植一遍，同时解决VM里面发现的bug。这非常耗时耗力。这些能移植的平台还好说，还有比如WebGL这样基于浏览器的平台。要让WebGL支持Mono的VM几乎是不可能的。</p></blockquote><ul><li><p>可以利用<strong>现成的在各个平台的C++编译器</strong>对代码执行<strong>编译期优化</strong>，这样可以进一步<strong>减小最终游戏的尺寸并提高游戏运行速度</strong>。</p></li><li><p>由于动态语言的特性，他们多半无需程序员太多关心内存管理，所有的内存分配和回收都由一个叫做GC（Garbage Collector）的组件完成。</p></li></ul><p>虽然通过IL2CPP以后代码变成了静态的C++，但是内存管理这块还是遵循C#的方式，这也是为什么最后还要有一个 <strong>IL2CPP VM</strong>的原因：<strong>它负责提供诸如GC管理，线程创建这类的服务性工作。</strong></p><p>但是由于去除了<strong>IL加载和动态解析</strong>的工作，<strong>使得IL2CPP VM可以做的很小</strong>，<strong>并且使得游戏载入时间缩短</strong>。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049027.png" alt="img"></p><p>在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后<strong>再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</strong></p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ol><li>相比Mono, 代码生成有很大的提高</li><li>可以调试生成的C++代码</li><li>可以启用引擎代码剥离(Engine code stripping)来减少代码的大小</li><li>程序的运行效率比Mono高，运行速度快</li><li>多平台移植非常方便</li><li>相比Mono构建应用慢</li><li>只支持AOT(Ahead of Time)编译</li></ol><h2 id="ILRuntime"><a href="#ILRuntime" class="headerlink" title="ILRuntime"></a>ILRuntime</h2><p>ILRuntime项目为基于C#的平台（例如Unity）提供了一个<code>纯C#实现</code>，<code>快速</code>、<code>方便</code>且<code>可靠</code>的IL运行时，使得能够在不支持JIT的硬件环境（如iOS）能够实现代码的热更新</p><h3 id="ILRuntime的优势"><a href="#ILRuntime的优势" class="headerlink" title="ILRuntime的优势"></a>ILRuntime的优势</h3><p>同市面上的其他热更方案相比，ILRuntime主要有以下优点：</p><ul><li>无缝访问C#工程的现成代码，无需额外抽象脚本API</li><li>直接使用VS2015进行开发，ILRuntime的解译引擎支持.Net 4.6编译的DLL</li><li>执行效率是L#的10-20倍</li><li>选择性的CLR绑定使跨域调用更快速，绑定后跨域调用的性能能达到slua的2倍左右（从脚本调用GameObject之类的接口）</li><li>支持跨域继承</li><li>完整的泛型支持</li><li>拥有Visual Studio的调试插件，可以实现真机源码级调试。支持Visual Studio 2015 Update3 以及Visual Studio 2017和Visual Studio 2019</li><li>最新的2.0版引入的寄存器模式将数学运算性能进行了大幅优化</li></ul><h3 id="C-vs-Lua"><a href="#C-vs-Lua" class="headerlink" title="C# vs Lua"></a>C# vs Lua</h3><p>目前市面上主流的热更方案，主要分为Lua的实现和用C#的实现，两种实现方式各有各的优缺点。</p><p>Lua是一个已经非常成熟的解决方案，但是对于Unity项目而言，也有非常明显的缺点。就是如果使用Lua来进行逻辑开发，就势必要求团队当中的人员需要同时对Lua和C#都特别熟悉，或者将团队中的人员分成C#小组和Lua小组。不管哪一种方案，对于中小型团队都是非常痛苦的一件事情。</p><p>用C#来作为热更语言最大的优势就是项目可以用同一个语言来进行开发，对Unity项目而言，这种方式肯定是开发效率最高的。</p><p>Lua的优势在于解决方案足够成熟，之前的C++团队可能比起C#，更加习惯使用Lua来进行逻辑开发。此外借助luajit，在某些情况下的执行效率会非常不错，但是luajit现在维护情况也不容乐观，官方还是推荐使用公版Lua来开发。</p><blockquote><p>如果需要测试ILRuntime对比Lua的性能Benchmark，需要确认以下几点：</p></blockquote><ul><li>ILRuntime加载的dll文件是<code>Release</code>模式编译的</li><li>dll中对外部API的调用都进行了<code>CLR绑定</code></li><li>确保<code>没有勾选Development Build</code>的情况下发布成正式真机运行包，而<code>不是在Editor中直接运行</code></li><li>可以直接使用Demo工程中提供的性能测试进行对比</li></ul><blockquote><p>ILRuntime设计上为了在开发时提供更多的调试支持，在Unity Editor中运行会有很多额外的性能开销，<br>因此在Unity Editor中直接测试并不能代表ILRuntime的实际运行性能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Mono </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Shader</title>
      <link href="/posts/9fa0374.html"/>
      <url>/posts/9fa0374.html</url>
      
        <content type="html"><![CDATA[<h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><h2 id="什么是-Shader？"><a href="#什么是-Shader？" class="headerlink" title="什么是 Shader？"></a>什么是 Shader？</h2><p>Shade 的英文意思，如下：<br>v.给…遮挡（光线）；把…涂暗</p><p>其中 把…涂暗 更贴近我们想要的意思。<br>所以：Shader 这个单词从字面上理解，就是把什么东西涂暗。</p><p>Shader 从单词字面上理解，就是把什么东西涂暗。<br>把什么东西涂暗的就是 Shader，就是着色器。</p><h2 id="Shader-把什么涂暗了？"><a href="#Shader-把什么涂暗了？" class="headerlink" title="Shader 把什么涂暗了？"></a>Shader 把什么涂暗了？</h2><p>有光明就有黑暗，有光照物体就有明暗对比，同时也会有阴影，而 Shader 之所以叫 Shader 是因为起初的时候，Shader 就是用来给物体增加明暗对比的，有了明暗对比，物体在游戏世界中就会更加立体，从而画面会更加真实。</p><p>所以 Shader 的作用就是给物体添加明暗对比。</p><h2 id="Shader-为什么叫-Shader"><a href="#Shader-为什么叫-Shader" class="headerlink" title="Shader 为什么叫 Shader"></a>Shader 为什么叫 Shader</h2><p>现在 Shader 不止可以给物体添加明暗对比，而且还可以做很多滤镜效果，也可以做很多性能优化（比如减少包大小、减少图片内存等）的事情。</p><p>也许，一开始给 Shader 起名叫 Shader 的时候，Shader 功能非常有限，仅仅只是给物体添加明暗对比（也就是光照计算），后来由于硬件和软件的发展， 很多离线渲染（电影 CG）的算法都逐步应用在实时渲染（主要是 游戏 和3D 仿真等），Shader 能做的事情就越来越多，发展到今天，Shader 主要的功能并不只有光照计算。</p><h2 id="Shader-是着色器"><a href="#Shader-是着色器" class="headerlink" title="Shader 是着色器"></a>Shader 是着色器</h2><p>什么是 Shader，中文叫做着色器，也就是给物体上色的意思，也就是说写 Shader 就是给物体上色的艺术。而这个上色不只是简单的色彩填充，而是涵盖了非常多的技巧（几何计算、颜色计算、贴图等）</p><p>所以中文的着色器，是一个非常精准的翻译。</p><p><strong>Shader 主要是光线数据作用在不同数据的物体上产生不同效果。</strong></p><h2 id="颜色的控制"><a href="#颜色的控制" class="headerlink" title="颜色的控制"></a>颜色的控制</h2><p>现有一张贴图，如下：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242145905.png" alt="5d1c4283dd75732329.png"></p><p>用来控制颜色的 shader 代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    // 图片上每个像素的颜色值</span><br><span class="line">    float4 color = tex2D(_MainTex, i.uv);</span><br><span class="line">            </span><br><span class="line">    // 返回颜色，表示将改像素的颜色值输出到屏幕上</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然，我们没有 Shader 的语法学习经验，但是凭我们的 C# 经验，可以将上述代码推测个大概来。</p><p>首先 float4 是一个类型，可以存储 4 个 float 数值。而颜色一般都是由 r（red 红色）、g（green，绿色）、b（blue，蓝色）、a（alpha，透明度） 四个值控制。所以 float4 可以存储一个颜色。</p><p>现在，我们把图片中每个像素颜色重的红色值设置为 0，图片结果则如下所示:<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192026547.png" alt="5d1c429881a1050254.png"></p><p>代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    // 图片上每个像素的颜色值</span><br><span class="line">    float4 color = tex2D(_MainTex, i.uv);</span><br><span class="line">            </span><br><span class="line">    color.r = 0;</span><br><span class="line"></span><br><span class="line">    // 返回颜色，表示将改像素的颜色值输出到屏幕上</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，图片变成了蓝绿色。</p><h1 id="卡通着色"><a href="#卡通着色" class="headerlink" title="卡通着色"></a>卡通着色</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>创建场景。</li><li>在场景创建球、</li><li>在 Assets 目录中创建材质。</li><li>在 Assets 目录中创建 Shader。</li><li>把 Shader 贴到材质上。</li><li>把材质贴到球上。</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p>材质的本质就是 Shader + Texture（贴图）。一个材质就是由 Shader 和 Texture 组成的。</p><p>这一句适用于通常情况下，有的时候，材质只有 Shader，并没有 Texture，而是需要我们调整一些参数。</p><p>纹理也是数据，所以“材质由 Shader 和 Texture 组成”这句话，更准确地说应该是“材质由 Shader 和 数据组成”。</p><h2 id="Shader文件"><a href="#Shader文件" class="headerlink" title="Shader文件"></a>Shader文件</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/Toon&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">appdata v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第一行-Shader-“Unlit-Toon”"><a href="#第一行-Shader-“Unlit-Toon”" class="headerlink" title="第一行 Shader “Unlit/Toon”"></a><strong>第一行 Shader “Unlit/Toon”</strong></h3><p>这句话做的事情很简单，就是定义 Shader 的名字以及路径。在这里定义的名字和路径可以在材质的 Inspector 面板上找到对应的 Shader，</p><h3 id="第二行-Properties"><a href="#第二行-Properties" class="headerlink" title="第二行 Properties"></a><strong>第二行 Properties</strong></h3><p>Properties 属性的意思，在这个代码块中，可以定义属性的。</p><p>但是 Shader 的属性可以通过 C# 脚本设置值，可以通过，所在材质的 Inspector 中进行设置值。</p><h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h3><p>SubShader 顾名思义就是子 Shader，为什么要区分出来个 SubShader 这个概念呢？</p><p>Unity 在调用 Shader 时，会扫描所有的 SubShader 并选择一个可以在目标平台上运行的 SubShader。<br>也就是说，SubShader 和目标平台有点关系。</p><p>对于 SubShader 的概念，我们目前只了解这些即可，以后再深入了解。</p><p>关于 SubShader，我们只要记住，一个 Shader 可以定义多个 SubShader ，具体选择哪个 SubShader 要看目标平台支不支持所定义的 SubShader 的特性即可。</p><h3 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h3><p>一个 Shader 可以定义多个 SubShader，同样地一个 SubShader 也可以定义多个 Pass。</p><p>这个 Pass 是什么意思呢？英语中 Pass 是通过的意思。</p><p>在 Shader 中 Pass 则是通道的意思。</p><p>这个通道又是什么？</p><p>通道的官方定义为：通道控制 GameObject 几何体的一次渲染。</p><p>也就是说我们写 Shader 一般都是在 Pass 代码块中控制渲染，在 Pass 代码块中我们可以做很多设置，以及实现很多渲染算法。</p><h2 id="纸片球变立体球"><a href="#纸片球变立体球" class="headerlink" title="纸片球变立体球"></a>纸片球变立体球</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/Toon&quot;</span><br><span class="line">&#123;</span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">_Diffuse(&quot;Diffuse&quot;,Color) = (1,1,1,1)</span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">  </span><br><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line">#pragma vertex vert</span><br><span class="line">#pragma fragment frag</span><br><span class="line"></span><br><span class="line">#include &quot;UnityCG.cginc&quot;</span><br><span class="line">#include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float2 uv : TEXCOORD0;</span><br><span class="line">float3 normal:NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos: SV_POSITION; </span><br><span class="line">float3 color : Color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">float4 _Diffuse;</span><br><span class="line"></span><br><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line"></span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">fixed3 worldNormal = normalize(mul(v.normal,(float3x3)unity_WorldToObject));</span><br><span class="line"></span><br><span class="line">fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));</span><br><span class="line"></span><br><span class="line">o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">return fixed4(i.color,1.0);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Diffuse基础色"><a href="#Diffuse基础色" class="headerlink" title="Diffuse基础色"></a>Diffuse基础色</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">_Diffuse(&quot;Diffuse&quot;,Color) = (1,1,1,1) // 基础色值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Properties 中，定义了一个 Diffuse 属性。</p><p>Diffuse 是什么意思呢？英文中是散射、扩散的意思，在 Shader（图形学）术语中，我们叫做漫反射，但是在这里，这个 Diffuse 属性，并不代表漫反射本身，而是一个基础颜色，我们的漫反射计算是在这个颜色的基础之上叠加而成的。</p><p>只要记住，在这个 Shader 中，它是基础颜色就好，或者干脆可以理解成它是物体上的颜色，也可。</p><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">return fixed4(i.color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这个代码是一个方法/函数。<br>方法名为 frag，返回值为 float4 类型，接受的参数是 v2f 类型。<br>这些词都是什么意思呢？</p><p>首先介绍方法名：frag，frag 是 fragment 的缩写，fragment 在英语中是片段、碎片的意思。<br>而在图形学术语中，fragment 叫做片元，而 fragment shader 就是片元着色器。<br>那这个 frag 方法，顾名思义就是片元着色器，而里边的实现，则是处理片元的意思。</p><p>片元着色器有一个别名：叫做像素着色器，而片元（fragment) 是 OpenGL 的 GLSL（OpenGL 着色语言）中的一个概念，这个概念先不用了解。</p><p>我们只要把当前的 frag 方法，按照像素着色器去理解即可，也就是说 frag 方法做的事情是每个像素都计算（返回）一遍颜色即可。</p><p>结论：frag 方法是 像素着色器（片元着色器），这个方法对每个像素（片元）进行意思颜色计算并输出（返回）给屏幕。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-简易对象池</title>
      <link href="/posts/6739242f.html"/>
      <url>/posts/6739242f.html</url>
      
        <content type="html"><![CDATA[<p>在Unity中我们经常会用到对象池，使用对象池无非就是解决两个问题:</p><ul><li>一是减少 new 时候寻址造成的消耗，该消耗的原因是内存碎片。</li><li>二是减少 Object.Instantiate 时内部进行序列化和反序列化而造成的CPU消耗。</li></ul><h2 id="设计："><a href="#设计：" class="headerlink" title="设计："></a>设计：</h2><p>从字面上理解对象池，池的意思就是容器。我们可以从池中获取一个对象(一条鱼)，也可以向池中放入一个对象(一条鱼)。获取的操作我们叫Allocate(分配),而放入一个对象我们叫Recycle(回收)。所以我们可以定义池的接口为如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IPool&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">T Allocate();</span><br><span class="line"></span><br><span class="line">bool Recycle(T obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用泛型呢？如何实现一个精简并且灵活的对象池。这个灵活很大一部分是通过泛型体现的。</p><p>池是容器的意思，在C#中可以是List,Queue或者Stack甚至是数组。所以对象池本身要维护一个容器。本篇我们选取Stack来作为池容器，原因是当我们在Allocate和Recycle时并不关心缓存的存储的顺序，只要求缓存对象的地址是连续的。代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">public abstract class Pool&lt;T&gt; : IPool&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">protected Stack&lt;T&gt; mCacheStack = new Stack&lt;T&gt;();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pool是个抽象类，实现一个精简并且灵活的对象池。这个灵活很大一部分是通过抽象类体现的。</p><p>现在对象的存取和缓存接口都设计好了，那么这些对象是从哪里来的呢？我们分析下，创建对象我们知道有两种方式，反射构造方法和new一个对象。对象池的一个重要功能就是缓存，要想实现缓存就要求对象可以在对象池内部进行创建。所以我们要抽象出一个对象的工厂，代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IObjectFactory&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">T Create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用工厂? 实现一个精简并且灵活的对象池。这个灵活很大一部分是通过工厂体现的。</p><p>OK，现在对象的创建，存取，缓存的接口都设计好了。下面放出Pool的全部代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">public abstract class Pool&lt;T&gt; : IPool&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">#region ICountObserverable</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// Gets the current count.</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;value&gt;The current count.&lt;/value&gt;</span><br><span class="line">public int CurCount</span><br><span class="line">&#123;</span><br><span class="line">get &#123; return mCacheStack.Count; &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endregion</span><br><span class="line"></span><br><span class="line">protected IObjectFactory&lt;T&gt; mFactory;</span><br><span class="line"></span><br><span class="line">protected Stack&lt;T&gt; mCacheStack = new Stack&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// default is 5</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">protected int mMaxCount = 5;</span><br><span class="line"></span><br><span class="line">public virtual T Allocate()</span><br><span class="line">&#123;</span><br><span class="line">return mCacheStack.Count == 0</span><br><span class="line">? mFactory.Create()</span><br><span class="line">: mCacheStack.Pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract bool Recycle(T obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象池实现"><a href="#对象池实现" class="headerlink" title="对象池实现"></a>对象池实现</h2><p>首先要实现一个对象的创建器,代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">public class CustomObjectFactory&lt;T&gt; : IObjectFactory&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">public CustomObjectFactory(Func&lt;T&gt; factoryMethod)</span><br><span class="line">&#123;</span><br><span class="line">mFactoryMethod = factoryMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Func&lt;T&gt; mFactoryMethod;</span><br><span class="line"></span><br><span class="line">public T Create()</span><br><span class="line">&#123;</span><br><span class="line">return mFactoryMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，只是维护了一个返回值为T的委托。<br>对象池实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// unsafe but fast</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;</span><br><span class="line">public class SimpleObjectPool&lt;T&gt; : Pool&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">readonly Action&lt;T&gt; mResetMethod;</span><br><span class="line"></span><br><span class="line">public SimpleObjectPool(Func&lt;T&gt; factoryMethod, Action&lt;T&gt; resetMethod = null,int initCount = 0)</span><br><span class="line">&#123;</span><br><span class="line">mFactory = new CustomObjectFactory&lt;T&gt;(factoryMethod);</span><br><span class="line">mResetMethod = resetMethod;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; initCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">mCacheStack.Push(mFactory.Create());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override bool Recycle(T obj)</span><br><span class="line">&#123;</span><br><span class="line">mResetMethod.InvokeGracefully(obj);</span><br><span class="line">mCacheStack.Push(obj);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用?"></a>如何使用?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var fishPool = new SimpleObjectPool&lt;Fish&gt;(() =&gt; new Fish(), null, 100);</span><br><span class="line"></span><br><span class="line">Log.I(&quot;fishPool.CurCount:&#123;0&#125;&quot;, fishPool.CurCount);</span><br><span class="line"></span><br><span class="line">var fishOne = fishPool.Allocate();</span><br><span class="line"></span><br><span class="line">Log.I(&quot;fishPool.CurCount:&#123;0&#125;&quot;, fishPool.CurCount);</span><br><span class="line"></span><br><span class="line">fishPool.Recycle(fishOne);</span><br><span class="line"></span><br><span class="line">Log.I(&quot;fishPool.CurCount:&#123;0&#125;&quot;, fishPool.CurCount);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">fishPool.Allocate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log.I(&quot;fishPool.CurCount:&#123;0&#125;&quot;, fishPool.CurCount);</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fishPool.CurCount:100</span><br><span class="line">fishPool.CurCount:99</span><br><span class="line">fishPool.CurCount:100</span><br><span class="line">fishPool.CurCount:90</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-射线</title>
      <link href="/posts/9d4bb48a.html"/>
      <url>/posts/9d4bb48a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Unity射线系统"><a href="#Unity射线系统" class="headerlink" title="Unity射线系统"></a>Unity射线系统</h1><h2 id="Demo展示"><a href="#Demo展示" class="headerlink" title="Demo展示"></a>Demo展示</h2><p>UI+Physical射线测试：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023267.gif" alt="12123123"></p><p>FPS自定义射线测试：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023524.gif" alt="img"></p><h2 id="UGUI射线工具"><a href="#UGUI射线工具" class="headerlink" title="UGUI射线工具"></a>UGUI射线工具</h2><p>实现功能，鼠标点击UI,返回鼠标点击的UI对象；</p><p>需要使用到鼠标点击事件-PointerEventData；</p><p>关键API:EventSystem.current.RaycastAll();</p><p>参数为鼠标点击事件，和接受射线返回结果集合；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">RaycastUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (EventSystem.current == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//鼠标点击事件</span></span><br><span class="line">    PointerEventData pointerEventData = <span class="keyword">new</span> PointerEventData(EventSystem.current);</span><br><span class="line">    <span class="comment">//设置鼠标位置</span></span><br><span class="line">    pointerEventData.position = Input.mousePosition;</span><br><span class="line">    <span class="comment">//射线检测返回结果</span></span><br><span class="line">    List&lt;RaycastResult&gt; results = <span class="keyword">new</span> List&lt;RaycastResult&gt;();</span><br><span class="line">    <span class="comment">//检测UI</span></span><br><span class="line">    EventSystem.current.RaycastAll(pointerEventData, results);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回最上层ui</span></span><br><span class="line">    <span class="keyword">if</span> (results.Count &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> results[<span class="number">0</span>].gameObject;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Physcial射线工具"><a href="#Physcial射线工具" class="headerlink" title="Physcial射线工具"></a>Physcial射线工具</h2><p>从摄像机发射射线，方向为，摄像机——鼠标位置；</p><p>可以获取射线碰撞到的3D物品的大部分信息：</p><p>可以活着hit.collider；意味着可以获取碰撞点的位置，物体等信息；</p><p>用来做鼠标点击地面控制人物位移；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">RaycastPhysical</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">    RaycastHit hit;</span><br><span class="line">    <span class="built_in">bool</span> isHit = Physics.Raycast((Ray) ray, <span class="keyword">out</span> hit);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (isHit)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(hit.collider.name);</span><br><span class="line">        <span class="keyword">return</span> hit.collider.gameObject; <span class="comment">//检测到碰撞，就把检测到的点记录下来</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject temp = RayCastTool.RaycastUI();</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (temp.CompareTag(<span class="string">&quot;Pic&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                temp.GetComponent&lt;Image&gt;().color = Color.red;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject temp = RayCastTool.RaycastPhysical();</span><br><span class="line">            </span><br><span class="line">            temp.GetComponent&lt;Renderer&gt;().material.color = Color.red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FPS射线测试"><a href="#FPS射线测试" class="headerlink" title="FPS射线测试"></a>FPS射线测试</h2><p>自定义射线的起始点Origin，方向，以及射线长度；</p><p>获取射线碰撞点的位置物体信息;</p><p>用来做第三人称FPS的射击判定，或者RPG远程技能判定；</p><p>第一人称FPS，射线起始点和方向，替换成相机——屏幕中心瞄准心；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestRayCast</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Transform player;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        player = GameObject.FindGameObjectWithTag(<span class="string">&quot;Player&quot;</span>).transform;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Ray ray = <span class="keyword">new</span> Ray(player.position, player.forward);</span><br><span class="line">        RaycastHit hit;</span><br><span class="line">        <span class="built_in">bool</span> isHit = Physics.Raycast((Ray) ray, <span class="keyword">out</span> hit,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Debug.DrawRay(player.position, player.forward*<span class="number">10</span>, Color.blue);</span><br><span class="line">        <span class="keyword">if</span> (isHit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hit.collider.CompareTag(<span class="string">&quot;Enemy&quot;</span>))</span><br><span class="line">                hit.collider.GetComponent&lt;Renderer&gt;().material.color = Color.red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/e85d694a.html"/>
      <url>/posts/e85d694a.html</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h3><p>简单地理解，满足以下两个条件的树就是二叉树：</p><p>本身是有序树；</p><p>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907612.gif" alt="二叉树示意图"></p><h3 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h3><ul><li>二叉树中，第 i 层最多有 2i-1 个结点。</li><li>如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。</li><li>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。</li></ul><blockquote><p>性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。<br>同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2<em>n2。所以，n 用另外一种方式表示为 n=n1+2</em>n2+1。<br>两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。</p></blockquote><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907257.gif" alt="满二叉树示意图"></p><p>满二叉树除了满足普通二叉树的性质，还具有以下性质：</p><ul><li>满二叉树中第 i 层的节点数为 2n-1 个。</li><li>深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。</li><li>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li><li>具有 n 个节点的满二叉树的深度为 log2(n+1)。</li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907572.gif" alt="完全二叉树示意图"></p><p>如图 3a) 所示是一棵完全二叉树，图 3b) 由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。</p><p>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。</p><p>⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。</p><p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：</p><ul><li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li><li>如果 2<em>i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2</em>i 。</li><li>如果 2<em>i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2</em>i+1 。</li></ul><h3 id="二叉树储存结构"><a href="#二叉树储存结构" class="headerlink" title="二叉树储存结构"></a>二叉树储存结构</h3><p>采用链式存储二叉树时，其节点结构由 3 部分构成：</p><ul><li>指向左孩子节点的指针（Lchild）；</li><li>节点存储的数据（data）；</li><li>指向右孩子节点的指针（Rchild）；</li></ul><p>表示该节点结构的 C#代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Definition for a binary tree node.</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">  public int val;</span><br><span class="line">  public TreeNode left;</span><br><span class="line">  public TreeNode right;</span><br><span class="line">  public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) &#123;</span><br><span class="line">  this.val = val;</span><br><span class="line">  this.left = left;</span><br><span class="line">  this.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907970.png" alt="img"></p><p>先序遍历：</p><ul><li>访问根节点；</li><li>访问当前节点的左子<a href="http://data.biancheng.net/view/23.html">树</a>；</li><li>若当前节点无左子树，则访问当前节点的右子树；</li></ul><p>中序遍历：</p><ol><li>访问当前节点的左子<a href="http://data.biancheng.net/view/23.html">树</a>；</li><li>访问根节点；</li><li>访问当前节点的右子树；</li></ol><p>后续遍历：</p><p>从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素。</p><blockquote><p>根-&gt; 左-&gt; 右<br>左-&gt; 根-&gt; 右<br>左-&gt; 右-&gt; 根<br>根再前就是前序，在中就是中序，在最后就是后续，遍历的时候可以三个为一组比较容易看</p></blockquote><p>递归写法遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历二叉树,并将遍历的结果保存到list中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="params">TreeNode node, IList&lt;TreeNode&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  list.Add(node);</span><br><span class="line">    dfs(node.left, list);</span><br><span class="line">    dfs(node.right, list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历二叉树,并将遍历的结果保存到list中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="params">TreeNode node, IList&lt;TreeNode&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(node.left, list);</span><br><span class="line">    list.Add(node);</span><br><span class="line">    dfs(node.right, list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续序遍历二叉树,并将遍历的结果保存到list中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="params">TreeNode node, IList&lt;TreeNode&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(node.left, list);</span><br><span class="line">    dfs(node.right, list);</span><br><span class="line">  list.Add(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归先序,要先访问根节点，然后再去访问左子树以及右子树，这明显是递归定义，但这里是用栈来实现的</span></span><br><span class="line"><span class="comment">//先需要先从栈顶取出节点，然后访问该节点，如果该节点不为空，则存储该节点，同时把该节点的右子树先入栈，然后左子树入栈。循环结束的条件是栈中不在有节点。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    IList&lt;TreeNode&gt; result = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span> || cur != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.Add(cur);</span><br><span class="line">            stack.Push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = stack.Pop();</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归中序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    IList&lt;TreeNode&gt; result = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span> || cur != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            stack.Push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = stack.Pop();</span><br><span class="line">          result.Add(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归后续</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">  TreeNode p = <span class="literal">null</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    IList&lt;TreeNode&gt; result = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span> || cur != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span>(cur != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          stack.Push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">      cur = stack.Peek();</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span> &amp;&amp; cur.right != p)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = stack.Pop();</span><br><span class="line">          result.Add(cur);</span><br><span class="line">            p = cur;</span><br><span class="line">          cur = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层次遍历：</p><p>按照二叉树中的层次从左到右依次遍历每层中的结点。具体的实现思路是：通过使用队列的数据结构，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907124.png" alt="img"></p><h2 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h2><h3 id="比较BFS和DFS"><a href="#比较BFS和DFS" class="headerlink" title="比较BFS和DFS"></a>比较BFS和DFS</h3><p>Breadth First Search（广度优先搜索），将相邻的节点一层层查找，找到最多的。</p><p>Deep FIrst Search（深度优先搜索），一直往下寻找，若没有剩余相邻节点时，回走一步，再查找剩余的下一个相邻节点，直到回到起始点</p><p>DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p><p>如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。</p><p>DFS 与 BFS在二叉树上进行 DFS 遍历和 BFS 遍历的代码比较。</p><p>DFS 遍历使用递归：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS 遍历使用队列数据结构：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">    queue.Enqueue(root);<span class="comment">// C# 的 add 写作 Enqueue()</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.Dequeue(); <span class="comment">// C# 的 pop 写作 Dequeue()</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.Enqueue(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.Enqueue(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907256.gif" alt="DFS 与 BFS 对比"></p><h3 id="BFS-的应用：层序遍历"><a href="#BFS-的应用：层序遍历" class="headerlink" title="BFS 的应用：层序遍历"></a>BFS 的应用：层序遍历</h3><p>BFS 的层序遍历应用：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LeetCode 102. Binary Tree Level Order Traversal</a> 二叉树的层序遍历（Medium）</p><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p><p>什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907225.jpg" alt="二叉树的层序遍历"></p><p>乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 Count（也就是这一层的结点数量），然后一口气处理完这一层的 Count 个结点。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907356.gif" alt="img"></p><p>在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; LevelOrder(TreeNode root) &#123;</span><br><span class="line">    IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; result = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    IList&lt;<span class="built_in">int</span>&gt; ans = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">    <span class="built_in">int</span> len = <span class="number">0</span>;</span><br><span class="line">    queue.Enqueue(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.Count != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = queue.Count;</span><br><span class="line">        ans.Clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          TreeNode node = queue.Dequeue();</span><br><span class="line">          ans.Add(node.val);</span><br><span class="line">          <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.Enqueue(node.left);</span><br><span class="line">          <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.Enqueue(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">      result.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(ans));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS的应用：回溯算法"><a href="#DFS的应用：回溯算法" class="headerlink" title="DFS的应用：回溯算法"></a>DFS的应用：<a href="https://liuyingbo.com/archives/376d0826.html">回溯算法</a></h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-Asset资源</title>
      <link href="/posts/521e43fc.html"/>
      <url>/posts/521e43fc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Unity资源文件夹介绍"><a href="#Unity资源文件夹介绍" class="headerlink" title="Unity资源文件夹介绍"></a>Unity资源文件夹介绍</h1><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242137186.png" alt="image-20211008233301906"></p><h2 id="编辑时"><a href="#编辑时" class="headerlink" title="编辑时"></a>编辑时</h2><p>在Asset文件下存在Resources和SteamingAsset文件夹；</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>只读不可修改，打包时直接写死，没有办法通过热更新替换资源；</p><p>可以存放任何格式的资源；</p><p>通过Resources.Load加载；</p><p>一般只存登录UI，congfig配置等不会修改的文件；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载</span></span><br><span class="line">GameObject go = Resources.Load&lt;GameObject&gt;(path);</span><br><span class="line">Sprite sp = Resouces.Load(path,<span class="keyword">typeof</span>(sprite)) <span class="keyword">as</span> sprite;</span><br><span class="line">TextAsset txt = Resources.Load(path) <span class="keyword">as</span> TextAsset;</span><br></pre></td></tr></table></figure><h3 id="SteamingAssets"><a href="#SteamingAssets" class="headerlink" title="SteamingAssets"></a>SteamingAssets</h3><p>存放打包后Unity打包后的资源，也就是我说的AssetBundle（ab包）；</p><p>可读可写，打包后移动端不能使用File类读取（用过www读取streamingAssetspath数据拷贝到persistentDataPath）；</p><h2 id="安装后"><a href="#安装后" class="headerlink" title="安装后"></a>安装后</h2><h3 id="Application-dataPath"><a href="#Application-dataPath" class="headerlink" title="Application.dataPath"></a>Application.dataPath</h3><p>包含游戏数据文件夹的路径，app程序包安装路径（不常用）；</p><p> 1.UnityEditor——<strong>默认Assets</strong>——可读可写 using StreamReader/StreamWriter/异步</p><p> 2.Andriod——data/app/xxx.apk——不可读不可写</p><p> 3.IOS——Application/…..app/Data——可读不可写（读没意义）</p><h3 id="Application-streamingAssetsPath"><a href="#Application-streamingAssetsPath" class="headerlink" title="Application.streamingAssetsPath"></a>Application.streamingAssetsPath</h3><p>数据流换成目录，外部数据文件（二进制，AssetsBundle.csv、数据裸露不加密）；</p><p> 1.除了Andriod都可读可写，使用WWW或者System.IO都可以；</p><p> 2.Andriod只读，只能用WWW读写——第三方压缩/解压库实现读写（待研究）；</p><p> <strong>3.安装包资源目录，不可修改；</strong></p><h3 id="Application-presistentDataPath"><a href="#Application-presistentDataPath" class="headerlink" title="Application.presistentDataPath"></a>Application.presistentDataPath</h3><p>持久化存储目录，应用更新、覆盖安装都不会清除；</p><p> 1.全平台可读可写——stream和file都可以读写；</p><p> <strong>2.热更新资源存放目录；</strong></p><h3 id="Application-temporaryCachePath"><a href="#Application-temporaryCachePath" class="headerlink" title="Application.temporaryCachePath"></a>Application.temporaryCachePath</h3><p>临时换成目录，可读可写（只有ios常用）；</p><h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><p>资源压缩文件（ab包），非路径，一种压缩文件的格式；</p><h1 id="AssetBundle-1"><a href="#AssetBundle-1" class="headerlink" title="AssetBundle"></a>AssetBundle</h1><h2 id="Asset-Bundle："><a href="#Asset-Bundle：" class="headerlink" title="Asset Bundle："></a><strong>Asset Bundle：</strong></h2><p><strong>AssetBundle</strong> 是一个存档文件，包含可在运行时加载的特定于平台的资源（模型、纹理、预制件、音频剪辑甚至整个场景）。AssetBundle 可以表达彼此之间的依赖关系；例如 AssetBundle A 中的材质可以引用 AssetBundle B 中的纹理。为了通过网络进行有效传递，可以根据用例要求选用内置算法来压缩 AssetBundle（LZMA 和 LZ4）。</p><p>AssetBundle 可用于可下载内容（DLC），减小初始安装大小，加载针对最终用户平台优化的资源，以及减轻运行时内存压力。</p><h2 id="AssetBundle-中有什么"><a href="#AssetBundle-中有什么" class="headerlink" title="AssetBundle 中有什么:"></a><strong>AssetBundle 中有什么:</strong></h2><p>“AssetBundle”可以指两种不同但相关的东西。</p><p>首先是磁盘上的实际文件。对于这种情况，我们称之为 AssetBundle 存档，在本文档中简称“存档”。存档可以被视为一个容器，就像文件夹一样，可以在其中包含其他文件。这些附加文件包含两种类型：</p><p>序列化文件和资源文件。序列化文件包含分解为各个对象并写入此单个文件的资源。资源文件只是为某些资源（纹理和音频）单独存储的二进制数据块，允许我们有效地在另一个线程上从磁盘加载它们。</p><p>其次是通过代码进行交互以便从特定存档加载资源的实际 AssetBundle 对象。此对象包含一个映射，即从已添加到此存档的资源的所有文件路径到按需加载的资源所包含的对象之间的映射。</p><h2 id="为-AssetBundle-分配资源"><a href="#为-AssetBundle-分配资源" class="headerlink" title="为 AssetBundle 分配资源"></a>为 AssetBundle 分配资源</h2><p>要为 AssetBundle 分配指定资源，请按照下列步骤操作：</p><p>1.从 Project 视图中选择要为捆绑包分配的资源 </p><p>2.在 Inspector 中检查对象</p><p> 3.在 Inspector 底部，应该会看到一个用于分配 AssetBundle 和变体的部分：</p><p> 4.左侧下拉选单分配 AssetBundle，而右侧下拉选单分配变量 </p><p>5.单击左侧下拉选单，其中显示“None”，表示当前注册的 AssetBundle 名称 </p><p>6.单击“New…”以创建新的 AssetBundle </p><p>7.输入所需的 AssetBundle 名称。请注意，AssetBundle 名称支持某种类型的文件夹结构，具体取决于您输入的内容。要添加子文件夹，请用“/”分隔文件夹名称。例如：AssetBundle 名称“environment/forest”将在 environment 子文件夹下创建名为 forest 的捆绑包 </p><p>8.一旦选择或创建了 AssetBundle 名称，便可以重复此过程在右侧下拉选单中分配或创建变体名称（如果需要）。构建 AssetBundle 不需要变体名称</p><h2 id="构建-AssetBundle"><a href="#构建-AssetBundle" class="headerlink" title="构建 AssetBundle"></a>构建 AssetBundle</h2><p>在 Assets 文件夹中创建一个名为 Editor 的文件夹，并将包含以下内容的脚本放在该文件夹中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System.IO;</span><br><span class="line">using UnityEditor;</span><br><span class="line"></span><br><span class="line">public class CreateAssetBundles</span><br><span class="line">&#123;</span><br><span class="line">    [MenuItem(&quot;Assets/Build AssetBundles&quot;)]</span><br><span class="line">    static void BuildAllAssetBundles()</span><br><span class="line">    &#123;</span><br><span class="line">        string assetBundleDirectory = &quot;Assets/AssetBundles&quot;;</span><br><span class="line">        if (!Directory.Exists(assetBundleDirectory))</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(assetBundleDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">        BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, BuildTarget.StandaloneOSX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此脚本将在 Assets 菜单底部创建一个名为“Build AssetBundles”的菜单项，该菜单项将执行与该标签关联的函数中的代码。单击 Build AssetBundles 时，将随构建对话框一起显示一个进度条。此过程将会获取带有 AssetBundle 名称标签的所有资源，并将它们放在 assetBundleDirectory 定义的路径中的文件夹中。</p><h2 id="将-AssetBundle-上传到场外存储"><a href="#将-AssetBundle-上传到场外存储" class="headerlink" title="将 AssetBundle 上传到场外存储"></a>将 AssetBundle 上传到场外存储</h2><p>此步骤对每个用户都是不同的，因此 Unity 不能告诉您应该具体如何操作。如果计划将 AssetBundle 上传到第三方托管站点，请在此步中执行该操作。如果正在严格执行本地开发并打算将所有 AssetBundle 都放在磁盘上，请跳转到下一步。</p><h2 id="加载-AssetBundle-和资源"><a href="#加载-AssetBundle-和资源" class="headerlink" title="加载 AssetBundle 和资源"></a>加载 AssetBundle 和资源</h2><p>打算从本地存储加载的用户可能会对 AssetBundles.LoadFromFile API 感兴趣。该 API 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LoadFromFileExample extends MonoBehaviour &#123;</span><br><span class="line">    function Start() &#123;</span><br><span class="line">        var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));</span><br><span class="line">        if (myLoadedAssetBundle == null) &#123;</span><br><span class="line">            Debug.Log(&quot;Failed to load AssetBundle!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(&quot;MyObject&quot;);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为-AssetBundle-准备资源"><a href="#为-AssetBundle-准备资源" class="headerlink" title="为 AssetBundle 准备资源"></a>为 AssetBundle 准备资源</h1><p>使用 AssetBundle 时，可以任意将任何资源分配给所需的任何捆绑包。但是，在设置捆绑包时需要考虑某些策略。以下分组策略旨在用于您认为适合的具体项目。可以根据需要随意混合和搭配这些策略。</p><h2 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h2><p>逻辑实体分组是指根据资源所代表的项目功能部分将资源分配给 AssetBundle。这包括各种不同部分，比如用户界面、角色、环境以及在应用程序整个生命周期中可能经常出现的任何其他内容。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>捆绑用户界面屏幕的所有纹理和布局数据</li><li>捆绑一个/一组角色的所有模型和动画</li><li>捆绑在多个关卡之间共享的景物的纹理和模型</li></ul><p>逻辑实体分组非常适合于可下载内容 (DLC)，因为通过这种方式将所有内容隔离后，可以对单个实体进行更改，而无需下载其他未更改的资源。</p><p>为了能够正确实施此策略，最大诀窍在于，负责为各自捆绑包分配资源的开发人员必须熟悉项目使用每个资源的准确时机和场合。</p><h2 id="类型分组"><a href="#类型分组" class="headerlink" title="类型分组"></a>类型分组</h2><p>根据此策略，可以将相似类型的资源（例如音频轨道或语言本地化文件）分配到单个 AssetBundle。</p><p>要构建供多个平台使用的 AssetBundle，类型分组是最佳策略之一。例如，如果音频压缩设置在 Windows 和 Mac 平台上完全相同，则可以自行将所有音频数据打包到 AssetBundle 并重复使用这些捆绑包，而着色器往往使用更多特定于平台的选项进行编译，因此为 Mac 构建的着色器捆绑包可能无法在 Windows 上重复使用。此外，这种方法非常适合让 AssetBundle 与更多 Unity 播放器版本兼容，因为纹理压缩格式和设置的更改频率低于代码脚本或预制件。</p><h2 id="并发内容分组"><a href="#并发内容分组" class="headerlink" title="并发内容分组"></a>并发内容分组</h2><p>并发内容分组是指将需要同时加载和使用的资源捆绑在一起。可以将这些类型的捆绑包用于基于关卡的游戏（其中每个关卡包含完全独特的角色、纹理、音乐等）。有时可能希望确保其中一个 AssetBundle 中的资源与该捆绑包中的其余资源同时使用。依赖于并发内容分组捆绑包中的单个资源会导致加载时间显著增加。您将被迫下载该单个资源的整个捆绑包。</p><p>并发内容分组捆绑包最常见的用例是针对基于场景的捆绑包。在此分配策略中，每个场景捆绑包应包含大部分或全部场景依赖项。</p><p>请注意，项目绝对可以也应该根据您的需求混用这些策略。对任何给定情形使用最优资源分配策略可以大大提高项目的效率。</p><p>例如，一个项目可能决定将不同平台的用户界面 (UI) 元素分组到各自的 Platform-UI 特定捆绑包中，但按关卡/场景对其交互式内容进行分组。</p><p>无论遵循何种策略，下面这些额外提示都有助于掌控全局：</p><ul><li>将频繁更新的对象与很少更改的对象拆分到不同的 AssetBundle 中</li><li>将可能同时加载的对象分到一组。例如模型及其纹理和动画</li><li>如果发现多个 AssetBundle 中的多个对象依赖于另一个完全不同的 AssetBundle 中的单个资源，请将依赖项移动到单独的 AssetBundle。如果多个 AssetBundle 引用其他 AssetBundle 中的同一组资源，一种有价值的做法可能是将这些依赖项拉入一个共享 AssetBundle 来减少重复。</li><li>如果不可能同时加载两组对象（例如标清资源和高清资源），请确保它们位于各自的 AssetBundle 中。</li><li>如果一个 AssetBundle 中只有不到 50% 的资源经常同时加载，请考虑拆分该捆绑包</li><li>考虑将多个小型的（少于 5 到 10 个资源）但经常同时加载内容的 AssetBundle 组合在一起</li><li>如果一组对象只是同一对象的不同版本，请考虑使用 AssetBundle 变体</li></ul><h1 id="构建-AssetBundle-1"><a href="#构建-AssetBundle-1" class="headerlink" title="构建 AssetBundle"></a>构建 AssetBundle</h1><p>在有关 <a href="AssetBundles-Workflow.html">AssetBundle 工作流程</a>的文档中，我们有一个代码示例将三个参数传递给 <code>BuildPipeline.BuildAssetBundles</code> 函数。让我们深入了解一下这方面。</p><p><em>Assets/AssetBundles</em>：这是 AssetBundle 要输出到的目录。可以将其更改为所需的任何输出目录，只需确保在尝试构建之前文件夹实际存在。</p><h4 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h4><p>可以指定几个具有各种效果的不同 <code>BuildAssetBundleOptions</code>。请参阅关于 <a href="../ScriptReference/BuildAssetBundleOptions.html">BuildAssetBundleOptions</a> 的脚本 API 参考查看所有这些选项的表格。</p><p>虽然可以根据需求变化和需求出现而自由组合 <code>BuildAssetBundleOptions</code>，但有三个特定的 <code>BuildAssetBundleOptions</code> 可以处理 AssetBundle 压缩：</p><ul><li><code>BuildAssetBundleOptions.None</code>: </li><li>此捆绑选项使用 LZMA 格式压缩，它是序列化数据文件的单个压缩 LZMA 流。LZMA 压缩要求在使用之前解压缩整个包。这会导致文件大小尽可能小，但由于解压缩，加载时间会稍长。值得注意的是，在使用此 BuildAssetBundleOptions 时，为了使用包中的任何资产，必须首先解压缩整个包。<br>解压缩包后，它将使用 LZ4 压缩在磁盘上重新压缩，这不需要在使用包中的资产之前解压缩整个包。当捆绑包包含资产时最好使用此方法，以便使用捆绑包中的一个资产意味着所有资产都将被加载。打包角色或场景的所有资产是可能使用此功能的捆绑包的一些示例。<br>由于文件较小，建议仅在从异地主机初始下载 AssetBundle 时使用 LZMA 压缩。<a href="../ScriptReference/Networking.UnityWebRequestAssetBundle.html">通过UnityWebRequestAssetBundle</a>加载的 LZMA 压缩资产包会自动重新压缩为 LZ4 压缩并缓存在本地文件系统上。如果您通过其他方式下载并存储该捆绑包，您可以使用<a href="../ScriptReference/AssetBundle.RecompressAssetBundleAsync.html">AssetBundle.RecompressAssetBundleAsync</a> API。</li><li><code>BuildAssetBundleOptions.UncompressedAssetBundle</code>：此捆绑包选项采用使数据完全未压缩的方式构建捆绑包。未压缩的缺点是文件下载大小增大。但是，下载后的加载时间会快得多。</li><li><code>BuildAssetBundleOptions.ChunkBasedCompression</code>：此捆绑包选项使用称为 LZ4 的压缩方法，因此压缩文件大小比 LZMA 更大，但不像 LZMA 那样需要解压缩整个包才能使用捆绑包。LZ4 使用基于块的算法，允许按段或“块”加载 AssetBundle。解压缩单个块即可使用包含的资源，即使 AssetBundle 的其他块未解压缩也不影响。</li></ul><p>使用 <code>ChunkBasedCompression</code> 时的加载时间与未压缩捆绑包大致相当，额外的优势是减小了占用的磁盘大小。</p><h4 id="BuildTarget"><a href="#BuildTarget" class="headerlink" title="BuildTarget"></a>BuildTarget</h4><p><code>BuildTarget.Standalone</code>：这里我们告诉构建管线，我们要将这些 AssetBundle 用于哪些目标平台。可以在关于 <a href="../ScriptReference/BuildTarget.html">BuildTarget</a> 的脚本 API 参考中找到可用显式构建目标的列表。但是，如果不想在构建目标中进行硬编码，请充分利用 <code>EditorUserBuildSettings.activeBuildTarget</code>，它将自动找到当前设置的目标构建平台，并根据该目标构建 AssetBundle。</p><p>一旦正确设置构建脚本，最后便可以开始构建资源包了。如果是按照上面的脚本示例进行的操作，请单击 <strong>Assets</strong> &gt; <strong>Build AssetBundles</strong> 以开始该过程。</p><p>现在已经成功构建了 AssetBundle，您可能会注意到 AssetBundles 目录包含的文件数量超出了最初的预期。确切地说，是多出了 2*(n+1) 个文件。让我们花点时间详细了解一下 <code>BuildPipeline.BuildAssetBundles</code> 产生的结果。</p><p>对于在编辑器中指定的每个 AssetBundle，可以看到一个具有 AssetBundle 名称+“.manifest”的文件。</p><p>随后会有一个额外捆绑包和清单的名称不同于先前创建的任何 AssetBundle。相反，此包以其所在的目录（构建 AssetBundle 的目录）命名。这就是清单捆绑包。我们以后会对此进行详细讨论并介绍使用方法。</p><h4 id="AssetBundle-文件"><a href="#AssetBundle-文件" class="headerlink" title="AssetBundle 文件"></a>AssetBundle 文件</h4><p>这是缺少 .manifest 扩展名的文件，其中包含在运行时为了加载资源而需要加载的内容。</p><p>AssetBundle 文件是一个存档，在内部包含多个文件。此存档的结构根据它是 AssetBundle 还是场景 AssetBundle 可能会略有不同。以下是普通 AssetBundle 的结构：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242142639.png" alt="img"></p><p>场景 AssetBundle 与普通 AssetBundle 的不同之处在于，它针对场景及其内容的串流加载进行了优化。</p><h4 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h4><p>对于生成的每个捆绑包（包括附加的清单捆绑包），都会生成关联的清单文件。清单文件可以使用任何文本编辑器打开，并包含诸如循环冗余校验 (CRC) 数据和捆绑包的依赖性数据之类的信息。对于普通 AssetBundle，它们的清单文件将如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ManifestFileVersion: <span class="number">0</span></span><br><span class="line">CRC: <span class="number">2422268106</span></span><br><span class="line">Hashes:</span><br><span class="line">  AssetFileHash:</span><br><span class="line">    serializedVersion: <span class="number">2</span></span><br><span class="line">    Hash: <span class="number">8b</span>6db55a2344f068cf8a9be0a662ba15</span><br><span class="line">  TypeTreeHash:</span><br><span class="line">    serializedVersion: <span class="number">2</span></span><br><span class="line">    Hash: <span class="number">37</span>ad974993dbaa77485dd2a0c38f347a</span><br><span class="line">HashAppended: <span class="number">0</span></span><br><span class="line">ClassTypes:</span><br><span class="line">- Class: <span class="number">91</span></span><br><span class="line">  Script: &#123;instanceID: <span class="number">0</span>&#125;</span><br><span class="line">Assets:</span><br><span class="line">  Asset_0: Assets/Mecanim/StateMachine.controller</span><br><span class="line">Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure><p>其中显示了包含的资源、依赖项和其他信息。</p><p>生成的清单捆绑包将有一个清单，但看起来更可能如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ManifestFileVersion: <span class="number">0</span></span><br><span class="line">AssetBundleManifest:</span><br><span class="line">  AssetBundleInfos:</span><br><span class="line">    Info_0:</span><br><span class="line">      Name: scene1assetbundle</span><br><span class="line">      Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure><p>这将显示 AssetBundle 之间的关系以及它们的依赖项。就目前而言，只需要了解这个捆绑包中包含 AssetBundleManifest 对象，这对于确定在运行时加载哪些捆绑包依赖项非常有用。</p><h1 id="AssetBundle-依赖项"><a href="#AssetBundle-依赖项" class="headerlink" title="AssetBundle 依赖项"></a>AssetBundle 依赖项</h1><p>如果一个或多个 <code>UnityEngine.Objects</code> 包含对位于另一个捆绑包中的 <code>UnityEngine.Object</code> 的引用，则 AssetBundle 可以变为依赖于其他 AssetBundle。如果 <code>UnityEngine.Object</code> 包含对任何 AssetBundle 中未包含的 <code>UnityEngine.Object</code> 的引用，则不会发生依赖关系。在这种情况下，在构建 AssetBundle 时，捆绑包所依赖的对象的副本将复制到捆绑包中。如果多个捆绑包中的多个对象包含对未分配给捆绑包的同一对象的引用，则每个对该对象具有依赖关系的捆绑包将创建其自己的对象副本并将其打包到构建的 AssetBundle 中。</p><p>如果 AssetBundle 中包含依赖项，则在加载尝试实例化的对象之前，务必加载包含这些依赖项的捆绑包。Unity 不会尝试自动加载依赖项。</p><p>参考以下示例，<strong>Bundle 1</strong> 中的材质引用了 <strong>Bundle 2</strong> 中的纹理：</p><p>在此示例中，在从 <strong>Bundle 1</strong> 加载材质之前，需要将 <strong>Bundle 2</strong> 加载到内存中。加载 <strong>Bundle 1</strong> 和 <strong>Bundle 2</strong> 的顺序无关紧要，重要的是在从 <strong>Bundle 1</strong> 加载材质之前应加载 <strong>Bundle 2</strong>。在下一部分，我们将讨论如何使用我们在上一部分介绍的 <code>AssetBundleManifest</code> 对象在运行时确定并加载依赖项。</p><h1 id="使用-AssetBundle"><a href="#使用-AssetBundle" class="headerlink" title="使用 AssetBundle"></a>使用 AssetBundle</h1><p>可以使用四种不同的 API 来加载 AssetBundle。它们的行为根据加载捆绑包的平台和构建 AssetBundle 时使用的压缩方法（未压缩、LZMA 和 LZ4）而有所不同。</p><p>我们必须使用的四个 API 是：</p><ul><li><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromMemoryAsync.html?_ga=1.226802969.563709772.1479226228">AssetBundle.LoadFromMemoryAsync</a></li><li><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromFile.html?_ga=1.259297550.563709772.1479226228">AssetBundle.LoadFromFile</a></li><li><a href="https://docs.unity3d.com/ScriptReference/WWW.LoadFromCacheOrDownload.html?_ga=1.226802969.563709772.1479226228">WWW.LoadfromCacheOrDownload</a></li><li><a href="https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.html?_ga=1.259297550.563709772.1479226228">UnityWebRequest</a> 的 <a href="https://docs.unity3d.com/ScriptReference/Networking.DownloadHandlerAssetBundle.html?_ga=1.264500235.563709772.1479226228">DownloadHandlerAssetBundle </a>（Unity 5.3 或更高版本）</li></ul><h2 id="AssetBundle-LoadFromMemoryAsync"><a href="#AssetBundle-LoadFromMemoryAsync" class="headerlink" title="AssetBundle.LoadFromMemoryAsync"></a>AssetBundle.LoadFromMemoryAsync</h2><p><a href="../ScriptReference/AssetBundle.LoadFromMemoryAsync.html">AssetBundle.LoadFromMemoryAsync</a></p><p>此函数采用包含 AssetBundle 数据的字节数组。也可以根据需要传递 CRC 值。如果捆绑包采用的是 LZMA 压缩方式，将在加载时解压缩 AssetBundle。LZ4 压缩包则会以压缩状态加载。</p><p>以下是如何使用此方法的一个示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> path = Application.streamingAssetsPath + <span class="string">&quot;/AssetBundles/OSX/wall&quot;</span>;</span><br><span class="line">    AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line">        Debug.Log(<span class="string">&quot;Failed to load AssetBundle!&quot;</span> + createRequest);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> createRequest;</span><br><span class="line"></span><br><span class="line">        AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line">        <span class="keyword">var</span> prefab = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这不是实现 LoadFromMemoryAsync 的唯一策略。File.ReadAllBytes(path) 可以替换为获得字节数组的任何所需过程。</p><h2 id="AssetBundle-LoadFromFile"><a href="#AssetBundle-LoadFromFile" class="headerlink" title="AssetBundle.LoadFromFile"></a>AssetBundle.LoadFromFile</h2><p><a href="../ScriptReference/AssetBundle.LoadFromFile.html">AssetBundle.LoadFromFile</a></p><p>从本地存储中加载未压缩的捆绑包时，此 API 非常高效。如果捆绑包未压缩或采用了数据块 (LZ4) 压缩方式，LoadFromFile 将直接从磁盘加载捆绑包。使用此方法加载完全压缩的 (LZMA) 捆绑包将首先解压缩捆绑包，然后再将其加载到内存中。</p><p>如何使用 <code>LoadFromFile</code> 的一个示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromFileExample</span> <span class="title">extends</span> <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function">function <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="string">&quot;myassetBundle&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (myLoadedAssetBundle == <span class="literal">null</span>) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Failed to load AssetBundle!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(<span class="string">&quot;MyObject&quot;</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在使用 Unity 5.3 或更早版本的 Android 设备上，尝试从流媒体资源 (Streaming Assets) 路径加载 AssetBundle 时，此 API 将失败。这是因为该路径的内容将驻留在压缩的 .jar 文件中。Unity 5.4 和更高版本则可以将此 API 调用与流媒体资源一起使用。</p><h2 id="WWW-LoadFromCacheOrDownload"><a href="#WWW-LoadFromCacheOrDownload" class="headerlink" title="WWW.LoadFromCacheOrDownload"></a>WWW.LoadFromCacheOrDownload</h2><p><a href="../ScriptReference/WWW.LoadFromCacheOrDownload.html">WWW.LoadFromCacheOrDownload</a></p><p><strong>即将弃用（使用 UnityWebRequest）</strong></p><p>此 API 对于从远程服务器下载 AssetBundle 或加载本地 AssetBundle 非常有用。这是一个陈旧且不太理想的 UnityWebRequest API 版本。</p><p>从远程位置加载 AssetBundle 将自动缓存 AssetBundle。如果 AssetBundle 被压缩，则将启动工作线程来解压缩捆绑包并将其写入缓存。一旦捆绑包被解压缩并缓存，它就会像 AssetBundle.LoadFromFile 一样加载。</p><p>如何使用 <code>LoadFromCacheOrDownload</code> 的一个示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromCacheOrDownloadExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">           <span class="keyword">while</span> (!Caching.ready)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> www = WWW.LoadFromCacheOrDownload(<span class="string">&quot;file://&quot;</span> + path, <span class="number">5</span>);</span><br><span class="line">        Debug.Log(path);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> www;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(www.error))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(www.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AssetBundle bundle = www.assetBundle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在 WWW 对象中缓存 AssetBundle 字节所需的内存开销，建议所有使用 WWW.LoadFromCacheOrDownload 的开发人员都应该确保自己的 AssetBundle 保持较小的大小 - 最多只有几兆字节。此外，还建议在有限内存平台（如移动设备）上运行的开发人员确保其代码一次只下载一个 AssetBundle，以此避免内存峰值。</p><p>如果缓存文件夹没有任何空间来缓存其他文件，LoadFromCacheOrDownload 将以迭代方式从缓存中删除最近最少使用的 AssetBundle，直到有足够的空间来存储新的 AssetBundle。如果无法腾出空间（因为硬盘已满，或者缓存中的所有文件当前都处于使用状态），LoadFromCacheOrDownload() 将不会使用缓存，而将文件流式传输到内存中</p><p>为了强制执行 LoadFromCacheOrDownload，需要更改版本参数（第二个参数）。仅当传递给函数的版本与当前缓存的 AssetBundle 的版本匹配，才会从缓存加载 AssetBundle。</p><h2 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h2><p><a href="../ScriptReference/Networking.UnityWebRequest.GetAssetBundle.html">UnityWebRequest</a></p><p>UnityWebRequest 有一个特定 API 调用来处理 AssetBundle。首先，需要使用 <code>UnityWebRequest.GetAssetBundle</code> 来创建 Web 请求。返回请求后，请将请求对象传递给 <code>DownloadHandlerAssetBundle.GetContent(UnityWebRequest)</code>。<code>GetContent</code> 调用将返回 AssetBundle 对象。</p><p>下载捆绑包后，还可以在 <a href="../ScriptReference/Networking.DownloadHandlerAssetBundle.html">DownloadHandlerAssetBundle</a> 类上使用 <code>assetBundle</code> 属性，从而以 <code>AssetBundle.LoadFromFile</code> 的效率加载 AssetBundle。</p><p>以下示例说明了如何加载包含两个游戏对象的 AssetBundle 并实例化这些游戏对象。要开始这个过程，我们只需要调用 <code>StartCoroutine(InstantiateObject())</code>;</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InstantiateObject</span>()</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(<span class="string">&quot;file://&quot;</span> + path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line">        AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">        GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Instantiate(cube);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用 UnityWebRequest 的优点在于，它允许开发人员以更灵活的方式处理下载的数据，并可能消除不必要的内存使用。这是比 UnityEngine.WWW 类更新和更优的 API。</p><h4 id="从-AssetBundle-加载资源"><a href="#从-AssetBundle-加载资源" class="headerlink" title="从 AssetBundle 加载资源"></a>从 AssetBundle 加载资源</h4><p>现在已经成功下载 AssetBundle，因此是时候最终加载一些资源了。</p><p>通用代码片段：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</span><br></pre></td></tr></table></figure><p>T 是尝试加载的资源类型。</p><p>决定如何加载资源时有几个选项。我们有 <code>LoadAsset</code>、<code>LoadAllAssets</code> 及其各自的异步对应选项 <code>LoadAssetAsync</code> 和 <code>LoadAllAssetsAsync</code>。</p><p>同步从 AssetBundle 加载资源的方法如下：</p><p>加载单个游戏对象：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject gameObject = loadedAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);</span><br></pre></td></tr></table></figure><p>加载所有资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();</span><br></pre></td></tr></table></figure><p>现在，在前面显示的方法返回要加载的对象类型或对象数组的情况下，异步方法返回 <a href="../ScriptReference/AssetBundleRequest.html">AssetBundleRequest</a>。在访问资源之前，需要等待此操作完成。加载资源：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync&lt;GameObject&gt;(assetName);</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line"><span class="keyword">var</span> loadedAsset = request.asset;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line"><span class="keyword">var</span> loadedAssets = request.allAssets;</span><br></pre></td></tr></table></figure><p>加载资源后，就可以开始了！可以像使用 Unity 中的任何对象一样使用加载的对象。</p><h4 id="加载-AssetBundle-清单"><a href="#加载-AssetBundle-清单" class="headerlink" title="加载 AssetBundle 清单"></a>加载 AssetBundle 清单</h4><p>加载 AssetBundle 清单可能非常有用。特别是在处理 AssetBundle 依赖关系时。</p><p>要获得可用的 <a href="../ScriptReference/AssetBundleManifest.html">AssetBundleManifest</a> 对象，需要加载另外的 AssetBundle（与其所在的文件夹名称相同的那个）并从中加载 AssetBundleManifest 类型的对象。</p><p>加载清单本身的操作方法与 AssetBundle 中的任何其他资源完全相同：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br></pre></td></tr></table></figure><p>现在，可以通过上面示例中的清单对象访问 <code>AssetBundleManifest</code> API 调用。从这里，可以使用清单获取所构建的 AssetBundle 的相关信息。此信息包括 AssetBundle 的依赖项数据、哈希数据和变体数据。</p><p>别忘了在前面的部分中，我们讨论过 AssetBundle 依赖项以及如果一个捆绑包对另一个捆绑包有依赖性，那么在从原始捆绑包加载任何资源之前，需要加载哪些捆绑包？清单对象可以动态地查找加载依赖项。假设我们想要为名为“assetBundle”的 AssetBundle 加载所有依赖项。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line"><span class="built_in">string</span>[] dependencies = manifest.GetAllDependencies(<span class="string">&quot;assetBundle&quot;</span>); <span class="comment">//传递想要依赖项的捆绑包的名称。</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> dependency <span class="keyword">in</span> dependencies)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经加载 AssetBundle、AssetBundle 依赖项和资源，因此是时候讨论如何管理所有这些已加载的 AssetBundle 了。</p><h2 id="管理已加载的-AssetBundle"><a href="#管理已加载的-AssetBundle" class="headerlink" title="管理已加载的 AssetBundle"></a>管理已加载的 AssetBundle</h2><p>从活动场景中删除对象时，Unity 不会自动卸载对象。资源清理在特定时间触发，也可以手动触发。</p><p>了解何时加载和卸载 AssetBundle 非常重要。不正确地卸载 AssetBundle 会导致在内存中复制对象或其他不良情况，例如缺少纹理。</p><p>关于 AssetBundle 管理最重要的事情就是何时调用</p><p><a href="../ScriptReference/AssetBundle.Unload.html">AssetBundle.Unload(bool)</a>; 以及应该将 true 还是 false 传递给函数调用。Unload 是一个非静态函数，可用于卸载 AssetBundle。此 API 会卸载正在调用的 AssetBundle 的标头信息。该参数指示是否还要卸载通过此 AssetBundle 实例化的所有对象。</p><p><code>AssetBundle.Unload(true)</code> 卸载从 AssetBundle 加载的所有游戏对象（及其依赖项）。这不包括复制的游戏对象（例如实例化的游戏对象），因为它们不再属于 AssetBundle。发生这种情况时，从该 AssetBundle 加载的纹理（并且仍然属于它）会从场景中的游戏对象消失，因此 Unity 将它们视为缺少纹理。</p><p>假设材质 M 是从 AssetBundle AB 加载的，如下所示。</p><p>如果调用 AB.Unload(true)，活动场景中的任何 M 实例也将被卸载并销毁。</p><p>如果改作调用 AB.Unload(false)，那么将会中断 M 和 AB 当前实例的链接关系。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242143748.png" alt="img"></p><p>如果稍后再次加载 AB 并且调用 AB.LoadAsset()，则 Unity 不会将现有 M 副本重新链接到新加载的材质。而是将加载 M 的两个副本。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242143614.png" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242143747.png" alt="img"></p><p>通常，使用 <code>AssetBundle.Unload(false)</code> 不会带来理想情况。大多数项目应该使用 <code>AssetBundle.Unload(true)</code> 来防止在内存中复制对象。</p><p>大多数项目应该使用 <code>AssetBundle.Unload(true)</code> 并采用一种方法来确保对象不会重复。两种常用方法是：</p><ul><li>在应用程序生命周期中具有明确定义的卸载瞬态 AssetBundle 的时间点，例如在关卡之间或在加载屏幕期间。</li><li>维护单个对象的引用计数，仅当未使用所有组成对象时才卸载 AssetBundle。这允许应用程序卸载和重新加载单个对象，而无需复制内存。</li></ul><p>如果应用程序必须使用 <code>AssetBundle.Unload(false)</code>，则只能以两种方式卸载单个对象：</p><ul><li>在场景和代码中消除对不需要的对象的所有引用。完成此操作后，调用 <a href="../ScriptReference/Resources.UnloadUnusedAssets.html">Resources.UnloadUnusedAssets</a>。</li><li>以非附加方式加载场景。这样会销毁当前场景中的所有对象并自动调用 <a href="../ScriptReference/Resources.UnloadUnusedAssets.html">Resources.UnloadUnusedAssets</a>。</li></ul><h1 id="加载依赖资源"><a href="#加载依赖资源" class="headerlink" title="加载依赖资源"></a>加载依赖资源</h1><h2 id="通过-API-获取-AssetBundle-依赖信息"><a href="#通过-API-获取-AssetBundle-依赖信息" class="headerlink" title="通过 API 获取 AssetBundle 依赖信息"></a>通过 API 获取 AssetBundle 依赖信息</h2><ul><li>GetAllAssetBundles()<ul><li>描述：获取所有的 AssetBundle 的名字</li></ul></li><li>GetAllDependencies(bundleName)<ul><li>描述：获取目标 AssetBundle 的所有依赖 AssetBundle 名字 (递归遍历)</li></ul></li><li>GetDirectDependencies(bundleName)<ul><li>获取目标 AssetBundle 的直接的依赖 AssetBundle 名字(只遍</li></ul></li></ul><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LYFramework.Tests</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleManifestExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> windowsBundlePath = AssetBundleUtil.FullPathForAssetBundleName(<span class="string">&quot;Windows&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> windowsBundle = AssetBundle.LoadFromFile(windowsBundlePath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manifest = windowsBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line"></span><br><span class="line">manifest.GetAllAssetBundles()</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(Debug.Log);</span><br><span class="line"></span><br><span class="line">manifest.GetAllDependencies(<span class="string">&quot;coin_get_prefab&quot;</span>)</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(dependBundle =&gt; Debug.LogFormat(<span class="string">&quot;coin_get_prefab depends:&#123;0&#125;&quot;</span>, dependBundle));</span><br><span class="line"></span><br><span class="line">windowsBundle.Unload(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果如下。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coin_get</span><br><span class="line">coin_get_prefab</span><br><span class="line">coin_get_prefab depends:coin_get</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#数据结构与算法</title>
      <link href="/posts/ba6d86a1.html"/>
      <url>/posts/ba6d86a1.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="什么是数据结构与算法？"><a href="#什么是数据结构与算法？" class="headerlink" title="什么是数据结构与算法？"></a>什么是数据结构与算法？</h3><p>在学习数据结构与算法的时候，常常会思考一个问题：什么是数据结构与算法？</p><p>这里比较找到了一个比较好的答案。</p><p>从宏观来讲：</p><ul><li>数据结构是一组数据的存储结构。</li><li>算法就是操作数据的方法。</li><li>数据结构为算法服务，算法要作用在特定的数据结构中。</li></ul><p>从狭义上来讲，就是数据结构与算法这门学科就是去学习比较经典的数据结构和算法。</p><p>有点像学习设计模式一样，学习 23 种设计模式。</p><h3 id="如何学习数据结构与算法？"><a href="#如何学习数据结构与算法？" class="headerlink" title="如何学习数据结构与算法？"></a>如何学习数据结构与算法？</h3><p>说到设计模式，学习数据结构与算法与学习设计模式非常相似的。</p><p>我们知道设计模式有 23 种，而一般一个开发者学习设计模式的时候，往往会对 23 个设计模式都从头到尾学一遍，但是学完之后发现除了记了个名字之外没啥卵用，就连名字也不一定记得住。</p><p>那么是以为 23 种设计模式的核心并不是设计模式本身，而是 23 种设计模式所遵循的 SOLID 原则，即六大设计原则，而开发者一开始最应该掌握的是六大设计原则，而不是设计模式，六大设计原则是核心，而 23 种设计模式算是 23 种对于六大设计原则的案例一样，一定要先搞清楚这一点。否则学习就会事倍功半，当然如果有一定的编码经验再去学设计模式更好一些。</p><p>学习数据结构与算法也是一样的，数据结构与算法的核心是时间复杂度和空间复杂度，就像对于设计模式中的六大设计原则一样，掌握了时间复杂度和空间复杂度的评估，那么剩下的经典的常用的数据结构和算法就是一个个案例而已，而不用死记硬背，当然有一定的编码经验再去学习会更好一些。</p><p>这就是数据结构与算法的学习思路。</p><h3 id="为什么要学习数据结构与算法？"><a href="#为什么要学习数据结构与算法？" class="headerlink" title="为什么要学习数据结构与算法？"></a>为什么要学习数据结构与算法？</h3><ul><li>国内大厂的面试比较爱考，但是考得不是很难</li><li>Google、Facebook、微软等更爱考，而且非常难。</li><li>可以评估代码性能，写出高性能的代码</li><li>开发时选择合适的数据结构</li><li>比较有名的基础框架，都柔和了很多基础数据解耦股和算法的设计思想</li><li>阅读源码的时候可以减少阻碍（比如遇到一些算法的实现）</li><li>提高编程能力</li><li>思维提升</li><li>简历上可以写一个精通数据结构与算法</li></ul><h3 id="数据结构与算法是不是高智商开发者的专属？"><a href="#数据结构与算法是不是高智商开发者的专属？" class="headerlink" title="数据结构与算法是不是高智商开发者的专属？"></a>数据结构与算法是不是高智商开发者的专属？</h3><p>当然不是，数据结构与算法的常用的知识点不多，而且也不需要高智商。重点还是熟能生巧。</p><h3 id="数据结构与算法学科的解决问题重点是什么？"><a href="#数据结构与算法学科的解决问题重点是什么？" class="headerlink" title="数据结构与算法学科的解决问题重点是什么？"></a>数据结构与算法学科的解决问题重点是什么？</h3><ul><li>更省更快地存储和处理数据的问题<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923357.png" alt="image.png"></li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度的定义很简单：</p><ul><li>算法的执行时间与数据规模之间的增长关系</li></ul><p>时间复杂度的全称其实叫做：渐进时间复杂度，我们就叫时间复杂度即可。</p><p>时间复杂度的定义难得的清晰，不像一些设计模式这样的定义非常抽象。</p><p>OK，既然时间复杂度的定义这么简单，那么我们也顺便说一下空间复杂度吧，空间复杂度的定义如下：</p><ul><li>算法的存储空间与数据规模之间的增长关系。</li></ul><p>空间复杂度的定义也非常直白。</p><p> List 的遍历，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 list 的数据规模是 3，其实就是数据量，那么这一段代码所执行的时间就是， Debug.Log(s) 所执行的时间 x 3。</p><p>用公式表示如下：</p><ul><li>代码总共执行的时间 = Debug.Log(s) 执行一次的时间 x list.Count</li></ul><p>那么该代码的执行时间与数据规模之间的增长关系是怎么样的呢？</p><p>其实以上的公式就回答了这个问题，代码的执行时间与数据规模之间的增长关系是一比一关系，即数据规模增长一倍，那么代码的执行时间也会增长一倍。</p><p>这里我们用 T(n) 表示代码总共执行的时间，用 UnitTime 表示 Debug.Log(s) 执行一次的时间，用 n 表示 数据的规模（lisnt.Count)，代入以上公式，如下：</p><ul><li>T(n) = UnitTime x n</li></ul><p>通过以上公式就能够算出以上代码所执行花费的时间，只不过 UnitTime 的执行时间非常依赖具体的软硬件环境，而以上这个公式实际上是 <strong>事后统计法</strong> 的统计方式。</p><p>而我们的时间复杂度，需要算出来的并不是代码中共执行所花费总时间，而是表示一个关系，即：代码执行时间与数据规模这件的增长关系。</p><p>而目前的 T(n) = UnitTime x n 这个公式，根据我们的所学的数学知识，能够得出的增长关系就是正比例关系。</p><p>但是在数据结构与算法中用大 O 表示法来表示算法执行时间与数据规模的增长关系，那么大 O 表示法如何使用呢？</p><p>很简单，就是 O(T(n))，但是这个 O(T(n)) 不是最终计算完的版本，还需要一些计算的过程。</p><p>第一步是吧 T(n) 代入到 O(T(n)) 中，结果如下：</p><ul><li>O(UnitTime x n)</li></ul><p>接着把系数、加减的常量、数量级更低的 n 都排除掉。</p><p>在 UnitTime x n 中，UnitTime 虽然目前是未知数，但是我们可以确定的是它肯定是一个常数，所以就直接把 UnitTime 去掉。</p><p>最终得到的执行时间与数据规模的增长关系如下：</p><ul><li>O(n)</li></ul><p>即，遍历 list 这个算法的执行时间与数据规模的增长关系，也就是所谓的时间复杂度为 O(n)。</p><p>时间复杂度这个概念对大家来说不是很难，但是一定要掌握，因为时间复杂度这个概念是整个 数据结构与算法 这门学科的灵魂。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// [&quot;List&quot;,&quot;数据结构与算法&quot;]</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;List&quot;</span>,</span><br><span class="line"><span class="string">&quot;数据结构与算法&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;List&quot;,&quot;数据结构与算法&quot;,&quot;框架搭建&quot;]</span></span><br><span class="line">list.Add(<span class="string">&quot;框架搭建&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;List&quot;,&quot;数据结构与算法&quot;,&quot;框架搭建&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.Add(<span class="string">&quot;Shader 案例&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构与算法&quot;,&quot;框架搭建&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.Remove(<span class="string">&quot;List&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;框架搭建&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.RemoveAll((content) =&gt; content.StartsWith(<span class="string">&quot;数据&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;插入的数据&quot;,&quot;框架搭建&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="string">&quot;插入的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;插入的数据&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.RemoveAt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> content <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923086.png" alt="image.png"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923377.png" alt="image.png"></p><h3 id="List-中的数据结构概念"><a href="#List-中的数据结构概念" class="headerlink" title="List 中的数据结构概念"></a>List 中的数据结构概念</h3><p>List 有一些数据结构相关的特性，比如：</p><ul><li>动态扩容</li><li>内存连续（任意访问）</li></ul><p>这些仅仅是一些特性，并不是概念。</p><p>那么 List 中有哪些数据结构的概念呢？</p><p>答案是线性表。</p><h2 id="线性表-与-非线性表"><a href="#线性表-与-非线性表" class="headerlink" title="线性表 与 非线性表"></a>线性表 与 非线性表</h2><p>线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿串起来，再存储到物理空间中”。</p><p>每个线性表上的数据最多只有前和后两个方向。</p><p>List 就是一种线性表，因为 List 符合以上的线性表的定义。</p><p>List 本质是一个数组，只不过这个数组是支持动态扩容的。通过看 List 源码就可以知道 List 内部维护了一个数组。</p><p>所以数组也是一种线性表，所以 List 与数组一样，也是一种线性表。</p><p>到这里大家可能会问，除了数组是线性表之外，还有哪些类型的数据结构是线性表？</p><p>答案是：链表、栈、队列。</p><p>而恰好，C# 中也有实现的数据结构与之对应，如下：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923712.png" alt="image.png"></p><p>而这些数据结构则是接下来要学习的内容。</p><p>既然有了线性表，那么就应该有非线性表，非线性表的常见数据结构如下：</p><ul><li>散列/哈希表（hash）</li><li>树：二叉树、堆等</li><li>图</li></ul><p>之所以这些数据结构叫非线性表是因为数据之间并不是简单的前后关系。</p><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><h3 id="字典简介"><a href="#字典简介" class="headerlink" title="字典简介"></a>字典简介</h3><p>Dictionary 是 C# 中比较常用的数据结构，从功能角度来说，用 List 和 Dictionary 其实就能满足大部分的业务开发需求。</p><p>Dictionary 是 key-value 存储的数据结构，即通过 key 去访问 value 值。而 List 则是通过索引去访问 value 值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure2020</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DictionaryExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Unity C# 数据结构与算法精讲&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;price&quot;</span>,<span class="string">&quot;9.9&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;,</span></span><br><span class="line"><span class="comment">//&quot;createAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dictionary.Add(<span class="string">&quot;createAt&quot;</span>,<span class="string">&quot;2021 年 12 月 12 日&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;,</span></span><br><span class="line"><span class="comment">//&quot;createAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">//&quot;updateAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dictionary.Add(<span class="string">&quot;updateAt&quot;</span>,<span class="string">&quot;2021 年 12 月 12 日&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;,</span></span><br><span class="line"><span class="comment">//&quot;updateAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dictionary.Remove(<span class="string">&quot;createAt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;,</span></span><br><span class="line"><span class="comment">//&quot;updateAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dictionary[<span class="string">&quot;updateAt&quot;</span>] = <span class="string">&quot;2021 年 12 月 12 日&quot;</span>;</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ keys @@@@&quot;</span>);</span><br><span class="line">dictionary.Keys.ToList().ForEach(Debug.Log);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ values @@@@&quot;</span>);</span><br><span class="line">dictionary.Values.ToList().ForEach(Debug.Log);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ key:value @@@@&quot;</span>);</span><br><span class="line">dictionary.ToList().ForEach(kv =&gt; Debug.LogFormat(<span class="string">&quot;key:&#123;0&#125;,value:&#123;1&#125;&quot;</span>, kv.Key, kv.Value));</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ containsKey @@@@&quot;</span>);</span><br><span class="line">Debug.LogFormat(<span class="string">&quot;dictionary.ContainsKey(updateAt):&#123;0&#125;&quot;</span>, dictionary.ContainsKey(<span class="string">&quot;updateAt&quot;</span>));</span><br><span class="line">Debug.LogFormat(<span class="string">&quot;dictionary.ContainsKey(createAt):&#123;0&#125;&quot;</span>, dictionary.ContainsKey(<span class="string">&quot;createAt&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923831.png" alt="image.png"></p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="Stack-简介"><a href="#Stack-简介" class="headerlink" title="Stack 简介"></a>Stack 简介</h3><p>Stack 叫做栈，栈数据结构的一个特点就是：后进先出，先进后出。</p><p>就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放，取的时候，我们也是从上往下一个个地依次取，不能从中间人物抽出。</p><p>从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StackExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;]</span></span><br><span class="line">stack.Push(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line">stack.Push(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;Stack&quot;,&quot;算法&quot;]</span></span><br><span class="line">stack.Push(<span class="string">&quot;Stack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">var</span> liangxie = stack.Pop();</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;pop liangxie:&quot;</span> + liangxie);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">var</span> algo = stack.Peek();</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;peek algo:&quot;</span> + algo);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ stack foreach @@@@&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> title <span class="keyword">in</span> stack)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(title);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923146.png" alt="image.png"></p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue-简介"><a href="#Queue-简介" class="headerlink" title="Queue 简介"></a>Queue 简介</h3><p>Queue 即，队列，队列是一种先进先出，后进后出的线性表。</p><p>那么队列也有两个基本的操作：</p><ul><li>Enqueue：入队</li><li>Dequeue：出队</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QueueExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;]</span></span><br><span class="line">queue.Enqueue(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line">queue.Enqueue(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;,&quot;Queue&quot;]</span></span><br><span class="line">queue.Enqueue(<span class="string">&quot;Queue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;算法&quot;,&quot;Queue&quot;]</span></span><br><span class="line"><span class="keyword">var</span> dataStructure = queue.Dequeue();</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;dequeue dataStructure:&quot;</span> + dataStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> algo = queue.Peek();</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;peek algo:&quot;</span> + algo);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ foreach queue @@@@&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> title <span class="keyword">in</span> queue)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(title);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923546.png" alt="image.png"></p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="HashSet-基本使用"><a href="#HashSet-基本使用" class="headerlink" title="HashSet 基本使用"></a>HashSet 基本使用</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HashSetExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Add(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Add(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Add(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;,&quot;HashSet&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Add(<span class="string">&quot;HashSet&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Remove(<span class="string">&quot;HashSet&quot;</span>);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;contains 算法:&quot;</span> + <span class="keyword">set</span>.Contains(<span class="string">&quot;算法&quot;</span>));</span><br><span class="line">Debug.Log(<span class="string">&quot;contains HashSet:&quot;</span> + <span class="keyword">set</span>.Contains(<span class="string">&quot;HashSet&quot;</span>));</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ set foreach @@@@&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> title <span class="keyword">in</span> <span class="keyword">set</span>)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(title);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923618.png" alt=""></p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LinkedListExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> linkedList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;数据结构&quot;</span></span><br><span class="line"><span class="keyword">var</span> dataStructureNode = linkedList.AddFirst(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;数据结构&quot;</span></span><br><span class="line"><span class="keyword">var</span> algoNode = linkedList.AddFirst(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;数据结构&quot;&lt;=&gt;&quot;LinkedList&quot;</span></span><br><span class="line"><span class="keyword">var</span> liangxieNode = linkedList.AddLast(<span class="string">&quot;LinkedList&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;专栏&quot;&lt;=&gt;&quot;数据结构&quot;&lt;=&gt;&quot;LinkedList&quot;</span></span><br><span class="line">linkedList.AddAfter(algoNode, <span class="string">&quot;专栏&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;专栏&quot;&lt;=&gt;&quot;数据结构&quot;&lt;=&gt;&quot;笔记&quot;&lt;=&gt;&quot;LinkedList&quot;</span></span><br><span class="line">linkedList.AddBefore(liangxieNode, <span class="string">&quot;笔记&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;专栏&quot;&lt;=&gt;&quot;笔记&quot;&lt;=&gt;&quot;LinkedList&quot;</span></span><br><span class="line">linkedList.Remove(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;专栏&quot;&lt;=&gt;&quot;笔记&quot;</span></span><br><span class="line">linkedList.Remove(liangxieNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhuanlanNode = linkedList.Find(<span class="string">&quot;专栏&quot;</span>);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;find zhuanlanNode:&quot;</span> + zhuanlanNode.Value);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ linkedList foreach @@@@&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> linkedList)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果和代码中注释和结果来看，LinkedList 中存储的元素并不是数据，而是一个个节点 LinkedListNode，而其中的节点才会去存储真正的数据。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924101.png" alt="image.png"></p><h3 id="链表-简介"><a href="#链表-简介" class="headerlink" title="链表 简介"></a>链表 简介</h3><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p><p>定义中有两个重点：</p><ul><li>内存中不连续、不顺序</li><li>逻辑上通过链表节点的指针实现</li></ul><p>也就是说与数组相反，链表在内存中是不连续的，既然不连续，那就不支持任意访问。不连续还有个好处就是不用考虑因动态扩容造成的 GC Alloc 和 GC Collect。</p><p>首先我们先定义一个链表节点对象，如下：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924665.png" alt="image.png"><br>即，该类有两个字段：</p><ul><li>指向下一个节点的 Next 字段</li><li>用于存储数据的 Data</li></ul><p>而一个比较典型的链表数据结构如下图所示；<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924769.png" alt="image.png"></p><p>图中的这种链表叫做单向链表。</p><p>单向链表的特点就是只有一个 Next 指针指向下一个节点。</p><p>那么到这里大家可能会问，链表 与 数组相比有什么优劣呢？</p><p>这里笔者简单总结下它们的优劣：</p><p>链表：</p><ul><li>不支持任意访问，想要实现任意访问的时间复杂度为 O(n)</li><li>天然支持动态扩容</li><li>在头结点或者尾结点插入数据的时间复杂度为 O(1)</li><li>在中间插入结点的方式分为两种：<ul><li>得到插入位置结点的情况下，插入一个节点的时间复杂度为 O(1)</li><li>在没有得到插入位置结点的情况下，插入一个时间复杂度为 O(n)</li></ul></li><li>查询某个符合条件的节点的时间复杂度为 O(n)</li><li>删除节点的时间复杂度也同理：<ul><li>在头和尾，或者得到插入位置的节点情况下是 O(1)</li><li>否则是 O(n)</li></ul></li><li>内存中不连续</li></ul><p>数组：</p><ul><li>支持任意访问，时间复杂度为 O(1)</li><li>不支持动态扩容，List 支持</li><li>插入数据的时间复杂度为 O(n)，因为要考虑数据搬移</li><li>删除数据的时间复杂度为 O(n)，也是要考虑数据搬移</li><li>查询符合条件的某个数据的时间复杂度是 O(n)</li><li>内存中连续</li></ul><p>以上就是链表和数组的简单对比，不同的存储形式有不同的功能和作用，所以如何挑选合适的数据结构对程序的性能来说是非常重要的。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="Hash-简介"><a href="#Hash-简介" class="headerlink" title="Hash 简介"></a>Hash 简介</h3><p>Hash 即哈希或者叫散列。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure2020</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HashPrincipleExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 学生类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 学生数组</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">Student[] mStudent = <span class="keyword">new</span> Student[]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1001&quot;</span>,Name = <span class="string">&quot;小数&quot;</span>&#125;, </span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1002&quot;</span>,Name = <span class="string">&quot;小据&quot;</span>&#125;, </span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1003&quot;</span>,Name = <span class="string">&quot;小结&quot;</span>&#125;, </span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1004&quot;</span>,Name = <span class="string">&quot;小构&quot;</span>&#125;, </span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1005&quot;</span>,Name = <span class="string">&quot;小与&quot;</span>&#125;, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 根据 Id 获取学生对象</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;id&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function">Student <span class="title">GetStudentById</span>(<span class="params"><span class="built_in">string</span> id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> idNumber = <span class="built_in">int</span>.Parse(id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = idNumber - <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mStudent[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 查询学生</span></span><br><span class="line"><span class="keyword">var</span> student = GetStudentById(<span class="string">&quot;1003&quot;</span>);</span><br><span class="line"></span><br><span class="line">Debug.Log(student.Id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetStudentById 的所使用的思想就是散列的思想，即通过把一个 key 转换成数组的下标，根据下标直接获取数据的思想。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表，即 Hashtable，是有一种使用散列思想的数据结构。而在 C# 中也有一个叫做 Hashtable 的数据结构。</p><p>我们都知道，数组是支持下标的任意访问的，散列表用的就是数组的任意访问的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>散列表由三个部分组成，即：</p><ul><li>key（关键字）</li><li>hash function（散列/哈希函数）</li><li>table（用于存储的数组）</li></ul><p>我们在上一篇知道，散列的思想本质上就是将 key 转换为 数组的下标，然后通过下标去访问数组的数据的一种思想，所以通过这一点不难看出，以上的三个部分中 hash function 就是将 key 转换为下标的一个方法。</p><p>而 table 一般就是用数组或者能够通过下标访问的一些数据结构实现。</p><p>其流程如下图所示：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924815.png" alt="image.png"></p><h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>Hashtable 的 hash function 其实就是将 key 的 hash code 转换为 数组下标。</p><p>代码如下：</p><ul><li>uint hashcode = InitHash(key, buckets.Length, out seed, out incr);</li><li>int bucketNumber = (int) (seed % (uint)buckets.Length);</li></ul><p>散列冲突指的就是，不同的 key 得到的 bucketNumber 有可能是一致的，也就是说数组的下标会产生重复的情况。</p><p>]把发生数组小标重复的情况叫做 散列冲突。</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>在发生散列冲突的时候，我们就需要解决掉这个冲突。</p><p>而解决这个冲突的方式一般有两种：</p><ul><li>开放寻址法（或闭散列法）</li><li>链表法（或开散列法）</li></ul><p>开放寻址法的特点非常简单，当发生散列冲突的时候，会在数组内寻找下一个可用的位置来存储数据，这时候会对数组进行遍历操作。</p><p>开放寻址法的缺陷就是当数组空余空间越少，发生散列冲突的概率越大，所以 C# 的 Hashtable 通过动态扩容来解决这个问题。</p><p>而链表法的特点则是，当法神散列冲突的时候，会在冲突位置来创建一个链表来存储数据。</p><p>而当发生冲突的时候，不管是开放寻址法还是链表法，都会去其他的内存空间中找到或者创建一个插槽（slot），用于存放数据。</p><p>在 C# 的 Hashtable 中，插槽可以理解为数组中一个空的 bucket。</p><p>由于在 C# Hashtable 中没有链表相关的代码，所以可以推测出 Hashtable 是使用开放寻址法来解决散列冲突。</p><h3 id="Hashtable-与-HashSet的区别"><a href="#Hashtable-与-HashSet的区别" class="headerlink" title="Hashtable 与 HashSet的区别"></a>Hashtable 与 HashSet的区别</h3><p>Hashtable 与 HashSet 的基本存储单元以及集合的不同导致了对应的 添加、删除、查询等算法的差异。</p><p>在 Hashtable 中，添加一个数据的流程如下：</p><ul><li>获取 key 的 hashcode：<ul><li>uint hashcode = InitHash(key, buckets.Length, out seed, out incr);</li></ul></li><li>获取下标：<ul><li>int bucketNumber = (int) (seed % (uint)buckets.Length);</li></ul></li><li>存储值：<ul><li>buckets[bucketNumber].val = nvalue;</li><li>buckets[bucketNumber].key = key;</li><li>buckets[bucketNumber].hash_coll |= (int) hashcode;</li></ul></li></ul><p>在 HashSet 中，添加一个数据的流程如下：</p><ul><li>获取 hash code：<ul><li>hashCode = value != null ? value.GetHashCode() : 0;</li></ul></li><li>根据 hash code 获取 bucket （Entry 的下标）<ul><li>bucket = ref GetBucketRef(hashCode);</li></ul></li><li>下标前移</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = bucket - 1; // Value in _buckets is 1-based</span><br></pre></td></tr></table></figure><ul><li>存储</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ref Entry entry = ref entries![index];</span><br><span class="line">entry.HashCode = hashCode;</span><br><span class="line">entry.Next = bucket - 1; // Value in _buckets is 1-based</span><br><span class="line">entry.Value = value;</span><br><span class="line">bucket = index + 1;</span><br><span class="line">_version++;</span><br><span class="line">location = index;</span><br></pre></td></tr></table></figure><p>其实，两者存储的流程是差不多的，区别在于当数据发生冲突的时候。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924811.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity协程</title>
      <link href="/posts/6b63b37.html"/>
      <url>/posts/6b63b37.html</url>
      
        <content type="html"><![CDATA[<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>yield 实质是一个语法糖，它让程序员能够更方便的去使用迭代器，通过 yield 你可以直接使用迭代器操作而不需要去实现 IEnumerable 和 IEnumerator，也不需要一个临时的 Collection 来完成迭代。</p><p>yield 有两种格式声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yield return &lt;expression&gt;;</span><br><span class="line">yield break;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace UniRxLesson</span><br><span class="line">&#123;</span><br><span class="line">  public class YieldExample : MonoBehaviour</span><br><span class="line">  &#123;</span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">      foreach (var empty in FiveTimes())</span><br><span class="line">      &#123;</span><br><span class="line">        Debug.Log(&quot;A&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private  IEnumerable FiveTimes()</span><br><span class="line">    &#123;</span><br><span class="line">      for (var i = 0; i &lt; 5; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        yield return string.Empty;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>每一次 foreach 的循环中都会调用迭代器方法，当 yield return 被执行到时，表达式的值会被返回，同时当前的函数的上下文信息被保存下来。下一次循环执行之时会重新从上一次停止的位置继续执行。你也可以使用 yield break 来终止迭代过程。</p><p>yield 关键字除了支持返回 IEnumerable 之外，还支持返回 IEnumerator。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace UniRxLesson</span><br><span class="line">&#123;</span><br><span class="line">  public class YieldExample : MonoBehaviour</span><br><span class="line">  &#123;</span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">      foreach (var empty in FiveTimes())</span><br><span class="line">      &#123;</span><br><span class="line">        Debug.Log(&quot;A&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var fourTimes = FourTimes();</span><br><span class="line"></span><br><span class="line">      while (fourTimes.MoveNext())</span><br><span class="line">      &#123;</span><br><span class="line">        Debug.Log(&quot;B&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IEnumerable FiveTimes()</span><br><span class="line">    &#123;</span><br><span class="line">      for (var i = 0; i &lt; 5; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        yield return string.Empty;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IEnumerator FourTimes()</span><br><span class="line">    &#123;</span><br><span class="line">      for (var i = 0; i &lt; 4; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        yield return string.Empty;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">B</span><br><span class="line">B</span><br><span class="line">B</span><br></pre></td></tr></table></figure><h3 id="yield-解释说明"><a href="#yield-解释说明" class="headerlink" title="yield 解释说明"></a>yield 解释说明</h3><p>我们把包含 yield 语句的方法或属性称为迭代块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public IEnumerator GetEnumerator()</span><br><span class="line">&#123;</span><br><span class="line">  yield return 1;</span><br><span class="line">  yield return 2;</span><br><span class="line">  yield return &quot;枚举器&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语句块在编译时将会编译成一个 yield 类型，其中包含一个状态机。yield 类型实现 IEnumerator 和 IDisposable 接口属性和方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class IEnumeratorTest</span><br><span class="line">&#123;</span><br><span class="line">  public IEnumerator GetEnumerator()</span><br><span class="line">  &#123;</span><br><span class="line">    yield return 1;</span><br><span class="line">    yield return 2;</span><br><span class="line">    yield return &quot;枚举器&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则会编译成如下类似的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class IEnuemratorTest</span><br><span class="line">&#123;</span><br><span class="line">  public IEnumerator GetEnumerator()</span><br><span class="line">  &#123;</span><br><span class="line">    return new Enumerator(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public class Enumerator:IEnumerator&lt;object&gt;,IEnumerator,IDisposable</span><br><span class="line">  &#123;</span><br><span class="line">    private int state;</span><br><span class="line">    private object current;</span><br><span class="line">    public Enumerator(int state)</span><br><span class="line">    &#123;</span><br><span class="line">      this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public object Current</span><br><span class="line">    &#123;</span><br><span class="line">      get </span><br><span class="line">      &#123;    </span><br><span class="line">        return current;</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Dispose()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public bool MoveNext()</span><br><span class="line">    &#123;</span><br><span class="line">      switch(state)</span><br><span class="line">      &#123;</span><br><span class="line">        case 0:</span><br><span class="line">          state++; // 改变当前迭代诶值为下一个元素位置</span><br><span class="line">          current = 1; // 当前迭代位置的对象</span><br><span class="line">          return true;</span><br><span class="line">        case 1:</span><br><span class="line">          state++; // 改变当前迭代位置为下一个元素位置</span><br><span class="line">          current = 2; // 当前迭代位置的对象</span><br><span class="line">          return true;</span><br><span class="line">        case 2:</span><br><span class="line">          state++; // 改变当前迭代位置为下一个元素位置</span><br><span class="line">          current = &quot;枚举器&quot;; // 当前迭代位置的对象</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void Reset()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举器其实就是通过每次调用 MoveNext() 方法，来改变集合中当前元素位置，来一个个遍历元素。类似通过更改下标来获取元素。yield 关键字其实是实现 IEnumerator 等接口如 MoveNext() 方法的编译器自动编译的关键字。</p><h3 id="yield-return种类"><a href="#yield-return种类" class="headerlink" title="yield return种类"></a><strong>yield return种类</strong></h3><blockquote><p>yield return 0 or yield return null: 程序在下一帧中从当前位置继续执行；</p><p>yield return 1,2,3,……: 程序等待1，2，3…帧之后从当前位置继续执行；</p><p>yield return new WaitForSeconds(n): 程序等待n秒后从当前位置继续执行；</p><p>yield new WaitForEndOfFrame(): 在所有的渲染以及GUI程序执行完成后从当前位置继续执行；</p><p>yield new WaitForFixedUpdate(): 所有脚本中的FixedUpdate()函数都被执行后从当前位置继续执行；</p><p>yield return WWW: 等待一个网络请求完成后从当前位置继续执行；</p><p>yield return StartCoroutine(): 等待一个协程执行完成后从当前位置继续执行；</p><p>yield break: 直接从当前位置跳出函数体，回到函数的根部；</p></blockquote><h2 id="协程（coroutine）"><a href="#协程（coroutine）" class="headerlink" title="协程（coroutine）"></a>协程（coroutine）</h2><p><strong>官方解释</strong>：在主程序运行的同时，开启另外一段逻辑处理，来协同当前程序的执行；</p><p><strong>个人理解：</strong>函数中调用另一个函数，另一个执行完成回来继续往下执行该函数；</p><p>StartCoroutine方法属于MonoBehaviour中API，和Invoke一样必须继承MonoBehaviour才能使用；</p><h3 id="通过-Unity-的-Update-模拟协程。"><a href="#通过-Unity-的-Update-模拟协程。" class="headerlink" title="通过 Unity 的 Update() 模拟协程。"></a>通过 Unity 的 Update() 模拟协程。</h3><p>修改上面代码，不使用 while 循环或者 foreach 关键字枚举元素。我们将在 Update() 实时刷新来枚举所有元素。</p><p>原理就是上面所说的每次 MoveNext() 方法后，改变当前的位置为下一个元素位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace UniRxLesson</span><br><span class="line">&#123;</span><br><span class="line">  public class CoroutineExample : MonoBehaviour</span><br><span class="line">  &#123;</span><br><span class="line">    private Update2CoroutineTest mUpdate2CoroutineTest = new Update2CoroutineTest();</span><br><span class="line"></span><br><span class="line">    IEnumerator mE;</span><br><span class="line"></span><br><span class="line">    public CoroutineExample()</span><br><span class="line">    &#123;</span><br><span class="line">      mE = mUpdate2CoroutineTest.GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">      if (mE.MoveNext())</span><br><span class="line">      &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Update2CoroutineTest</span><br><span class="line">    &#123;</span><br><span class="line">      public IEnumerator GetEnumerator()</span><br><span class="line">      &#123;</span><br><span class="line">        Debug.Log(&quot;协程:&quot; + 1);</span><br><span class="line">        yield return 0;</span><br><span class="line">        Debug.Log(&quot;协程:&quot; + 2);</span><br><span class="line">        yield return 0;</span><br><span class="line">        Debug.Log(&quot;协程:&quot; + &quot;枚举器&quot;);</span><br><span class="line">        yield return 0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">协程:1</span><br><span class="line">协程:2</span><br><span class="line">协程:枚举器</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>现在我们用 StartCoroutine（）方法启动协程。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class CoroutineTest : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">  void Start()</span><br><span class="line">  &#123;</span><br><span class="line">    CoroutineJsTest coroutineJsTest = new CoroutineJsTest();</span><br><span class="line">    StartCoroutine(coroutineJsTest.GetEnumerator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CorotuineJsTest</span><br><span class="line">&#123;</span><br><span class="line">  public IEnumerator GetEnumerator()</span><br><span class="line">  &#123;</span><br><span class="line">    Debug.Log(&quot;协程:&quot; + 1);</span><br><span class="line">    yield return 0;</span><br><span class="line">    Debug.Log(&quot;协程:&quot; + 2);</span><br><span class="line">    yield return 0;</span><br><span class="line">    Debug.Log(&quot;协程:&quot; + &quot;枚举器&quot;);</span><br><span class="line">    yield return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">协程:1</span><br><span class="line">协程:2</span><br><span class="line">协程:枚举器</span><br></pre></td></tr></table></figure><p>从上面可以看出，在 update 方法模拟协程和使用 Unity 自带 StartCoroutine() 方法启动协程效果差不多。看来自 Unity 实现的 StartCoroutine() 启动协程和我们 Update() 模拟是一样的。但是也不确定到底是不是通过类似 Update() 方法实现的。反编译 UnityEngine.dll 程序集也没有找到具体实现方法。。。。。但是唯一确定的一点就是 Unity 也是通过枚举一步步运行程序块的。</p><p>类似 Update() 模拟协程，每次遇到 yield return，就执行 yield 类型的 MoveNext() 方法，改变当前迭代位置为下一个元素位置。等待下一次 MoveNext() 方法调用。</p><p>StartCoroutine() 方法会不停的调用 MoveNext() 方法（这样就类似于 foreach）。直到枚举结束。</p><p>但是注意的是，yield return 后面跟的值除了 Unity 自带的累（如：new WaitForSeconds（0.2f)。继承自 YieldInstruction） 和协程语句块（返回值为 IEnumerator 的方法），其他值没有意义（yield return 0 和 yield return null） 其实都是一样的，只是遇到 yield return 就做相同处理，不会去处理后面跟的值了）。</p><h3 id="协程终止"><a href="#协程终止" class="headerlink" title="协程终止"></a><strong>协程终止</strong></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StopCoroutine (<span class="built_in">string</span> methodName)<span class="comment">//终止指定的协程</span></span><br><span class="line">StopAllCoroutine() <span class="comment">//终止所有协程</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Coroutine 其实是一个 迭代器模式 + 定时器的一种实现。</p><p>与我们的 UniRx 的 Observable + Scheduler + LINQ 非常类似。</p><p>关于协程的原理我们理解到这里就够了。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192022975.jpeg" alt="1.jpg"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192022065.jpeg" alt="2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity-编辑器扩展</title>
      <link href="/posts/cffbee7c.html"/>
      <url>/posts/cffbee7c.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、菜单栏拓展"><a href="#一、菜单栏拓展" class="headerlink" title="一、菜单栏拓展"></a><strong>一、菜单栏拓展</strong></h2><h3 id="Menultem"><a href="#Menultem" class="headerlink" title="Menultem"></a>Menultem</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Menultem(&quot;Test/CreatePanel/func1 %_Q&quot;),true,1]</span><br></pre></td></tr></table></figure><p>1、路径+快捷键，是否启用，排列顺序</p><p>2、配合Selection.Object选中物体文件夹时启用</p><p>3、方法必须是静态方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[MenuItem(&quot;Test/OpenPanel %_Q&quot;,true)]</span><br><span class="line">public static bool IsSelected()</span><br><span class="line">&#123;</span><br><span class="line"> if (Selection.objects.Length &gt; 0)</span><br><span class="line"> return  true;</span><br><span class="line"> else </span><br><span class="line"> return false;</span><br><span class="line">&#125;</span><br><span class="line">[MenuItem(&quot;Test/OpenPanel %_Q&quot;,false)]</span><br><span class="line">public static void OpenPanel()</span><br><span class="line">&#123;</span><br><span class="line">Undo.DestroyObjectImmediate(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049785.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/2522637-20210918100911449-1331448070.png" alt="img"></p><p>4、快捷键</p><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">字符</th></tr></thead><tbody><tr><td style="text-align:center">%</td><td style="text-align:center">Ctrl</td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">Shift</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">Alt</td></tr><tr><td style="text-align:center">LEFT/RIGHT/UP/DOWN</td><td style="text-align:center">方向键</td></tr><tr><td style="text-align:center">F1-F12</td><td style="text-align:center">F功能键</td></tr><tr><td style="text-align:center">_g</td><td style="text-align:center">字母g</td></tr></tbody></table></div><hr><h2 id="二、鼠标右键拓展"><a href="#二、鼠标右键拓展" class="headerlink" title="二、鼠标右键拓展"></a><strong>二、鼠标右键拓展</strong></h2><h3 id="CONTEXT"><a href="#CONTEXT" class="headerlink" title="CONTEXT"></a>CONTEXT</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[MenuItem(&quot;CONTEXT/组件名/方法名（按钮名）&quot;)]</span><br></pre></td></tr></table></figure><p>方法前加这句特性，可以在组件的鼠标右键菜单中添加相应的按钮方法，方法必须有参数MenuCommand</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[MenuItem(&quot;CONTEXT/Rigidbody/Clear&quot;)]</span><br><span class="line">static void ClearMassAndGravity(MenuCommand cmd)</span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody rgd = cmd.context as Rigidbody;</span><br><span class="line">    rgd.mass = 0.1f;</span><br><span class="line">    rgd.useGravity = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049579.png" alt="img"></p><h3 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[MenuItem(&quot;Assets/一级目录/二级目录&quot;,default/fasle, 显示优先级)]</span><br></pre></td></tr></table></figure><p>Assets面板中添加鼠标右键快捷操作；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[MenuItem(&quot;Assets/aaa/bbb&quot;,default,1)]</span><br><span class="line">public static void TestFunc2()</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(&quot;aaa&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049522.png" alt="img"></p><h3 id="ContextMenu"><a href="#ContextMenu" class="headerlink" title="ContextMenu"></a>ContextMenu</h3><p>1.ContextMenu(“选项名”)——脚本添加右键菜单按钮；</p><p>2.ContextMenuItem（”字段名”，”方法名”）+字段+方法——脚本属性添加右键按钮；</p><p>自行尝试，不赘述了，都可给脚本添加鼠标右键菜单栏</p><hr><h2 id="三、创建面板"><a href="#三、创建面板" class="headerlink" title="三、创建面板"></a><strong>三、创建面板</strong></h2><p>1、固定大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EditorWindow.GetWindow&lt;T&gt;(面板类型，是否可浮动,&quot;Title&quot;,聚焦窗口)</span><br></pre></td></tr></table></figure><p>2、自定义大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EditorWindow.GetWindowWithRect&lt;T&gt;(rect,可浮动,&quot;Title&quot;,聚焦窗口)</span><br></pre></td></tr></table></figure><p>T需要继承EditorWindow</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[MenuItem(&quot;Test/OpenPanel %_Q&quot;)]</span><br><span class="line">public static void OpenPanel()</span><br><span class="line">&#123;</span><br><span class="line">    Rect wr =new Rect(0,0,300,700);</span><br><span class="line">    //TestPanel win = EditorWindow.GetWindow&lt;TestPanel&gt;(false, &quot;UGUIConfig&quot;, false);</span><br><span class="line">    TestPanel win = EditorWindow.GetWindowWithRect&lt;TestPanel&gt;(wr, false, &quot;UGUIConfig&quot;, false);</span><br><span class="line">    win.Show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049308.png" alt="img"></p><hr><h2 id="四、Insptector界面拓展"><a href="#四、Insptector界面拓展" class="headerlink" title="四、Insptector界面拓展"></a><strong>四、Insptector界面拓展</strong></h2><p>在Example脚本的insptector界面添加执行按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public override void OnInspectorGUI()</span><br><span class="line">&#123;</span><br><span class="line">    base.OnInspectorGUI();</span><br><span class="line">    Example _example = target as Example;</span><br><span class="line">    if (GUILayout.Button(&quot;执行Example方法&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        _example.LogError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049312.png" alt="img"></p><hr><h2 id="五、GUILayout"><a href="#五、GUILayout" class="headerlink" title="五、GUILayout"></a><strong>五、GUILayout</strong></h2><p><strong>1.布局</strong></p><p>GUILayout.BeginVertical</p><p>GUILayout.EndVertical</p><p>GUILayout.BeginHorizontal</p><p>GUILayout.EndHorizontal</p><p>GUILayout.Option[]——以下都属于该分类，自定义布局大小</p><p>GUILayout.Width,GUILayout.Height,GUILayout.MaxWidth/MinWidth,GUILayout.ExpandWidth…</p><p><strong>2.控件</strong></p><p>GUILayout.Button(“name”,option)</p><p>GUILayout.SelectionGrid(gridId,new []{“”,””,””,””},每行个数)</p><p>GUILayout.PasswordField(string,’*’)</p><hr><h2 id="六、EditorGUILayout"><a href="#六、EditorGUILayout" class="headerlink" title="六、EditorGUILayout"></a>六、<strong>EditorGUILayout</strong></h2><p><strong>1.控件</strong></p><p>ObjectField</p><p>IntField</p><p>FloatField</p><p>LabelField</p><p>TextField</p><p>TextArea</p><p>ColorField</p><p>CurveField</p><p>EnumFlagsField</p><p>LayerField</p><p>TagField</p><p>BoundsField</p><p>Vector2Field</p><p><strong>2.滑条</strong></p><p>Slider</p><p>MinMaxSlider</p><p><strong>3.布局</strong></p><p>BeginFadeGroup(float) 百分比</p><p>EndFadeGroup</p><p>BeginToggleGroup(“name”,bool) 开关</p><p>EndToggleGroup</p><p>BeginScrollView(vector2,option) 位置，滚动区域大小</p><p>EndScrollView</p><p><strong>4.下拉框</strong></p><p>EnumPopup(EnumIndex)</p><p>Popup(index,string[])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">e.g:</span><br><span class="line">GUILayout.BeginVertical();</span><br><span class="line"></span><br><span class="line">GUILayout.BeginHorizontal();</span><br><span class="line">font = EditorGUILayout.ObjectField(font, typeof(Font), false) as Font;</span><br><span class="line">fontSize = EditorGUILayout.IntField(fontSize);</span><br><span class="line">GUILayout.EndHorizontal();</span><br><span class="line"></span><br><span class="line">EditorGUILayout.LabelField(&quot;计时: &quot;,EditorApplication.timeSinceStartup.ToString());</span><br><span class="line"></span><br><span class="line">floatValue = EditorGUILayout.FloatField(&quot;浮点数&quot;, floatValue);</span><br><span class="line"></span><br><span class="line">num = EditorGUILayout.Slider (&quot;Slider&quot;, num, -3, 3);</span><br><span class="line">//IntSlider</span><br><span class="line">EditorGUILayout.BeginFadeGroup(1f); // 组开始</span><br><span class="line">GUILayout.Button(&quot;Button0&quot;); // 组中的内容，我这写了3个按钮</span><br><span class="line">GUILayout.Button(&quot;Button1&quot;);</span><br><span class="line">GUILayout.Button(&quot;Button2&quot;);</span><br><span class="line">EditorGUILayout.EndFadeGroup(); // 组结束</span><br><span class="line"></span><br><span class="line">toggleOpen = EditorGUILayout.BeginToggleGroup(&quot;Toggle&quot;, toggleOpen); // 组开始</span><br><span class="line">_color= EditorGUILayout.ColorField(&quot;Color&quot;, _color); // 组中的内容</span><br><span class="line">str = EditorGUILayout.TextField(&quot;Text&quot;, str);</span><br><span class="line">EditorGUILayout.EndToggleGroup();</span><br><span class="line"></span><br><span class="line">_scrollPos = EditorGUILayout.BeginScrollView(_scrollPos,GUILayout.MaxHeight(60)); // 组开始</span><br><span class="line">EditorGUILayout.LabelField(&quot;1212 12 312 1244124&quot;); // 组中的内容</span><br><span class="line">EditorGUILayout.LabelField(&quot;123123123123123&quot;);</span><br><span class="line">EditorGUILayout.TextArea(&quot;12312312\n 3123123&quot;);</span><br><span class="line">EditorGUILayout.LabelField(&quot;123123123123123&quot;);</span><br><span class="line">EditorGUILayout.LabelField(&quot;123123123123123&quot;);</span><br><span class="line">EditorGUILayout.LabelField(&quot;123123123123123&quot;);</span><br><span class="line">EditorGUILayout.LabelField(&quot;123123123123123&quot;);</span><br><span class="line">EditorGUILayout.EndScrollView(); // 组结束</span><br><span class="line"></span><br><span class="line">_animationCurve = EditorGUILayout.CurveField(&quot;AnimationCurve&quot;, _animationCurve);</span><br><span class="line"></span><br><span class="line">gridId = GUILayout.SelectionGrid(gridId, new[] &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;&#125;, 3);</span><br><span class="line"></span><br><span class="line">GUILayout.BeginHorizontal();</span><br><span class="line">EditorGUILayout.LabelField(&quot;密码：&quot;,GUILayout.Width(50));</span><br><span class="line">password = GUILayout.PasswordField(password, &#x27;*&#x27;);</span><br><span class="line">GUILayout.EndHorizontal();</span><br><span class="line"></span><br><span class="line">EditorGUILayout.MinMaxSlider(&quot;MinMaxSlider&quot;,ref sliderValue2,ref sliderValue3,10,20);</span><br><span class="line"></span><br><span class="line">flagtype=(flagTestType)EditorGUILayout.EnumFlagsField(flagtype);</span><br><span class="line"></span><br><span class="line">popupindex=(flagTestType)EditorGUILayout.EnumPopup(popupindex);</span><br><span class="line"></span><br><span class="line">layer = EditorGUILayout.LayerField(&quot;LayerField&quot;, layer);</span><br><span class="line">tag = EditorGUILayout.TagField(&quot;TagField&quot;, tag);</span><br><span class="line">go = EditorGUILayout.ObjectField(&quot;ObjectField&quot;, go, typeof(GameObject), true);</span><br><span class="line">EditorGUILayout.Space();</span><br><span class="line"></span><br><span class="line">boundsv=EditorGUILayout.BoundsField(&quot;BoundsField&quot;,boundsv);</span><br><span class="line"></span><br><span class="line">//EditorGUILayout.PropertyField();</span><br><span class="line"></span><br><span class="line">index =EditorGUILayout.Popup(index, options);</span><br><span class="line">if(GUILayout.Button(&quot;Create&quot;))</span><br><span class="line">    InstantiatePrimitive();</span><br><span class="line"></span><br><span class="line">p1 =EditorGUILayout.Vector2Field(&quot;Point 1:&quot;, p1);</span><br><span class="line"></span><br><span class="line">GUILayout.EndVertical();</span><br><span class="line"></span><br><span class="line"> 复制 全屏</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049875.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/posts/376d0826.html"/>
      <url>/posts/376d0826.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是回溯法"><a href="#什么是回溯法" class="headerlink" title="什么是回溯法"></a>什么是回溯法</h2><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p>在二叉树系列中，我们已经不止一次，提到了回溯，例如 二叉树：以为使用了递归，其实还隐藏着回溯。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><h2 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="回溯法的效率"></a>回溯法的效率</h2><p>回溯法的性能如何呢，这里要和大家说清楚了，「虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法」。</p><p>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案」，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><p>那么既然回溯法并不高效为什么还要用它呢？</p><p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p><h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p><p>组合问题：N个数里面按一定规则找出k个数的集合<br>排列问题：N个数按一定规则全排列，有几种排列方式<br>切割问题：一个字符串按一定规则有几种切割方式<br>子集问题：一个N个数的集合里有多少符合条件的子集<br>棋盘问题：N皇后，解数独等等</p><p>组合是不强调元素顺序的，排列是强调元素顺序」。</p><p>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p><p>记住组合无序，排列有序，就可以了。</p><h2 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h2><p>所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。</p><p>递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。</p><h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><p>回溯函数模板返回值以及参数<br>在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。</p><p>回溯算法中函数返回值一般为void。</p><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p><p>回溯函数伪代码如下：</p><p>void backtracking(参数)<br>回溯函数终止条件<br>既然是树形结构，那么我们在讲解 二叉树的递归的时候，就知道遍历树形结构一定要有终止条件。</p><p>所以回溯也有要终止条件。</p><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><p>所以回溯函数终止条件伪代码如下：</p><p>if (终止条件) {<br>    存放结果;<br>    return;<br>}<br>回溯搜索的遍历过程<br>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p>如图：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191900634.png" alt="关于回溯算法，你该了解这些！_java"></p><p>注意图中，集合大小和孩子的数量是相等的！</p><p>回溯函数遍历过程伪代码如下：</p><p>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>    处理节点;<br>    backtracking(路径，选择列表); // 递归<br>    回溯，撤销处理结果<br>}<br>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p><p>backtracking这里自己调用自己，实现递归。</p><p>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p>分析完过程，回溯算法模板框架如下：</p><p>void backtracking(参数) {<br>    if (终止条件) {<br>        存放结果;<br>        return;<br>    }</p><pre><code>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;    处理节点;    backtracking(路径，选择列表); // 递归    回溯，撤销处理结果&#125;</code></pre><p>}</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回溯和递归是相辅相成的。</p><p>接着提到了回溯法的效率，回溯法其实就是暴力查找，并不是什么高效的算法。</p><p>然后列出了回溯法可以解决几类问题，可以看出每一类问题都不简单。</p><p>最后回溯法解决的问题都可以抽象为树形结构（N叉树），并给出了回溯法的模板。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/posts/a80d0031.html"/>
      <url>/posts/a80d0031.html</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划为什么重要？"><a href="#动态规划为什么重要？" class="headerlink" title="动态规划为什么重要？"></a>动态规划为什么重要？</h2><p>从面试的角度看，动态规划是正规算法面试中无论如何都逃不掉的必考题。</p><p>其实最主要的原因就是动态规划非常适合面试，因为动态规划没办法「背」。</p><p>我们很多求职者其实是通过背题来面试的，而之前这个做法屡试不爽，什么翻转二叉树、翻转链表，快排、归并、冒泡一顿背，基本上也能在面试中浑水摸鱼过去，其实这哪是考算法能力、算法思维，这就是考谁的备战态度好，愿意花时间去背题而已，把连背都懒得背的筛出去就完事了。</p><p>但是随着互联网遇冷，人才供给进一步过热，背题的人越来越多，面试的门槛被增加了，因此这个时候需要一种非常考验算法思维、变化多端而且容易设计的题目类型，动态规划就完美符合这个要求。</p><p>比如 LeetCode 中有1261道算法类题目,其中动态规划题目占据了近200道，动态规划能占据总题目的 1/6 的比例,可见其火热程度。</p><p>更重要的是，动态规划的题目难度以中高难度为主</p><p>所以,既然我们已经知道这是算法面试的必考题了,我们怎么准备都不为过。</p><h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>动态规划(Dynamic programming，简称DP)是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>态规划与分治方法类似，都是通过组合子问题的解来来求解原问题的。再来了解一下什么是分治方法，以及这两者之间的差别，分治方法将问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来，求出原问题的解。而动态规划与之相反，动态规划应用与子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治方法会做许多不必要的工作，他会反复求解那些公共子子问题。而动态规划对于每一个子子问题只求解一次，将其解保存在一个表格里面，从而无需每次求解一个子子问题时都重新计算，避免了不必要的计算工作。</p><h2 id="动态规划题目的特点"><a href="#动态规划题目的特点" class="headerlink" title="动态规划题目的特点"></a>动态规划题目的特点</h2><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855834.png" alt="img"></h3><h2 id="从「钱」讲起"><a href="#从「钱」讲起" class="headerlink" title="从「钱」讲起"></a>从「钱」讲起</h2><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855346.png" alt="image-20220115172412260"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855201.png" alt="image-20220115172506732"></p><p>我们可以算一下，按照贪心算法的策略，我们先拿出3个最大面值的7，再拿出一个面值5然后就没有办法继续了。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855989.png" alt="image-20220115173020707"></p><p>这里就有问题了,贪心算法的弊端在这种特殊面值钱币面前展露无疑,原因就在于「只顾眼前，无大局观」，在先拿出最大的 7 面值的硬币后就彻底把周旋余地堵死了,因为剩下的 21 要想凑足付出的代价是非常高的,我们需要依次拿出4个面值为2的硬币。</p><h2 id="改进计算策略"><a href="#改进计算策略" class="headerlink" title="改进计算策略"></a>改进计算策略</h2><p>那么既然贪心算法已经不适用于这种场景了,我们应该如何改变计算策略呢?</p><p>当我们面试过程中遇到这种问题时,如果一时没有思路,也要想到一种万能算法—暴力破解。</p><p>我们分析一下上述题目,它的问题其实是「给定一组面额的硬币,我们用现有的币值凑出27最少需要多少个币」。</p><ul><li>那么假设最后一个硬币为a[k]的话，那么剩下27 - a[k]，这个时候问题又变成了，我们凑出 27 - a[k]最少需要多少个币</li></ul><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855018.png" alt="image-20220115180634272"></p><p>问题可以不断被分解为「我们用现有的币值凑出 n 最少需要多少个币」,比如我们用 f(n) 函数代表 「凑出 n 最少需要多少个币」.</p><p>把「原有的大问题逐渐分解成类似的但是规模更小的子问题」这就是最优子结构,我们可以通过自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><p>这个时候我们分别假设 2、5、7 三种面值的币分别为最后一个硬币的情况：</p><ul><li>最后一枚硬币的面额为 7: min = f(20) + 1</li><li>最后一枚硬币的面额为 5: min = f(22) + 1</li><li>最后一枚硬币的面额为 2: min = f(25) + 1</li></ul><p>这个时候大家发现问题所在了吗?最少找零 min 与 <code>f(20)、f(22)、f(25)</code> 三个函数解中的最小值是有关的，毕竟后面的「+1」是大家都有的。</p><p>假设凑的硬币总额为 n，那么  <code>f(20) = f(n-7)</code>、<code>f(22) = f(n-5)</code>、<code>f(25) = f(n-2)</code>，我们得出以下公式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = min&#123;f(n-2), f(n-5), f(n-7)&#125; + 1</span><br></pre></td></tr></table></figure><p>我们再具体到上面公式中 <code>f(n-1)</code> 凑够它的最小硬币数量是多少,是不是又变成下面这个公式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n-1) = min&#123;f(n-2-1), f(n-1-5), f(n-1-7)&#125; + 1</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855787.jpg" alt="image-20220115193905486"></p><p>这真是似曾相识,这不就是递归吗?</p><p>是的,我们可以通过递归来求出最少找零问题的解,代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f(n) &#123;</span><br><span class="line">    if(n === 0) return 0</span><br><span class="line">    let min = Infinity</span><br><span class="line">    if (n &gt;= 2) &#123;</span><br><span class="line">        min = Math.min(f(n-2) + 1, min)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (n &gt;= 5) &#123;</span><br><span class="line">        min = Math.min(f(n-5) + 1, min)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (n &gt;= 7) &#123;</span><br><span class="line">        min = Math.min(f(n-7) + 1, min)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(f(27)) // 4</span><br></pre></td></tr></table></figure><h2 id="递归的弊端"><a href="#递归的弊端" class="headerlink" title="递归的弊端"></a>递归的弊端</h2><p>我们看似已经把问题解决了,但是别着急,我们继续测试,当n=70的时候,我们测试要凑出这个数最少我们需要多少个硬币。</p><p>答案是10,但是我们的耗时如下:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855507.awebp" alt="2020-01-21-23-02-13"></p><p>如果n=270呢?在八代i7处理器和node.js 12.x版本的加持下我跑了这么长时间都没算出来:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855076.awebp" alt="2020-01-21-23-04-26"></p><p>当n=27000的时候,我们成功的爆栈了:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855407.awebp" alt="2020-01-21-23-05-56"></p><p>所以为什么会造成如此长的执行耗时?归根到底是递归算法的低效导致的,我们看如下图:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855583.awebp" alt="2020-01-21-23-12-00"></p><p>我们如果计算f(70)就需要分别计算最后一个币为2、5、7三种面值时的不同情况，而这三种不同情况作为子问题又可以被分解为三种情况，依次类推…这样的算法复杂度有 O(3ⁿ),这是极为低效的。</p><p>我们再仔细看图:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855664.awebp" alt="2020-01-21-23-17-13"></p><p>我们用红色标出来的都是相同的计算函数，比如有两个f(64)、f(58)、f(54)，这些都是重复的,这些只是我们整个计算体系下的冰山一角,我们还有非常多的重复计算没办法在图中展示出来。</p><p>可见我们重复计算了非常多的无效函数，浪费了算力,到底有多浪费我们已经从上面函数执行时间测试上有了一定的认识。</p><p>我们不妨再举一个简单的例子，比如我们要计算 「1 + 1 + 1 + 1 + 1 + 1 + 1 + 1」的和。</p><p>我们开始数数…,直到我们数出上面计算的和为 8，那么，我们再在上述 「1 + 1 + 1 + 1 + 1 + 1 + 1 + 1」 后面 「+ 1」，那么和是多少？</p><p>这个时候你肯定数都不会数，脱口而出「9」。</p><p>为什么我们在后面的计算这么快？是因为我们已经在大脑中记住了之前的结果 「8」，我们只需要计算「8 + 1」即可，这避免了我们重复去计算前面的已经计算过的内容。</p><p>我们用的递归像什么？像继续数「1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1」来计算出「9」，这是非常耗时的。</p><p>我们假设用 m 种面值的硬币凑 n 最少需要多少硬币，在上述问题下递归的时间复杂度是惊人的O(nᵐ),指数级的时间复杂度可以说是最差的时间复杂度之一了。</p><p>我们已经发现问题所在了,大量的重复计算导致时间复杂度奇高,我们必须想办法解决这个问题。</p><h2 id="备忘录与递归"><a href="#备忘录与递归" class="headerlink" title="备忘录与递归"></a>备忘录与递归</h2><p>既然已经知道存在大量冗余计算了,那么我们可不可以建立一个备忘录,把计算过的答案记录在备忘录中,再有我们需要答案的时候,我们去备忘录中查找,如果能查找到就直接返回答案,这样就避免了重复计算,这就是算法中典型的空间换时间的思维，我们用备忘录占用的额外内存换取了更高效的计算。</p><p>有了思路后,其实代码实现非常简单,我们只需要建立一个缓存备忘录,在函数内部校验校验是否存在在结果,如果存在返回即可。我们的执行时间只有:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191855404.awebp" alt="2020-01-22-09-52-37"></p><p>实际上利用备忘录来解决递归重复计算的问题叫做「记忆化搜索」。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191856918.awebp" alt="2020-01-21-23-17-13"></p><p>这个方法本质上跟回溯法的「剪枝」是一个目的，就是把上图中存在重复的节点全部剔除,只保留一个节点即可,当然上图没办法把所有节点全部展示出来,如果剔除全部重复节点最后只会留下线性的节点形式:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191856028.awebp" alt="2020-01-22-10-04-33"></p><p>这个带备忘录的递归算法时间复杂度只有O(n),已经跟动态规划的时间复杂度相差不大了。</p><p>那么这不就可以了吗？为什么还要搞动态规划？</p><p>还记得我们上面提到递归的另一大问题吗？</p><p>爆栈！</p><p>这是我们备忘录递归计算 <code>f(27000)</code> 的结果:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191856368.awebp" alt="2020-01-22-10-07-19"></p><p>编程语言栈的深度是有限的,即使我们进行了剪枝,在五位数以上的情况下就会再次产生爆栈的情况,这导致递归根本无法完成大规模的计算任务。</p><p>这是递归的计算形式决定的,我们这里的递归是「自顶向下」的计算思路，即从 <code>f(70) f(69)...f(1)</code> 逐步分解,这个思路在这里并不完全适用,我们需要一种「自底向上」的思路来解决问题。</p><p>「自底向上」就是 <code>f(1) ... f(70) f(69)</code>通过小规模问题递推来解决大规模问题,动态规划通常是用迭代取代递归来解决问题。</p><blockquote><p>「自顶向下」的思路在另一种算法思想中非常常见,那就是分治算法</p></blockquote><p>除此之外,递归+备忘录的另一个缺陷就是再没有优化空间了,因为在最坏的情况下，递归的最大深度是 n。</p><p>因此，我们需要系统递归堆栈使用 O(n) 的空间,这是递归形式决定的,而换成迭代之后我们根本不需要如此多的的储存空间,我们可以继续往下看。</p><h2 id="动态转移方程"><a href="#动态转移方程" class="headerlink" title="动态转移方程"></a>动态转移方程</h2><p>还记得上面我们利用备忘录缓存之后各个节点的形式是什么样的吗,我们把它这个「备忘录」作为一张表，这张表就叫做 DP table,如下:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191856193.awebp" alt="2020-01-22-22-06-59"></p><blockquote><p>注意: 上图中 <code>f[n]</code> 代表凑够 n 最少需要多少币的函数,方块内的数字代表函数的结果</p></blockquote><p>我们不妨在上图中找找规律?</p><p>我们观察<code>f[1]</code>: <code>f[1] = min(f[-1], f[-5], f[-7]) + 1</code></p><p>由于<code>f[-5]</code> 这种负数是不存在的,我们都设为正无穷大,那么<code>f[1] = 1</code>。</p><p>再看看<code>f[5]</code>: <code>f[1] = min(f[3], f[0], f[-2]) + 1</code>,这实际是在求<code>f[3] = Infinity、</code>f[0] = 0<code>、</code>f[-2]=Infinity<code>中最小的值即0，最后加上1，即1，那么</code>f[5] = 1`。</p><p>发现了吗？我们任何一个节点都可以通过之前的节点来推导出来，根本无需再做重复计算，这个相关的方程是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[n] = min(f[n-2], f[n-5], f[n-7]) + 1</span><br></pre></td></tr></table></figure><p>还记得我们提到的动态规划有更大的优化空间吗?递归+备忘录由于递归深度的原因需要 O(n) 的空间复杂度,但是基于迭代的动态规划只需要常数级别的复杂度。</p><p>看下图,比如我们求解 f(70),只需要前面三个解,即 <code>f(59)</code> <code>f(69)</code> <code>f(65)</code> 套用公式即可求得,那么 <code>f(0)f(1) ... f(58)</code> 根本就没有用了,我们可以不再储存它们占用额外空间,这就留下了我们优化的空间。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191856023.awebp" alt="2020-03-09-19-10-43"></p><p>上面的方程就是动态转移方程,而解决动态规划题目的钥匙也正是这个动态转移方程。</p><p>当然,如果你只推导出了动态转移方程基本上可以把动态规划题做出来了,但是往往很多人却做不对,这是为什么?这就得考虑边界问题。</p><h2 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h2><p>部分的边界问题其实我们在上面的部分已经给出解决方案了,针对这个找零问题我们有以下边界问题。</p><p><strong>处理f[n]中n为负数的问题</strong>: 针对这个问题我们的解决方案是凡是n为负数的情况,一律将<code>f[n]</code>视为正无穷大,因为正常情况下我们是不会有下角标为负数的数组的,所以其实 n 为负数的 <code>f[n]</code> 根本就不存在,又因为我们要求最少找零,为了排除这种不存在的情况,也便于我们计算,我们直接将其视为正无穷大,可以最大程度方便我们的动态转移方程的实现。</p><p><strong>处理f[n]中n为0的问题</strong>：<code>n=0</code> 的情况属于动态转移方程的初始条件,初始条件也就是动态转移方程无法处理的特殊情况,比如我们如果没有这个初始条件,我们的方程是这样的: <code>f[0] = min(f[-2], f[-5], f[-7]) + 1</code>,最小的也是正无穷大,这是特殊情况无法处理,因此我们只能人肉设置初始条件。</p><p>处理好边界问题我们就可以得到完整的动态转移方程了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[0] = 0 (n=0)</span><br><span class="line">f[n] = min(f[n-2], f[n-5], f[n-7]) + 1 (n&gt;0)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="找零问题完整解析"><a href="#找零问题完整解析" class="headerlink" title="找零问题完整解析"></a><a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fcoin-change%2F">找零问题完整解析</a></h2><p>那么我们再回到这个找零问题中,这次我们假设给出不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其实上面的找零问题就是我们一直处理的找零问题的通用化,我们的面额是定死的,即1、5、11，这次是不定的，而是给了一个数组 coins 包含了相关的面值。</p><p><strong>确定最优子结构:</strong> 最优子结构即原问题的解由子问题的最优解构成,我们假设最少需要k个硬币凑足总面额n,那么<code>f(n) = min&#123;f(n-cᵢ)&#125;</code>, <code>cᵢ</code> 即是硬币的面额。</p><p><strong>处理边界问题:</strong> 依然是老套路,当n为负数的时候,值为正无穷大,当n=0时,值也为0.</p><p><strong>得出动态转移方程</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[0] = 0 (n=0)</span><br><span class="line">f[n] = min(f[n-cᵢ]) + 1 (n&gt;0)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们总结一下学习历程：</p><ol><li>从贪心算法入手来解决找零问题，发现贪心算法并不是在任何情况下都能找到最优解</li><li>我们决定换一种思路来解决存在的问题，我们最终发现了关键点,即「最优子结构」</li><li>借助上面的两个发现，我们用递归的方式解决了最少找零问题</li><li>但是经过算法复杂度分析和实际测试，我们发现递归的方法效率奇低，我们必须用一种方法来解决当前问题</li><li>我们用备忘录+递归的形式解决了时间复杂度问题,但是自顶向下的思路导致我们无法摆脱爆栈的阴霾,我们需要一种「自底向上」的全新思路</li><li>我们通过动态转移方程以迭代的方式高效地解出了此题</li></ol><p>其实动态规划本质上就是被一再优化过的暴力破解,我们通过动态规划减少了大量的重叠子问题,此后我们讲到的所有动态规划题目的解题过程，都可以从暴力破解一步步优化到动态规划。</p><p>本文我们学习了动态规划到底是怎么来的，在此后的解题过程中我们如果没有思路可以在脑子里把这个过程再过一遍，但是我们之后的题解就不会再把整个过程走一遍了，而是直接用动态规划来解题。</p><p>可能你会问面试题这么多,到底哪一道应该用动态规划?如何判断?</p><p>其实最准确的办法就是看题目中的给定的问题，这个问题能不能被分解为子问题，再根据子问题的解是否可以得出原问题的解。</p><p>当然上面的方法虽然准确,但是需要一定的经验积累,我们可以用一个虽然不那么准确,但是足够简单粗暴的办法,如果题目满足以下条件之一,那么它大概率是动态规划题目:</p><ul><li>求最大值，最小值</li><li>判断方案是否可行</li><li>统计方案个数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC</title>
      <link href="/posts/183e2cbd.html"/>
      <url>/posts/183e2cbd.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="IOC简介"><a href="#IOC简介" class="headerlink" title="IOC简介"></a>IOC简介</h2><p>IOC全称为Invertuon Of Control，也就是控制反转。<br>控制反转是一种设计思想。而不是具体的技术。<br>IOC这种设计思想有很多方式实现，最常见的实现方式就是DI。</p><h2 id="DI简介"><a href="#DI简介" class="headerlink" title="DI简介"></a>DI简介</h2><p>DI的全称是Dependency Injection，也就是依赖注入，是IOC思想的一种实现。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>什么是依赖？看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">  public B b = new B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中就是A依赖B。<br>我再这里理解为，A对象里面持有B对象，如果B对象不存在，那么A就无法成立，所以是A对象依赖B。</p><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>什么是注入呢？看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">  public B b = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B &#123;&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  var a = new A();</span><br><span class="line">  var b = new B();</span><br><span class="line"></span><br><span class="line">  a.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出总共有两个对象，分别是a和b。可以看出现在的A对象是依赖B对象的。<br><strong>a.b=b;</strong>这句代码就是将b对象注入到a对象的b成员中。<br>有时候可以把注入就理解成设置值。<br>依赖注入也就是吧某个对象依赖的对象进行赋值。</p><h1 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h1><h2 id="QF中的IOC"><a href="#QF中的IOC" class="headerlink" title="QF中的IOC"></a>QF中的IOC</h2><p>QF是一种框架，是作者最近正在学习的一种框架，这个框架不要求会，我们就拿QF中的DI来进行详细的了解一下DI。<br>我们在使用DI方案的时候一般都离不开DI容器这个概念。育德时候DI容易也叫做IOC容器。就是：DIContainer 和 IOCContainer。<br>下面我们来看看QF中是如何使用IOC的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace QF.Master.Example</span><br><span class="line">&#123;    </span><br><span class="line"></span><br><span class="line">    public class ServiceA</span><br><span class="line">    &#123;</span><br><span class="line">        public void Say()</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;I am ServiceA:&quot; + this.GetHashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class IOCExample : MonoBehaviour </span><br><span class="line">    &#123;</span><br><span class="line">        // 声明为需要注入的对象</span><br><span class="line">        [Inject] </span><br><span class="line">        public ServiceA A &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        void Start () </span><br><span class="line">        &#123;</span><br><span class="line">            // 创建实例容器</span><br><span class="line">            var container = new QFrameworkContainer();</span><br><span class="line"></span><br><span class="line">            // 注册类型</span><br><span class="line">            container.Register&lt;ServiceA&gt;();</span><br><span class="line"></span><br><span class="line">            // 注入对象（会自动查找 Inject Atrributet的对象)</span><br><span class="line">            container.Inject(this);</span><br><span class="line"></span><br><span class="line">            // 注入之后，就可以直接使用 A 对象了</span><br><span class="line">            A.Say();        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是完整的案例，我们只要仔细看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建实例容器</span><br><span class="line">var container = new QFrameworkContainer();</span><br><span class="line"></span><br><span class="line">// 注册类型</span><br><span class="line">container.Register&lt;ServiceA&gt;();</span><br><span class="line"></span><br><span class="line">// 注入对象（会自动查找 Inject Atrributet的对象)</span><br><span class="line">container.Inject(this);</span><br><span class="line"></span><br><span class="line">// 注入之后，就可以直接使用 A 对象了</span><br><span class="line">A.Say();</span><br></pre></td></tr></table></figure><p>首先我们创建了一个容器，并且在容器里注册了一个ServiceA对象。这些其实都是可以自己写一个脚本进行封装的。<br>接下来我们来看注入：<strong>container.Inject(this);</strong>这句就是注入对象，注入的就是刚才注册的对象。<br>接下来我们就可以使用this对象里的ServiceA对象了，为啥注入到A对象了，这里是框架给设计好了，只要在对应的对象上面添加[Inject]就代表是需要注入的对象。注入的时候就会对其进行赋值。<br>我们可以看下面的图进行理解：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902943.png" alt="img"></p><p>这是QF框架中的使用方法，我们不用会这种方法，因为只是针对QF框架的，我们学习的是IOC的这种思想。</p><h2 id="DI容器的强大之处"><a href="#DI容器的强大之处" class="headerlink" title="DI容器的强大之处"></a>DI容器的强大之处</h2><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><p>一般情况下DI容器会提供如下的API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注册类型：Register&lt;TSource,TTarget&gt;</span><br><span class="line">注入:Inject(object obj)</span><br><span class="line">解析:Resolve&lt;T&gt;()</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>注册和注入在刚才代码中已经有体现了。<br>在 DI Container 中，Resolve 实际上是根据类型返回实例。<br>DI容器的职责很简单，就是管理依赖和注入依赖。<br>DI容器中的容器代表的就是存储依赖的容器，容器里面装的就是依赖。<br>一般的DI容器利用的其实就是Dictonary<Type,object>来作为核心数据结构。<br>根据Type就可以得到依赖的对象，然后通过Inject注入到对象中。</p><h3 id="强大之处"><a href="#强大之处" class="headerlink" title="强大之处"></a>强大之处</h3><p>有了单例这个工具，当我们需要写一个独立模块的时候，很容易用单例就实现了。而且通过单例（或静态类）实现的独立模块，与其他模块之间的交互会变得非常容易。<br>这种结构好于直接撸的结构，毕竟它有一定的扩展性（只需实现单例），维护性上也还可以（模块独立），但是它很容易达到瓶颈，尤其是当单例的数量逐渐随着项目变多的时候。<br>因为单例的获取是没有限制的，任何层级的代码都可以获取到任何层级的单例，如下图示：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902488.png" alt="img"></p><p>虽然我们在预定上分了很多层，但是当我们的模块数量超过一定数量时，约定就很难遵循，因为我们访问模块的时候就需要去看一遍层级的示意图：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902548.png" alt="img"></p><p>这就造成项目达到一定规模，约定就变成了限制，让我们很难遵循。<br>从约定上，来说，我们怎么约定都可以，而约定的图示，就是上边的图。那些分层都是一些抽象的概念，比如游戏流程、主逻辑层、业务模块、框架层、底层，这些都是约定的结构。一般都是存在于文档上，并不会通过技术手段表达。<br>而从技术限制这个角度来说，单例的访问是没有限制的，就算是用最佳实践，也是没有限制的。而且单例难以表达约定上的分层的那些概念，因为只要一个模块变成单例了，那么这个模块就在技术上失去了层次关系。<br>如下图：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902306.png" alt="img"></p><p>如图所示，在使用单例的时候蓝牙和商店模块就在同一层级了，就失去了层级的约定。<br>使用单例时，项目结构的设计非常依赖于约定（文档等等）。<br>在项目规模比较少的时候，是没问题的，因为模块数量也比较少，但是一旦项目规模变大，模块数量变多，那么约定就会越来越难以遵循，就会非常容易导致项目结构的崩溃。<br>这个时候，有一种很简单的解决方式，就是最顶层模块都用单例，然后一些底层的模块，作为顶层的成员变量，从而达到逻辑层无法直接访问底层模块，而是必须通过顶层模块间接地使用底层模块服务。<br>如下图：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902290.png" alt="img"></p><p>这样就解决了单例结构无法表达层级的问题，但是同时也失去了单例带来的种种好处，比如易扩展，维护性（模块独立）。<br>现在不容易扩展模块了，因为要扩展模块需要考虑依赖关系，也不容易维护了，因为模块不独立了。<br>而这里不容易维护指的是各个模块不容易单独维护了，但是整体项目会更容易维护。<br>接下来就体现DI Container 的作用了，它的出现可以让各个模块容易维护，也容易扩展，同时让整个项目也同样容易维护，而且可以通过技术限制来分担一部分约定。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>从上面解决单例问题的图我们可以看到，有大量的依赖关系，这个依赖关系我们可以理解成对象的持有或者变量。<br>就是因为这些依赖关系，造成了此结构的维护性和扩展性降低了。因为模块本身也是对象，对象就有声明周期，那么对象和是去new就很重要。<br>我们来看看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public  class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB ModuleB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ModuleB</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以知道ModuleA是依赖ModuleB，这样我们在使用ModuleA的时候要考虑A中ModuleB是不是有值。<br>创建ModuleB我们可以考虑在ModuleA内部创建和外部创建两种情况：</p><h3 id="在ModuleA内部创建"><a href="#在ModuleA内部创建" class="headerlink" title="在ModuleA内部创建"></a>在ModuleA内部创建</h3><p>看下列代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public  class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB ModuleB = new ModuleB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式也很简单，创建ModuleA的时候ModuleB一定被创建了，但是此时的ModuleB是比较难共用的。</p><h3 id="在ModuleA外部创建"><a href="#在ModuleA外部创建" class="headerlink" title="在ModuleA外部创建"></a>在ModuleA外部创建</h3><p>看下列代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  var moduleA = new ModuleA();</span><br><span class="line">  moduleA.ModuleB = new ModuleB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来没问题，因为在外部创建过程中，我们非常清晰地知道，moduleA.ModuleB 是有实例的。 但是我们看下在 ModuleA 内部使用 ModuleB 时的情况，代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB ModuleB;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  void XXX()</span><br><span class="line">  &#123;</span><br><span class="line">    ModuleB. // 在这里会想 ModuleB 到底有没有值？在哪里设置的值？</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看看单例的解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  void XXX()</span><br><span class="line">  &#123;</span><br><span class="line">    ModuleB.Instance.DoSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不用考虑ModuleB的创建过程。<br>现在这种结构就是有大量的依赖，不易维护不易扩展也都出现在这个依赖上，因为依赖要考虑依赖对象的创建过程。</p><h3 id="使用-DI-Container-管理依赖"><a href="#使用-DI-Container-管理依赖" class="headerlink" title="使用 DI Container 管理依赖"></a>使用 DI Container 管理依赖</h3><p>利用DI代码就变成下面的方式了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  [Inject]</span><br><span class="line">  public ModuleB ModuleB &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">  void XXX()</span><br><span class="line">  &#123;</span><br><span class="line">    ModuleB.DoSomeThing(); // 放心用，因为不用考虑依赖的创建过程。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要在启动程序的时候进行注册：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static QFrameworkContainer Container &#123;get;private set;&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  Container = new Contaner();</span><br><span class="line"></span><br><span class="line">  Container.Register&lt;ModuleB&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们在创建ModuleA的时候需要注入对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void MethodA()</span><br><span class="line">&#123;</span><br><span class="line">  App.Container.Inject(new ModuleA());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 DIContainer之后我们的结构就变成了下图所示：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191902598.png" alt="img"></p><p>我们只需要，在模块内部声明模块作为变量，而不需要考虑创建过程，这样就导致每个模块都是可独立测试的（易维护），而扩展一个模块，不需要用单例实现，而是注册到类型容器即可，扩展性比单例还容易。这就是 DI Container 的最核心的优势。</p><h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><p>我们来了解DIContainer 的一个基础知识：域</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>域这个概念我们在学习C#的时候接触过，域的俗称就是代码块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class A</span><br><span class="line">// 类范围内的域</span><br><span class="line">&#123;</span><br><span class="line">  public void Main()</span><br><span class="line">  // 方法范围内的域</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码的注释就可以看出，代码块其实就是域<br>C# 的域的特性就是内部的域中的代码可以调用外部域中的变量。</p><h2 id="DIContainer中的域"><a href="#DIContainer中的域" class="headerlink" title="DIContainer中的域"></a>DIContainer中的域</h2><p>首先我们要考虑一个问题，每次DIContainer在注入实例的时候，注入的是新的还是返回的同一个实例呢？<br>而这个问题所描述的行为指的是 DIContainer 的域。<br>我们来看看QF中是如何注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当注册依赖时，使用 Register&lt;Type&gt;() 方法时，每次注入都会创建新的实例。</span><br><span class="line">当注册依赖时，使用 RegisterInstance(object obj) 方法时，每次注入都会使用 obj 实例。</span><br></pre></td></tr></table></figure><p>我们来看看演示的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace QF.Master.Example</span><br><span class="line">&#123;</span><br><span class="line">    public class SomeService </span><br><span class="line">    &#123;</span><br><span class="line">        public void Description()</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;SomeService:&quot; + this.GetHashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class SomeObject</span><br><span class="line">    &#123;</span><br><span class="line">        public void Description()</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;SomeObject:&quot; + this.GetHashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class IOCScopeExample : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeObject ObjA &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeObject ObjB &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeObject ObjC &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeService ServiceA &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        [Inject]</span><br><span class="line">        public SomeService ServiceB &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        void Start () </span><br><span class="line">        &#123;</span><br><span class="line">            var container = new QFrameworkContainer();</span><br><span class="line"></span><br><span class="line">            // 每次注入都创建新的实例</span><br><span class="line">            container.Register&lt;SomeObject&gt;();</span><br><span class="line"></span><br><span class="line">            // 每次注入都使用同一个实例</span><br><span class="line">            container.RegisterInstance(new SomeService());</span><br><span class="line"></span><br><span class="line">            // 注入</span><br><span class="line">            container.Inject(this);</span><br><span class="line"></span><br><span class="line">            ObjA.Description();</span><br><span class="line">            ObjB.Description();</span><br><span class="line">            ObjC.Description();</span><br><span class="line">            ServiceA.Description();</span><br><span class="line">            ServiceB.Description();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看看运行的结果：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191903164.png" alt="img"></p><p>我们不难看到过 Register</p><p>() 注册的依赖，每次注入时创建新的实例，而通过 RegisterInstance(object obj) 注册的依赖，每次注入都返回同一个 obj 实例。<br>总结如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Register&lt;T&gt;，每次注入时创建新的实例。</span><br><span class="line">RegisterInstance(object obj)，每次注入时，返回同一个 obj 对象。</span><br></pre></td></tr></table></figure><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖倒置原则，即：Dependency Inversion Principle，很多时候缩写成 DIP。<br>这个原则包含了两个主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。</span><br><span class="line">抽象接口不应该依赖于实现，而实现依赖于抽象接口</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念"><a href="#高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念" class="headerlink" title="高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念"></a>高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念</h2><p>我们来拿一个司机开车的例子，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Driver</span><br><span class="line">&#123;</span><br><span class="line">  // 司机的职责是开车</span><br><span class="line">  public void Drive(Benz benz)</span><br><span class="line">  &#123;</span><br><span class="line">    benz.Run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Benz</span><br><span class="line">&#123;</span><br><span class="line">  public void Run()</span><br><span class="line">  &#123;</span><br><span class="line">    Debug.Log(&quot;奔驰汽车开始运行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  var lucas = new Driver();</span><br><span class="line">  var benz = new Benz();</span><br><span class="line"></span><br><span class="line">  lucas.Drive(benz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前A同学负责开发Driver类，B同学负责开发Benz类。这时候突然多了一个需求，那就是有一个同学的车换成了宝马，那我们需要重新创建一个BMW类。<br>然而因为A同学和B同学开发的类耦合性太强了，所以都需要重新改一下代码，这时候看看这句话：高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。这样我们把车和司机都依赖于抽象，更改后的代码是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Driver</span><br><span class="line">&#123;</span><br><span class="line">  // 司机的职责是开车</span><br><span class="line">  public void Drive(ICar car)</span><br><span class="line">  &#123;</span><br><span class="line">    car.Run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface ICar</span><br><span class="line">&#123;</span><br><span class="line">  void Run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//public class Benz : ICar</span><br><span class="line">//&#123;</span><br><span class="line">//  public void Run()</span><br><span class="line">//  &#123;</span><br><span class="line">//    Debug.Log(&quot;奔驰汽车开始运行&quot;)</span><br><span class="line">//  &#125;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">public class BMW : ICar</span><br><span class="line">&#123;</span><br><span class="line">  public void Run()</span><br><span class="line">  &#123;</span><br><span class="line">    Debug.Log(&quot;宝马汽车开始运行&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  var lucas = new Driver();</span><br><span class="line">  var bmw = new BMW();</span><br><span class="line"></span><br><span class="line">  lucas.Drive(bmw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，当更换车的时候，不需要修改高层的代码，只需要把车的类更换掉就行了。<br>实际上，要完全实现”高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念“这一个主题的话，Driver 类也应该抽象出来一个 IDriver，不过对于目前的结构来说没有必要。</p><h2 id="抽象接口不应该依赖于实现，而实现依赖于抽象接口"><a href="#抽象接口不应该依赖于实现，而实现依赖于抽象接口" class="headerlink" title="抽象接口不应该依赖于实现，而实现依赖于抽象接口"></a>抽象接口不应该依赖于实现，而实现依赖于抽象接口</h2><p>我们直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lucas = new Driver();</span><br><span class="line">ICar car = new BMW();</span><br><span class="line"></span><br><span class="line">lucas.Drive(car);</span><br></pre></td></tr></table></figure><p>其中的 ICar car = new BMW() 就实现了“实现依赖于抽象接口”这一主题。<br>依赖这个概念需要再次更新了，上文中说到司机需要车才能当好司机，所以司机依赖车，那么现在 BMW 需要实现 ICar 接口，才能正常使用，那么 BMW 类依赖 ICar 接口，（实现依赖抽象接口)。<br>实际上依赖倒置原则的两个主题都在说一件事情，两个类之间的交互通过抽象（接口、抽象类）来完成。<br>而通过一个抽象，可以将两个类的变化隔离。即 A 类修改或扩展甚至是替换都不影响 B，反过来也是如此。<br>通过依赖倒置原则可以提高整个系统的灵活性和扩展性还有维护性。</p><h1 id="通过DIContainer实现DIP"><a href="#通过DIContainer实现DIP" class="headerlink" title="通过DIContainer实现DIP"></a>通过DIContainer实现DIP</h1><p>我们这时候来想想，其实依赖也就等于需求了。<br>而 QF 中的 DIContainer 支持前两种依赖管理，而市面上有个 IOC 容器，叫做 Zenject，支持以上全部的依赖关系。</p><h2 id="DIContainer-中的接口依赖管理（QF）"><a href="#DIContainer-中的接口依赖管理（QF）" class="headerlink" title="DIContainer 中的接口依赖管理（QF）"></a>DIContainer 中的接口依赖管理（QF）</h2><p>在上文中，我们说过QF中的依赖注入的时候DIContainer提供了两个API，分别是Register 与 RegisterInstance，分别是注入的时候是新的还是说同一个。<br>实际上这两者都有一些重载，即支持接口依赖的注册。<br>多说无用，放出来代码大家来体会一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace QF.Master.Example</span><br><span class="line">&#123;</span><br><span class="line">    public interface ILoginService</span><br><span class="line">    &#123;</span><br><span class="line">        void Login();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class LoginService : ILoginService</span><br><span class="line">    &#123;</span><br><span class="line">        public void Login()</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;登录成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class IOCInterfaceExample : MonoBehaviour </span><br><span class="line">    &#123;</span><br><span class="line">        [Inject]</span><br><span class="line">        public ILoginService LoginService &#123;get;set;&#125;</span><br><span class="line"></span><br><span class="line">        void Start () </span><br><span class="line">        &#123;</span><br><span class="line">            var container = new QFrameworkContainer();</span><br><span class="line"></span><br><span class="line">            container.RegisterInstance&lt;ILoginService&gt;(new LoginService());</span><br><span class="line"></span><br><span class="line">            // Register 也支持注册接口依赖</span><br><span class="line">            //container.Register&lt;ILoginService,LoginService&gt;();</span><br><span class="line"></span><br><span class="line">            container.Inject(this);</span><br><span class="line"></span><br><span class="line">            LoginService.Login();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，代码中可以根据接口注入具体的实例，使脚本可以依赖 ILoginService 接口而不依赖于 LoginService 类。</p><h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>在上文我们已经了解了依赖倒置原则和依赖注入的方案。了解了上面两个概念。这样会让我们更容易了解控制反转。</p><h2 id="控制正转"><a href="#控制正转" class="headerlink" title="控制正转"></a>控制正转</h2><p>有反转就有正转，我们先来看看正转的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB B = new ModuleB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ModuleB</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是正转，就是依赖的对象在内部进行创建，其实这不叫正转，这是正常的控制过程。<br>控制的意思其实就是依赖的对象创建的过程。也就是上述代码中的B的创建控制过程。<br>正转的过程就是被依赖对象B的创建是由依赖对象A控制，谁依赖谁创建。<br>控制反转就好理解了，就是被依赖对象B的创建是由外部控制了，就不需要依赖对象A进行控制创建了。<br>控制反转代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleA</span><br><span class="line">&#123;</span><br><span class="line">  public ModuleB B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ModuleB</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">  var moduleA = new ModuleA();</span><br><span class="line">  // 对象创建过程由外部控制</span><br><span class="line">  moduleA.B = new ModuleB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制反转意思是类依赖对象创建的过程由外部控制，而不是在类内部控制。</strong></p><h1 id="依赖注入与控制反转"><a href="#依赖注入与控制反转" class="headerlink" title="依赖注入与控制反转"></a>依赖注入与控制反转</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">控制反转：依赖对象的创建过程交给外部控制。 </span><br><span class="line">依赖注入：依赖对象在外部进行设置。</span><br></pre></td></tr></table></figure><p>控制反转是设计原则，或者说是设计模式，而依赖注入是控制反转的具体实现。<br>控制反转的具体实现除了有常用的依赖注入还有一种方案叫依赖查找，这里我们不介绍。<br>控制反转和依赖注入有一些细微的差别，控制反转的重点在于依赖对象创建过程的控制，而依赖注入的重点在于依赖对象如何设置，实际上这两个概念都在说，依赖对象的创建和设置都在外边搞，不要在类内部搞。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOC </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/364ea8cc.html"/>
      <url>/posts/364ea8cc.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何正确使用设计模式？"><a href="#如何正确使用设计模式？" class="headerlink" title="如何正确使用设计模式？"></a>如何正确使用设计模式？</h2><p>设计模式要活学活用，不要生搬硬套。想要游刃有余地使用设计模式，需要打下牢固的程序设计语言基础、夯实自己的编程思想、积累大量的时间经验、提高开发能力。目的都是让程序低耦合，高复用，高内聚，易扩展，易维护。</p><h3 id="1-需求驱动"><a href="#1-需求驱动" class="headerlink" title="1. 需求驱动"></a>1. 需求驱动</h3><p>不仅仅是功能性需求，需求驱动还包括性能和运行时的需求，如软件的可维护性和可复用性等方面。设计模式是针对软件设计的，而软件设计是针对需求的，一定不要为了使用设计模式而使用设计模式，否则可能会使设计变得复杂，使软件难以调试和维护。</p><h3 id="2-分析成功的模式应用项目"><a href="#2-分析成功的模式应用项目" class="headerlink" title="2. 分析成功的模式应用项目"></a>2. 分析成功的模式应用项目</h3><p>对现有的应用实例进行分析是一个很好的学习途径，应当注意学习已有的项目，而不仅是学习设计模式如何实现，更重要的是注意在什么场合使用设计模式。</p><h3 id="3-充分了解所使用的开发平台"><a href="#3-充分了解所使用的开发平台" class="headerlink" title="3. 充分了解所使用的开发平台"></a>3. 充分了解所使用的开发平台</h3><p>设计模式大部分都是针对面向对象的软件设计，因此在理论上适合任何面向对象的语言，但随着技术的发展和编程环境的改善，设计模式的实现方式会有很大的差别。在一些平台下，某些设计模式是自然实现的。</p><p>不仅指编程语言，平台还包括平台引入的技术。例如，Java EE 引入了反射机制和依赖注入，这些技术的使用使设计模式的实现方式产生了改变。</p><h3 id="4-在编程中领悟模式"><a href="#4-在编程中领悟模式" class="headerlink" title="4. 在编程中领悟模式"></a>4. 在编程中领悟模式</h3><p>软件开发是一项实践工作，最直接的方法就是编程。没有从来不下棋却熟悉定式的围棋高手，也没有不会编程就能成为架构设计师的先例。掌握设计模式是水到渠成的事情，除了理论只是和实践积累，可能会“渐悟”或者“顿悟”。</p><h3 id="5-避免设计过度"><a href="#5-避免设计过度" class="headerlink" title="5.避免设计过度"></a>5.避免设计过度</h3><p>设计模式解决的是设计不足的问题，但同时也要避免设计过度。一定要牢记简洁原则，要知道设计模式是为了使设计简单，而不是更复杂。如果引入设计模式使得设计变得复杂，只能说我们把简单问题复杂化了，问题本身不需要设计模式。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。</p><p>这里的软件实体包括以下几个部分：</p><ol><li>项目中划分出的模块</li><li>类与接口</li><li>方法</li></ol><p>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><h3 id="开闭原则的作用"><a href="#开闭原则的作用" class="headerlink" title="开闭原则的作用"></a>开闭原则的作用</h3><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p><h4 id="1-对软件测试的影响"><a href="#1-对软件测试的影响" class="headerlink" title="1. 对软件测试的影响"></a>1. 对软件测试的影响</h4><p>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</p><h4 id="2-可以提高代码的可复用性"><a href="#2-可以提高代码的可复用性" class="headerlink" title="2. 可以提高代码的可复用性"></a>2. 可以提高代码的可复用性</h4><p>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</p><h4 id="3-可以提高软件的可维护性"><a href="#3-可以提高软件的可维护性" class="headerlink" title="3. 可以提高软件的可维护性"></a>3. 可以提高软件的可维护性</h4><p>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p><h3 id="开闭原则的实现方法"><a href="#开闭原则的实现方法" class="headerlink" title="开闭原则的实现方法"></a>开闭原则的实现方法</h3><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</p><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h3 id="里氏替换原则的作用"><a href="#里氏替换原则的作用" class="headerlink" title="里氏替换原则的作用"></a>里氏替换原则的作用</h3><p>里氏替换原则的主要作用如下。</p><ol><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它克服了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ol><h3 id="里氏替换原则的实现方法"><a href="#里氏替换原则的实现方法" class="headerlink" title="里氏替换原则的实现方法"></a>里氏替换原则的实现方法</h3><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>根据上述理解，对里氏替换原则的定义可以总结如下：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li></ul><p>通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁（Robert C.Martin）于 1996 年在 <a href="http://c.biancheng.net/cplus/">C++</a> Report 上发表的文章。</p><p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p><p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p><p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><h3 id="依赖、倒置原则的作用"><a href="#依赖、倒置原则的作用" class="headerlink" title="依赖、倒置原则的作用"></a>依赖、倒置原则的作用</h3><p>依赖倒置原则的主要作用如下。</p><ul><li>依赖倒置原则可以降低类间的耦合性。</li><li>依赖倒置原则可以提高系统的稳定性。</li><li>依赖倒置原则可以减少并行开发引起的风险。</li><li>依赖倒置原则可以提高代码的可读性和可维护性。</li></ul><h3 id="依赖倒置原则的实现方法"><a href="#依赖倒置原则的实现方法" class="headerlink" title="依赖倒置原则的实现方法"></a>依赖倒置原则的实现方法</h3><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><ol><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ol><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><ol><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li></ol><h3 id="单一职责原则的优点"><a href="#单一职责原则的优点" class="headerlink" title="单一职责原则的优点"></a>单一职责原则的优点</h3><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。</p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li><li>提高类的可读性。复杂性降低，自然其可读性会提高。</li><li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><h3 id="单一职责原则的实现方法"><a href="#单一职责原则的实现方法" class="headerlink" title="单一职责原则的实现方法"></a>单一职责原则的实现方法</h3><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。</p><p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><h3 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点"></a>接口隔离原则的优点</h3><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><h3 id="接口隔离原则的实现方法"><a href="#接口隔离原则的实现方法" class="headerlink" title="接口隔离原则的实现方法"></a>接口隔离原则的实现方法</h3><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。</p><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><h3 id="迪米特法则的优点"><a href="#迪米特法则的优点" class="headerlink" title="迪米特法则的优点"></a>迪米特法则的优点</h3><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p><ol><li>降低了类之间的耦合度，提高了模块的相对独立性。</li><li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li></ol><p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><h3 id="迪米特法则的实现方法"><a href="#迪米特法则的实现方法" class="headerlink" title="迪米特法则的实现方法"></a>迪米特法则的实现方法</h3><p>从迪米特法则的定义和特点可知，它强调以下两点：</p><ol><li>从依赖者的角度来说，只依赖应该依赖的对象。</li><li>从被依赖者的角度说，只暴露应该暴露的方法。</li></ol><p>所以，在运用迪米特法则时要注意以下 6 点。</p><ol><li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。</li><li>在对其他类的引用上，将引用其他对象的次数降到最低。</li><li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li><li>谨慎使用序列化（Serializable）功能。</li></ol><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><h3 id="合成复用原则的重要性"><a href="#合成复用原则的重要性" class="headerlink" title="合成复用原则的重要性"></a>合成复用原则的重要性</h3><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><h3 id="合成复用原则的实现方法"><a href="#合成复用原则的实现方法" class="headerlink" title="合成复用原则的实现方法"></a>合成复用原则的实现方法</h3><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p><div class="table-container"><table><thead><tr><th>设计原则</th><th>一句话归纳</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>降低维护带来的新风险</td></tr><tr><td>依赖倒置原则</td><td>高层不应该依赖低层，要面向接口编程</td><td>更利于代码结构的升级扩展</td></tr><tr><td>单一职责原则</td><td>一个类只干一件事，实现类要单一</td><td>便于理解，提高代码的可读性</td></tr><tr><td>接口隔离原则</td><td>一个接口只干一件事，接口要精简单一</td><td>功能解耦，高聚合、低耦合</td></tr><tr><td>迪米特法则</td><td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td><td>只和朋友交流，不和陌生人说话，减少代码臃肿</td></tr><tr><td>里氏替换原则</td><td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td><td>防止继承泛滥</td></tr><tr><td>合成复用原则</td><td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td><td>降低代码耦合</td></tr></tbody></table></div><p>实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</p><blockquote><p>记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p></blockquote><p>在程序设计时，我们应该将程序功能最小化，每个类只干一件事。若有类似功能基础之上添加新功能，则要合理使用继承。对于多方法的调用，要会运用接口，同时合理设置接口功能与数量。最后类与类之间做到低耦合高内聚。</p><h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><div class="table-container"><table><thead><tr><th>分类</th><th>设计模式</th><th>简述</th><th>一句话归纳</th><th>目的</th><th>生活案例</th></tr></thead><tbody><tr><td>创建型设计模式 （简单来说就是用来创建对象的）</td><td>工厂模式（Factory Pattern）</td><td>不同条件下创建不同实例</td><td>产品标准化，生产更高效</td><td>封装创建细节</td><td>实体工厂</td></tr><tr><td>单例模式（Singleton Pattern）</td><td>保证一个类仅有一个实例，并且提供一个全局访问点</td><td>世上只有一个我</td><td>保证独一无二</td><td>CEO</td><td></td></tr><tr><td>原型模式（Prototype Pattern）</td><td>通过拷贝原型创建新的对象</td><td>拔一根猴毛，吹出千万个</td><td>高效创建对象</td><td>克隆</td><td></td></tr><tr><td>建造者模式（Builder Pattern）</td><td>用来创建复杂的复合对象</td><td>高配中配和低配，想选哪配就哪配</td><td>开放个性配置步骤</td><td>选配</td><td></td></tr><tr><td>结构型设计模式 （关注类和对象的组合）</td><td>代理模式（Proxy Pattern）</td><td>为其他对象提供一种代理以控制对这个对象的访问</td><td>没有资源没时间，得找别人来帮忙</td><td>增强职责</td><td>媒婆</td></tr><tr><td>外观模式（Facade Pattern）</td><td>对外提供一个统一的接口用来访问子系统</td><td>打开一扇门，通向全世界</td><td>统一访问入口</td><td>前台</td><td></td></tr><tr><td>装饰器模式（Decorator Pattern）</td><td>为对象添加新功能</td><td>他大舅他二舅都是他舅</td><td>灵活扩展、同宗同源</td><td>煎饼</td><td></td></tr><tr><td>享元模式（Flyweight Pattern）</td><td>使用对象池来减少重复对象的创建</td><td>优化资源配置，减少重复浪费</td><td>共享资源池</td><td>全国社保联网</td><td></td></tr><tr><td>组合模式（Composite Pattern）</td><td>将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理</td><td>人在一起叫团伙，心在一起叫团队</td><td>统一整体和个体</td><td>组织架构树</td><td></td></tr><tr><td>适配器模式（Adapter Pattern）</td><td>将原来不兼容的两个类融合在一起</td><td>万能充电器</td><td>兼容转换</td><td>电源适配</td><td></td></tr><tr><td>桥接模式（Bridge Pattern）</td><td>将两个能够独立变化的部分分离开来</td><td>约定优于配置</td><td>不允许用继承</td><td>桥</td><td></td></tr><tr><td>行为型设计模式 （关注对象之间的通信）</td><td>模板模式（Template Pattern）</td><td>定义一套流程模板，根据需要实现模板中的操作</td><td>流程全部标准化，需要微调请覆盖</td><td>逻辑复用</td><td>把大象装进冰箱</td></tr><tr><td>策略模式（Strategy Pattern）</td><td>封装不同的算法，算法之间能互相替换</td><td>条条大道通罗马，具体哪条你来定</td><td>把选择权交给用户</td><td>选择支付方式</td><td></td></tr><tr><td>责任链模式（Chain of Responsibility Pattern）</td><td>拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</td><td>各人自扫门前雪，莫管他们瓦上霜</td><td>解耦处理逻辑</td><td>踢皮球</td><td></td></tr><tr><td>迭代器模式（Iterator Pattern）</td><td>提供一种方法顺序访问一个聚合对象中的各个元素</td><td>流水线上坐一天，每个包裹扫一遍</td><td>统一对集合的访问方式</td><td>逐个检票进站</td><td></td></tr><tr><td>命令模式（Command Pattern）</td><td>将请求封装成命令，并记录下来，能够撤销与重做</td><td>运筹帷幄之中，决胜千里之外</td><td>解耦请求和处理</td><td>遥控器</td><td></td></tr><tr><td>状态模式（State Pattern）</td><td>根据不同的状态做出不同的行为</td><td>状态驱动行为，行为决定状态</td><td>绑定状态和行为</td><td>订单状态跟踪</td><td></td></tr><tr><td>备忘录模式（Memento Pattern）</td><td>保存对象的状态，在需要时进行恢复</td><td>失足不成千古恨，想重来时就重来</td><td>备份、后悔机制</td><td>草稿箱</td><td></td></tr><tr><td>中介者模式（Mediator Pattern）</td><td>将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散</td><td>联系方式我给你，怎么搞定我不管</td><td>统一管理网状资源</td><td>朋友圈</td><td></td></tr><tr><td>解释器模式（Interpreter Pattern）</td><td>给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</td><td>我想说”方言“，一切解释权都归我</td><td>实现特定语法解析</td><td>摩斯密码</td><td></td></tr><tr><td>观察者模式（Observer Pattern）</td><td>状态发生改变时通知观察者，一对多的关系</td><td>到点就通知我</td><td>解耦观察者与被观察者</td><td>闹钟</td><td></td></tr><tr><td>访问者模式（Visitor Pattern）</td><td>稳定数据结构，定义新的操作行为</td><td>横看成岭侧成峰，远近高低各不同</td><td>解耦数据结构和数据操作</td><td>KPI考核</td><td></td></tr><tr><td></td><td>委派模式（Delegate Pattern）</td><td>允许对象组合实现与继承相同的代码重用，负责任务的调用和分配</td><td>这个需求很简单，怎么实现我不管</td><td>只对结果负责</td><td>授权委托书</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c# async/await</title>
      <link href="/posts/969b7c0d.html"/>
      <url>/posts/969b7c0d.html</url>
      
        <content type="html"><![CDATA[<p>Talk is cheap, Show you the code first！</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;111 balabala. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    AsyncMethod();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;222 balabala. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">AsyncMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ResultFromTimeConsumingMethod = TimeConsumingMethod();</span><br><span class="line">    <span class="built_in">string</span> Result = <span class="keyword">await</span> ResultFromTimeConsumingMethod + <span class="string">&quot; + AsyncMethod. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">    Console.WriteLine(Result);</span><br><span class="line">    <span class="comment">//返回值是Task的函数可以不用return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数就是一个耗时函数，可能是IO操作，也可能是cpu密集型工作。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">TimeConsumingMethod</span>()</span></span><br><span class="line">&#123;            </span><br><span class="line">    <span class="keyword">var</span> task = Task.Run(()=&gt; &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Helo I am TimeConsumingMethod. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Helo I am TimeConsumingMethod after Sleep(5000). My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello I am TimeConsumingMethod&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步方法的结构"><a href="#异步方法的结构" class="headerlink" title="异步方法的结构"></a>异步方法的结构</h2><p>上面是一个的使用<code>async/await</code>的例子（为了方便解说原理我才写的这样复杂的）。<br>使用<code>async/await</code>能非常简单的创建异步方法，防止耗时操作阻塞当前线程。<br>使用<code>async/await</code>来构建的异步方法，逻辑上主要有下面三个结构：</p><h3 id="调用异步方法"><a href="#调用异步方法" class="headerlink" title="调用异步方法"></a>调用异步方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;111 balabala. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    AsyncMethod();<span class="comment">//这个方法就是异步方法，异步方法的调用与一般方法完全一样</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;222 balabala. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：微软建议异步方法的命名是在方法名后添加Aysnc后缀，示例是我为了读起来方便做成了前缀，在真正构建异步方法的时候请注意用后缀。(好吧我承认是我忘记了，然后图片也都截好了再修改太麻烦了。。。。就懒得重新再修改了)</p><p>异步方法的返回类型只能是<code>void</code>、<code>Task</code>、<code>Task&lt;TResult&gt;</code>。示例中异步方法的返回值类型是<code>Task</code>。</p><p>另外，上面的AsyncMethod()会被编译器提示报警，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/871381-20181228114807481-1116809909-20211205214420768.png" alt="img"><br>因为是异步方法，所以编译器提示在前面使用<code>await</code>关键字，这个后面再说，为了不引入太多概念导致难以理解暂时就先这么放着。</p><h3 id="异步方法本体"><a href="#异步方法本体" class="headerlink" title="异步方法本体"></a>异步方法本体</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">AsyncMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ResultFromTimeConsumingMethod = TimeConsumingMethod();</span><br><span class="line">    <span class="built_in">string</span> Result = <span class="keyword">await</span> ResultFromTimeConsumingMethod + <span class="string">&quot; + AsyncMethod. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">    Console.WriteLine(Result);</span><br><span class="line">    <span class="comment">//返回值是Task的函数可以不用return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>async</code>来修饰一个方法，表明这个方法是异步的，声明的方法的返回类型必须为：<code>void</code>或<code>Task</code>或<code>Task&lt;TResult&gt;</code>。方法内部必须含有<code>await</code>修饰的方法，如果方法内部没有<code>await</code>关键字修饰的表达式，哪怕函数被<code>async</code>修饰也只能算作同步方法，执行的时候也是同步执行的。</p><p>被await修饰的只能是<code>Task</code>或者<code>Task&lt;TResule&gt;</code>类型，通常情况下是一个返回类型是<code>Task/Task&lt;TResult&gt;</code>的方法，当然也可以修饰一个<code>Task/Task&lt;TResult&gt;</code>变量，await只能出现在已经用async关键字修饰的异步方法中。上面代码中就是修饰了一个变量<code>ResultFromTimeConsumingMethod</code>。</p><p>关于被修饰的对象，也就是返回值类型是<code>Task</code>和<code>Task&lt;TResult&gt;</code>函数或者<code>Task/Task&lt;TResult&gt;</code>类型的变量：如果是被修饰对象的前面用<code>await</code>修饰，那么返回值实际上是<code>void</code>或者<code>TResult</code>（示例中<code>ResultFromTimeConsumingMethod</code>是<code>TimeConsumingMethod()</code>函数的返回值，也就是<code>Task&lt;string&gt;</code>类型，当<code>ResultFromTimeConsumingMethod</code>在前面加了<code>await</code>关键字后 <code>await ResultFromTimeConsumingMethod</code>实际上完全等于 <code>ResultFromTimeConsumingMethod.Result</code>）。如果没有<code>await</code>，返回值就是<code>Task</code>或者<code>Task&lt;TResult&gt;</code>。</p><h3 id="耗时函数"><a href="#耗时函数" class="headerlink" title="耗时函数"></a>耗时函数</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数就是一个耗时函数，可能是IO密集型操作，也可能是cpu密集型工作。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">TimeConsumingMethod</span>()</span></span><br><span class="line">&#123;            </span><br><span class="line">    <span class="keyword">var</span> task = Task.Run(()=&gt; &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Helo I am TimeConsumingMethod. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Helo I am TimeConsumingMethod after Sleep(5000). My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello I am TimeConsumingMethod&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数才是真正干活的（为了让逻辑层级更分明，我把这部分专门做成了一个函数，在后面我会精简一下直接放到异步函数中，毕竟活在哪都是干）。</p><p>在示例中是一个CPU密集型的工作，我另开一线程让他拼命干活干5s。如果是IO密集型工作比如文件读写等可以直接调用.Net提供的类库，对于这些类库底层具体怎么实现的？是用了多线程还是DMA？或者是多线程+DMA？这些问题我没有深究但是从表象看起来和我用Task另开一个线程去做耗时工作是一样的。</p><p><code>await</code>只能修饰<code>Task/Task&lt;TResult&gt;</code>类型，所以这个耗时函数的返回类型只能是<code>Task/Task&lt;TResult&gt;</code>类型。</p><p>总结：有了上面三个结构就能完成使用一次异步函数。</p><h2 id="async-await异步函数的原理"><a href="#async-await异步函数的原理" class="headerlink" title="async/await异步函数的原理"></a>async/await异步函数的原理</h2><p>在开始讲解这两个关键字之前,为了方便，对某些方法做了一些拆解，拆解后的代码块用代号指定：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191926902.png" alt="img"><br>上图对示例代码做了一些指定具体就是：</p><ul><li>Caller代表调用方函数，在上面的代码中就是button1_Click函数。</li><li>CalleeAsync代表被调用函数，因为代码中被调用函数是一个异步函数，按照微软建议的命名添加了Async后缀，在上面示例代码中就是AsyncMethod()函数。</li><li>CallerChild1代表调用方函数button1_Click在调用异步方法CalleeAsync之前的那部分代码。</li><li>CallerChild2代表调用方函数button1_Click在调用异步方法CalleeAsync之后的那部分代码。</li><li>CalleeChild1代表被调用方函数AsyncMethod遇到await关键字之前的那部分代码。</li><li>CalleeChild2代表被调用方函数AsyncMethod遇到await关键字之后的那部分代码。</li><li>TimeConsumingMethod是指被await修饰的那部分耗时代码（实际上我代码中也是用的这个名字来命名的函数）</li></ul><h3 id="示例代码的执行流程"><a href="#示例代码的执行流程" class="headerlink" title="示例代码的执行流程"></a>示例代码的执行流程</h3><p><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/871381-20181228102447984-1724889626-20211205214443093.png" alt="img"><br>为了方便观看我模糊掉了对本示例没有用的输出。<br>这里涉及到了两个线程，线程ID分别是1和3。</p><p>Caller函数被调用，先执行CallerChild1代码，这里是同步执行与一般函数一样，然后遇到了异步函数CalleeAsync。</p><p>在CalleeAsync函数中有await关键字，await的作用是打分裂点。</p><p>编译器会把整个函数（CalleeAsync）从这里分裂成两个函数。await关键字之前的代码作为一个函数（按照我上面定义的指代，下文中就叫这部分代码CalleeChild1）await关键字之后的代码作为一个函数（CalleeChild2）。</p><p>CalleeChild1在调用方线程执行（在示例中就是主线程Thread1），执行到await关键字之后，另开一个线程耗时工作在Thread3中执行，然后立即返回。这时调用方会继续执行下面的代码CallerChild2（注意是Caller不是Callee）。</p><p>在CallerChild2被执行期间，TimeConsumingMethod也在异步执行（可能是在别的线程也可能是CPU不参与操作直接DMA的IO操作）。</p><p>当TimeConsumingMethod执行结束后，CalleeChild2也就具备了执行条件，而这个时候CallerChild2可能执行完了也可能没有，由于CallerChild2与CalleeChild2都会在Caller的线程执行，这里就会有冲突应该先执行谁，编译器会在合适的时候在Caller的线程执行这部分代码。示意图如下：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191926902.png" alt="img"></p><p>请注意，CalleeChild2在上图中并没有画任何箭头，因为这部分代码的执行是由编译器决定的，暂时无法具体描述是什么时候执行。</p><p>总结一下：</p><p>整个流程下来，除了TimeConsumingMethod函数是在Thread3中执行的，剩余代码都是在主线程Thread1中执行的.</p><p>也就是说异步方法运行在当前同步上下文中，只有激活的时候才占用当前线程的时间，异步模型采用时间片轮转来实现（这一点我没考证，仅作参考）。</p><p>你也许会说，明明新加了一个Thread3线程怎么能说是运行在当前的线程中呢？这里说的异步方法运行在当前线程上的意思是由CalleeAsync分裂出来的CalleeChild1和CalleeChild2的确是运行在Thread1上的。</p><h2 id="带返回值的异步函数"><a href="#带返回值的异步函数" class="headerlink" title="带返回值的异步函数"></a>带返回值的异步函数</h2><p>之前的示例代码中异步函数是没有返回值的，作为理解原理足够了，但是在实际应用场景中，带返回值的应用才是最常用的。那么，上代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;111 balabala. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="keyword">var</span> ResultTask  = AsyncMethod();</span><br><span class="line">    Console.WriteLine(ResultTask.Result);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;222 balabala. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">AsyncMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ResultFromTimeConsumingMethod = TimeConsumingMethod();</span><br><span class="line">    <span class="built_in">string</span> Result = <span class="keyword">await</span> ResultFromTimeConsumingMethod + <span class="string">&quot; + AsyncMethod. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">    Console.WriteLine(Result);</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数就是一个耗时函数，可能是IO操作，也可能是cpu密集型工作。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">TimeConsumingMethod</span>()</span></span><br><span class="line">&#123;            </span><br><span class="line">    <span class="keyword">var</span> task = Task.Run(()=&gt; &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Helo I am TimeConsumingMethod. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Helo I am TimeConsumingMethod after Sleep(5000). My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello I am TimeConsumingMethod&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要更改的地方在这里：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191926246.png" alt="img"><br>按理说没错吧？然而，这代码一旦执行就会卡死。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>是的，死锁。分析一下为什么：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191926066.png" alt="img"></p><p>按照之前我划定的代码块指定，在添加了新代码后CallerChild2与CalleeChild2的划分如上图。</p><p>这两部分代码块都是在同一个线程上执行的，也就是主线程Thread1，而且通常情况下CallerChild2是会早于CalleeChild2执行的(毕竟CalleeChild2得在耗时代码块执行之后执行)。</p><p><code>Console.WriteLine(ResultTask.Result);</code>(CallerChild2)其实是在请求CalleeChild2的执行结果，此时明显CalleeChild2还没有结束没有return任何结果，那<code>Console.WriteLine(ResultTask.Result);</code>就只能阻塞Thread1等待，直到CalleeChild2有结果。</p><p>然而问题就在这，CalleeChild2也是在Thread1上执行的，此时CallerChild2一直占用Thread1等待CalleeChild2的结果，耗时程序结束后轮到CalleeChild2执行的时候CalleeChild2又因Thread1被CallerChild2占用而抢不到线程，永远无法return，那么CallerChild2就会永远等下去，这就造成了死锁。</p><p>解决办法有两种一个是把<code>Console.WriteLine(ResultTask.Result);</code>放到一个新开线程中等待(个人觉得这方法有点麻烦，毕竟要新开线程)，还有一个方法是把Caller也做成异步方法：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191926554.png" alt="img"><br>ResultTask.Result变成了ResultTask 的原因上面也说了，await修饰的<code>Task/Task&lt;TResult&gt;</code>得到的是TResult。</p><p>之所以这样就能解决问题是因为嵌套了两个异步方法，现在的Caller也成了一个异步方法，当Caller执行到await后直接返回了（await拆分方法成两部分），CalleeChild2执行之后才轮到Caller中await后面的代码块（<code>Console.WriteLine(ResultTask.Result);</code>）。</p><p>另外，把Caller做成异步的方法也解决了一开始的那个警告，还记得么？<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191926714.png" alt="img"></p><h2 id="这样没省多少事啊？"><a href="#这样没省多少事啊？" class="headerlink" title="这样没省多少事啊？"></a>这样没省多少事啊？</h2><p>到现在，你可能会说：使用<code>async/await</code>不比直接用Task.Run()来的简单啊？比如我用<code>Task</code>的<code>TaskContinueWith</code>方法也能实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> ResultTask = Task.Run(()=&gt; &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Helo I am TimeConsumingMethod. My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Helo I am TimeConsumingMethod after Sleep(5000). My Thread ID is :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello I am TimeConsumingMethod&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ResultTask.ContinueWith(OnDoSomthingIsComplete);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDoSomthingIsComplete</span>(<span class="params">Task&lt;<span class="built_in">string</span>&gt; t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Action action = () =&gt; &#123;</span><br><span class="line">        textBox1.Text = t.Result;</span><br><span class="line">    &#125;;</span><br><span class="line">    textBox1.Invoke(action);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Continue Thread ID :&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，上面的代码也能实现。但是，<code>async/await</code>的优雅的打开方式是这样的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> t = Task.Run(() =&gt; &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello I am TimeConsumingMethod&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    textBox1.Text = <span class="keyword">await</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没，惊不惊喜，意不意外，寥寥几行就搞定了，不用再多写那么多函数，使用起来也很灵活。最让人头疼的跨线程修改控件的问题完美解决了，再也不用使用Invoke了，因为修改控件的操作压根就是在原来的线程上做的，还能不阻塞UI。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#反射机制</title>
      <link href="/posts/c758ede5.html"/>
      <url>/posts/c758ede5.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-反射机制"><a href="#C-反射机制" class="headerlink" title="C#反射机制"></a>C#反射机制</h2><p>资料转载自知乎:<a href="https://zhuanlan.zhihu.com/p/41282759">https://zhuanlan.zhihu.com/p/41282759</a></p><h3 id="何为反射"><a href="#何为反射" class="headerlink" title="何为反射?"></a><strong>何为反射?</strong></h3><p>首先我们通过两个实例来说明反射的大体概念。</p><p>B超:大家体检的时候大概都做过B超,B超可以透过肚皮探测到你内脏的生理情况。这是如何做到的呢?B超是B型超声波,它可以透过肚皮通过向你体内发射B型超声波,当超声波遇到内脏壁的时候就会产生一定的“回音”反射,然后把“回音”进行处理就可以显示出内脏的情况了。</p><p>地球内部结构:地球的内部结构大体可以分为三层:地壳、地幔和地核。如何在地球表面不用深入地球内部就知道其内部的构造呢?我们可以向地球发射“地震波”,“地震波”分两种一种是“横波”,另一种是“纵波”。“横波”只能穿透固体,而“纵波”既可穿透固体又可以穿透液体。通过在地面对纵波和横波的反回情况,我们就可以大体断定地球内部的构造了。</p><p>大家注意到这两个例子的共同特点,就是从一个对象的外部去了解对象内部的构造,而且都是利用了波的反射功能。在.NET中的反射也可以实现从对象的外部来了解对象(或程序集)内部结构的功能,哪怕你不知道这个对象(或程序集)是个什么东西,另外.NET中的反射还可以运态创建出对象并执行它其中的方法。</p><p>反射是.NET中的重要机制,通过反射,可以在运行时获得程序或程序集中每一个类型(包括类、结构、委托、接口和枚举等)的成员和成员的信息。有了反射,即可对每一个类型了如指掌。另外我还可以直接创建对象,即使这个对象的类型在编译时还不知道。</p><p>为什么使用反射,而不直接引用它的dll或者类型呢?</p><p>例如你有个main.exe,需要使用say.dll,draw.dll,突然客户说我们要添加一个跑的功能,那么只需要按照我们约定的规则做一个run的dll,之前的main.exe不需要做任何修改(就是不需要再去导入run.dll,其中需要其他的设计来规范),在main.exe中就能直接使用run.dll了。</p><p>其实,我们已经在不自觉地使用它了,举个最简单的例子,当你在VS的设计器里拖入一个控件后,设计器会通过反射获取这个控件的属性,并提供你进行设置。那么,问题来了,为什么要用反射呢?因为设计器在做的时候,根本不可能预知将来有什么控件会被你拖入进去。</p><h3 id="反射的用途简要介绍"><a href="#反射的用途简要介绍" class="headerlink" title="反射的用途简要介绍"></a><strong>反射的用途简要介绍</strong></h3><p>反射的用途大体总结如下,我们会在下面详细的进行介绍。<br>(1)使用Assembly定义和加载程序集,加载在程序集清单中列出模块,以及从此程序集中查找类型并创建该类型的实例。<br>(2)使用Module了解包含模块的程序集以及模块中的类等,还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。<br>(3)使用ConstructorInfo了解构造函数的名称、参数、访问修饰符(如pulic 或private)和实现详细信息(如abstract或virtual)等。<br>(4)使用MethodInfo了解方法的名称、返回类型、参数、访问修饰符(如pulic 或private)和实现详细信息(如abstract或virtual)等。<br>(5)使用FiedInfo了解字段的名称、访问修饰符(如public或private)和实现详细信息(如static)等,并获取或设置字段值。<br>(6)使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等,添加或移除事件处理程序<br>(7)使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等,获取或设置属性值。<br>(8)使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数,以及参数在方法签名中的位置等。</p><p>反射用到的主要类:</p><p>System.Type 类—通过这个类可以访问任何给定数据类型的信息。<br>System.Reflection.Assembly类—它可以用于访问给定程序集的信息,或者把这个程序集加载到程序中。<br>System.Type类:System.Type 类对于反射起着核心的作用。但它是一个抽象的基类,Type有与每种数据类型对应的派生类,我们使用这个派生类的对象的方法、字段、属性来查找有关该类型的所有信息。获取给定类型的Type引用有3种常用方式:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924905.jpg" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924797.jpg" alt="img"></p><h3 id="Type类的属性"><a href="#Type类的属性" class="headerlink" title="Type类的属性:"></a><strong>Type类的属性:</strong></h3><p>Name 数据类型名</p><p>FullName 数据类型的完全限定名(包括命名空间名)<br>Namespace 定义数据类型的命名空间名<br>IsAbstract 指示该类型是否是抽象类型</p><p>IsArray 指示该类型是否是数组</p><p>IsClass 指示该类型是否是类<br>IsEnum 指示该类型是否是枚举<br>IsInterface 指示该类型是否是接口<br>IsPublic 指示该类型是否是公有的<br>IsSealed 指示该类型是否是密封类<br>IsValueType 指示该类型是否是值类型</p><h3 id="Type类的方法"><a href="#Type类的方法" class="headerlink" title="Type类的方法:"></a><strong>Type类的方法:</strong></h3><p>GetConstructor(), GetConstructors():返回<br>ConstructorInfo类型,用于取得该类的构造函数的信息<br>GetEvent(), GetEvents():返回EventInfo类型,用于取得该类的事件的信息<br>GetField(), GetFields():返回FieldInfo类型,用于取得该类的字段(成员变量)的信息<br>GetInterface(), GetInterfaces():返回InterfaceInfo类型,用于取得该类实现的接口的信息<br>GetMember(), GetMembers():返回MemberInfo类型,用于取得该类的所有成员的信息<br>GetMethod(), GetMethods():返回MethodInfo类型,用于取得该类的方法的信息<br>GetProperty(), GetProperties():返回PropertyInfo类型,用于取得该类的属性的信息可以调用这些成员,其方式是调用Type的InvokeMember()方法,或者调用MethodInfo, PropertyInfo和其他类的Invoke()方法。</p><h3 id="反射的具体使用"><a href="#反射的具体使用" class="headerlink" title="反射的具体使用"></a><strong>反射的具体使用</strong></h3><p>(1)我们首先定义一个类用来测试反射</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924938.jpg" alt="img"></p><p>该类就是一个普通的类,我们下面就使用它测试反射的各种常见操作。</p><p>(2)查看类中的构造方法<br>我们可以根据对象进而查看内部的构造函数以及参数。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924955.jpg" alt="img"></p><p>(3)用构造函数动态生成对象<br>我们使用构造函数动态创建一个新的对象,如下代码所示:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924817.jpg" alt="img"></p><p>(4) 用Activator生成对象</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925381.jpg" alt="img"></p><p>上面代码中,Activator.CreateInstance第一个参数为需要创建对象的类型,后面的为调用构造函数的参数,上面的三种格式都可以,只是调用的构造函数不同而已。</p><p>(5)查看类中的属性</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925621.jpg" alt="img"></p><p>(6)查看类中的public方法</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925591.jpg" alt="img"></p><p>(7)查看类中的public字段</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925222.jpg" alt="img"></p><p>(8)用反射生成对象,并调用属性、方法和字段进行操作</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925479.jpg" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925822.jpg" alt="img"></p><p>(9)System.Reflection.Assembly介绍<br>Assembly类可以获得程序集的信息,也可以动态的加载程序集,</p><p>以及在程序集中查找类型信息,并创建该类型的实例。使用Assembly类可以降低程序集之间的耦合,有利于软件结构的合理化。通过程序集名称返回Assembly对象</p><p>Assembly ass = Assembly.Load(“ClassLibrary831”);</p><p>通过DLL文件名称返回Assembly对象</p><p>Assembly ass =<br>Assembly.LoadFrom(“ClassLibrary831.dll”);</p><p>通过Assembly获取程序集中类</p><p>Type t = ass.GetType(“ClassLibrary831.NewClass”);</p><p>//参数必须是类的全名<br>通过Assembly获取程序集中所有的类</p><p>Type[] t = ass.GetTypes();</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925413.jpg" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925330.jpg" alt="img"></p><p>(10)System.Reflection.Assembly使用</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925424.jpg" alt="img"></p><p>(11)反射当前项目中的类</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925461.jpg" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925748.jpg" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191925631.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习-C# 3.0</title>
      <link href="/posts/8bf2423b.html"/>
      <url>/posts/8bf2423b.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-3-0-版本"><a href="#C-3-0-版本" class="headerlink" title="C# 3.0 版本"></a>C# 3.0 版本</h2><p>C# 3.0 新增的语法特性，如下:</p><ul><li>自动实现的属性</li><li>匿名类型</li><li>查询表达式（LINQ）</li><li>表达式</li><li>表达式树</li><li>扩展方法</li><li>隐式类型本地变量</li><li>分部方法</li><li>对象和集合初始值设定项</li></ul><h2 id="自动实现属性"><a href="#自动实现属性" class="headerlink" title="自动实现属性"></a>自动实现属性</h2><p>这个特性非常简单，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PropertyExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// C# 3.0之前</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> mNickName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> NickName</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> mNickName; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; mNickName = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C# 3.0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单，看代码就懂了。</p><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p>代码也很简单，如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> &#123;Title = <span class="string">&quot;Name&quot;</span>&#125;;</span><br><span class="line">Debug.Log(person.Title);</span><br></pre></td></tr></table></figure><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>lambda 表达式非常简单，就是匿名方法的一种表现，如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LambdaExpressionExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// C# 1.0</span></span><br><span class="line">        Action action1 = <span class="keyword">new</span> Action(Func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// C# 2.0 </span></span><br><span class="line">        Action actionB = <span class="built_in">delegate</span> &#123;  &#125;;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// C# 3.0</span></span><br><span class="line">        Action acionC = () =&gt; &#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h2><p>表达式树实际上是 Expression 这个 API 的使用，先看下代码，如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq.Expressions;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExpressionTreeExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建表达式树  </span></span><br><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt; expr = num =&gt; num &lt; <span class="number">5</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 将表达式树编译为一个委托  </span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; result = expr.Compile();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 执行表达式树的委托</span></span><br><span class="line">Debug.Log(result(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// True</span></span><br></pre></td></tr></table></figure><p>通过表达式树可以构造一个委托出来，当执行委托的时候，就执行表达式树所表达的代码。</p><p>以上这段代码是通过 labmda 表达式来构建的表达式树，而最原始的表达式树的创建过程是通过 Expression 提供的 API，一个一个构建的，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq.Expressions;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExpressionTreeExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建一个 num 参数</span></span><br><span class="line"><span class="keyword">var</span> num = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个 常数 5</span></span><br><span class="line"><span class="keyword">var</span> five = Expression.Constant(<span class="number">5</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line"><span class="comment">// 创建一个表达式 num &lt; 5</span></span><br><span class="line"><span class="keyword">var</span> numLessThan5 = Expression.LessThan(num, five);</span><br><span class="line"><span class="comment">// 创建一个 labmda 表达式 (num)=&gt;num &lt; 5</span></span><br><span class="line"><span class="keyword">var</span> labmda = Expression.Lambda&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt;(numLessThan5, <span class="keyword">new</span> ParameterExpression[]</span><br><span class="line">&#123;</span><br><span class="line">num</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将表达式树编译为一个委托  </span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; result = labmda.Compile();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 执行表达式树的委托</span></span><br><span class="line">Debug.Log(result(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// True</span></span><br></pre></td></tr></table></figure><p>以上的构建过程同 lambda 形式的构建过程。</p><p>表达式树非常适合做方法参数的验证等工作。</p><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>扩展方法也非常简单，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StaticExtensionsExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.Show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 定义</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 需要是静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MonoExtensions</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;self&quot;&gt;</span>需要有 this 关键字<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">this</span> MonoBehaviour self</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">self.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="隐式类型本地变量"><a href="#隐式类型本地变量" class="headerlink" title="隐式类型本地变量"></a>隐式类型本地变量</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StaticExtensionsExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 隐式 （使用 var)</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 显式</span></span><br><span class="line"><span class="built_in">int</span> age2 = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StaticExtensionsExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> TestPartialMethod();</span><br><span class="line"></span><br><span class="line">obj.Click();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">TestPartialMethod</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Click</span>()</span>&#123; OnClick();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 不能有访问权限,实际上是 private 权限</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">OnClick</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">TestPartialMethod</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">OnClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">&quot;OnClick&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// OnClick</span></span><br></pre></td></tr></table></figure><h2 id="对象和集合初始值设定项"><a href="#对象和集合初始值设定项" class="headerlink" title="对象和集合初始值设定项"></a>对象和集合初始值设定项</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InitialExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> SomeClass() &#123;Age = <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> students = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123;<span class="string">&quot;凉鞋&quot;</span>, <span class="string">&quot;匠人&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;Apple&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;B&quot;</span>, <span class="string">&quot;Banana&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展方法-1"><a href="#扩展方法-1" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>因为扩展方法是 C# 的特色概念，也就是说 C# 有，但是别的语言没有（最近用于 Flutter 的 Dart 支持了扩展方法）。</p><p>这样就导致了很多在 C# 容易做的事情，在别的语言中就变得非常困难。</p><p>扩展方法可以让我们对现有的对象增加方法，而不用去修改对象类的代码、编译等。</p><p>扩展方法本质上是一个静态方法。</p><p>在 C# 中，最常见的扩展方法就是 LINQ 。</p><p>对于 Unity 开发者来说，第一次接触扩展方法，应该是在使用 DOTween 的时候。</p><p>DOTween 的示例代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), <span class="number">2</span>)</span><br><span class="line">  .SetEase(Ease.OutQuint)</span><br><span class="line">  .SetLoops(<span class="number">4</span>)</span><br><span class="line">  .OnComplete(myFunction);</span><br></pre></td></tr></table></figure><p>当然不用扩展方法，也是可以做到以上这样的链式编程的，但是有了扩展方法，会更容易实现链式的 API 的，可以让每个类各司其职。</p><h3 id="传统用法：扩展对象的方法"><a href="#传统用法：扩展对象的方法" class="headerlink" title="传统用法：扩展对象的方法"></a>传统用法：扩展对象的方法</h3><p>通过再封装的方式重命名 Unity 的 API，比如:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">BehaviourExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">Show</span>(<span class="params"><span class="keyword">this</span> GameObject selfObj</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            selfObj.SetActive(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> selfObj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Show</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T selfComponent</span>) <span class="keyword">where</span> T : Component</span></span><br><span class="line">        &#123;</span><br><span class="line">            selfComponent.gameObject.Show();</span><br><span class="line">            <span class="keyword">return</span> selfComponent;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方式:</span></span><br><span class="line"><span class="comment">// this.Show(); // this 是 MonoBehaivour</span></span><br></pre></td></tr></table></figure><h3 id="基础的链式-API"><a href="#基础的链式-API" class="headerlink" title="基础的链式 API"></a>基础的链式 API</h3><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExtensionsExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用扩展方法的方式定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExtensionsExample <span class="title">SayHello</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExtensionsExample <span class="title">SayGoodBye</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">&quot;Goodbye&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.SayHello()</span><br><span class="line">.DoSomething()</span><br><span class="line">.SayGoodBye();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展方法的方式定义</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MonoExtensions</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 使用泛型约束</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;self&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">DoSomething</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T self</span>) <span class="keyword">where</span> T : MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">self.name = <span class="string">&quot;DoSomething&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链式的 API 的核心就是返回自己（return this），可以把写死，也可以用泛型约束做成稍微通用一点的链式 API。</p><h3 id="Fluent-API"><a href="#Fluent-API" class="headerlink" title="Fluent API"></a>Fluent API</h3><p>Fluent API，流式的 API，或者说有阶段的 API。</p><p>其实以上的两种扩展方法使用方式都属于 Fluent API 范畴，只不过这些 API 还不够 Fluent。</p><p>Fluent API 是两个老外提出的。</p><p>有阶段的链式 API，举个例子。代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStageStart</span> : <span class="title">IStageA</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStageA</span> : <span class="title">IStageB</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStageB</span> : <span class="title">IStageBase</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStageBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecuteStage</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StageExtensions</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IStageA <span class="title">EnterStageA</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T self</span>) <span class="keyword">where</span> T : IStageStart</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IStageB <span class="title">EnterStageB</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T self</span>) <span class="keyword">where</span> T : IStageA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExtensionsExample</span> : <span class="title">MonoBehaviour</span>, <span class="title">IStageStart</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.EnterStageA()</span><br><span class="line">.EnterStageB()</span><br><span class="line">.ExecuteStage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.EnterStageB()</span><br><span class="line">.ExecuteStage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ExecuteStage();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个会报编译错误 因为顺序不对</span></span><br><span class="line"><span class="comment">// this.ExecuteStage()</span></span><br><span class="line"><span class="comment">// .EnterStageB(); </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExecuteStage</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心就是通过泛型约束和接口的继承，来强制让 API 按照一定顺序的调用。</p><h2 id="查询表达式（LINQ"><a href="#查询表达式（LINQ" class="headerlink" title="查询表达式（LINQ)"></a>查询表达式（LINQ)</h2><p>查询表达式是用上了之后会离不开的一个特性，它主要做的一个事情就是对数据集合的查询。</p><p>我们看下示例代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LINQExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> students = <span class="keyword">new</span> List&lt;Student&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">new</span> Student() &#123;Name = <span class="string">&quot;凉鞋&quot;</span>, Age = <span class="number">18</span>&#125;,</span><br><span class="line"><span class="keyword">new</span> Student() &#123;Name = <span class="string">&quot;hor&quot;</span>, Age = <span class="number">16</span>&#125;,</span><br><span class="line"><span class="keyword">new</span> Student() &#123;Name = <span class="string">&quot;天赐&quot;</span>, Age = <span class="number">17</span>&#125;,</span><br><span class="line"><span class="keyword">new</span> Student() &#123;Name = <span class="string">&quot;阿三&quot;</span>, Age = <span class="number">18</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.基本的遍历</span></span><br><span class="line">students.ForEach(s =&gt; Debug.Log(s.Name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.基本的条件过滤（Age &gt; 5)</span></span><br><span class="line">students.Where(s =&gt; s.Age &gt; <span class="number">5</span>)</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(s =&gt; Debug.Log(s.Name));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与以上代码等价</span></span><br><span class="line">(<span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line"><span class="keyword">where</span> s.Age &gt; <span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> s)</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(s =&gt; Debug.Log(s.Name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.基本的变换（student 转换成 name）</span></span><br><span class="line">students.Select(s =&gt; s.Name)</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(name =&gt; Debug.Log(name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与以上代码等价</span></span><br><span class="line">(<span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line"><span class="keyword">select</span> s.Name)</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(name =&gt; Debug.Log(name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.基本的分组（使用学生的名字分组）</span></span><br><span class="line">students.GroupBy(s =&gt; s.Name)</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(<span class="keyword">group</span> =&gt; Debug.Log(<span class="keyword">group</span>.Count()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与以上代码等价</span></span><br><span class="line">(<span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line"><span class="keyword">group</span> s <span class="keyword">by</span> s.Name)</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(<span class="keyword">group</span> =&gt; Debug.Log(<span class="keyword">group</span>.Count()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等等</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LINQ 这个东西，很重要也很有用，它的理念是函数式编程，底层实现类似于上一篇文章的阶段性链式 API，不过比接口继承 + 泛型约束的方式更复杂一些。</p><p>理解 LINQ 是学习 UniRx 的基础，也是使用 .Net Core 的 Entity Framework Core 的基础。</p><p>LINQ 有各个语言的版本，如果做前端，那么 linq.js 是数据查询的必备的一个库。</p><h3 id="LINQ-扩展"><a href="#LINQ-扩展" class="headerlink" title="LINQ 扩展"></a>LINQ 扩展</h3><ul><li>LINQ = IEnumerable + Operator + foreach/ForEach/Single/First/ToList/ToDictionary/ToHashSet等等</li></ul><p>IEnumerable 实际上就是集合，C# 中的 Array、Dictionary、List、Stack、Queue 都是集合，都是可以用 LINQ 的。</p><p>Operator 是操作符：比如 Where、Select、GroupBy、Distinct 都是操作符。</p><p>而以上公式的第三个部分就是具体的操作了，一般情况下，经过 LINQ 操作符操作后得到的是一个集合，这个集合可以直接用 foreach 进行遍历，也可以转换成 List 或则 Dictionary 等数据结构。</p><p>如果想要从头到尾只用一行代码，那么就可以直接 ToList ，然后调用 List 的 ForEach，笔者在上一小节的示例代码就是这么做的。</p><p>主要记住这个核心，那么剩下的就只需要去一个个掌握 操作符（Operator）就可以了。</p><p>具体的每个操作符是什么意思可以看下微软的官方文档，如下:</p><ul><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/linq/">LINQ 教程</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.enumerable.aggregate?view=netframework-3.5">Enumerable 方法(操作符大全)</a></li></ul><p>进入操作符大全之后具体看这里即可:<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191929871.png" alt="image.png"><br>一个个点进去，就能看到每个 API 的简介和示例了。</p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>LINQ 的底层实现主要用了以下特性:</p><ul><li>扩展方法</li><li>泛型约束</li><li>表达式树（源码中，没有看到表达式树相关的 API，但是微软的表达式树文档上说 表达式树是 LINQ 的基础）</li></ul><p>而 LINQ 的两个核心接口是，IEnumerable 和 IEnumerator。</p><p>所有的集合都实现了 IEnumerable，比如 List、Dictinoary、Stack 等等。</p><p>所有的操作符都实现了 IEnumerator，比如 Where、Select、GroupBy 等等。</p><p>大部分操作符同时实现了 IEnumerable 和 IEnumurator，这样才可以对集合再进行一次操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>核心接口时 IEnumable 和 IEnumerator</li><li>使用的核心特性为 泛型约束 和 扩展方法</li><li><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191929281.png" alt="image.png"></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>C# 1.0 主要是让 C# 变成了一个合格的面向对象语言，在此之上还提供了委托 Attribute 特性，这两个特性一个是使 C# 朝着函数式编程的方向上发展，另一个则使 C# 可以对程序添加声明性信息，这时候已经有了 Attribute 和 反射 这一黄金搭档。</p><p>完全掌握 C# 1.0，算是对 C# 这门语言达到了入门程度了，这时候用 C# 写一些逻辑是没问题的，只不过实现业务会有点不方便，但是都可以写的，基本上 C# 1.0 所支持的特性是我们平时编程所使用到的大部分特性。</p><p>C# 2.0，主要提供了泛型和迭代器还有匿名方法，提供了泛型之后就需要支持协变和逆变，匿名方法的支持可以让 C# 的回调更加简洁(delegte {})。</p><p>完全掌握 C# 2.0 ，算是对 C# 这门语言达到了基础程度了，在写业务上不会遇到太大的语法特性问题。而 C# 2.0 中的的匿名方法和泛型的 API（比如 List<T>）在业务的开发上会用的比较多，而需要设计泛型 API 的地方一般都是比较偏底层的部分。</p><p>C# 3.0，主要提供了 LINQ 和 扩展方法，这两个算是革命性的特性，有了 LINQ 处理数据的代码就变得更加简洁精炼了，而有了扩展方法使得对系统的扩展能力大幅增强。</p><p>完全掌握 C# 3.0 ，已经算是进阶的使用者了，LINQ 虽然在 Unity 上使用会有点效率问题，但是整体上它的“函数式编程的思想“会根深蒂固地影响我们写的每一行代码，LINQ 大幅简化了我们对数据操作的代码，而扩展方法可以让我们可以写出更合理的代码。</p><p>大概就是这样的一个过程。</p><p>而之后 C# 4.0 到 C# 8.0（截止到 2020 年 1 月），只有一个比较重要的特性，就是 Task 以及 async 和 await 的关键字支持。</p><p>构建 C# 的知识体系，简单的版本如下:</p><p>C# 1.0:</p><ul><li>类（class）</li><li>结构（struct）</li><li>接口（interface）</li><li>事件（event）</li><li>属性（property）</li><li>委托（delegates）</li><li>表达式</li><li>语句</li><li>特性（有时候也叫属性）（Attribute）</li></ul><p>C# 2.0:</p><ul><li>泛型</li><li>分部类型（partial）</li><li>匿名方法</li><li>可以为 null 的值类型</li><li>迭代器</li><li>协变和逆变</li><li>getter/setter 单独可访问性</li><li>方法组转换（委托）</li><li>静态类</li><li>委托推断</li></ul><p>C# 3.0 :</p><ul><li>自动实现的属性</li><li>匿名类型</li><li>查询表达式（LINQ）</li><li>Lambda 表达式</li><li>表达式树</li><li>扩展方法</li><li>隐式类型本地变量</li><li>分部方法</li><li>对象和集合初始值设定项</li></ul><p>以上没有反射这个特性，因为反射不是特性而是 .Net 的 API，当然要支持反射，语言层面上也是要做一些支持的。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习-C# 2.0</title>
      <link href="/posts/cfb0.html"/>
      <url>/posts/cfb0.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-2-0-版本"><a href="#C-2-0-版本" class="headerlink" title="C# 2.0 版本"></a>C# 2.0 版本</h2><p>在 C# 2.0 版本提供的特性如下:</p><ul><li>泛型</li><li>分部类型（partial）</li><li>匿名方法</li><li>可以为 null 的值类型</li><li>迭代器</li><li>协变和逆变</li><li>getter/setter 单独可访问性</li><li>方法组转换（委托）</li><li>静态类</li><li>委托推断</li></ul><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191928011.png" alt="image.png"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>最常用的 List<T> 就是泛型的一个应用。</p><p>C# 文档地址：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/index">泛型</a></p><h3 id="泛型-API-的设计"><a href="#泛型-API-的设计" class="headerlink" title="泛型 API 的设计"></a>泛型 API 的设计</h3><p>要设计一个泛型 的 API 非常简单，看以下代码中的 GetTypeName 方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReflectionExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetTypeName</span>&lt;<span class="title">T</span>&gt;()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> type.Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(GetTypeName&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果:</span></span><br><span class="line"><span class="comment">// String</span></span><br></pre></td></tr></table></figure><p>泛型可以把一个类或者一个方法，当做一个模板，而这个模板所需要填充的内容则是定义的各种类型，所以泛型可以最大限度地实现代码的复用。</p><h3 id="C-什么要实现泛型？"><a href="#C-什么要实现泛型？" class="headerlink" title="C# 什么要实现泛型？"></a>C# 什么要实现泛型？</h3><p>C# 实现泛型这个特性，肯定是为了解决开发者遇到的实际问题的，要想知道泛型具体解决了什么问题，那么就要回过头看看没实现泛型之前的 C# 语言有什么样的问题？</p><p>在 C# 实现泛型之前，我们只能使用 ArrayList 来充当不定长的数组。</p><p>而 ArrayList 所存储的元素都需要转换成 object 类型，其中也包括值类型，而值类型转换成 object 需要做装箱操作，这样会造成性能的消耗。</p><p>这是第一个问题，就是性能问题。</p><p>而 ArrayList 所存储的 object 类型，是类型不安全的，为什么说是类型不安全呢？</p><p>因为，ArrayList 可以存储任何类型，可以同时存储 int 和 string 甚至是自己创建的对象，也就是说你从 ArrayList 中拿到一个元素，那么这个元素的类型是不确定的，没有约束的。</p><p>那么有没有什么方式避免 ArrayList 存储值类型造成的性能消耗么，同时也能约束存储的类型。</p><p>答案就是泛型。</p><p>在 C# 添加了泛型这个特性之后，List<T> 就成为了 ArrayList 的替代，List<T> 不管是存储值类型还是引用类型，它的性能都是非常高的，而一旦确定了 T 是什么类型，那么 List 中只能添加类型为 T （或者继承于 T）的元素。</p><p>所以，泛型类型可以最大限度地重用代码之外，还可以保护类型安全性以及提高性能。</p><p>这就是泛型存在的意义。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191928908.png" alt="image.png"></p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>说到泛型，有一个重要的特性就是泛型约束。</p><p>先写一个泛型约束的示例，如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 只能获取值类型的名字</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetTypeName</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : <span class="keyword">struct</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> type.Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(GetTypeName&lt;<span class="built_in">int</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果:</span></span><br><span class="line"><span class="comment">// int</span></span><br></pre></td></tr></table></figure><p>在定义了 GetTypeName<T> 方法后，还加上了一个 where T : struct。</p><p>意思是给 T 类型必须要继承 struct，而只要继承了 struct 那么说明 T 类型是值类型。</p><p>在 C# 中 int、float 等都是值类型，所以就可以将 int 类型传给 GetTypeName<T> 中的 T。</p><p>在刚开始接触泛型的时候，觉得泛型用得不多，但是当写了很多通用工具后，发现泛型真的是一个很方便、易用的语言特性。</p><p>一般情况下，我们通过方法、类、继承的方式来达到代码的复用，但是加上了泛型之后，可以更进一步地达到代码的复用。</p><p>关于泛型约束更全面且深入地使用，建议阅读微软的官方指南:<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters">泛型约束</a></p><h3 id="泛型使用"><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h3><p>使用泛型这个概念比较多的地方是 一些底层的、通用的代码。</p><p>比如用来创建单例的模板，泛型这个概念一开始接触的时候会觉得非常复杂，但是一旦用它设计过几个通用工具后，就会觉得泛型是一个非常好用的<strong>设计工具</strong>。</p><p>在一般的项目开发的过程中，写界面逻辑 或者 游戏的业务逻辑时，基本上不需要我们去设计泛型的 API，但是像 List、Dictionary 等 .Net 提供的数据结构中，要求我们最起码要掌握泛型 API 的基本使用。</p><p>而如果我们在项目开发中负责写一些通用工具的时候，那么就有很大的概率需要我们自己设计泛型 API 了。</p><p>需要我们设计的泛型 API 的大致类型如下:</p><ul><li>泛型接口</li><li>泛型类</li><li>泛型方法</li><li>泛型委托</li><li>泛型的反射</li><li>等等</li></ul><p>像泛型委托、泛型的反射、泛型的方法 这些设计起来难度不是那么高。</p><p>而泛型类 和 泛型接口 则涉及到了 继承 的问题，那么理解起来可能会有一点难度。</p><p>这里举个例子，如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// T 要保证继承 Base&lt;T&gt;</span></span><br><span class="line"><span class="comment">// T 是泛型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Base</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Base</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        T Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 SameClass 里 T 就是 SomeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span> : <span class="title">Base</span>&lt;<span class="title">SomeClass</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> SomeClass Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这段代码，算是泛型 API 设计中比较绕的设计方式了，如果能看懂那是最好了，如果看不懂也没关系，因为这样的代码一般都是出现在一些框架或者库的底层。</p><p>如果你打算自己写一个框架或者库，那么泛型部分最起码要能够自己写出来以上这样的代码才行。</p><h3 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h3><p>先看如下代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这样写是合法的（但是性能很差）</span></span><br><span class="line">BaseClass[] baseClass = <span class="keyword">new</span> SubClass[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样是会报编译错误的 </span></span><br><span class="line">            <span class="comment">// 因为 List&lt;BaseClass&gt; 不是 List&lt;SubClass&gt; 的父类</span></span><br><span class="line">            <span class="comment">// 它们是两个完全不同的类型</span></span><br><span class="line">List&lt;BaseClass&gt; baseClasses = <span class="keyword">new</span> List&lt;SubClass&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 SubClass 继承了 BaseClass，在 Awake 方法中，用父类的数组变量接收子类的数组是没问题的。</p><p>但是用父类的 List 接收子类的数组就会报编译错误，这是泛型的一个设计问题。</p><p>不过我们换一种写法，缺没什么问题，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 合法的协变 C# 4.0 之前，支持的简单协变</span></span><br><span class="line">IEnumerable&lt;BaseClass&gt; baseClassesA = <span class="keyword">new</span> SubClass[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法的协变 C# 4.0 之前，支持的简单协变</span></span><br><span class="line">IEnumerable&lt;BaseClass&gt; baseClassesB = <span class="keyword">new</span> List&lt;BaseClass&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// C# 4.0 后这样写是合法的,也是协变</span></span><br><span class="line">IEnumerable&lt;BaseClass&gt; baseClassesC = <span class="keyword">new</span> List&lt;SubClass&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么以上的代码是合法的呢，其实原因非常简单，因为 IEnumerable 是只读的，也就是说我们不可以为 IEnumerable 添加数据。而次要的原因是 List 和 Array 都实现了 IEnuemrable 接口，而 SubClass 继承了 BaseClass，这些共同的条件才可以允许协变的发生。</p><p>那么在 C# 中，如何确保 IEnumerable 是只读的呢？非常简单，只需要在泛型定义上加上 out 关键字即可，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"><span class="comment">// C# 4.0 之后的 iEnumerable 定义</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">System.Collections.Generic</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span>&lt;[<span class="title">Nullable</span>(2)] <span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">  &#123;</span><br><span class="line">    [<span class="meta">NullableContext(1)</span>]</span><br><span class="line">    <span class="function">IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 C# 4.0 之前的定义如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">System.Collections.Generic</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 C# 4.0 之前，没有加上 out 关键字，那么协变就无法在 IEnumerable 和 List 之间发生。<br>这就是泛型的协变的作用。</p><p>想自己实现一个也非常简单，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Base</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sub</span>&lt;<span class="title">T</span>&gt; : <span class="title">Base</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 完全合法 发生了协变</span></span><br><span class="line">Base&lt;<span class="built_in">object</span>&gt; baseObject = <span class="keyword">new</span> Sub&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，关于协变就介绍到这里，接下来介绍逆变。</p><h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>理解了协变，逆变就更容易被理解了。</p><p>逆变只需要用 in 关键字，来标记父接口的类型是只写的。</p><p>具体的示例代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 用 in 表示只写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Base</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">T Value &#123; <span class="keyword">set</span>; &#125; <span class="comment">// 不能声明 get</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sub</span>&lt;<span class="title">T</span>&gt; : <span class="title">Base</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> T Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 完全合法</span></span><br><span class="line">Base&lt;<span class="built_in">string</span>&gt; baseObject = <span class="keyword">new</span> Sub&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">baseObject.Value = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看懂了，就算理解了逆变了。</p><p>这里总结一下：</p><ul><li>协变就是父接口的泛型是只读的，用 out 关键字修饰即可</li><li>逆变就是父接口的泛型是只写的，用 in 关键字修饰即可</li><li>如果无法确定父接口的泛型是只读和只写的，只能确保同泛型类型之间发生协变。比如:`IEnumerable<string> a = new List<string>();</li></ul><h2 id="分部类型-partial"><a href="#分部类型-partial" class="headerlink" title="分部类型 partial"></a>分部类型 partial</h2><p>分部类型可以把一个类的定义拆分到不同的文件中。</p><p>这样非常容易实现对类进行扩展的操作。</p><p>基本的使用方式如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要在同一个程序集中的同一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Partial</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 类名 和 访问权限 要完全一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PartialClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> A &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Partial</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 加上 abstract 关键字，那么 PartialClass 则变成抽象类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PartialClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> B &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>微软的官方文档说，partial 关键字设计的初衷则是为了把一个类的职责拆分给不同的开发者维护。</p><p>而现实情况则是，partial 关键字一般是用来给界面类拆分 View 和 Controller 的职责。</p><p>比如 Xamarin 的中一个界面的代码一般会分别写在两个文件中，即 SomeUI.cs 和 SomeUI.Designer.cs。</p><p>SomeUI.cs 中主要是提供给用户自己写逻辑用的，充当的是 Controller 的职责，而 SomeUI.Designer.cs 主要是提供一个 UI 元素的引用提供，充当的是 View 的职责，为什么拆分成两个文件呢？这是因为 SomeUI.Designer.cs 中的代码，完全是自动生成的。</p><p>大概代码如下:<br>SomeUI.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">SomeUI</span> : <span class="title">ViewController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SomeUI.Designer.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">SomeUI</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Bind</span>]</span><br><span class="line">    <span class="keyword">public</span> UIText Text;</span><br><span class="line">  </span><br><span class="line">    [<span class="meta">Bind</span>]</span><br><span class="line">    <span class="keyword">public</span> UIButton Button;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 partial 关键字比较常见的用法。</p><p>当然还有一些用法，像 UniRx 的 API 统一都是由 Observable 静态类提供的，而 UniRx 有大量的操作符和事件源的 API，那么都写在一个 Observable 静态类中那是不现实的，所以作者用 partial 关键字把 Observable 静态类拆分到了几个文件中，这样情况就好多了。</p><p>大概用法如下:<br>Observable.XXX.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">partial</span> Observable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IObserver&lt;TSource&gt; <span class="title">Create</span>()</span> &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observable.YYY.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">partial</span> Observable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IObserver&lt;TSource&gt; <span class="title">Timer</span>()</span> &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 partial 关键字的另一个用法就是拆分 API 的定义。</p><h2 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h2><p>C# 2.0 中的匿名方法写法如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DelegateExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> Action&lt;<span class="built_in">int</span>&gt; OnValueChanged;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// C# 1.0 中 委托只能注册方法</span></span><br><span class="line">OnValueChanged = OnSomeValueChanged;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C# 2.0 中 委托支持了匿名方法（）</span></span><br><span class="line">OnValueChanged = <span class="built_in">delegate</span>(<span class="built_in">int</span> <span class="keyword">value</span>) &#123; Debug.Log(<span class="keyword">value</span>); &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnSomeValueChanged</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单，匿名方法就不多说了。</p><h2 id="可以为-null-的值类型"><a href="#可以为-null-的值类型" class="headerlink" title="可以为 null 的值类型"></a>可以为 null 的值类型</h2><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NullableValueTypeExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span>? number = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，可以为 null 的值类型，我们在 Unity 开发中用得非常少。</p><p>值类型和引用类型相比，有一个不太方便的地方就是值类型的变量，比较难以判断是否进行过初始化。而引用类型则比较容易，如果值为 null，说明未初始化。</p><p>而有了可空值类型这个特性，就比容易判断一个 number 是否是初始化过了。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是非常重要的一个 C# 特性。</p><p>Coroutine、LINQ、甚至是 UniRx 的实现都是以迭代器为基础的。</p><p>那么什么是 C# 中的迭代器呢？</p><p>我们先看一个示例，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IEnumerableExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> <span class="title">GetSomeValue</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerable <span class="title">GetSomeValue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><p>其中 GetSomeValue 叫做迭代器方法，GetSomeValue 中写了 yield return 这样的语句。</p><p>从以上代码中的输出结果，就可以猜到 GetSomeValue 具体做了什么事情，在 foreach 遍历时，每次遍历获取到的 value 值，就是 GetSomevalue 中返回的值。</p><p>换一个角度，我们可以把 GetSomeValue 的返回 IEnumerable 当做一个 int 数组，数组中的值分别是 1，2，3，这样的话就比较容易理解了。</p><p>我们来介绍下 GetSomeValue 还可以返回哪些类型的参数，如下:</p><ul><li>IEnumerable</li><li>IEnumerator</li><li>IEnumerable<T></li><li>IEnumerator<T></li></ul><p>示例代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IEnumerableExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> <span class="title">GetSomeValue</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">GetSomeValue2</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> <span class="title">GetSomeValue3</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">GetSomeValue4</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerable <span class="title">GetSomeValue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GetSomeValue2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 只要有 GetEnumerator 方法就可以用 foreach 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetSomeValue3</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GetSomeValue4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 只要有 GetEnumerator 方法就可以用 foreach 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">int</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5 </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 7 </span></span><br><span class="line"><span class="comment">// 8 </span></span><br><span class="line"><span class="comment">// 9 </span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h3 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h3><blockquote><p>在不知道集合内部细节的情况下，提供一个按序方法存取的一个对象集合体的每一个单元。—GoF<br>提供一种方法顺序访问一个集合对象中的各个元素，又不暴露该对象的内部表示</p></blockquote><p>迭代器模式由于经常使用到，已经被 .Net 收录到 API 中。</p><p>在 C# 中，经常使用泛型存储对象，当想按序存取这些泛型容器时，都会使用 C# 的 foreach 语句。</p><p>foreach 语句就是一个能顺序访问一个集合的方法。<br>它就是 C# 语言内置的迭代器模式。</p><h3 id="如何使用-IEnumerable"><a href="#如何使用-IEnumerable" class="headerlink" title="如何使用 IEnumerable"></a>如何使用 IEnumerable</h3><p>在使用之前，我们先理解一下 IEnumerable。这里老师直接给一个比较容易记住的定义，IEnumerable 中文意思是 可枚举的，教练直接把他理解为 IForeachable（可遍历的），虽然定义不是很准确，但是在区分 IEnumerable 和 IEnumerator 时候很容易搞清楚。</p><p>我们直接看下 IEnumerable 的定义:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个接口告知调方对象的子项可以枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">IEnumerator <span class="title">GetEnumerator</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UniRxLesson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IEnumerableExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ForEachable</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">object</span>[] mObjArray = <span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">4</span>]</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mObjArray.GetEnumerator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> foreachAble = <span class="keyword">new</span> ForEachable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> foreachAble)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>只要实现一个 GetEnumerator 就可以使用 foreach 了。</p><h3 id="foreach-同等实现"><a href="#foreach-同等实现" class="headerlink" title="foreach 同等实现"></a>foreach 同等实现</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UniRxLesson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ForEachExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ForEachable</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">object</span>[] mObjArray = <span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">4</span>]</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mObjArray.GetEnumerator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> foreachAble = <span class="keyword">new</span> ForEachable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动与 IEnumerator 协作</span></span><br><span class="line"><span class="keyword">var</span> i = foreachAble.GetEnumerator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i.MoveNext())</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">var</span> number = i.Current;</span><br><span class="line">Debug.Log(number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>代码中出现的 MoveNext、Current 等 API 简单看下 IEnumerator 定义就清楚了。</p><h3 id="IEnumerator-定义"><a href="#IEnumerator-定义" class="headerlink" title="IEnumerator 定义"></a>IEnumerator 定义</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;             <span class="comment">//将游标的内部位置向前移动</span></span><br><span class="line"><span class="built_in">object</span> Current&#123;<span class="keyword">get</span>;&#125;         <span class="comment">//获取当前的项（只读属性）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>;                <span class="comment">//将游标重置到第一个成员前面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IEnuemrator-代码示例"><a href="#IEnuemrator-代码示例" class="headerlink" title="IEnuemrator 代码示例"></a>IEnuemrator 代码示例</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UniRxLesson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IEnumeratorExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">ForEachable</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FiveTimes();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">FiveTimes</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> mCount = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">mCount--;</span><br><span class="line"><span class="keyword">return</span> mCount &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">mCount = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="built_in">string</span>.Empty; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> foreachAble = <span class="keyword">new</span> ForEachable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> empty <span class="keyword">in</span> foreachAble)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// A</span></span><br></pre></td></tr></table></figure><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield 实质是一个语法糖，它让程序员能够更方便的去使用迭代器，通过 yield 你可以直接使用迭代器操作而不需要去实现 IEnumerable 和 IEnumerator，也不需要一个临时的 Collection 来完成迭代。</p><p>yield 有两种格式声明</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> &lt;expression&gt;;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p> yield 工作流程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UniRxLesson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">YieldExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> empty <span class="keyword">in</span> <span class="title">FiveTimes</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>  IEnumerable <span class="title">FiveTimes</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// A</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191928017.png" alt="image.png"></p><h2 id="getter-setter-单独可访问性"><a href="#getter-setter-单独可访问性" class="headerlink" title="getter/setter 单独可访问性"></a>getter/setter 单独可访问性</h2><p>getter/setter 单独可访问性，英文原文是 getter/setter seperate accessbility，翻译成人话应该是，gette/setter 的分别的访问权限。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PropertyExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> mAge = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mAge;    </span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 可以单独设置 setter 的访问权限</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span> </span><br><span class="line">        &#123;</span><br><span class="line">            mAge = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191928855.png" alt="image.png"></p><p>get 和 set 的访问器，可以有不同的访问权限。</p><h2 id="方法组转换（委托）"><a href="#方法组转换（委托）" class="headerlink" title="方法组转换（委托）"></a>方法组转换（委托）</h2><p>这个特性，直接看如下代码就懂了。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CSharpExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SomeDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SomeFunc</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Example</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// C# 1.0 只能这样写，要使用 new 关键字</span></span><br><span class="line">        SomeDelegate delegateA = <span class="keyword">new</span> SomeDelegate(SomeFunc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// C# 2.0 可以直接这样写 </span></span><br><span class="line">        SomeDelegate delegateB = SomeFunc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><p>静态类 与 非静态类唯一的区别就是 静态类不能实例化。</p><p>除了这个静态类是实现静态扩展方法的基础之一，不过静态扩展在 C# 3.0 才开始支持。</p><p>还有一个比较重要的一点就是静态构造方法。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SimpleClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">long</span> baseline;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">SimpleClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        baseline = DateTime.Now.Ticks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态构造函数在类的静态成员第一次访问或第一个类实例创建之前由系统调用</li></ul><p>在 Unity 中，静态构造函数调用时机一般是前者，也就是静态类中的成员被第一次访问的时候调用。</p><p>想了解更多静态构造跟多地特性，可以看 C# 官方文档：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/static-constructors"> 静态构造函数（C# 编程指南）</a></p><h2 id="委托推断"><a href="#委托推断" class="headerlink" title="委托推断"></a>委托推断</h2><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CSharpExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SomeDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SomeFunc</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Example</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// C# 1.0 只能这样写，要使用 new 关键字</span></span><br><span class="line">        SomeDelegate delegateA = <span class="keyword">new</span> SomeDelegate(SomeFunc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// C# 2.0 可以直接这样写 </span></span><br><span class="line">        SomeDelegate delegateB = SomeFunc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实和方法组转换的例子一模一样。</p><p>方法组转换的重点是方法组，方法组实际上就是方法名，可以把一个方法组直接设置给一个同类型同返回值的委托变量上，在这个直接设置值的过程中，方法组本身发生了方法组转换。</p><p>而委托推断意思就是，通过委托的返回值和参数去匹配方法组。</p><p>方法组转换和 委托推断共同可以实现以上的示例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>泛型：<ul><li>泛型约束：where</li><li>协变：父接口只读用 out T，父接口&lt;父类型&gt; = 子类&lt;\子类型&gt;</li><li>逆变：父接口只写用 in T。父接口&lt;子类型&gt; = 子类&lt;父类型&gt;</li></ul></li><li>分部类型：<ul><li>使用 partial 关键字将一个类的定义拆分到多个文件中（或者多个代码位置中）</li><li>用途：<ul><li>ViewController 中的 VIew 和 Controller 分别声明（代码生成部分和编程部分）</li><li>同一个类的 API 分别在不同的文件中声明</li><li>等等</li></ul></li></ul></li><li>匿名方法：<ul><li>delegate(int a )=&gt;{}</li></ul></li><li>可空值类型:<ul><li>int? a = null</li><li>笔者自己的理解就是为了比较方便地判断一个值类型是否进行过初始化</li></ul></li><li>迭代器:<ul><li>IEnumerable: 可以直接 foreach</li><li>IEnumerator：需要作为 GetEnumerator 的返回值时，可以对所在的对象 foreach</li><li>yield return：语法糖，通过生成代码来生成迭代器对象</li></ul></li><li>协变和逆变：在泛型中有介绍</li><li>getter/setter 可单独访问性：<ul><li>可以单独为 setter 或 getter 设置访问权限</li></ul></li><li>方法组转换、委托推断：<ul><li>del a = funcB</li><li>方法组就是方法名</li></ul></li><li>静态类<ul><li>不能创建实例的类</li><li>静态构造，在第一次访问时调用</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 高性能数组去重</title>
      <link href="/posts/ac7b046b.html"/>
      <url>/posts/ac7b046b.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、测试模版"><a href="#一、测试模版" class="headerlink" title="一、测试模版"></a><strong>一、测试模版</strong></h2><p>数组去重是一个老生常谈的问题，网上流传着有各种各样的解法</p><p>为了测试这些解法的性能，我写了一个测试模版，用来计算数组去重的耗时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// distinct.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">100000</span>), <span class="function">(<span class="params">x, index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">50000</span>), <span class="function">(<span class="params">x, index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index+index</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始数组去重&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="comment">// 数组去重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;去重后的长度&#x27;</span>, <span class="title function_">distinct</span>(arr1, arr2).<span class="property">length</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;耗时&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure><p>这里分别创建了两个长度为 10W 和 5W 的数组</p><p>然后通过 distinct() 方法合并两个数组，并去掉其中的重复项</p><p>数据量不大也不小，但已经能说明一些问题了</p><h2 id="二、Array-filter-indexOf"><a href="#二、Array-filter-indexOf" class="headerlink" title="二、Array.filter() + indexOf"></a><strong>二、Array.filter() + indexOf</strong></h2><p>这个方法的思路是，将两个数组拼接为一个数组，然后使用 ES6 中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">Array.filter()</a> 遍历数组，并结合 indexOf 来排除重复项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = a.<span class="title function_">concat</span>(b);</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我被吐槽的那个数组去重方法，看起来非常简洁，但实际性能。。。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191905590.png" alt="img"></p><p>是的，现实就是这么残酷，处理一个长度为 15W 的数组都需要 8427ms</p><h2 id="三、双重-for-循环"><a href="#三、双重-for-循环" class="headerlink" title="三、双重 for 循环"></a><strong>三、双重 for 循环</strong></h2><p>最容易理解的方法，外层循环遍历元素，内层循环检查是否重复</p><p>当有重复值的时候，可以使用 push()，也可以使用 splice()</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = a.<span class="title function_">concat</span>(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>, len=arr.<span class="property">length</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=i+<span class="number">1</span>; j&lt;len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">                arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一</span></span><br><span class="line">                len--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法占用的内存较高，效率也是最低的</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191905868.png" alt="img"></p><h2 id="四、for…of-includes"><a href="#四、for…of-includes" class="headerlink" title="四、for…of + includes()"></a><strong>四、for…of + includes()</strong></h2><p>双重for循环的升级版，外层用 for…of 语句替换 for 循环，把内层循环改为 includes()</p><p>先创建一个空数组，当 includes() 返回 false 的时候，就将该元素 push 到空数组中 </p><p>类似的，还可以用 indexOf() 来替代 includes()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = a.<span class="title function_">concat</span>(b)</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        !result.<span class="title function_">includes</span>(i) &amp;&amp; result.<span class="title function_">push</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法和 filter + indexOf 挺类似</p><p>只是把 filter() 的内部逻辑用 for 循环实现出来，再把 indexOf 换为 includes</p><p>所以时长上也比较接近</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191905065.png" alt="img"></p><h2 id="五、Array-sort"><a href="#五、Array-sort" class="headerlink" title="五、Array.sort()"></a><strong>五、Array.sort()</strong></h2><p>首先使用 sort() 将数组进行排序</p><p>然后比较相邻元素是否相等，从而排除重复项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = a.<span class="title function_">concat</span>(b)</span><br><span class="line">    arr = arr.<span class="title function_">sort</span>()</span><br><span class="line">    <span class="keyword">let</span> result = [arr[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>, len=arr.<span class="property">length</span>; i&lt;len; i++) &#123;</span><br><span class="line">        arr[i] !== arr[i-<span class="number">1</span>] &amp;&amp; result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法只做了一次排序和一次循环，所以效率会比上面的方法都要高</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191905801.png" alt="img"></p><h2 id="六、new-Set"><a href="#六、new-Set" class="headerlink" title="六、new Set()"></a><strong>六、new Set()</strong></h2><p>ES6 新增了 <a href="http://es6.ruanyifeng.com/#docs/set-map">Set</a> 这一数据结构，类似于数组，但 <strong>Set 的成员具有唯一性</strong></p><p>基于这一特性，就非常适合用来做数组去重了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那使用 Set 又需要多久时间来处理 15W 的数据呢？</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191905961.png" alt="img"></p><p>喵喵喵？？？ 57ms ？？我没眼花吧？？</p><p>然后我在两个数组长度后面分别加了一个0，在 150W 的数据量之下…</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191905032.png" alt="img"></p><p>居然有如此高性能且简洁的数组去重办法？！</p><h2 id="七、for…of-Object"><a href="#七、for…of-Object" class="headerlink" title="七、for…of + Object"></a><strong>七、for…of + Object</strong></h2><p>这个方法我只在一些文章里见过，实际工作中倒没怎么用</p><p>首先创建一个空对象，然后用 for 循环遍历</p><p>利用<strong>对象的属性不会重复</strong>这一特性，校验数组元素是否重复</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = a.<span class="title function_">concat</span>(b)</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj[i]) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(i)</span><br><span class="line">            obj[i] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我看到这个方法的处理时长，我又傻眼了</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191905183.png" alt="img"></p><p><strong>15W 的数据居然只要 16ms ？？？ 比 Set() 还快？？？</strong></p><p>然后我又试了试 150W 的数据量…</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191906118.png" alt="img"></p><p>emmmmmmm…. 惹不起惹不起…</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录</title>
      <link href="/posts/4067e4b.html"/>
      <url>/posts/4067e4b.html</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟手机验证：https-www-yima123-xyz"><a href="#虚拟手机验证：https-www-yima123-xyz" class="headerlink" title="虚拟手机验证：https://www.yima123.xyz/"></a>虚拟手机验证：<a href="https://www.yima123.xyz/">https://www.yima123.xyz/</a></h2><h2 id="壁纸网站：https-wallhaven-cc"><a href="#壁纸网站：https-wallhaven-cc" class="headerlink" title="壁纸网站：https://wallhaven.cc"></a>壁纸网站：<a href="https://wallhaven.cc">https://wallhaven.cc</a></h2><h2 id="翻墙软件：https-cylink-one"><a href="#翻墙软件：https-cylink-one" class="headerlink" title="翻墙软件：https://cylink.one"></a>翻墙软件：<a href="https://cylink.one">https://cylink.one</a></h2><h2 id="GitClone加速：gitclone-com"><a href="#GitClone加速：gitclone-com" class="headerlink" title="GitClone加速：gitclone.com"></a>GitClone加速：gitclone.com</h2><h2 id="图片压缩工具：https-pngquant-org"><a href="#图片压缩工具：https-pngquant-org" class="headerlink" title="图片压缩工具：https://pngquant.org"></a>图片压缩工具：<a href="https://pngquant.org">https://pngquant.org</a></h2><h2 id="动漫网站：https-www-agefans-vip"><a href="#动漫网站：https-www-agefans-vip" class="headerlink" title="动漫网站：https://www.agefans.vip"></a>动漫网站：<a href="https://www.agefans.vip">https://www.agefans.vip</a></h2><h2 id="ppt模板：https-www-canva-com"><a href="#ppt模板：https-www-canva-com" class="headerlink" title="ppt模板：https://www.canva.com"></a>ppt模板：<a href="https://www.canva.com">https://www.canva.com</a></h2><h2 id="图书（电子书）：https-singlelogin-me"><a href="#图书（电子书）：https-singlelogin-me" class="headerlink" title="图书（电子书）：https://singlelogin.me"></a>图书（电子书）：<a href="https://singlelogin.me">https://singlelogin.me</a></h2><h2 id="游戏下载（需翻墙）：https-byrut-org"><a href="#游戏下载（需翻墙）：https-byrut-org" class="headerlink" title="游戏下载（需翻墙）：https://byrut.org/"></a>游戏下载（需翻墙）：<a href="https://byrut.org/">https://byrut.org/</a></h2><h2 id="Unity资源下载：-https-unityassetcollection-com"><a href="#Unity资源下载：-https-unityassetcollection-com" class="headerlink" title="Unity资源下载： https://unityassetcollection.com/"></a>Unity资源下载： <a href="https://unityassetcollection.com/">https://unityassetcollection.com/</a></h2><h2 id="Mac软件下载：https-www-macyy-cn"><a href="#Mac软件下载：https-www-macyy-cn" class="headerlink" title="Mac软件下载：https://www.macyy.cn/"></a>Mac软件下载：<a href="https://www.macyy.cn/">https://www.macyy.cn/</a></h2><h2 id="Mac谷歌跨域浏览器："><a href="#Mac谷歌跨域浏览器：" class="headerlink" title="Mac谷歌跨域浏览器："></a>Mac谷歌跨域浏览器：</h2><p>open -n -a /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome —args —user-data-dir=”/tmp/chrome_dev_test” —disable-web-security</p>]]></content>
      
      
      <categories>
          
          <category> 闲言碎语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲言碎语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习-C# 1.0</title>
      <link href="/posts/88769655.html"/>
      <url>/posts/88769655.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-1-0"><a href="#C-1-0" class="headerlink" title="C# 1.0"></a>C# 1.0</h2><p>我们先罗列一下 C# 1.0 发布时所包含的语法特性，如下：</p><ul><li>类（class）</li><li>结构（struct）</li><li>接口（interface）</li><li>事件（event）</li><li>属性（property）</li><li>委托（delegates）</li><li>表达式</li><li>语句</li><li>特性（有时候也叫属性）（Attribute）</li></ul><p>C# 1.0 的特性只有以上这些。</p><p>基本上它涵盖了 C# 中最常用、最核心、最基础部分的内容。C# 使用进阶，一些非常基础的东西就不记录了。</p><p> <img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191926400.png" alt="image.png"></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>单纯从功能上来说，类可以：</p><ul><li>包含变量（属性）</li><li>包含方法（行为）</li><li>继承</li><li>用来创建对象</li></ul><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191926942.png" alt="image.png"></p><h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><p>有了类我们比较容易地进行面向对象编程，没有类当然也可以面向对象编程，只不过会不那么容易做到。</p><p>那么什么是面向对象编程呢？</p><p>我的理解只有两个字，建模。</p><p>建模就是对需要实现的功能或者需要解决的问题建立业务模型。</p><p>比如要实现购买商品功能，就需要我们创建商品对象，还要把购买商品的行为归属到另一个对象中，这个对象有可能是顾客对象，也有可能是平台对象。</p><p>这就是非常典型的面向对象建模案例。</p><p>那么如果是面向过程中的购买商品会是什么样的呢？</p><p>我们也许这样考虑，购买商品先创建一个购买商品函数，然后函数可能需要调用数据库，那就再写一个调用数据库的函数交媾购买商品函数调用，依次类推。</p><p>其实要区分面向对象编程与面向过程编程非常容易。</p><p>面向对象编程是以对象为基础进行思考的，而面向过程是以功能（函数）为基础进行思考的。</p><p>这就是两者的差别。</p><h3 id="面向对象与面向过程是对立的吗？"><a href="#面向对象与面向过程是对立的吗？" class="headerlink" title="面向对象与面向过程是对立的吗？"></a>面向对象与面向过程是对立的吗？</h3><p>不是对立的，面向对象更擅设计，而面向过程更擅长实现。</p><p>在使用 C# 的时候，两种编程思维都是会用到的。</p><h3 id="没有类如何面向对象编程？"><a href="#没有类如何面向对象编程？" class="headerlink" title="没有类如何面向对象编程？"></a>没有类如何面向对象编程？</h3><p>面向对象编程，当然要有对象了，如果没有类的话，其实也可以实现面向对象编程。</p><p>c 语言虽然不支持类，但是也可以通过宏或者一些模拟的手段支持类和对象的。</p><p>Lua 语言也没有提供类功能，但是通过元表也是能够模拟类和对象的。</p><p>OK，到此，面向对象这个话题可能与我们的专栏话题不太对题，但是一想到类，就不自觉地扯到面向对象这个话题了。</p><p>总是面向对象编程的核心就是两个字：建模。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927703.png" alt="image.png"></p><h3 id="引用类型和值类型"><a href="#引用类型和值类型" class="headerlink" title="引用类型和值类型"></a>引用类型和值类型</h3><p>几乎在每一本编程语言书籍上都会谈到引用类型和值类型这两个概念。</p><p>具体的引用类型和值类型相关的细节，大家在网上找各种文章就可以了。</p><p>引用类型，是用类创建的类型就是引用类型。</p><p>值类型包含基础类型和结构体（struct）创建出来的类型。</p><p>如下：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927309.png" alt="image.png"></p><p>就是这么简单。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>值类型直接存储其值，而引用类型存储对其值的引用</p><p>值类型 和 引用类型 是非常重要且非常基础的话题，所以想深入研究，网上能够找到一大堆文章。</p><h3 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h3><p>记住这句话就行。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927535.png" alt="image.png"></p><h3 id="关键特性和功能"><a href="#关键特性和功能" class="headerlink" title="关键特性和功能"></a>关键特性和功能</h3><ul><li>类的功能</li><li>类在编程生涯中的作用</li><li>面向对象和面向过程</li><li><p>值类型和引用类型</p></li><li><p>类的访问权限（封装性）</p></li><li>类的命名</li><li>抽象类 与 接口（继承性、多态性）</li><li>内部类</li><li>partial 关键字</li><li>泛型类</li><li>等等</li></ul><h3 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h3><p>访问权限有：internal、private、public。</p><p>internal class 一般在打 dll 的时候作用很大，可以控制有些类不让用户访问到。</p><p>private class 用得不多，一般作为内部类存在。</p><p>没了</p><p>如果不知道 internal 是什么作用，的可以在评论区提问。</p><h3 id="类的命名"><a href="#类的命名" class="headerlink" title="类的命名"></a>类的命名</h3><p>类的命名一般是名词，起名要合适，具体如何算合适？小班的文章中会介绍。</p><h3 id="抽象类-与-接口"><a href="#抽象类-与-接口" class="headerlink" title="抽象类 与 接口"></a>抽象类 与 接口</h3><p>抽象类中有的时候需要些抽象方法，抽象方法需要在子类中覆写。</p><p>实现接口可以显式实现和隐式实现，显式实现可以控制方法的访问权限，这个在接口的部分会仔细讲。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>有的时候需要在类内部创建一些只需要在类内部使用的对象，这时候可以用内部类。</p><h3 id="partial-关键字"><a href="#partial-关键字" class="headerlink" title="partial 关键字"></a>partial 关键字</h3><p>paritial 可以实现类的逻辑拆分到不同的文件。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类需要适配不同的类型的时候，可以用泛型类，比如单例的模板。</p><p>OK，到此就简单过了一些类相关的特性，只需要读一遍有个印象即可，如果遇到不懂的部分，自行百度。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927252.png" alt="image.png"></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>首先要说到结构体，第一时间想到的就是：结构体是值类型。</p><p>那么值类型具体是什么样的呢？</p><p>不知道大家记不记得 Unity 中有 Vector3、Vector2 这样的向量类型，我们接触 Vector3 比较多的地方是 transform.position 和 transform.localPosition。</p><p>在刚开始接触 transform.position 和 transform.localPosition 的时候，会对一件事情会非常印象深刻</p><p>这件事情就是如果我想给一个 transform 的 x 坐标赋值，那么代码就要像如下的方式去写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var position = transform.position;</span><br><span class="line">position.x = 1.0f;</span><br><span class="line">transform.position = position;</span><br></pre></td></tr></table></figure><p>一个简单的赋值代码，需要些三行，觉得很麻烦。</p><p>为什么不像如下的方式写呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.position.x = 1.0;</span><br></pre></td></tr></table></figure><p>这样写多方便？</p><p>这是因为，position 的类型 Vector3 是 struct 类型，struct 是值类型，同时 position 是 transform 的一个属性（而不是成员变量），所以就必须要给整个 position 变量赋值，而不是 position 变量中的某一个变量。</p><p>这就是 struct 和 class 最明显的区别。</p><p>作为一个属性时， struct 无法对单一的成员变量赋值，而 class 则是只要允许可以随便赋值。</p><p>其实关于结构体，其实有很多细节可以进行学习，但是我们不用学那么多。</p><p>根据自己的经验，结构体只需要知道如下关键点就行了：</p><ul><li>是值类型</li><li>不能设置为 null</li><li>声明变量时，本身就有值了</li><li>赋值时是深拷贝</li><li>不能局部赋值（比如 transofrm.position.x 不能直接赋值）<br>除了以上者五点比较重要之外，在其他情况下，很少用到结构体，最起码从以前到现在，接触到和结构体相关的编码实践也仅限于以上的五点特性。</li></ul><p>而除了者五点之外，肯定还有很多其他的特性，其他的特性也许不那么常用，也可以简单地过一遍。</p><h3 id="其它的细节"><a href="#其它的细节" class="headerlink" title="其它的细节"></a>其它的细节</h3><ul><li><p>在结构声明中，除非将字段声明为 const 或 static，否则无法初始化。</p></li><li><p>结构不能声明无参数构造函数（没有参数的构造函数）或终结器。</p></li><li><p>结构在分配时进行复制。将结构分配给新变量时，将复制所有数据，并且对新副本所做的任何修改不会更改原始副本的数据。在处理值类型的集合（如<code>Dictionary&lt;string, myStruct&gt;</code>）时，请务必记住这一点。</p></li><li><p>结构是值类型，不同于类，类是引用类型。</p></li><li><p>与类不同，无需使用<code>new</code>运算符即可对结构进行实例化。</p></li><li><p>结构可以声明具有参数的构造函数。</p></li><li><p>一个结构无法继承自另一个结构或类，并且它不能为类的基类。所有结构都直接继承自<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.valuetype">ValueType</a>，后者继承自<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.object">Object</a>。</p></li><li><p>结构可以实现接口。</p></li><li><p>结构不能为<code>null</code>，并且不能向结构变量分配<code>null</code>，除非将变量声明为可为空的值类型。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927818.png" alt="image.png"></p></li></ul><h2 id="接口（inteface）"><a href="#接口（inteface）" class="headerlink" title="接口（inteface）"></a>接口（inteface）</h2><p>是为了实现一个跑道生成器，使用 interface 来定义了一个跑道的实现标准，然后将跑道共同的逻辑都写到了跑道基类中（抽象类），最后每一种特殊的跑道则继承跑道基类，然后特殊的逻辑通过复写基类的方法即可。</p><p>大致的结构如下。<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927125.png" alt="image.png"></p><p>interface 可以制定标准，可以解耦合，可以做设计，可以做限制等。</p><h3 id="隐式实现"><a href="#隐式实现" class="headerlink" title="隐式实现"></a>隐式实现</h3><p>interface 的实现，大多是是隐式实现的，我们先看如下代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStage</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Generate</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Stage</span> : <span class="title">IStage</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Generate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;跑道生成&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显式实现"><a href="#显式实现" class="headerlink" title="显式实现"></a>显式实现</h3><p>显式实现的代码其实非常简单如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStage</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Generate</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Stage</span> : <span class="title">IStage</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IStage.Generate()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;跑道生成&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>显式实现的方法在调用时，方法所在对象必须是所实现的接口类型。</li></ul><p>比较绕，什么意思呢？</p><p>我们尝试调用 Stage 的 Generate 方法，调用代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stage = <span class="keyword">new</span> Stage();</span><br><span class="line">      </span><br><span class="line">stage.Generate();</span><br></pre></td></tr></table></figure><p>写完以上代码，IDE 会报错，如下：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927725.png" alt="image.png"></p><p>这是因为 stage 目前是一个 Stage 类型，而不是 IStage 类型。</p><p>如果想调用 Generate 方法，必须像如下方式这样写：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IStage stage = <span class="keyword">new</span> Stage();</span><br><span class="line">      </span><br><span class="line">stage.Generate();</span><br></pre></td></tr></table></figure><p>使用 IStage 变量来接收。</p><p>显式实现是为了解决实现多个接口时有可能出现的重名问题。</p><h3 id="显式实现的应用场景"><a href="#显式实现的应用场景" class="headerlink" title="显式实现的应用场景"></a>显式实现的应用场景</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFlyable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老鹰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Eagle</span> : <span class="title">IFlyable</span>, <span class="title">IBird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fly 实现的是哪个接口？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中 IFlyable 和 IBird 都有 Fly 这个方法，那么同时实现了两个接口的 Eagle，其中的 Fly 方法，到底是属于哪个接口的 Fly 呢？</p><p>答案是两个接口都实现了。</p><p>其实这样是没什么问题的。</p><p>但是如果 IFlyable 和 IBird 的 Fly 不一样，要分别实现这两个接口的 Fly 该怎么办呢？</p><p>这就需要使用接口的 显式实现 了。</p><p>分别实现后的代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFlyable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老鹰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Eagle</span> : <span class="title">IFlyable</span>, <span class="title">IBird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IFlyable.Fly()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;flyable fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> IBird.Fly()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;bird fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> eagle = <span class="keyword">new</span> Eagle();</span><br><span class="line">    (eagle <span class="keyword">as</span> IBird).Fly();</span><br><span class="line">    (eagle <span class="keyword">as</span> IFlyable).Fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// bird fly</span></span><br><span class="line"><span class="comment">// flyable fly</span></span><br></pre></td></tr></table></figure><p>这样就解决了，接口方法重名的问题。</p><p>OK，这是 C# 官方的推荐用法，使用 接口的显式实现 来解决多个接口有重名方法的问题。</p><p>还有其他使用场景一般是为了降低接口方法的访问权限。</p><p>我们看如下代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Command</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 降低了 Execute 的访问权限</span></span><br><span class="line">    <span class="comment">// 这样 Command 对象无法直接调用 Execute 方法</span></span><br><span class="line">    <span class="comment">// 避免被用户误操作</span></span><br><span class="line">    <span class="keyword">void</span> ICommand.Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        OnExecute();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnExecute</span>()</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> ICommand.Dispose()</span><br><span class="line">    &#123;</span><br><span class="line">        OnDispose();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDispose</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorldCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="title">OnExecute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       Debug.Log(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CommandExecuter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExecuteCommand</span>(<span class="params">ICommand command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        command.Execute();</span><br><span class="line">        command.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> command = <span class="keyword">new</span> HelloWorldCommand();</span><br><span class="line">    <span class="comment">// command.Execute(); 无法直接调用</span></span><br><span class="line">    CommandExecuter.ExecuteCommand(command);<span class="comment">// 可以交给专门的执行器执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 降低接口方法权限的好处，就是用户创建出来的对象无法直接使用接口方法，而是把接口方法交给专门的调用器调用，这样可以避免用户误操作。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927429.png" alt="image.png"></p><p>其实还有一些关于接口的一些细节描述没有介绍，</p><ul><li>接口类似于只有抽象成员的抽象基类。 实现接口的任何类或结构都必须实现其所有成员。</li><li>接口无法直接进行实例化。 其成员由实现接口的任何类或结构来实现。</li><li>接口可以包含事件、索引器、方法和属性。</li><li>接口不包含方法的实现。</li><li>一个类或结构可以实现多个接口。 一个类可以继承一个基类，还可实现一个或多个接口。</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>C# 语言的事件这个概念一般用得比较少，用得比较多的是委托。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Data &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> Action&lt;EventArgs&gt; SomeEvent;</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    SomeEvent += OnSomeEvent;</span><br><span class="line"></span><br><span class="line">    SomeEvent(<span class="keyword">new</span> EventArgs()</span><br><span class="line">    &#123;</span><br><span class="line">        Data = <span class="number">10</span></span><br><span class="line">    &#125;);</span><br><span class="line">          </span><br><span class="line">    SomeEvent -= OnSomeEvent;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">if</span> (SomeEvent != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SomeEvent.Invoke(<span class="keyword">new</span> EventArgs()</span><br><span class="line">        &#123;</span><br><span class="line">            Data = <span class="number">20</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnSomeEvent</span>(<span class="params">EventArgs eventArgs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(eventArgs.Data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果为</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>代码很简单，event 的用法，其实和委托的语言特性差不多，都可以通过 += 和 -= 运算符进行注册和注销。</p><p>但是有一个非常重要的区别，就是 event 只能在所声明的类的内部调用。</p><p>也就是说，以上的代码中的 SomeEvent，在别的类中无法调用的，但是在别的类中可以进行 += 和 -= 操作。</p><p>这就是事件与委托最核心的区别。</p><p>这个区别不是约定，而是会报编译错误的一个限制。</p><p>除了这个其他的方面事件和委托差不多。</p><p>由于有了这个限制，事件只能从内向外发送事件。</p><p>只需要记住事件只能在类的内部触发即可。</p><p>除了这一点外，还有一种可能觉得比较新鲜的特性，就是事件的属性器不是 set 和 get，而是 add 和 remove，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> Action&lt;EventArgs&gt; SomeEvent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">add</span> &#123; mSomeEvent += <span class="keyword">value</span>; &#125;</span><br><span class="line">    <span class="keyword">remove</span> &#123; mSomeEvent -= <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Action&lt;EventArgs&gt; mSomeEvent;</span><br></pre></td></tr></table></figure><h2 id="属性器"><a href="#属性器" class="headerlink" title="属性器"></a>属性器</h2><p>属性器有一个好处，就是隔离类内部的变化，当类内部发生改变，而外部可以不受到任何影响。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> student = <span class="keyword">new</span> Student() &#123; Age = <span class="number">15</span> &#125;;</span><br><span class="line">  </span><br><span class="line">    Debug.Log(student.Age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码没什么问题，接下来，由于需求变更，Student 的 Age 需要根据生日计算，而不是直接录入年龄，因为随着时间变换，学生的 Age 需要每年更新一次，如果根据生日自动计算，就会省去每年更新的操作。</p><p>实现需求后，如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> DateTime.Now.Year - BirthYear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BirthYear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> student = <span class="keyword">new</span> Student() &#123; BirthYear = <span class="number">2004</span> &#125;;</span><br><span class="line">  </span><br><span class="line">    Debug.Log(student.Age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当用到 Age 部分的代码就不用进行变更了，只需要变更 Student 类的内部就可以了。</p><p>这是属性的一种用法，就是用来隔离类内部的变化，而隔离内部的变化的这个特性，其实就是 面向对象的 封装性。</p><p>C# 1.0 中的属性器，没有简写版本，只能是如下代码所示的方式定义属性器:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> mName; &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; mName = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> mName;</span><br></pre></td></tr></table></figure><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>C# 中的委托真的是非常好用，C# 的委托相比 C++ 的函数指针，更加安全，相比 Java 的匿名类，更加简洁。</p><h3 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h3><p>C# 内置了 Action<T>、Func<T> 等委托定义，基本上用到委托的部分用 Action 和 Func 就可以满足大多数需求了。</p><p>Action<T>、Func<T> 的区别是 ：</p><p>Action<T>只有参数类型，不能传返回类型。所以Action<T>的委托函数都是没有返回值的。</p><p>Func<T>有返回类型</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>注册委托 和 注销委托 最好成对出现</li><li>委托有可能为 null，所以最好在声明委托变量时，设置一个初始值，可以减少空指针异常的风险，如下:</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Action&lt;<span class="built_in">int</span>&gt; OnAgeChanged = (age)=&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>什么是表达式呢？</p><p>官方的定义：</p><ul><li>表达式是由一个或多个操作数以及零个或多个组成的序列，其计算结果为一个值、对象、方法或命名空间 。</li></ul><p>这就是表达式的相对严谨一些的定义了。</p><p>虽然定义理解起来比较晦涩，但是我们在日常开发中，会写大量的表达式。</p><p>比如如下代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 x &gt; 10，i &lt; 10，这种代码就是一种表达式。</p><p>那么表达式有哪些分类呢？</p><p>我们来逐个过一遍表达式的类型。</p><h3 id="数值和字符串"><a href="#数值和字符串" class="headerlink" title="数值和字符串"></a>数值和字符串</h3><p>最简单的两种表达式是数值和字符串，代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 5;</span><br><span class="line">string text = &quot;Hello World&quot;;</span><br></pre></td></tr></table></figure><p>代码中的 5 和 Hello World 就是表达式值，而 i 和 text 则是声明的变量。</p><p>以上的两行代码一般叫做声明两个变量，但是我们也可以叫做两个表达式的声明。</p><p>在表达式中使用 i 和 text 这些变量的时候，变量名称计算为当前在改变量的内存位置所存储的值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(i); <span class="comment">// Output: 5</span></span><br><span class="line">Debug.Log(text); <span class="comment">// Output: Hello World</span></span><br></pre></td></tr></table></figure><h3 id="调用表达式"><a href="#调用表达式" class="headerlink" title="调用表达式"></a>调用表达式</h3><p>调用表达式非常简单，就是方法调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWork</span>()</span> &#123;&#125;</span><br><span class="line">DoWork(); <span class="comment">// 调用表达式</span></span><br><span class="line"></span><br><span class="line">Action SomeAction = ()=&gt;&#123;&#125;;</span><br><span class="line">SomeAction(); <span class="comment">// 调用表达式</span></span><br></pre></td></tr></table></figure><h3 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h3><p>虽然 C# 1.0 没有支持，但是 LINQ 则是查询表达式</p><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c(paramA)=&gt;&#123;  <span class="keyword">return</span> someValue; &#125;</span><br><span class="line"></span><br><span class="line">()=&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line">(paramA)=&gt;someValue;</span><br></pre></td></tr></table></figure><p>除了以上这些表达式，还剩下一些概念：</p><ul><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/index">表达式树 (C#)</a></li><li>表达式主体定义:<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members">Expression-bodied members</a></li></ul><p>这些平时用的不多，但是对于理解 C# 语言还是蛮有好处的。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927324.png" alt="image.png"></p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句的介绍非常简单，任何可以用分号结尾的代码就是一个语句。</p><p>比如:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> result = <span class="number">1</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>虽然语句的概念比较好理解，但是在 C# 语言中，语句的类型有非常多。</p><p>它们分别如下:</p><ul><li>声明语句</li><li>表达式语句</li><li>选择语句<ul><li>if、else、switch、case</li></ul></li><li>迭代语句<ul><li>do、for、foreach、in、while</li></ul></li><li>跳转语句<ul><li>break、continue、default、goto、return、yield</li></ul></li><li>异常处理语句<ul><li>throw、try-catch、try-finally、try-catch-finally</li></ul></li><li>await 语句</li><li>yield return 语句</li><li>fixed 语句</li><li>lock 语句</li><li>空语句</li><li>等等</li></ul><p>而具体的细节这里就不介绍了，大家只要知道语句是什么样的一个东西 并且 C# 1.0 中包含语句这个特性就可以了。</p><p>如果想详细了解可以查阅如下地址：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/statements">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/statements</a></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927802.png" alt="image.png"></p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h3><p>反射，英文为：Reflection。</p><p>核心就是使用各种类型（Type）相关的 API。</p><p>对于反射来说，其 Hello World 如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Example.CSharp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReflectionExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> type = <span class="keyword">typeof</span>(SomeClass);</span><br><span class="line">Debug.Log(type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// QFramework.Example.CSharp.ReflectionExample+SomeClass</span></span><br></pre></td></tr></table></figure><p>代码很简单，typeof 可以获取到一个类的 Type。</p><p>而获取一个类或对象的类型信息，就算是一种反射操作了。</p><h3 id="反射的官方定义"><a href="#反射的官方定义" class="headerlink" title="反射的官方定义"></a>反射的官方定义</h3><p>下面给出反射的官方定义，如下:</p><ul><li><p>提供封装程序集、模块和类型的对象</p></li><li><p>反射提供以下对象</p><ul><li>封装了程序集的对象</li><li>封装了模块的对象</li><li>封装了类型的对象</li></ul></li></ul><p>在 C# 中，我们可以通过 Type 获取到该类所在的程序集、模块、以及本身的类型，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Example.CSharp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReflectionExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> type = <span class="keyword">typeof</span>(SomeClass);</span><br><span class="line"><span class="comment">// 程序集</span></span><br><span class="line">Debug.Log(type.Assembly);</span><br><span class="line"><span class="comment">// 模块</span></span><br><span class="line">Debug.Log(type.Module);</span><br><span class="line"><span class="comment">// 类型名字</span></span><br><span class="line">Debug.Log(type.Name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果:</span></span><br><span class="line"><span class="comment">// Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null</span></span><br><span class="line"><span class="comment">// Assembly-CSharp.dll</span></span><br><span class="line"><span class="comment">// SomeClass</span></span><br></pre></td></tr></table></figure><p>通过一个对象的 GetType() 获取到 Type 对象。</p><p>type 还可以访问大量的类相关的信息，比如是否是 Class？是否是抽象的？是否是值类型等等。</p><ul><li>类信息查询 API：获取各种名字。</li><li>检测 API：判断 type 是否是某一个事物（比如是否是抽象的，等等）</li><li>类结构查询 API：获取父类类型、获取方法、获取构造、获取成员变量等等。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QFramework.Example.CSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReflectionExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过对象的 GetType 获取对象 </span></span><br><span class="line">            <span class="keyword">var</span> type = <span class="keyword">new</span> SomeClass().GetType();</span><br><span class="line"></span><br><span class="line">            Debug.LogFormat(<span class="string">&quot;FullName:&#123;0&#125;&quot;</span>, type.FullName);</span><br><span class="line">            Debug.LogFormat(<span class="string">&quot;IsClass:&#123;0&#125;&quot;</span>, type.IsClass);</span><br><span class="line">            Debug.LogFormat(<span class="string">&quot;Namespace:&#123;0&#125;&quot;</span>, type.Namespace);</span><br><span class="line">            <span class="comment">// 是否是抽象的（抽象类、接口）</span></span><br><span class="line">            Debug.LogFormat(<span class="string">&quot;IsAbstract:&#123;0&#125;&quot;</span>, type.IsAbstract);</span><br><span class="line">            <span class="comment">// 是否是值类型</span></span><br><span class="line">            Debug.LogFormat(<span class="string">&quot;IsValueType:&#123;0&#125;&quot;</span>, type.IsValueType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果:</span></span><br><span class="line"><span class="comment">// FullName:QFramework.Example.CSharp.ReflectionExample+SomeClass</span></span><br><span class="line"><span class="comment">// IsClass:True</span></span><br><span class="line"><span class="comment">// Namespace:QFramework.Example.CSharp</span></span><br><span class="line"><span class="comment">// IsAbstract:False</span></span><br><span class="line"><span class="comment">// IsValueType:False</span></span><br></pre></td></tr></table></figure><h3 id="反射知识体系"><a href="#反射知识体系" class="headerlink" title="反射知识体系:"></a>反射知识体系:</h3><ul><li>基本的反射对象的 API 类型<ul><li>信息查询</li><li>检测</li><li>结构查询</li></ul></li><li>Type 对象提供的 结构查询 API<ul><li>GetPropertys()、GetProeprty(name)：返回 PropertyInfo 对象，可以 SetValue 和 GetValue</li><li>GetMethods()、GetMethod(name)：返回 MethodInfo 对象，可以 Invoke</li><li>GetMembers()、GetMember(name)：返回 MemberInfo 对象</li><li>GetFields()、GetField(name)：返回 FieldInfo 对象，可以 SetValue 和 GetValue</li></ul></li><li>Assembly 提供的 API<ul><li>Assembly.LoadFrom(fullPath)</li><li>Assembly.GetExecutingAssembly()</li><li>assembly.CreateInstance(typeName)</li></ul></li></ul><h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><p>Attribute 有时候翻译成特性，有时候翻译成属性。</p><p>使用 Attribute，可以在类或者方法、属性、程序集中声明一些标记。使用 Attribute 标记程序后，可以在运行时使用反射来查询特性。</p><p>一般情况下，最常接触的 Attribute 就是 SerializableAttribute，示例代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Serializable 标记的类，可以进行序列化和反序列化，比如用 JsonUtility 或者一些 XML 库。</p><p>而第二个常见的 Attribute 也许是 Unity 提供的 SerializeField，它可以让私有的成员变量在 Inspector 上进行显示。</p><p>代码如下:<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927730.png" alt="image.png"></p><p>效果如下:<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927554.png" alt="image.png"></p><h3 id="自定义-Attribute"><a href="#自定义-Attribute" class="headerlink" title="自定义 Attribute"></a>自定义 Attribute</h3><p>要想实现自定义的 Attribute 非常简单，只需要继承 Attribute 类即可，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutoSetHelloWorldAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">AutoSetHelloWorld</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好 AutoSetHelloWorld Attribute 后，我们可以将它标记到一个成员变量上。</p><p>AutoSetHelloWorld 意思是自动设置 HelloWorld 给所标记的成员变量。</p><p>但是光是把 SomeClass 中的 Text 变量标记为 AutoSetHelloWorld 是不够的，因为 Attribute 往往需要和反射技术一起使用。</p><p>OK，我们看下如何对 SomeClass 的 Text 变量赋值的代码，如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AttributeExample</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建 SomeClass 对象 </span></span><br><span class="line"><span class="keyword">var</span> someObject = <span class="keyword">new</span> SomeClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 SomeClass 的类型</span></span><br><span class="line"><span class="keyword">var</span> type = someObject.GetType(); <span class="comment">// typeof(SomeClass) 亦可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有成员变量</span></span><br><span class="line"><span class="keyword">var</span> members = type.GetMembers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有标记 AutoSetHelloWorld 的成员变量</span></span><br><span class="line"><span class="keyword">var</span> markedMembers =</span><br><span class="line">members.Where(m =&gt; m.GetCustomAttributes(<span class="keyword">typeof</span>(AutoSetHelloWorldAttribute), <span class="literal">false</span>).Length != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 Hello World</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> markedMember <span class="keyword">in</span> markedMembers)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> fieldInfo = markedMember <span class="keyword">as</span> FieldInfo;</span><br><span class="line"></span><br><span class="line">fieldInfo.SetValue(someObject, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Debug.Log(someObject.Text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中包含了很多 反射相关的代码</p><p>我们看下 AttributeExample 的输出结果，如下:<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191927150.png" alt="image.png"></p><ul><li>自定义 Attribute 只需要继承 System.Attribute</li><li>自定义 Attribute 通常需要与反射配合</li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四叉树碰撞检测算法</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="四叉树是什么"><a href="#四叉树是什么" class="headerlink" title="四叉树是什么?"></a><strong>四叉树是什么?</strong></h3><p>四叉树本身是树结构的一种，如果物体过多的话，先根据物体所处位置划分成四块，如果每个块的中的物体数量还是很多的话，继续划分成四块。如下图红线所示。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191906614.gif" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>检测的时候，就是根据待测试对象的位置，去找属于哪个块，再把这个块中的物体告诉你。如下图中的绿色物体。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191906797.gif" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>那么怎么实现四叉树呢？用好 <code>github</code> 就行了(误)，搜了一下，找到一个库，直接拿来改改就行了。</p><p><a href="https://github.com/timohausmann/quadtree-js">GitHub - timohausmann/quadtree-js: A lightweight quadtree implementation for javascript</a></p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Quadtree</span>(<span class="params"> bounds, max_objects, max_levels, level </span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max_objects</span>    = max_objects || <span class="number">10</span>;　<span class="comment">//每个区域可以容纳的最大对象数，超过就需要划分</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max_levels</span>     = max_levels || <span class="number">4</span>;　<span class="comment">//最多划几层四叉树</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">level</span>      = level || <span class="number">0</span>;　<span class="comment">//当前树或子树的层，根为0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bounds</span>         = bounds; <span class="comment">//bounds就是对象集，每个点包括x,y,width,height(有些实现是圆形，这个是矩形)</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">objects</span>        = [];　<span class="comment">//属于当前节点的对象，不包括子节点的对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span>      = [];　<span class="comment">//属于当前树的节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><p>当调用Insert函数向树中插入对象的时候，如果当前节点没有被划分过的时候，会判断节点的对象数是否超过的限制的max_objects,如果超过了的话当前节点就会调用这个split方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Quadtree</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">split</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> nextLevel = <span class="variable language_">this</span>.<span class="property">level</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> subWidth = <span class="title class_">Math</span>.<span class="title function_">round</span>( <span class="variable language_">this</span>.<span class="property">bounds</span>.<span class="property">width</span> / <span class="number">2</span> );</span><br><span class="line">    <span class="keyword">var</span> subHeight = <span class="title class_">Math</span>.<span class="title function_">round</span>( <span class="variable language_">this</span>.<span class="property">bounds</span>.<span class="property">height</span> / <span class="number">2</span> );</span><br><span class="line">    <span class="keyword">var</span> x = <span class="title class_">Math</span>.<span class="title function_">round</span>( <span class="variable language_">this</span>.<span class="property">bounds</span>.<span class="property">x</span> );</span><br><span class="line">    <span class="keyword">var</span> y = <span class="title class_">Math</span>.<span class="title function_">round</span>( <span class="variable language_">this</span>.<span class="property">bounds</span>.<span class="property">y</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//第一象限，和数学里的坐标轴一样，不过起点变了而已</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span>[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Quadtree</span>(&#123;</span><br><span class="line">        x   : x + subWidth, </span><br><span class="line">        y   : y, </span><br><span class="line">        width   : subWidth, </span><br><span class="line">        height  : subHeight</span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">max_objects</span>, <span class="variable language_">this</span>.<span class="property">max_levels</span>, nextLevel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二象限</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span>[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Quadtree</span>(&#123;</span><br><span class="line">        x   : x, </span><br><span class="line">        y   : y, </span><br><span class="line">        width   : subWidth, </span><br><span class="line">        height  : subHeight</span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">max_objects</span>, <span class="variable language_">this</span>.<span class="property">max_levels</span>, nextLevel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三象限</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span>[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Quadtree</span>(&#123;</span><br><span class="line">        x   : x, </span><br><span class="line">        y   : y + subHeight, </span><br><span class="line">        width   : subWidth, </span><br><span class="line">        height  : subHeight</span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">max_objects</span>, <span class="variable language_">this</span>.<span class="property">max_levels</span>, nextLevel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第四象限</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span>[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Quadtree</span>(&#123;</span><br><span class="line">        x   : x + subWidth, </span><br><span class="line">        y   : y + subHeight, </span><br><span class="line">        width   : subWidth, </span><br><span class="line">        height  : subHeight</span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">max_objects</span>, <span class="variable language_">this</span>.<span class="property">max_levels</span>, nextLevel);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>基本是切割，没什么太值得一说的，划分后的节点level + 1了</p><h3 id="查找对象"><a href="#查找对象" class="headerlink" title="查找对象"></a>查找对象</h3><p>插入节点和碰撞检测的时候我们需要先知道对象在这个节点所在的象限，这个函数输入一个有x,y,width,height的对象，并判断应该属于这个节点的哪个象限。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Quadtree</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getIndex</span> = <span class="keyword">function</span>(<span class="params"> pRect </span>) &#123;</span><br><span class="line">    </span><br><span class="line">    　<span class="keyword">var</span>     index           = -<span class="number">1</span>,</span><br><span class="line">        verticalMidpoint    = <span class="variable language_">this</span>.<span class="property">bounds</span>.<span class="property">x</span> + (<span class="variable language_">this</span>.<span class="property">bounds</span>.<span class="property">width</span> / <span class="number">2</span>),</span><br><span class="line">        horizontalMidpoint  = <span class="variable language_">this</span>.<span class="property">bounds</span>.<span class="property">y</span> + (<span class="variable language_">this</span>.<span class="property">bounds</span>.<span class="property">height</span> / <span class="number">2</span>),</span><br><span class="line"> </span><br><span class="line">        topQuadrant = (pRect.<span class="property">y</span> &lt; horizontalMidpoint &amp;&amp; pRect.<span class="property">y</span> + pRect.<span class="property">height</span> &lt; horizontalMidpoint),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//pRect can completely fit within the bottom quadrants</span></span><br><span class="line">        bottomQuadrant = (pRect.<span class="property">y</span> &gt; horizontalMidpoint);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>( pRect.<span class="property">x</span> &lt; verticalMidpoint &amp;&amp; pRect.<span class="property">x</span> + pRect.<span class="property">width</span> &lt; verticalMidpoint ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( topQuadrant ) &#123;</span><br><span class="line">            index = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( bottomQuadrant ) &#123;</span><br><span class="line">            index = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( pRect.<span class="property">x</span> &gt; verticalMidpoint ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( topQuadrant ) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( bottomQuadrant ) &#123;</span><br><span class="line">            index = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>比较简单的数学，不过值得注意一点的是，如果一个对象是跨象限的，那么在它会返回-1</p><h3 id="插入对象到节点"><a href="#插入对象到节点" class="headerlink" title="插入对象到节点"></a>插入对象到节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Quadtree</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params"> pRect </span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">var</span> index;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前节点已经划分过了，就查找对象所属象限，递归调用</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">nodes</span>[<span class="number">0</span>] !== <span class="string">&#x27;undefined&#x27;</span> ) &#123;</span><br><span class="line">        index = <span class="variable language_">this</span>.<span class="title function_">getIndex</span>( pRect );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( index !== -<span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">nodes</span>[index].<span class="title function_">insert</span>( pRect );   </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">objects</span>.<span class="title function_">push</span>( pRect );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果节点对象超过设置值，而且还能继续划分(level没到上限)的时候</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable language_">this</span>.<span class="property">objects</span>.<span class="property">length</span> &gt; <span class="variable language_">this</span>.<span class="property">max_objects</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">level</span> &lt; <span class="variable language_">this</span>.<span class="property">max_levels</span> ) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先划分节点</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">nodes</span>[<span class="number">0</span>] === <span class="string">&#x27;undefined&#x27;</span> ) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">split</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把对象加入对应子节点</span></span><br><span class="line">        <span class="keyword">while</span>( i &lt; <span class="variable language_">this</span>.<span class="property">objects</span>.<span class="property">length</span> ) &#123;</span><br><span class="line">            </span><br><span class="line">            index = <span class="variable language_">this</span>.<span class="title function_">getIndex</span>( <span class="variable language_">this</span>.<span class="property">objects</span>[ i ] );</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( index !== -<span class="number">1</span> ) &#123;                    </span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">nodes</span>[index].<span class="title function_">insert</span>( <span class="variable language_">this</span>.<span class="property">objects</span>.<span class="title function_">splice</span>(i, <span class="number">1</span>)[<span class="number">0</span>] );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这里值得注意一点的是，如果一个对象是跨象限的，这种时候怎么处理。看代码段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( index !== -<span class="number">1</span> ) &#123;                    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span>[index].<span class="title function_">insert</span>( <span class="variable language_">this</span>.<span class="property">objects</span>.<span class="title function_">splice</span>(i, <span class="number">1</span>)[<span class="number">0</span>] );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>之前getIndex的时候我们就说过，如果一个对象是跨象限的，getIndex会返回-1，从代码来看，跨象限的对象会被放在当前节点的objects里面而不会被划给子节点。<strong>这一点很有必要</strong>，因为blabla(待补充)</p><h3 id="返回碰撞候选列表"><a href="#返回碰撞候选列表" class="headerlink" title="返回碰撞候选列表"></a>返回碰撞候选列表</h3><p>四叉树最核心的一部分就是要过滤掉一些根本不可能碰撞的对象，避免对比全部的对象以此来提高效率，这个函数输入一个包含x,y,width,height的对象，返回一个集合，是经过过滤后的可能和输入对象发生碰撞的候选对对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Quadtree</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">retrieve</span> = <span class="keyword">function</span>(<span class="params"> pRect </span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span>     index = <span class="variable language_">this</span>.<span class="title function_">getIndex</span>( pRect ),</span><br><span class="line">        returnObjects = <span class="variable language_">this</span>.<span class="property">objects</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//if we have subnodes ...</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">nodes</span>[<span class="number">0</span>] !== <span class="string">&#x27;undefined&#x27;</span> ) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if pRect fits into a subnode ..</span></span><br><span class="line">        <span class="keyword">if</span>( index !== -<span class="number">1</span> ) &#123;</span><br><span class="line">            returnObjects = returnObjects.<span class="title function_">concat</span>( <span class="variable language_">this</span>.<span class="property">nodes</span>[index].<span class="title function_">retrieve</span>( pRect ) );</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//if pRect does not fit into a subnode, check it against all subnodes</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="property">length</span>; i=i+<span class="number">1</span> ) &#123;</span><br><span class="line">                returnObjects = returnObjects.<span class="title function_">concat</span>( <span class="variable language_">this</span>.<span class="property">nodes</span>[i].<span class="title function_">retrieve</span>( pRect ) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> returnObjects;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>首先我们先确立一下，对于一个对象来说，<strong>什么样的对象才算是可能和它发生碰撞的候选对象？</strong>，代码里面主要分两部分来考虑<br> <strong>一个是对象就在这个节点的某个象限里面</strong>，这个时候看代码段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( index !== -<span class="number">1</span> ) &#123;</span><br><span class="line">    returnObjects = returnObjects.<span class="title function_">concat</span>( <span class="variable language_">this</span>.<span class="property">nodes</span>[index].<span class="title function_">retrieve</span>( pRect ) );</span><br><span class="line">    </span><br><span class="line"><span class="comment">//if pRect does not fit into a subnode, check it against all subnodes</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果一个对象在当前节点的某个象限里面，则其碰撞候选是当前节点的对象加上那个象限里面调用retrieve的节点。这里也解释了为什么跨象限的节点的对象就放在当前节点上，因为跨象限的节点也有可能和某个象限内的节点发生碰撞，所以需要把这些对象都加入到候选对象里面(尽管可能这个对象在第四象限，而跨象限的对象在第一象限和第二象限之间)</p><p><strong>其次是这个对象本身就是跨象限的</strong>，这个时候看代码段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="property">length</span>; i=i+<span class="number">1</span> ) &#123;</span><br><span class="line">        returnObjects = returnObjects.<span class="title function_">concat</span>( <span class="variable language_">this</span>.<span class="property">nodes</span>[i].<span class="title function_">retrieve</span>( pRect ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>就是直接把这个节点的所有子节点递归把结果集合到一起，然后根据上面retrieve的内容我们知道，如果输入的对象不在节点的任意象限内，则返回节点上的对象</p><p>总结一下就是，当这个对象是个跨象限的对象的时候</p><p>可能发生碰撞的是<strong>所属节点所有跨象限的对象</strong>加上<strong>所跨象限的所有内容</strong>，具体可以在网站上自己试一下<a href="https://link.jianshu.com?t=http://timohausmann.de/quadtree.js/simple.html">simple demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 碰撞检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo 搭建个人博客（四）：SEO 优化及站点被搜索引擎收录设置</title>
      <link href="/posts/e60e7857.html"/>
      <url>/posts/e60e7857.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们必须把我们的网站推送到搜索引擎那， 不然别人除了输入我们的域名或者搜索文章，是没法发现我们的博文。</p><p>如何查看我的网站是否被收录：</p><p>site:你的网站<br>比如我的：site:liuyingbo.com</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162354633.png" alt="image-20211128150936068"></p><h2 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h2><p>站点地图即 <a href="https://baike.baidu.com/item/sitemap/6241567?fr=aladdin">sitemap</a>， 是一个页面，上面放置了网站上需要搜索引擎抓取的所有页面的链接。站点地图可以告诉搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。所以我们首先需要生成一个站点地图</p><p>安装百度和 Google 的站点地图生成插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>然后来到站点目录配置文件<code>_config.yml</code>，在下面添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">站点地图</span></span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>然后重新推送到服务器，在访问如下 URL:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://你的域名/sitemap.xml</span><br><span class="line">https://你的域名/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>看看有没有出现代码。有的话就成功。</p><p>给你的 hexo 网站添加蜘蛛协议 robots.txt, 把 robots.txt 放在你的 hexo 站点的 source 文件下即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo robots.txt</span></span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line"></span><br><span class="line">Sitemap: https://liuyyingbo.com/sitemap.xml</span><br><span class="line">Sitemap: https://liuyingbo.com/baidusitemap.xml</span><br></pre></td></tr></table></figure><h2 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h2><h3 id="提交网站"><a href="#提交网站" class="headerlink" title="提交网站"></a>提交网站</h3><p>通过百度站长平台进行链接提交，增加网站的索引量。先去注册并登录：<a href="ziyuan.baidu.com">百度站长平台</a></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162354058.png" alt="百度站长平台"></p><p>然后需要验证网站，我选择的是<code>https://</code>，这根据你前面是否添加 SSL 证书来选择。并且我使用的是不带 www 的，看个人。然后到第三步，我使用的 <strong>HTML 标签验证</strong>。你也可以选择自己喜欢的方式</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162355028.png" alt="验证网站"></p><p>把 content 中的字符串复制到主题配置文件 中的<code>baidu_site_verification</code>就好。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Baidu Webmaster tools verification.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See: https://ziyuan.baidu.com/site</span></span><br><span class="line">baidu_site_verification: #这里填上面的字符串</span><br></pre></td></tr></table></figure><h3 id="提交链接"><a href="#提交链接" class="headerlink" title="提交链接"></a>提交链接</h3><p>主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>然后到站点目录配置文件<code>_config.yml</code>，添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主动推送百度，被百度收录</span></span><br><span class="line">baidu_url_submit:</span><br><span class="line">  count: 10 # 提交最新的10个链接</span><br><span class="line">  host: # 百度站长平台中注册的域名</span><br><span class="line">  token: # 秘钥，百度站长平台 &gt; 推送接口 &gt; 接口调用地址中token字段</span><br><span class="line">  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里，不用改</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162355087.png" alt="自动提交"></p><p>其次，记得查看<code>_config.yml</code> 文件中 url 的值， 必须包含是百度站长平台注册的域名， 比如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">URL</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span></span><br><span class="line">url: https://liuyingbo.com</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure><p>最后，加入新的 deployer:</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162355464.png" alt="deployer"></p><p>其主动推送的实现原理如下：</p><ul><li>新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接</li><li>新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎</li></ul><h3 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h3><p>可以在<code>themes\next\layout\_third-party</code>中看到一个 baidu-push.swig 文件，这应该是现在 next 版本自带的。所以就不用配置了。如果没有则，在此目录下创建一个名为：baidu-push.swig 文件。然后添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> theme.<span class="property">baidu_push</span> %&#125;</span><br><span class="line">  &lt;script&#123;&#123; pjax &#125;&#125;&gt;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> bp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">      <span class="keyword">var</span> curProtocol = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">      bp.<span class="property">src</span> = (curProtocol === <span class="string">&#x27;https&#x27;</span>) ? <span class="string">&#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;</span> : <span class="string">&#x27;http://push.zhanzhang.baidu.com/push.js&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">      s.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(bp, s);</span><br><span class="line">    &#125;)();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162355124.png" alt="手动提交"></p><p>然后就是等待收录了，反正百度收录慢得要死。</p><h2 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h2><p>提交谷歌搜索引擎比较简单，在提交之前，我们依然可以使用 site:域名 查看网站是否被收录。进入谷歌站长，登录你的谷歌账号。然后如下操作，要是第一次就弹出一个让你输入域名的提示框，就直接输入你要收录的网站域名就行。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162355999.png" alt="选择资源类型"></p><p>选择第一个或者第二个都可以的，我两个都做了，也与百度的类似。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162355075.png" alt="验证所有权"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162355835.png" alt="验证所有权"></p><p>你也可以下载个 HTML 文件然后放在站点目录下的 source 中，然后推送到服务器。或者把 content 中的字符串复制到<code>主题配置文件</code>中的 google_site_verification 就好。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Google Webmaster tools verification.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See: https://www.google.com/webmasters</span></span><br><span class="line">google_site_verification:</span><br></pre></td></tr></table></figure><p>输入完就不用去理了。第二天会自动收录。</p><h2 id="其他收录"><a href="#其他收录" class="headerlink" title="其他收录"></a>其他收录</h2><p>其他搜索引擎的收录都很类似，就不一一赘述了。</p><h2 id="url持久化"><a href="#url持久化" class="headerlink" title="url持久化"></a>url持久化</h2><p>我们可以发现 hexo 默认生成的文章地址路径是 【网站名称／年／月／日／文章名称】。</p><p>这种链接对搜索爬虫是很不友好的，第一它的 url 结构超过了三层，太深了。<br>下面我推荐一种方式：安装 hexo-abbrlink</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>然后配置_config.yml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">permalink: archives/:abbrlink.html</span></span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure><p>之后部署一下，就看到你的链接变成了这样：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162355244.png" alt="image-20211129223653846"></p><h2 id="添加nofollow标签"><a href="#添加nofollow标签" class="headerlink" title="添加nofollow标签"></a>添加nofollow标签</h2><p>给非友情链接的出站链接添加「nofollow」标签，nofollow 标签是由谷歌领头创新的一个「反垃圾链接」的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-nofollow --save</span><br></pre></td></tr></table></figure><p>再在站点的<code>_config.yml</code>中添加配置，将 nofollow 设置为 true 这样，例外的链接将不会被加上 nofollow 属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nofollow:</span><br><span class="line">  enable: true</span><br><span class="line">  field: site</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;exclude1.com&#x27;</span><br><span class="line">    - &#x27;exclude2.com&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo 搭建个人博客（三）：使用 GitHub Actions 实现 Hexo 博客自动部署</title>
      <link href="/posts/9e797af3.html"/>
      <url>/posts/9e797af3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-相关知识点"><a href="#Hexo-相关知识点" class="headerlink" title="Hexo 相关知识点"></a>Hexo 相关知识点</h2><p>静态博客简单，但是发布博文时稍显麻烦，一般需要下面两步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d // 相当于 hexo g + hexo d</span><br></pre></td></tr></table></figure><p>如果考虑到同步源文件，还需要每次更改后，将源文件 push 到指定仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>我们可以将 Hexo 文件分为两类，一类是源文件，即下面这些文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>一类是 public 文件，即网站文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">├── 2020</span><br><span class="line">├── categories</span><br><span class="line">├── tags</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>发布博文的这三个操作代表：</p><ul><li>hexo clean：删除网站（public）文件</li><li>hexo g：生成网站（public）文件</li><li>hexo d：将本地网站（public）文件同步到指定仓库（如：yourname.github.io）中</li></ul><p>我使用一个私有仓库存放 Hexo 源文件，在 deppwang/deppwang.github.io 中存放网站文件。所以每次发布或者更新博文时，需要使用 push 操作更新源文件，再执行 <code>hexo clean</code>、<code>hexo g -d</code> 更新博客，比较麻烦,而且github在国内经常登录不上。</p><p>所以我们希望能在 push 源文件后，由 <a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">CI/CD</a>（持续集成/持续部署）工具为我们执行 <code>hexo clean</code>、<code>hexo g -d</code> 这两个操作。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162350983.png" alt="Image result for github action"></p><h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p>CI/CD 工具前有 Travis CI，现有 GitHub Actions，这里使用 GitHub Actions。</p><p>GitHub Actions 的工作原理：我们提前设置好需要自动化执行的任务，GitHub Actions 监控当前仓库的某一个操作（如：push），一旦有此操作，就自动化执行这些任务。</p><p>所以我们希望使用 GitHub Actions 后，只需要往源文件仓库 push 更新源文件，GitHub Actions 监控到 push 操作时，就自动化执行 <code>hexo clean</code>、<code>hexo g -d</code> 操作，完成博文发布。</p><p>Action 存放在项目根目录的 <code>.github/workflows</code> 下，后缀为 <code>.yml</code>。一个 Action 相当于一个工作流 workflow，一个工作流可以有多个任务 job，每个任务可以分为几步 step。任务、步骤依次执行。</p><p>每个 Action 是一个独立脚本，所以可以作为代码仓库。</p><ul><li><code>actions/setup-node</code> 就表示 <code>github.com/actions/setup-node</code> 这个 <a href="https://github.com/actions/setup-node">仓库</a>，代表安装 node.js。Action 为 action.yml</li></ul><p>可以通过下面这种格式来使用别人写好的 action，@借用了指针的概念：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actions/setup-node@74bc508 # 指向一个 commit</span><br><span class="line">actions/setup-node@v1.0    # 指向一个标签</span><br><span class="line">actions/setup-node@master  # 指向一个分支</span><br></pre></td></tr></table></figure><p>关于 GitHub Actions 更多知识，请看 <a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程 - 阮一峰</a>。</p><p>现在需要实现一个 Action，使其能够执行 <code>hexo clean</code>、<code>hexo g -d</code> 操作。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162350352.png" alt="Image result for hexo action"></p><h2 id="Hexo-Action"><a href="#Hexo-Action" class="headerlink" title="Hexo Action"></a>Hexo Action</h2><p>非第一次生成 SSH Key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t </span><br></pre></td></tr></table></figure><p>将生成的 <code>public key</code> 作为网站文件仓库 <code>Settings &gt; Deploy Keys</code> 的 Deploy Key。Deploy Keys 中的公钥针对于当前仓库。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162351185.png" alt="image-20211219145647038"></p><p>将生成的 <code>private key</code> 作为 Hexo 源文件仓库 <code>Settings &gt; Secrets</code> 的 一个名叫 <code>DEPLOY_KEY</code> 的 <code>Secret</code>。注意：需要复制包括 <code>-----BEGIN OPENSSH PRIVATE KEY-----</code> 和 <code>-----END OPENSSH PRIVATE KEY-----</code> 的整个内容。Secret 相当于一个变量，可以使私有变量不公开。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162351777.png" alt="image-20211219145921537"></p><p>为什么要用 SSH Key？</p><ul><li>SSH Key，是一对密匙：公钥+私钥，用于加密本地仓库和远程仓库的传输内容。是非对称加密，可公钥加密、私钥解密；或私钥加密、公钥解密。</li><li>使用 GitHub Actions 是借助 GitHub 提供的环境，跟本地环境一样，也需要有私钥。当 GitHub Action 执行 <code>hexo g -d</code> 时，用私钥 DEPLOY_KEY 加密，GitHub 用网站文件仓库的 Deploy Key 进行验证。</li></ul><h2 id="创建-workflow"><a href="#创建-workflow" class="headerlink" title="创建 workflow"></a>创建 workflow</h2><p>在私人代码仓库里点 Actions<br> 然后创建一个新文件 <code>.github/workflows/deploy.yml</code><br> deploy 名字可以自取但是一定要放在<code>.github/workflows</code>目录中</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162351965.png" alt="image-20211219150406411"></p><ul><li>deploy.yml 内容如下：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-18.04</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">github.event.repository.owner.id</span> <span class="string">==</span> <span class="string">github.event.sender.id</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 700 ~/.ssh</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;改成你的邮箱&quot;</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;改成你的用户名&quot;</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo deploy</span></span><br></pre></td></tr></table></figure><h2 id="发布成功"><a href="#发布成功" class="headerlink" title="发布成功"></a>发布成功</h2><p>之后只要修改文章后将源码推送到github仓库，就可以在Action中看到自动编译发布的过程。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162351540.png" alt="image-20211219150757637"></p><h2 id="可能出现的问题：Deploy-失败"><a href="#可能出现的问题：Deploy-失败" class="headerlink" title="可能出现的问题：Deploy 失败"></a>可能出现的问题：Deploy 失败</h2><p>可能出现以下 3 三种情况：</p><h3 id="1、"><a href="#1、" class="headerlink" title="1、"></a><strong>1、</strong></h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162351733.png" alt="image-20200215220503185"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host key verification failed</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>出现此问题请检查 <code>站点配置文件</code>，看 deploy 是否存在出 GitHub 以外的仓库，如 Coding 。</p><p>解决方式：去除 GitHub 以外的仓库。</p><h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a><strong>2、</strong></h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162351995.png" alt="image-20200215220635619"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load key &quot;/root/ssh/id_rsa&quot;: invalid format</span><br><span class="line">gitagithub.com: Permission denied (publickey)</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>出现此问题请检查 SSH Key，看 Private Key 是否正确且完整的复制</p><h3 id="3、"><a href="#3、" class="headerlink" title="3、"></a><strong>3、</strong></h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162351801.png" alt="image-20200216183926423"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found in /github/workspace</span><br><span class="line">ERROR Try running: &#x27;npm install hexo --save&#x27;</span><br></pre></td></tr></table></figure><p>解决方式：将 <code>uses: sma11black/hexo-action@v1.0.0</code> 改为 <code>uses: deppwang/hexo-aciton@v1.0.1</code>，<code>@v1.0.1</code> 在 <code>entrypoint.sh</code> 中 <code>hexo g -d</code> 前添加了命令 <code>npm install hexo --save</code></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo 搭建个人博客（二）：使用GitHub PicGod搭建图床</title>
      <link href="/posts/be96b5b1.html"/>
      <url>/posts/be96b5b1.html</url>
      
        <content type="html"><![CDATA[<h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>图床这是个老生常谈的问题了，流行过不少的图床但是基本都凉凉了。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>图床是个啥东西就不用过多介绍了，先来对比一下各路图床：</p><ul><li><del>微博图床：以前用的人比较多，从2019年4月开始开启了防盗链，凉凉</del></li><li><del>SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧</del></li><li><del>其他小众图床：随时有挂掉的风险</del></li><li><del>Imgur等国外图床：国内访问速度太慢，随时有被墙的风险</del></li></ul><ul><li>语雀图床，语雀用的oss本来挺好用，也开启防盗链了</li><li>大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，容量限制，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说）</li><li>Github图床<br>Gitee 图床</li></ul><p>如果舍得花钱可以选择大厂存储服务，定期交流量费即可。略过第2步直接往下看，如果喜欢稳定且免费的图床可以继续往下看gitee 就是github在国内的一个翻版，操作基本一致，github有时候访问会有抽风现象，原因你懂的 毕竟方校长的GFW不是吃素的。</p><p>因此，GitHub 图床是个不错的选择，利用 jsDelivr CDN 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo 工具一键上传，操作简单高效，GitHub 和 jsDelivr 都是大厂，不用担心跑路问题，不用担心速度和容量问题，而且完全免费，可以说是目前免费图床的最佳解决方案！</p><h2 id="搭建github仓库图床"><a href="#搭建github仓库图床" class="headerlink" title="搭建github仓库图床"></a>搭建github仓库图床</h2><p>登录/注册GitHub，新建一个仓库，填写好仓库名，仓库描述，根据需求选择是否为仓库初始化一个README.md描述文件</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162349301.png" alt="在这里插入图片描述"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162349469.png" alt="在这里插入图片描述"></p><ul><li>生成Token</li></ul><p>在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162349632.png" alt="在这里插入图片描述"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162350079.png" alt="在这里插入图片描述"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162350638.png" alt="在这里插入图片描述"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162350187.png" alt="在这里插入图片描述"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162350841.png" alt="在这里插入图片描述"></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p>前往<a href="https://github.com/Molunerfinn/picgo/releases">下载PicGo</a>，安装好后开始配置图床</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162350359.png" alt="在这里插入图片描述"></p><p>设定仓库名：按照【用户名/图床仓库名】的格式填写</p><p>设定分支名：【main】</p><p>设定Token：粘贴之前生成的【Token】</p><p>指定存储路径：填写想要储存的路径，如【ITRHX-PIC/】，这样就会在仓库下创建一个名为 ITRHX-PIC 的文件夹，图片将会储存在此文件夹中</p><p>设定自定义域名：它的作用是，在图片上传后，PicGo 会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，并放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【<a href="https://cdn.jsdelivr.net/gh/用户名/图床仓库名">https://cdn.jsdelivr.net/gh/用户名/图床仓库名</a> 】，上传完毕后，我们就可以通过【<a href="https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径">https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径</a> 】加速访问我们的图片了，比如上图的图片链接为：<a href="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/08.jpg">https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/08.jpg</a></p><p>参考上面创建了一个仓库如下图</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162350040.png" alt="在这里插入图片描述"></p><p>至此免费图床搭建完成。可以使用PicGo 工具 愉快的上传图片了，直接粘贴在markdown博客编写工具中就可以了。</p><p>图片不能重复上传，因为都会在同一个目录下，重复上传会有重名错误。</p><h2 id="进行图片上传"><a href="#进行图片上传" class="headerlink" title="进行图片上传"></a>进行图片上传</h2><p>配置好PicGo后，我们就可以进行高效创作了，将图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的，此外PicGo还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo 搭建个人博客（一）</title>
      <link href="/posts/c137e341.html"/>
      <url>/posts/c137e341.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo ?"></a><strong>什么是Hexo ?</strong></h2><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162345842.jpg" alt="img"></p><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：<a href="https://link.zhihu.com/?target=https%3A//github.com/hexojs/hexo">hexojs/hexo</a> 如果想要更加全面的了解Hexo，可以到其官网 <a href="https://link.zhihu.com/?target=https%3A//hexo.io/">Hexo</a> 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。</p><p><strong>这是我的个人博客效果:</strong> <a href="liuyingbo.com">刘英博 · Hawk</a></p><p>下面正式从零开始搭建年轻人的第一个网站。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="获得个人网站域名"><a href="#获得个人网站域名" class="headerlink" title="获得个人网站域名"></a>获得个人网站域名</h3><p>域名是网站的入口，也是网站的第一印象，比如饿了么的官网的域名是：<a href="https://link.zhihu.com/?target=https%3A//www.ele.me/">https://www.ele.me/</a> ，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀，比如我选择就是常见的com后缀。很多小众奇特的后缀在大陆是没办法备案的，网站也就无法上线。然而使用GitHub托管我们的网站，完全不需要备案，因为托管我们的网站内容的服务器在美国，而且在国内备案流程也比较繁杂，时间需要一周左右。</p><p>申请域名的地方有很多，这里推荐阿里云：<a href="https://link.zhihu.com/?target=https%3A//www.aliyun.com/">阿里云-为了无法计算的价值</a> 申请入口：<a href="https://link.zhihu.com/?target=https%3A//wanwang.aliyun.com/domain/">域名注册</a> 购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用即可。</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a><strong>GitHub创建个人仓库</strong></h3><p>登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：<a href="https://link.zhihu.com/?target=https%3A//github.com/">Build software better, together</a> 点击GitHub中的New repository创建新仓库，仓库名应该为：<strong>用户名</strong>.<a href="https://link.zhihu.com/?target=http%3A//github.io">http://github.io</a> 这个<strong>用户名</strong>使用你的GitHub帐号名称代替，这是固定写法</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a><strong>安装Git</strong></h3><p>什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看<a href="https://link.zhihu.com/?target=http%3A//weibo.com/liaoxuefeng">廖雪峰</a>老师的Git教程：<a href="https://link.zhihu.com/?target=http%3A//www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程</a> 从Git官网下载：<a href="https://link.zhihu.com/?target=https%3A//git-scm.com/download/win">Git - Downloading Package</a> 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入<code>git --version</code>测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">liuyingbo@liuyingbodeMacBook-Pro ~ % git --version</span><br><span class="line">git version 2.32.0 (Apple Git-132)</span><br></pre></td></tr></table></figure><p>在命令行里，设置user.name和user.email配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>生成ssh密钥文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t</span><br></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复，Mac打开隐藏文件显示<code>Shift+Command+.</code>，windows应该在C盘。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162330967.png" alt="image-20211219141017633"></p><p>打开<a href="https://link.zhihu.com/?target=https%3A//github.com/settings/keys">GitHub_Settings_keys</a> 页面，新建new SSH Key</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162330086.jpg" alt="img"></p><p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，输入<code>ssh git@github.com</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">liuyingbo@liuyingbodeMacBook-Pro ~ % ssh git@github.com</span><br><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi liuyingbor! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">Connection to github.com closed.</span></span><br></pre></td></tr></table></figure><p>如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a><strong>安装Node.js</strong></h3><p>Hexo基于Node.js，Node.js下载地址：<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/download/">Download | Node.js</a> 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入<code>node -v</code>,出现版本号说明成功:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">liuyingbo@liuyingbodeMacBook-Pro ~ % node -v</span><br><span class="line">v14.15.1</span><br></pre></td></tr></table></figure><p>检测npm是否安装成功，在命令行中输入<code>npm -v</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">liuyingbo@liuyingbodeMacBook-Pro ~ % npm -v</span><br><span class="line">8.1.3</span><br></pre></td></tr></table></figure><p>到这了，安装Hexo的环境已经全部搭建完成。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h2><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，进入文件夹中，打开命令行</p><p>使用npm命令安装Hexo，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure><p>这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>注意，这里的命令都是作用在刚刚创建的Blog文件夹中。</p><p>为了检测我们的网站雏形，分别按顺序输入以下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new 我的第一个博客</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>这些命令在后面作介绍，完成后，打开浏览器输入地址：localhost:4000</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162331379" alt="img"></p><p>现在来介绍常用的Hexo 命令</p><p>npm install hexo -g #安装Hexo<br>npm update hexo -g #升级<br>hexo init #初始化博客</p><p>命令简写<br>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy #部署</p><p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p><p>刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。</p><h2 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a><strong>推送网站</strong></h2><p>上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为<strong>站点</strong>配置文件，</p><p>进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为<strong>主题</strong>配置文件，如下图</p><p>下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p><p>deploy:<br>type: git<br>repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git<br>branch: 切记githun现在将master改为main了，因为master有奴隶的意思参考如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy</span>:</span><br><span class="line">  - <span class="attr">type</span>: git</span><br><span class="line">    repository : git@github.<span class="property">com</span>:liuyingbor/liuyingbor.<span class="property">github</span>.<span class="property">io</span>.<span class="property">git</span></span><br><span class="line">    <span class="attr">branch</span>: main</span><br></pre></td></tr></table></figure><p>保存站点配置文件。</p><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这时，我们分别输入三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 <a href="https://link.zhihu.com/?target=http%3A//xxxx.github.io">http://xxxx.github.io</a> 比如我的xxxx就是我的GitHub用户名：<a href="http://liuyingbor.github.io">http://liuyingbor.github.io</a></p><p>你就会发现你的博客已经上线了，可以在网络上被访问了。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a><strong>绑定域名</strong></h2><p>虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:<a href="https://link.zhihu.com/?target=http%3A//xxxx.github.io">http://xxxx.github.io</a> (知乎排版可能会出现”<a href="http://&quot;字样">http://&quot;字样</a>) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162331398.png" alt="image-20211219143141062"></p><p>然后添加解析,包括添加两条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 <a href="https://link.zhihu.com/?target=http%3A//xxxx.github.io">http://xxxx.github.io</a> 的ip地址，填入进去。第二个记录类型是CNAME，CNAME的记录值是：你的用户名.<a href="https://link.zhihu.com/?target=http%3A//github.io">http://github.io</a> 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Github Page，输入你的域名</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162331500.png" alt="image-20211219145146663"></p><p>点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这个文件的作用是防止每次发布博客时候因为重新编译导致之前设置的域名消失。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162331850.png" alt="image-20211219143530159"></p><p>保存，命名为CNAME ，注意保存成<strong>所有文件</strong>也就是无后缀的文件而不是<strong>txt文件</strong>。</p><p>完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a><strong>更换主题</strong></h2><p>如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：<a href="https://butterfly.js.org/">Butterfly</a> 我自己使用的是Butterfly主题，可以在blog目录中的themes文件夹中查看你自己主题是什么。现在把默认主题更改成Butterfly主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>修改 Hexo 根目錄下的 _config.yml，把主題改為butterfly。下面是效果图，具体的设置参考官网吧。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211162334762.png" alt="效果图"></p><h2 id="初识Markdown语法"><a href="#初识Markdown语法" class="headerlink" title="初识Markdown语法"></a><strong>初识Markdown语法</strong></h2><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown语法简洁明了、容易掌握，而且功能比纯文本更强，因此写博客使用它，可以让用户更加专注的写文章，而不需要费尽心力的考虑样式，相对于html已经算是轻量级语言，像有道云笔记也支持Markdown写作。并且Markdown完全兼容html，也就是可以在文章里直接插入html代码。比如给博文添加音乐，就可以直接把音乐的外链html代码插入文章中。具体语法参看：<a href="https://link.zhihu.com/?target=http%3A//www.appinn.com/markdown/">Markdown 语法说明(简体中文版)</a> 可以说十分钟就可以入门。当然，工欲善其事必先利其器，选择一个好的Markdown编辑器也是非常重要的，这里推荐<a href="https://www.typora.net/">Typora</a> ，这个最新版已经开始收费了，也可以使用本地的文本编辑器，更多的Markdown的语法与编辑器自己可以搜索了解。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>终于写到这里了，也算是基本圆满完成了我的写作初衷，总结自己的一些经验，分享一些有趣的东西，不过脖子也是僵硬的受不了。我知道很多人想要建立自己的个人网站却一直没有付诸行动，希望这篇文章能给你一点点灵感与想法，just do it。本文是github平台的搭建过程，其他平台可以参看相关资料，也有很多其他优秀的博客框架值得学习。如果有任何建议或想法、或疑问欢迎在评论区交流， 做好的网站不妨在评论区贴出网址，让大家一起学习。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"狼唤`Blog","short_name":"狼唤","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/color.css"/>
      <url>/css/color.css</url>
      
        <content type="html"><![CDATA[/* 颜色 */:root {    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-gray-op: #9999992b;    --anzhiyu-theme-top: var(--anzhiyu-theme);    --anzhiyu-white: #fff;    --anzhiyu-white-op: rgba(255, 255, 255, 0.2);    --anzhiyu-black: #000;    --anzhiyu-black-op: rgba(0, 0, 0, 0.2);    --anzhiyu-none: rgba(0, 0, 0, 0);    --anzhiyu-gray: #999999;    --anzhiyu-yellow: #ffc93e;    --anzhiyu-border-radius: 8px;    --anzhiyu-main: var(--anzhiyu-theme);    --anzhiyu-main-op: var(--anzhiyu-theme-op);    --anzhiyu-shadow-theme: 0 8px 12px -3px var(--anzhiyu-theme-op);    --anzhiyu-shadow-main: 0 8px 12px -3px var(--anzhiyu-main-op);    --anzhiyu-shadow-blue: 0 8px 12px -3px rgba(40, 109, 234, 0.2);    --anzhiyu-shadow-white: 0 8px 12px -3px rgba(255, 255, 255, 0.2);    --anzhiyu-shadow-black: 0 0 12px 4px rgba(0, 0, 0, 0.05);    --anzhiyu-shadow-yellow: 0px 38px 77px -26px rgba(255, 201, 62, 0.12);    --anzhiyu-shadow-red: 0 8px 12px -3px #ee7d7936;    --anzhiyu-shadow-green: 0 8px 12px -3px #87ee7936;    --anzhiyu-shadow-border: 0 8px 16px -4px #2c2d300c;    --anzhiyu-shadow-blackdeep: 0 2px 16px -3px rgba(0, 0, 0, 0.15);    --anzhiyu-logo-color: linear-gradient(215deg, #4584ff 30%, #ff7676 70%);    --style-border: 1px solid var(--anzhiyu-card-border);    --anzhiyu-blue-main: #3b70fc;    --style-border-hover: 1px solid var(--anzhiyu-main);    --style-border-dashed: 1px dashed var(--anzhiyu-theme-op);    --style-border-avatar: 4px solid var(--anzhiyu-background);    --style-border-always: 1px solid var(--anzhiyu-card-border);    --anzhiyu-white-acrylic1: #fefeff !important;    --anzhiyu-white-acrylic2: #fcfdff !important;    --anzhiyu-black-acrylic2: #08080a !important;    --anzhiyu-black-acrylic1: #0b0b0e !important;    --anzhiyu-main-none: #b8b8b800 !important;  }    [data-theme="light"] {    --anzhiyu-theme: #3b70fc;    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-blue: #3b70fc;    --anzhiyu-red: #d8213c;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #363636;    --anzhiyu-background: #f7f9fe;    --anzhiyu-reverse: #000;    --anzhiyu-maskbg: rgba(255, 255, 255, 0.6);    --anzhiyu-maskbgdeep: rgba(255, 255, 255, 0.85);    --anzhiyu-hovertext: var(--anzhiyu-theme);    --anzhiyu-ahoverbg: #f7f7fa;    --anzhiyu-lighttext: var(--anzhiyu-main);    --anzhiyu-secondtext: rgba(60, 60, 67, 0.6);    --anzhiyu-scrollbar: rgba(60, 60, 67, 0.4);    --anzhiyu-card-btn-bg: #edf0f7;    --anzhiyu-post-blockquote-bg: #fafcff;    --anzhiyu-post-tabs-bg: #f2f5f8;    --anzhiyu-secondbg: #edf0f7;    --anzhiyu-shadow-nav: 0 5px 12px -5px rgba(102, 68, 68, 0.05);    --anzhiyu-card-bg: #fff;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #c0c6d8;  }    [data-theme="dark"] {    --global-bg: #191919;    --anzhiyu-theme: #0084ff;    --anzhiyu-theme-op: #0084ff23;    --anzhiyu-blue: #0084ff;    --anzhiyu-red: #ff3842;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #f7f7fa;    --anzhiyu-background: #18171d;    --anzhiyu-reverse: #fff;    --anzhiyu-maskbg: rgba(0, 0, 0, 0.6);    --anzhiyu-maskbgdeep: rgba(0, 0, 0, 0.85);    --anzhiyu-hovertext: #0a84ff;    --anzhiyu-ahoverbg: #fff;    --anzhiyu-lighttext: #f2b94b;    --anzhiyu-secondtext: #a1a2b8;    --anzhiyu-scrollbar: rgba(200, 200, 223, 0.4);    --anzhiyu-card-btn-bg: #30343f;    --anzhiyu-post-blockquote-bg: #000;    --anzhiyu-post-tabs-bg: #121212;    --anzhiyu-secondbg: #30343f;    --anzhiyu-shadow-nav: 0 5px 20px 0px rgba(28, 28, 28, 0.4);    --anzhiyu-card-bg: #1d1b26;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #42444a;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* 鼠标图标 */  body {    cursor: url("/img/x1.cur"), auto;  }  a,  [type="button"]:not(:disabled),  [type="reset"]:not(:disabled),  [type="submit"]:not(:disabled),  button:not(:disabled) {    cursor: url("/img/x2.cur"), auto !important;  }  /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }  .pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;  }    .pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;  }    .pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;  }    .pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;  }  @keyframes gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }  #aside-content .aside-list > .aside-list-item .content > time {    display: none;  }  #aside-content .aside-list > .aside-list-item .content > .title {    -webkit-line-clamp: 3;    font-weight: 700;    padding: 2px 0;  }  #aside-content .aside-list > .aside-list-item {    padding: 8px;    padding-top: 6px !important;    padding-bottom: 6px !important;    border-radius: 12px;    transition: 0.3s;    margin: 4px 0;    cursor: pointer;  }  @media screen and (min-width: 1300px) {    #aside-content .aside-list > .aside-list-item:hover {      transform: scale(1.03);    }    #aside-content .aside-list > .aside-list-item:active {      transform: scale(0.97);    }  }  #aside-content .aside-list > .aside-list-item:hover .thumbnail > img {    transform: scale(1);  }  #aside-content .aside-list > .aside-list-item:not(:last-child) {    border-bottom: 0 dashed var(--anzhiyu-background) !important;  }  #aside-content .aside-list > .aside-list-item .thumbnail {    border-radius: 8px;    border: var(--style-border);  }  #aside-content .aside-list > .aside-list-item:hover {    background: var(--anzhiyu-blue-main);    color: var(--anzhiyu-white);    transition: 0.3s;    box-shadow: var(--anzhiyu-shadow-main);  }  #aside-content .aside-list > .aside-list-item:hover a {    color: var(--anzhiyu-white) !important;  }  .card-widget.card-recent-post {    padding: 0.4rem 0.6rem !important;  }  /* 归档样式 */span.card-archive-list-count {  width: auto;  text-align: left;  font-size: 1.5rem;  line-height: 0.9;  font-weight: 700;}.card-archive-list-count-group {  display: flex;  flex-direction: row;  align-items: baseline;}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a span:last-child,#aside-content .card-categories ul.card-category-list > .card-category-list-item a span:last-child {  width: fit-content;  margin-left: 4px;}span.card-archive-list-count {  width: auto;  text-align: left;  font-size: 1.1rem;  line-height: 0.9;  font-weight: 700;}.card-archive-list-date {  font-size: 14px;  opacity: 0.6;}li.card-archive-list-item {  width: 100%;  flex: 0 0 48%;}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:hover,#aside-content .card-categories ul.card-category-list > .card-category-list-item a:hover {  color: var(--anzhiyu-white);  background-color: var(--anzhiyu-theme);  box-shadow: var(--anzhiyu-shadow-theme);  border-radius: 8px;  padding-left: 0.5rem;  padding-right: 0.5rem;}@media screen and (min-width: 1300px) {  #aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:hover,  #aside-content .card-categories ul.card-category-list > .card-category-list-item a:hover {    transform: scale(1.03);  }  #aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:active,  #aside-content .card-categories ul.card-category-list > .card-category-list-item a:active {    transform: scale(0.97);  }}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a,#aside-content .card-categories ul.card-category-list > .card-category-list-item a {  border-radius: 8px;  margin: 4px 0;  display: flex;  flex-direction: column;  align-content: space-between;  border: var(--style-border);}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a span:first-child,#aside-content .card-categories ul.card-category-list > .card-category-list-item a span:first-child {  width: auto;  flex: inherit;}#aside-content .card-archives ul.card-archive-list,#aside-content .card-categories ul.card-category-list {  display: flex;  flex-direction: row;  justify-content: space-between;  flex-wrap: wrap;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener("visibilitychange", function () {  if (document.hidden) {    //离开当前页面时标签显示内容    document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";    clearTimeout(titleTime);  } else {    //返回当前页面时标签显示内容    document.title = "♪(^∇^*)欢迎肥来！" + OriginTitile;    //两秒后变回正常标题    titleTime = setTimeout(function () {      document.title = OriginTitile;    }, 2000);  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[!(function (c) {    var l,      h,      a,      t,      i,      v =        '<svg><symbol id="icon-dragon_chen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-498.122105 265.620211L431.157895 754.526316V485.052632h-66.074948c-14.470737 110.645895-44.355368 197.066105-102.696421 260.742736l-39.747368-36.432842C306.526316 617.876211 323.368421 462.901895 323.368421 242.526316V215.578947h377.263158v53.894737H377.182316c-0.404211 58.260211-2.209684 112.128-6.359579 161.684211H700.631579v53.894737h-122.152421a481.172211 481.172211 0 0 0 76.826947 119.70021l66.479158-39.855158 27.728842 46.214737-54.460631 32.687158c29.507368 24.953263 63.757474 45.675789 102.80421 58.098526l-16.303158 51.361684c-134.224842-42.711579-222.773895-167.073684-261.551158-268.207157H485.052632v221.857684l68.985263-41.391158 27.728842 46.214737-109.783579 65.886316zM646.736842 377.263158h-215.578947v-53.894737h215.578947v53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-dog_xu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-375.592421 150.393263c33.684211 44.544 75.210105 74.698105 124.739369 90.812632l11.425684 3.718737 10.401684-6.009264C781.204211 727.740632 808.421053 622.565053 808.421053 592.842105h-53.894737c0 22.069895-19.132632 80.869053-33.711158 103.504842-34.816-14.605474-64.538947-39.262316-89.249684-74.13221 48.316632-55.269053 92.079158-117.328842 120.535579-179.900632l-49.044211-22.285473c-23.767579 52.250947-59.742316 104.717474-100.055579 152.656842-24.010105-50.930526-41.148632-115.927579-51.658105-195.395369H700.631579v-53.894737h-155.189895A1848.050526 1848.050526 0 0 1 538.947368 161.684211h-53.894736c0 58.206316 2.155789 112.074105 6.494315 161.68421H323.368421v26.947368c0 216.549053-13.177263 263.545263-100.702316 359.046737l39.747369 36.432842c63.326316-69.093053 92.806737-118.272 105.714526-206.848H485.052632v-53.894736h-111.319579a1742.147368 1742.147368 0 0 0 3.449263-107.789474h120.158316c12.611368 98.250105 35.031579 177.475368 67.395368 238.187789-61.978947 65.536-128.053895 117.975579-173.298526 142.282106l25.519158 47.481263c47.589053-25.573053 114.095158-77.446737 177.55621-142.821053z m125.170526-411.971368l-80.842105-80.842106-38.103579 38.103579 80.842105 80.842106 38.103579-38.103579z" fill="#231F20" ></path></symbol><symbol id="icon-dog" viewBox="0 0 1024 1024"><path d="M894.814316 904.434526l83.240421-183.134315-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939369-185.263158-0.134737-7.922526-0.134737-33.953684-0.134736-55.996631-30.693053 15.306105-70.090105 19.887158-106.09179 19.887157-92.752842 0-163.624421-23.983158-210.647579-71.275789a192.512 192.512 0 0 1-27.944421-36.513684H377.263158v377.263158c342.662737 0 403.105684 51.092211 494.592 128.377263 7.922526 6.682947 15.521684 13.312 22.959158 19.86021z" fill="#85C3DE" ></path><path d="M326.063158 282.947368c0 34.250105-13.231158 44.463158-29.642105 44.463158s-29.642105-10.213053-29.642106-44.463158c0-34.223158 13.231158-44.463158 29.642106-44.463157s29.642105 10.24 29.642105 44.463157zM269.473684 430.295579v311.646316L190.275368 916.210526h59.203369L323.368421 753.637053V377.263158h-26.947368c-119.403789 0-172.732632-53.382737-185.505685-107.789474h35.624421c51.092211 0 68.581053-15.764211 120.535579-62.544842 12.773053-11.506526 28.079158-25.276632 47.023158-41.741474l18.351158-15.952842-69.658947-99.139368-44.085895 30.989474 41.768421 59.472842c-11.183158 9.862737-20.884211 18.593684-29.480421 26.327579C180.736 212.156632 176.235789 215.578947 146.539789 215.578947H53.894737v26.947369c0 88.710737 66.910316 178.149053 215.578947 187.769263z m216.710737-161.414737c2.290526 71.733895 28.698947 136.326737 75.048421 182.918737C618.711579 509.628632 702.437053 538.947368 810.091789 538.947368c18.593684 0 36.190316-1.158737 52.628211-3.449263 3.745684 111.265684 33.630316 170.334316 51.496421 196.015158l-38.507789 84.722526C782.174316 742.049684 688.774737 700.631579 377.263158 700.631579v53.894737c34.277053 0 65.697684 0.512 94.639158 1.509052L374.595368 970.105263h59.203369l96.013474-211.240421c66.182737 4.338526 117.005474 11.829895 157.911578 22.016L626.229895 916.210526h59.176421l54.16421-119.134315c47.616 18.405053 79.737263 42.091789 113.125053 69.739789L805.753263 970.105263h59.203369l113.071157-248.778105-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939368-185.263158C985.168842 498.553263 1024 447.811368 1024 377.263158c0-95.205053-66.506105-161.684211-161.684211-161.684211v53.894737c65.482105 0 107.789474 42.307368 107.789474 107.789474 0 89.088-87.013053 107.789474-160.013474 107.789474-92.752842 0-163.624421-23.983158-210.647578-71.27579-30.315789-30.504421-45.891368-65.832421-53.35579-98.735158 11.210105 6.952421 22.932211 13.338947 35.274105 19.186527l23.04-48.720843c-92.106105-43.654737-148.992-128.646737-219.243789-243.981473l-46.026105 28.05221c49.448421 81.246316 92.968421 148.506947 147.051789 199.302737z" fill="#231F20" ></path></symbol><symbol id="icon-goat" viewBox="0 0 1024 1024"><path d="M548.378947 646.736842a952.32 952.32 0 0 1 140.90779-161.68421H107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L66.721684 754.526316h417.172211c20.345263-41.472 43.654737-77.446737 64.485052-107.789474z" fill="#F7C768" ></path><path d="M608.256 144.734316C555.762526 115.577263 506.098526 107.789474 485.052632 107.789474V53.894737c32.579368 0 91.270737 11.452632 149.369263 43.735579 75.290947 41.822316 130.694737 94.531368 171.385263 150.878316C755.873684 288.013474 697.101474 323.368421 646.736842 323.368421h-107.789474v-53.894737h107.789474c20.506947 0 48.424421-11.210105 80.437895-31.285895a471.04 471.04 0 0 0-118.918737-93.453473zM832.673684 342.231579c-16.384 0-29.642105 10.24-29.642105 44.463158 0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642105-44.463158c0-34.223158-13.231158-44.463158-29.642105-44.463158zM1024 619.789474C1024 347.109053 901.066105 122.448842 686.753684 3.395368l-26.165895 47.104C914.324211 191.461053 964.688842 440.400842 969.647158 592.842105h-84.506947c-17.92-35.624421-45.352421-69.12-87.013053-101.995789l-16.788211-13.285053-16.734315 13.392842c-66.128842 52.897684-134.629053 127.083789-187.311158 209.677474H102.965895l-8.272842-20.318316C159.043368 617.013895 161.684211 603.109053 161.684211 485.052632v-53.894737h485.052631v-53.894737H161.684211c0-80.384 14.309053-110.026105 66.586947-137.916632l-25.384421-47.535158C123.365053 234.226526 107.789474 291.920842 107.789474 377.263158v107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L110.618947 862.315789h58.206316l-43.897263-107.789473h103.477895l43.897263 107.789473h58.206316l-43.897263-107.789473h259.47621C508.981895 824.939789 485.052632 899.152842 485.052632 970.105263h53.894736c0-68.688842 27.270737-144.060632 68.958316-215.578947H687.157895c7.410526 0 13.473684 6.063158 13.473684 13.473684V862.315789h53.894737v-94.315789c0-37.160421-30.208-67.368421-67.368421-67.368421h-44.65179c40.771368-58.017684 89.438316-111.427368 138.913684-153.626947C841.512421 600.037053 862.315789 655.225263 862.315789 754.526316h53.894737c0-38.912-2.748632-74.482526-11.102315-107.789474H1024v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-goat_wei" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 50.202947c52.304842 70.925474 136.973474 152.144842 232.528843 190.383158l19.994947-50.041263c-109.271579-43.708632-202.805895-152.629895-238.780632-217.49221H808.421053v-53.894737H538.947368v-53.894737h215.578948v-53.894737h-215.578948V161.684211h-53.894736v161.68421h-215.578948v53.894737h215.578948v53.894737H215.578947v53.894737h255.757474c-35.974737 64.862316-129.536 173.783579-238.807579 217.49221l20.021895 50.041263c95.528421-38.238316 180.197053-119.484632 232.501895-190.383158V808.421053h53.894736v-246.218106z" fill="#231F20" ></path></symbol><symbol id="icon-dragon" viewBox="0 0 1024 1024"><path d="M366.376421 344.441263l152.980211-152.98021c43.142737-43.142737 141.204211-9.216 270.201263 115.738947-15.225263 9.835789-25.114947 15.818105-44.13979 32.256s-38.076632 35.489684-59.418947 56.832c-4.203789 4.203789-51.173053 53.221053-78.740211 82.027789-10.805895-12.126316-22.743579-24.171789-34.654315-36.082526L493.136842 362.792421l-54.218105 54.218105-72.542316-72.569263zM862.315789 512c0 46.834526-45.352421 80.842105-107.789473 80.842105-108.948211 0-189.359158-28.806737-267.129263-56.697263C414.100211 509.871158 344.872421 485.052632 258.182737 485.052632 80.788211 485.052632 0 588.126316 0 683.897263h53.894737C73.216 659.779368 135.302737 646.736842 177.340632 646.736842c77.338947 0 223.124211 23.282526 291.893894 47.912421C547.462737 722.701474 615.989895 754.526316 734.315789 754.526316 862.315789 754.526316 916.210526 670.315789 916.210526 512h-53.894737z" fill="#FF8787" ></path><path d="M552.421053 1024c-69.766737 0-113.825684-13.958737-156.402527-27.459368-54.487579-17.273263-110.807579-35.004632-232.421052-26.516211l-3.826527-53.733053c131.718737-9.458526 195.934316 10.967579 252.52379 28.887579 42.226526 13.365895 78.686316 24.926316 140.126316 24.926316 92.752842 0 148.210526-57.936842 148.210526-113.960421 0-16.949895-5.524211-101.618526-114.634105-101.618526-64.970105 0-112.747789 23.336421-163.328 48.02021C365.325474 830.571789 300.301474 862.315789 204.288 862.315789 85.908211 862.315789 0 787.294316 0 683.897263 0 588.126316 80.788211 485.052632 258.182737 485.052632c86.689684 0 155.917474 24.818526 229.214316 51.09221 45.810526 16.410947 92.564211 33.172211 145.488842 44.166737 9.000421-7.033263 13.850947-16.276211 13.850947-26.758737 0-37.187368-37.672421-74.859789-74.13221-111.265684l-3.287579-3.287579 38.103579-38.103579 3.260631 3.287579C652.853895 446.275368 700.631579 494.026105 700.631579 553.552842c0 12.719158-2.802526 24.926316-7.976421 36.109474A594.997895 594.997895 0 0 0 754.526316 592.842105c62.437053 0 107.789474-34.007579 107.789473-80.842105 0-58.853053-52.870737-110.268632-108.840421-164.702316l-8.057263-7.841684c-19.024842 16.437895-38.076632 35.489684-59.418947 56.832l-38.103579-38.103579c74.805895-74.832842 134.898526-134.898526 268.314947-141.931789V55.619368c-63.407158 7.787789-120.993684 39.424-121.667368 39.801264l-15.818105 8.811789-14.120421-11.344842C731.701895 66.452211 709.712842 53.894737 673.684211 53.894737c-41.418105 0-74.347789 25.869474-109.190737 53.301895-26.624 20.911158-54.137263 42.549895-86.851369 53.194105L469.342316 161.684211h-69.093053l-105.525895 105.525894-38.103579-38.130526L324.015158 161.684211H161.684211V107.789474h303.104c22.231579-8.272842 43.708632-25.168842 66.398315-42.981053C569.829053 34.438737 613.618526 0 673.684211 0c48.909474 0 81.408 17.946947 110.888421 40.097684C813.702737 26.300632 877.729684 0 943.157895 0h26.947368v323.368421h-53.894737v-53.167158c-54.164211 3.098947-92.914526 15.845053-127.002947 36.675369l1.832421 1.778526C852.587789 368.505263 916.210526 430.376421 916.210526 512c0 60.928-43.708632 109.945263-107.789473 127.622737V700.631579h53.894736v-53.894737h53.894737v53.894737h53.894737v53.894737h-53.894737v53.894737h-53.894737v-53.894737h-53.894736c-29.722947 0-53.894737-24.171789-53.894737-53.894737v-53.894737c-118.325895 0-207.063579-31.797895-285.318737-59.877053C400.437895 562.229895 335.494737 538.947368 258.182737 538.947368 117.059368 538.947368 53.894737 611.732211 53.894737 683.897263 53.894737 757.221053 115.738947 808.421053 204.288 808.421053c11.910737 0 23.228632-0.538947 34.034526-1.536C248.454737 796.321684 269.473684 770.640842 269.473684 739.166316c0-33.118316-43.088842-70.979368-58.152421-81.596632l30.935579-44.139789c8.299789 5.793684 81.111579 58.664421 81.111579 125.736421 0 19.429053-4.527158 37.052632-10.994526 52.304842 30.773895-10.051368 58.314105-23.498105 86.662737-37.349053C452.877474 727.848421 508.577684 700.631579 585.997474 700.631579 702.410105 700.631579 754.526316 778.725053 754.526316 856.144842 754.526316 938.657684 678.912 1024 552.421053 1024z m-21.180632-623.104L493.136842 362.792421l137.889684-137.889684 38.103579 38.103579-137.889684 137.889684z m-126.760421-18.351158l-38.103579-38.103579 152.980211-152.98021 38.103579 38.103579-152.980211 152.98021z m282.004211-218.624c15.494737-9.754947 43.331368-31.447579 43.331368-31.447579-25.734737-27.809684-49.556211-33.333895-67.368421-29.07621-19.240421 4.608-37.753263 24.602947-37.753263 24.602947s42.253474 22.447158 61.790316 35.920842z" fill="#231F20" ></path></symbol><symbol id="icon-horse" viewBox="0 0 1024 1024"><path d="M776.003368 646.736842c16.599579-99.947789 43.439158-181.086316 83.213474-256.538947l6.817684-12.934737H269.473684c-36.756211 0-53.894737 54.945684-53.894737 92.05221 0 46.753684 6.656 77.527579 70.278737 176.074106l84.533895 128.269473L498.876632 646.736842h277.126736z" fill="#FFAF6E" ></path><path d="M1024 0v404.210526c0 33.333895 0 134.736842-92.079158 134.736842h-13.824l-78.362947-109.056c-22.743579 49.906526-40.340211 103.046737-53.490527 162.950737h115.092211C937.310316 592.842105 970.105263 625.637053 970.105263 661.638737c0 60.631579-69.389474 154.300632-77.312 164.75621l-43.008-32.471579C875.466105 759.861895 916.210526 693.813895 916.210526 661.638737c0-5.982316-8.919579-14.901895-14.901894-14.901895h-125.332211C761.128421 736.121263 754.526316 840.569263 754.526316 970.105263h-53.894737c0-283.971368 31.097263-453.605053 110.888421-605.049263l20.318316-38.534737 112.801684 156.995369c14.443789-4.419368 25.465263-20.938105 25.465263-79.306106V0h53.894737z m-161.684211 161.684211h53.894737V0h-53.894737v80.842105c-17.381053-14.955789-38.184421-26.947368-80.842105-26.947368h-134.736842v53.894737h134.736842c37.672421 0 80.842105 40.906105 80.842105 53.894737z m-107.789473 0h-215.578948v53.894736h161.684211l53.894737-53.894736zM300.894316 766.544842L400.680421 916.210526h64.754526l-95.043368-142.551579L498.876632 646.736842h167.855157a1212.631579 1212.631579 0 0 1 9.431579-53.894737h-199.383579l-175.885473 173.702737z m109.97221-184.400842l-37.861052-38.319158-132.419369 130.802526C173.729684 571.095579 161.684211 529.812211 161.684211 469.315368 161.684211 398.578526 199.464421 323.368421 269.473684 323.368421h323.368421l53.894737-53.894737H269.473684c-6.709895 0-13.258105 0.565895-19.698526 1.482105C234.927158 249.451789 204.638316 215.578947 160.633263 215.578947 65.967158 215.578947 0 349.291789 0 469.315368c0 70.170947 16.141474 136.650105 49.232842 202.671158L6.197895 723.833263l41.472 34.41179 66.128842-79.737264-8.704-16.033684C83.105684 622.133895 53.894737 558.214737 53.894737 469.315368 53.894737 368.451368 106.765474 269.473684 160.633263 269.473684c13.231158 0 25.815579 9.889684 35.43579 20.533895C142.874947 321.967158 107.789474 388.500211 107.789474 469.315368c0 78.201263 19.698526 130.937263 93.642105 243.981474l-55.296 54.622316L280.899368 970.105263h64.754527l-130.048-195.072 195.260631-192.889263z" fill="#231F20" ></path></symbol><symbol id="icon-monkey_shen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 134.736842h161.684211v53.894737h53.894737V269.473684h-215.578948V161.684211h-53.894736v107.789473h-215.578948v431.157895h53.894737v-53.894737h161.684211v215.578947h53.894736v-215.578947z m0-161.68421h161.684211v107.789473h-161.684211v-107.789473z m-215.578947 0h161.684211v107.789473h-161.684211v-107.789473z m215.578947-161.684211h161.684211v107.789474h-161.684211v-107.789474z m-215.578947 0h161.684211v107.789474h-161.684211v-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-ox_chou" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-161.68421 188.631579h-159.555369c13.985684-172.813474 43.115789-357.429895 70.817684-385.158737L700.631579 269.473684H323.368421v53.894737h107.169684c-1.940211 45.756632-8.192 103.962947-15.76421 161.684211H323.368421v53.894736h83.968c-9.862737 68.446316-20.264421 130.128842-25.734737 161.684211H215.578947v53.894737h592.842106v-53.894737z m-346.543158-161.684211h149.800421a3313.717895 3313.717895 0 0 0-16.842105 161.684211h-158.477474c6.036211-35.247158 16.114526-95.636211 25.519158-161.684211z m22.608842-215.578947h171.735579c-15.198316 41.121684-27.405474 100.594526-36.890948 161.684211h-150.123789c7.383579-57.505684 13.419789-115.361684 15.279158-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-monkey" viewBox="0 0 1024 1024"><path d="M757.733053 485.052632H565.894737a80.842105 80.842105 0 0 0-80.842105 80.842105v215.578947c0 40.96 43.546947 99.678316 77.446736 139.210105C596.426105 960.215579 603.055158 970.105263 603.055158 970.105263H754.526316s15.144421-18.674526 45.891368-58.071579S862.315789 809.984 862.315789 717.608421c0-89.573053-47.993263-166.346105-104.582736-232.555789z" fill="#C3D686" ></path><path d="M538.947368 1024h-53.894736c0-32.794947 25.869474-87.417263 77.446736-103.316211C528.599579 881.152 485.052632 822.433684 485.052632 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h80.842105v53.894737h-80.842105a26.947368 26.947368 0 0 0-26.947369 26.947368c0 19.725474 36.675368 77.473684 92.133053 134.736842h88.602947c20.210526-14.147368 88.737684-71.464421 88.737685-198.602105 0-108.382316-93.237895-202.967579-168.151579-278.986105-49.502316-50.202947-88.576-89.842526-98.735158-128.61979-11.749053-44.732632-21.584842-112.586105-26.327579-148.318315H377.263158c-45.136842 0-89.519158 8.434526-121.802105 53.894736H431.157895v53.894737c-97.28 0-107.789474 113.071158-107.789474 161.684211v53.894737h53.894737v161.68421h-53.894737v-107.789474h-26.947368c-170.253474 0-188.631579-94.234947-188.631579-134.736842 0-31.043368 35.220211-72.326737 55.727158-93.722947 2.694737-14.686316 5.847579-28.348632 9.431579-41.013895H161.684211V215.578947h31.528421C239.642947 120.993684 317.224421 107.789474 377.263158 107.789474h185.640421l2.802526 23.794526c0.134737 1.050947 12.719158 106.657684 27.944421 164.756211 6.494316 24.872421 44.624842 63.514947 84.965053 104.448C760.481684 483.813053 862.315789 587.129263 862.315789 717.608421c0 92.375579-31.124211 155.028211-61.898105 194.425263C904.919579 892.146526 970.105263 803.004632 970.105263 673.684211c0-91.405474-42.819368-154.381474-84.237474-215.255579C847.791158 402.458947 808.421053 344.576 808.421053 269.473684c0-119.349895 87.093895-161.684211 161.68421-161.68421v53.894737c-32.417684 0-107.789474 10.509474-107.789474 107.789473 0 58.502737 31.555368 104.933053 68.096 158.639158C974.282105 492.597895 1024 565.679158 1024 673.684211c0 177.286737-108.301474 296.421053-269.473684 296.421052h-161.684211c-37.672421 0-53.894737 40.906105-53.894737 53.894737zM229.214316 269.473684a384.808421 384.808421 0 0 0-14.012632 58.341053l-1.401263 8.488421-6.090105 6.117053c-22.878316 22.932211-44.813474 52.601263-46.026105 62.275368 0 56.805053 53.76 75.264 107.789473 79.386947V431.157895c0-58.691368 13.473684-119.619368 46.511158-161.684211h-86.770526zM323.368421 1024h-53.894737c0-32.794947 25.869474-87.417263 77.446737-103.316211C313.020632 881.152 269.473684 822.433684 269.473684 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h45.16379A188.847158 188.847158 0 0 1 565.894737 592.842105h134.736842v53.894737h-134.736842c-74.293895 0-134.736842 60.442947-134.736842 134.736842v26.516211l-53.894737 0.377263V781.473684c0-9.162105 0.646737-18.135579 1.913263-26.947368H350.315789c-14.848 0-26.947368 12.072421-26.947368 26.947368 0 19.725474 36.675368 77.473684 92.133053 134.736842H431.157895v53.894737h-53.894737c-37.672421 0-53.894737 40.906105-53.894737 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-horse_wu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 26.947368h269.473685v-53.894736H538.947368v-161.684211h161.684211v-53.894737H411.001263c12.045474-33.28 20.156632-69.793684 20.156632-107.789473h-53.894737c0 121.963789-105.364211 233.391158-106.415158 234.496l38.858105 37.349052c2.883368-3.018105 43.816421-46.133895 77.392842-110.160842H485.052632v161.684211H215.578947v53.894736h269.473685v323.368421h53.894736V538.947368z" fill="#231F20" ></path></symbol><symbol id="icon-ox" viewBox="0 0 1025 1024"><path d="M540.294737 754.526316h215.578947c20.210526 0 35.112421 1.374316 53.894737 4.581052 91.863579 15.656421 145.354105 67.691789 161.684211 86.069895V916.210526h53.894736V635.580632l-7.895579-7.895579c-9.269895-9.269895-36.513684-49.232842-44.032-196.527158H540.294737a161.684211 161.684211 0 0 0-161.684211 161.68421v131.098948c43.304421 20.210526 97.28 30.585263 161.684211 30.585263z" fill="#FFAF6E" ></path><path d="M1025.347368 635.580632V916.210526h-53.894736v-71.033263c-16.330105-18.405053-69.820632-70.413474-161.684211-86.069895V916.210526h-53.894737v-161.68421h-107.789473v215.578947h-53.894737V700.631579h161.68421c100.998737 0 172.570947 38.669474 215.578948 71.868632v-115.738948c-33.684211-43.627789-51.712-137.458526-53.706106-279.498105H701.978947c-76.934737 0-127.218526-26.219789-175.804631-51.550316a1556.048842 1556.048842 0 0 0-26.839579-13.743158c-26.839579 26.004211-66.209684 44.921263-115.738948 55.511579 24.441263 22.986105 60.874105 52.116211 106.469053 72.838737l-22.312421 49.044211c-76.584421-34.816-129.589895-88.926316-150.824421-113.125053-10.644211 0.619789-21.477053 1.024-32.687158 1.024a473.734737 473.734737 0 0 1-123.365053-15.952842l-93.022315 186.314105 68.581052 53.86779C167.882105 579.557053 237.891368 538.947368 324.715789 538.947368v53.894737c-95.986526 0-170.361263 62.490947-171.088842 63.137684l-16.78821 14.282106-136.838737-107.358316 109.729684-219.809684C46.430316 314.448842 1.347368 267.371789 1.347368 199.868632 1.347368 89.815579 121.586526 53.894737 163.031579 53.894737v53.894737c-14.120421 0-107.789474 17.165474-107.789474 92.079158C55.242105 290.465684 192.188632 323.368421 284.240842 323.368421c67.907368 0 122.421895-12.988632 157.696-35.624421-42.711579-14.336-95.097263-23.120842-169.337263-18.324211l-3.503158-53.786947c95.878737-6.117053 160.148211 8.515368 211.429053 28.833684C484.244211 235.439158 486.4 225.818947 486.4 215.578947c0-48.855579-57.829053-76.288-58.394947-76.557473l22.393263-49.017263C454.063158 91.648 540.294737 131.826526 540.294737 215.578947c0 18.566737-3.422316 35.84-9.997474 51.631158 7.060211 3.584 13.985684 7.168 20.776421 10.698106C597.854316 302.322526 638.248421 323.368421 701.978947 323.368421h269.473685v26.947368c0 214.689684 35.220211 266.590316 45.999157 277.369264l7.895579 7.895579z m-729.384421 25.141894l-98.789052 118.541474 86.797473 137.835789 45.594948-28.725894-65.913263-104.690527 37.052631-44.43621C358.642526 785.192421 439.080421 808.421053 540.294737 808.421053v-53.894737c-99.893895 0-175.077053-24.549053-223.474526-72.946527l-20.857264-20.857263z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit_mao" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-377.263158-188.631579h107.789474v323.368421c-20.48 0-39.936-11.264-40.016842-11.317895l-27.728842 46.214737c3.206737 1.940211 32.660211 18.997895 67.745684 18.997895 30.746947 0 53.894737-23.147789 53.894737-53.894737V269.473684h-215.578948v538.947369h53.894737V323.368421z m-107.789473 242.526316v-242.526316h-53.894737v196.904421l-107.789474 40.421053v-243.927579l169.094737-48.316632-14.821053-51.819789L269.473684 276.102737v304.801684l-36.405895 13.662316 18.917053 50.472421 178.741895-67.018105c-5.039158 69.928421-55.269053 106.981053-165.133474 122.933894l7.733895 53.328842C325.712842 746.657684 485.052632 723.536842 485.052632 565.894737z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit" viewBox="0 0 1024 1024"><path d="M680.96 488.744421a1666.667789 1666.667789 0 0 0-54.433684-23.95621c-16.006737 12.234105-33.899789 20.264421-60.631579 20.264421h-80.842105c-36.810105 0-83.644632 30.396632-104.394106 67.772631-42.819368 77.123368-53.409684 117.813895-11.021473 201.701053C397.096421 808.879158 431.157895 876.409263 431.157895 970.105263h338.539789l68.338527-138.859789c20.129684-40.96 24.252632-73.701053 24.252631-110.349474 0.026947-57.397895-25.061053-159.717053-181.328842-232.151579z" fill="#FFBDD8" ></path><path d="M862.315789 720.896c0 36.621474-4.122947 69.389474-24.252631 110.349474L769.697684 970.105263H485.052632v-53.894737h48.370526C507.877053 880.074105 485.052632 833.509053 485.052632 781.473684c0-59.418947 24.171789-113.313684 63.218526-152.360421l38.103579 38.103579A161.091368 161.091368 0 0 0 538.947368 781.473684c0 54.784 35.381895 104.043789 63.514948 134.736842h133.712842l53.490526-108.759579c15.710316-31.851789 18.755368-55.834947 18.755369-86.554947 0-80.976842-63.434105-150.096842-178.607158-195.503158-17.542737 8.138105-38.292211 13.554526-63.919158 13.554526h-80.842105c-13.958737 0-43.924211 15.979789-57.290106 40.016843l-47.104-26.165895C401.408 515.449263 448.242526 485.052632 485.052632 485.052632h80.842105c37.268211 0 57.478737-15.440842 79.090526-36.45979C625.367579 336.195368 549.753263 269.473684 485.052632 269.473684h-107.789474a21.288421 21.288421 0 0 0-5.955369 2.021053A683.762526 683.762526 0 0 0 302.187789 194.021053c-35.84-34.223158-61.763368-58.933895-94.908631-79.440842A42.442105 42.442105 0 0 0 185.478737 107.789474a22.824421 22.824421 0 0 0-17.381053 7.194947c-10.913684 11.425684-6.063158 28.240842 1.428211 39.181474 21.989053 32.121263 47.912421 56.858947 83.752421 91.109052 20.614737 19.671579 49.259789 43.169684 77.392842 63.08379C281.007158 367.400421 215.578947 484.432842 215.578947 592.842105c0 74.482526 24.791579 124.065684 51.065264 176.586106C294.534737 825.209263 323.368421 882.903579 323.368421 970.105263h-53.894737c0-74.482526-24.791579-124.065684-51.065263-176.586105C190.517895 737.738105 161.684211 680.043789 161.684211 592.842105c0-90.866526 42.226526-197.685895 93.453473-274.485894a803.759158 803.759158 0 0 1-39.046737-34.115369C177.852632 247.754105 150.231579 221.399579 125.035789 184.616421c-24.441263-35.759158-22.797474-78.686316 4.069053-106.819368 26.300632-27.567158 70.898526-31.043368 106.522947-9.000421 37.941895 23.444211 65.562947 49.798737 103.774316 86.258526 9.970526 9.512421 33.037474 32.309895 56.93979 60.550737h68.634947c-27.621053-37.780211-60.416-72.730947-88.522105-99.543579-28.833684-27.540211-54.730105-52.116211-84.533895-74.024421L326.305684 0.296421c31.232 23.228632 57.802105 48.532211 87.309474 76.719158 53.840842 51.388632 94.450526 100.594526 121.74821 146.83621 82.836211 26.650947 150.042947 116.870737 165.025685 230.750316l1.724631 13.177263-9.404631 9.404632c-3.772632 3.772632-7.706947 7.653053-11.802948 11.587368C837.227789 561.178947 862.315789 663.498105 862.315789 720.896zM309.463579 754.526316c3.934316 8.057263 7.895579 16.087579 11.991579 24.144842C348.887579 832.970105 377.263158 889.128421 377.263158 970.105263h53.894737c0-93.696-34.061474-161.226105-61.520842-215.578947h-60.173474z m597.90821 53.894737c-3.422316 9.404632-7.814737 19.806316-13.770105 31.959579L829.790316 970.105263h60.065684l52.143158-105.957052c10.778947-21.935158 17.515789-40.016842 21.90821-55.727158h-56.535579zM514.694737 390.736842c0-34.223158-13.231158-44.463158-29.642105-44.463158s-29.642105 10.24-29.642106 44.463158c0 34.250105 13.231158 44.463158 29.642106 44.463158s29.642105-10.213053 29.642105-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rat_zi" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 188.631579v-215.578947h269.473685v-53.894737H538.947368v-39.585684c26.543158-18.081684 94.585263-65.050947 177.852632-127.488L700.631579 215.578947H323.368421v53.894737h295.316211a4221.008842 4221.008842 0 0 1-121.640421 85.369263l-11.991579 8.003369V431.157895H242.526316v53.894737h242.526316v215.578947c0 48.343579-13.850947 53.894737-134.736843 53.894737v53.894737c105.391158 0 188.631579 0 188.631579-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-rat" viewBox="0 0 1024 1024"><path d="M727.659789 431.157895c-132.581053 0-220.348632 47.454316-285.803789 154.354526-19.779368 32.309895-15.845053 76.503579-9.404632 96.579368 3.260632 10.159158 7.760842 18.647579 12.422737 25.546106C464.761263 737.010526 499.927579 754.526316 538.947368 754.526316h66.829474c1.158737 17.893053-1.967158 34.762105-15.144421 53.975579-12.692211 18.539789-37.807158 40.151579-56.32 54.810947 25.249684-0.673684 52.709053-0.997053 83.240421-0.997053C877.487158 862.315789 970.105263 711.922526 970.105263 571.176421 936.421053 512 882.364632 431.157895 727.659789 431.157895z" fill="#85C3DE" ></path><path d="M210.432 1012.897684l-43.573895-31.690105c106.954105-147.051789 185.317053-171.196632 423.828211-172.705684 21.396211-31.258947 16.249263-56.266105 9.377684-89.70779-3.557053-17.138526-7.221895-34.842947-7.221895-54.433684 0-68.958316 25.330526-104.636632 63.407158-136.973474l34.896842 41.040842c-29.453474 25.061053-44.409263 46.780632-44.409263 95.932632 0 14.093474 2.937263 28.402526 6.063158 43.546947 5.901474 28.510316 12.8 62.032842-1.131789 99.462737 166.373053-10.24 264.542316-96.902737 264.542315-236.193684C916.210526 418.330947 827.580632 323.368421 684.921263 323.368421c-83.644632 0-153.303579 29.696-174.187789 39.612632a224.875789 224.875789 0 0 1-20.533895 31.339789l-41.741474-34.115368 20.884211 17.057684-20.911158-16.976842C448.781474 359.828211 485.052632 314.287158 485.052632 262.736842c0-34.816-8.946526-60.766316-26.570106-77.069474-17.515789-16.249263-44.786526-24.602947-81.219368-24.953263V323.368421h-53.894737V109.783579l24.872421-1.913263c64.700632-4.931368 114.095158 7.895579 146.863158 38.238316C524.207158 173.056 538.947368 212.291368 538.947368 262.736842c0 11.102316-1.131789 21.908211-3.072 32.202105 37.268211-12.584421 89.842526-25.465263 149.045895-25.465263C858.165895 269.473684 970.105263 387.907368 970.105263 571.176421 970.105263 711.922526 877.487158 862.315789 617.552842 862.315789c-258.667789 0-311.942737 19.698526-407.120842 150.581895z m19.105684-256.835368c-12.045474 0-24.387368-0.565895-37.025684-1.64379l-22.096842-1.859368-2.425263-22.016C167.747368 728.144842 161.684211 672.444632 161.684211 631.026526c0-103.585684 21.450105-178.903579 53.894736-259.045052V107.789474h53.894737v274.782315l-2.021052 4.904422C235.439158 465.758316 215.578947 533.800421 215.578947 631.026526c0 22.878316 2.101895 51.442526 3.826527 70.979369 99.678316 2.802526 172.813474-35.408842 222.450526-116.493474l48.020211 24.090947c-11.237053 28.133053-11.371789 51.577263-0.377264 67.853474 9.701053 14.282105 28.645053 23.174737 49.448421 23.174737v53.894737c-39.019789 0-74.186105-17.515789-94.073263-46.888421a100.244211 100.244211 0 0 1-12.422737-25.546106c-53.221053 49.178947-121.128421 73.943579-202.913684 73.970527zM379.957895 525.473684c0-34.223158-13.231158-44.463158-29.642106-44.463158s-29.642105 10.24-29.642105 44.463158c0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642106-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rooster_you" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-215.578947-188.631579h-161.684211v-26.947368h161.684211V242.526316H269.473684v53.894737h161.684211v26.947368h-161.684211v485.052632h53.894737v-53.894737h377.263158v53.894737h53.894737V323.368421zM323.368421 646.736842h377.263158v53.894737H323.368421v-53.894737z m0-269.473684h107.789474c0 103.316211-72.784842 107.654737-81.084632 107.789474L350.315789 538.947368c46.592 0 134.736842-33.792 134.736843-161.68421h53.894736v107.789474c0 29.722947 24.171789 53.894737 53.894737 53.894736h107.789474v53.894737H323.368421v-215.578947z m377.263158 0v107.789474h-107.789474v-107.789474h107.789474z m-215.578947-80.842105h53.894736v26.947368h-53.894736v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-rooster" viewBox="0 0 1024 1024"><path d="M891.688421 506.421895C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V116.224l-323.368421 195.745684V323.368421c0 78.524632 14.928842 131.664842 29.372632 183.053474 12.611368 44.894316 24.522105 87.282526 24.522105 140.314947 0 101.618526-77.931789 176.693895-168.286316 203.991579l5.416422 11.587368h215.578947c24.333474 0 43.385263-0.242526 58.556631-2.128842C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947z" fill="#FF8787" ></path><path d="M673.684211 354.357895c-16.384 0-29.642105-10.213053-29.642106-44.463158 0-34.223158 13.231158-44.463158 29.642106-44.463158s29.642105 10.24 29.642105 44.463158c0 34.250105-13.258105 44.463158-29.642105 44.463158zM540.106105 970.105263l-50.58021-107.789474h156.05221l50.607158 107.789474h59.553684l-51.60421-109.918316C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V107.789474c0-59.445895-48.343579-107.789474-107.789473-107.789474a107.924211 107.924211 0 0 0-107.789474 106.172632 100.890947 100.890947 0 0 0-24.117895-3.314527 88.710737 88.710737 0 0 0-88.602947 88.602948c0 20.668632 5.227789 39.720421 10.671158 53.921684l-99.489684 59.688421 93.749894 14.470737V377.263158c0 14.416842-5.901474 21.692632-33.360842 49.152l-11.129263 11.129263C398.228211 326.521263 324.985263 269.473684 215.740632 269.473684 96.768 269.473684 0 366.241684 0 485.214316V646.736842h53.894737v-161.522526A162.007579 162.007579 0 0 1 215.740632 323.368421c82.081684 0 140.422737 36.244211 240.64 152.252632l-38.615579 38.615579C367.804632 461.285053 323.098947 431.157895 259.584 431.157895A151.983158 151.983158 0 0 0 107.789474 582.952421V754.526316h53.894737v-171.573895A98.007579 98.007579 0 0 1 259.584 485.052632c46.322526 0 79.629474 20.911158 137.027368 86.016l18.970948 21.530947 128.080842-128.080842C572.200421 435.981474 592.842105 415.366737 592.842105 377.263158v-97.926737l23.309474-14.120421-13.662316-23.04c-0.161684-0.242526-14.578526-24.899368-14.578526-50.688 0-19.132632 15.575579-34.708211 34.70821-34.708211 5.093053 0 26.785684 3.179789 39.558737 18.647579l26.327579 46.026106 39.774316-24.090948-20.372211-49.367579C704.754526 140.449684 700.631579 117.517474 700.631579 107.789474c0-29.722947 24.171789-53.894737 53.894737-53.894737s53.894737 24.171789 53.894737 53.894737v215.578947c0 85.935158 16.680421 145.300211 31.366736 197.632C851.887158 564.008421 862.315789 601.141895 862.315789 646.736842c0 95.285895-99.408842 161.684211-188.631578 161.684211h-209.461895l-68.419369-145.704421C375.242105 618.954105 338.108632 592.842105 296.448 592.842105A80.976842 80.976842 0 0 0 215.578947 673.711158V862.315789h53.894737v-188.604631c0-14.874947 12.099368-26.974316 26.974316-26.974316 20.533895 0 38.965895 14.147368 50.553263 38.858105L480.579368 970.105263h59.526737z" fill="#231F20" ></path></symbol><symbol id="icon-snake_si" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-242.041263 180.762947l-52.116211-13.797052C657.219368 749.864421 651.425684 754.526316 619.789474 754.526316h-242.526316V485.052632h269.473684v53.894736h53.894737V215.578947H323.368421v538.947369c0 29.722947 24.171789 53.894737 53.894737 53.894737h242.526316c77.689263 0 91.189895-51.065263 108.274526-115.658106zM377.263158 269.473684h269.473684v161.684211H377.263158v-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-tiger_yin" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-257.42821 299.250526l-107.789474-53.894737-24.117895 48.208843 107.789474 53.894736 24.117895-48.208842z m-269.473685-5.658947l-24.117894-48.208842-107.789474 53.894737 24.117895 48.208842 107.789473-53.894737zM700.631579 431.157895h-161.684211v-53.894737h107.789474v-53.894737H377.263158v53.894737h107.789474v53.894737h-161.684211v323.368421h53.894737v-53.894737h269.473684v53.894737h53.894737V431.157895z m-161.684211 161.68421h107.789474v53.894737h-107.789474v-53.894737z m-161.68421 0h107.789474v53.894737h-107.789474v-53.894737z m161.68421-107.789473h107.789474v53.894736h-107.789474v-53.894736z m-161.68421 0h107.789474v53.894736h-107.789474v-53.894736zM754.526316 215.578947h-223.097263l-20.803369-62.410105-51.119158 17.057684L474.624 215.578947H269.473684v107.789474h53.894737v-53.894737h377.263158v53.894737h53.894737V215.578947z" fill="#231F20" ></path></symbol><symbol id="icon-snake" viewBox="0 0 1024 1024"><path d="M107.789474 790.474105c0-72.434526 67.880421-91.513263 121.451789-91.513263 74.401684 0 153.815579 34.438737 237.891369 70.925474 50.580211 21.935158 104.609684 45.325474 162.250105 63.083789-52.412632 44.786526-118.784 74.347789-195.152842 83.078737-143.171368 16.357053-326.440421 7.006316-326.440421-125.574737zM377.263158 215.578947c-15.575579 0-30.288842 3.449263-43.654737 9.377685A250.691368 250.691368 0 0 0 323.368421 296.421053c0 115.550316 76.422737 169.391158 137.83579 212.614736 8.138105 5.712842 16.141474 11.371789 23.848421 17.057685V323.368421a107.789474 107.789474 0 0 0-107.789474-107.789474z" fill="#C3D686" ></path><path d="M671.528421 788.857263c44.328421 11.964632 89.626947 19.563789 136.892632 19.56379 89.168842 0 161.684211-60.442947 161.68421-134.736842s-72.515368-134.736842-161.68421-134.736843c-19.078737 0-37.025684 1.509053-54.218106 4.015158-0.754526-101.402947-38.211368-172.355368-79.413894-219.648L673.684211 323.368421a1749.962105 1749.962105 0 0 1-79.036632-1.751579c45.702737 35.866947 108.705684 107.870316 105.984 232.367158 0 0.431158-0.080842 0.808421-0.10779 1.239579-34.923789 10.994526-66.155789 26.731789-95.097263 45.190737a163.085474 163.085474 0 0 0-15.845052-42.388211c-21.557895-39.639579-60.065684-66.775579-97.360842-93.022316C433.098105 423.343158 377.263158 384 377.263158 296.421053c0-130.290526 108.274526-188.631579 215.578947-188.631579 64.134737 0 132.715789 12.045474 214.366316 37.807158C802.330947 180.250947 780.099368 209.381053 700.631579 214.635789V161.684211h-53.894737v53.679157c-63.272421-1.024-104.528842-5.200842-104.986947-5.254736l-5.578106 53.598315C538.408421 263.949474 592.357053 269.473684 673.684211 269.473684c125.170526 0 188.631579-48.128 188.631578-143.063579V106.981053l-18.432-6.144C747.789474 68.823579 668.025263 53.894737 592.842105 53.894737c-158.666105 0-269.473684 99.732211-269.473684 242.526316 0 115.550316 76.422737 169.391158 137.83579 212.614736 33.684211 23.713684 65.509053 46.106947 81.003789 74.698106 9.539368 17.542737 13.285053 33.414737 12.341895 47.750737 21.153684 9.108211 42.118737 17.839158 62.949052 25.977263C671.151158 620.193684 729.977263 592.842105 808.421053 592.842105c59.445895 0 107.789474 36.271158 107.789473 80.842106s-48.343579 80.842105-107.789473 80.842105c-105.472 0-203.237053-42.388211-297.768421-83.429053-94.800842-41.094737-184.346947-79.952842-281.411369-79.952842C122.718316 591.171368 53.894737 644.715789 53.894737 727.578947c0 79.063579 67.098947 136.434526 159.555368 136.434527 142.174316 0 230.426947-66.883368 306.79579-129.886316 31.420632 13.419789 62.787368 26.058105 94.450526 37.133474-47.077053 49.637053-110.969263 82.566737-186.610526 91.270736l5.066105 53.625264c93.453474-7.006316 143.144421 9.350737 195.718737 26.543157 46.457263 15.225263 94.127158 30.854737 169.822316 30.854737 19.994947 0 41.957053-1.077895 66.344421-3.557052l-5.416421-53.625263c-105.283368 10.778947-158.100211-6.548211-213.935158-24.872422-22.150737-7.275789-44.624842-14.632421-70.305684-20.345263a334.848 334.848 0 0 0 96.14821-82.297263z m-458.078316 21.261474C162.573474 810.118737 107.789474 784.276211 107.789474 727.578947c0-60.847158 62.733474-82.539789 121.451789-82.539789 77.850947 0 154.731789 30.288842 235.250526 64.943158-66.263579 52.924632-139.722105 100.136421-251.041684 100.136421z" fill="#231F20" ></path></symbol><symbol id="icon-tiger" viewBox="0 0 1024 1024"><path d="M431.157895 162.250105V134.736842c0-41.552842-39.289263-80.842105-80.842106-80.842105-28.833684 0-57.128421 4.661895-58.314105 4.850526L269.473684 62.490947v83.887158C144.788211 223.824842 89.222737 346.839579 66.991158 431.157895h266.051368c240.747789 0 415.851789 107.789474 415.85179 269.473684-14.848-25.114947-43.924211-53.894737-88.68379-53.894737-67.988211 0-121.263158 71.033263-121.263158 161.684211 0 66.802526 30.477474 119.888842 60.712421 156.16 12.638316 15.171368 36.055579 37.726316 59.014737 58.88 5.066105 0.107789 9.781895 0.538947 15.009685 0.538947 219.297684 0 350.315789-191.811368 350.315789-377.263158C1024 327.545263 679.855158 172.813474 431.157895 162.250105z" fill="#F7C768" ></path><path d="M673.684211 1024c-114.768842 0-188.820211-33.333895-254.167579-62.787368-53.625263-24.144842-99.974737-45.002105-161.28-45.002106-40.448 0-83.590737 23.255579-103.639579 45.16379l-39.747369-36.432842C142.497684 894.787368 199.168 862.315789 258.236632 862.315789c68.392421 0 119.861895 21.288421 172.921263 45.056V673.684211c0-35.166316-17.542737-64.107789-30.639158-80.815158-15.198316 9.835789-32.067368 18.890105-50.741895 26.947368l-21.342316-49.475368C469.800421 509.413053 485.052632 377.317053 485.052632 323.368421V221.642105A597.827368 597.827368 0 0 0 404.210526 215.578947h-26.947368V134.736842c0-12.099368-14.848-26.947368-26.947369-26.947368-9.377684 0-18.836211 0.592842-26.947368 1.347368V269.473684h-53.894737V211.671579c-136.030316 102.912-158.450526 266.886737-161.306947 295.882105 9.135158 9.108211 38.992842 25.061053 71.976421 38.669474l38.103579-59.365053 12.449684-1.589894C321.212632 473.653895 377.263158 392.192 377.263158 323.368421h53.894737c0 88.333474-68.796632 192.242526-180.870737 213.342316l-48.397474 75.398737-20.291368-7.437474C53.894737 557.756632 53.894737 523.317895 53.894737 512c0-50.041263 37.025684-254.733474 215.578947-365.621895V62.490947l22.528-3.745684C293.187368 58.556632 321.482105 53.894737 350.315789 53.894737c41.552842 0 80.842105 39.289263 80.842106 80.842105v27.513263c248.697263 10.563368 592.842105 165.295158 592.842105 484.486737 0 185.451789-131.018105 377.263158-350.315789 377.263158z m-13.473685-323.368421c-36.513684 0-67.368421 49.367579-67.368421 107.789474 0 85.746526 68.096 145.084632 89.465263 161.549473 91.540211-2.533053 164.378947-45.487158 213.827369-107.654737H700.631579v-53.894736h230.238316c8.919579-17.273263 16.357053-35.354947 22.285473-53.894737h-239.885473l-6.467369-17.650527C706.290526 735.582316 692.439579 700.631579 660.210526 700.631579zM485.052632 931.112421c33.926737 14.066526 70.521263 26.597053 114.607157 33.468632C569.424842 928.309895 538.947368 875.223579 538.947368 808.421053c0-90.650947 53.274947-161.684211 121.263158-161.684211 44.759579 0 73.835789 28.779789 88.68379 53.894737h217.007158c2.775579-17.866105 4.203789-35.920842 4.203789-53.894737 0-38.938947-5.658947-74.752-15.925895-107.627789l-126.706526 126.679579-38.103579-38.103579L932.001684 485.052632a367.939368 367.939368 0 0 0-57.775158-81.596632l-154.543158 154.543158-38.103579-38.103579 153.573053-153.573053a537.869474 537.869474 0 0 0-82.593684-56.751158l-140.665263 140.638316-38.103579-38.103579 128.134737-128.134737A794.731789 794.731789 0 0 0 538.947368 231.046737V323.368421c0 50.149053-11.102316 156.698947-95.932631 236.328421 18.378105 23.417263 42.037895 63.407158 42.037895 113.987369v257.42821zM215.578947 431.157895v-53.894737c39.774316 0 53.894737-29.022316 53.894737-53.894737h53.894737c0 53.571368-37.025684 107.789474-107.789474 107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-boar" viewBox="0 0 1024 1024"><path d="M732.079158 377.263158c-107.789474 0-186.421895 31.393684-281.869474 126.841263L180.331789 773.982316C257.724632 807.909053 348.725895 808.421053 485.052632 808.421053h96.013473c55.834947-34.411789 133.551158-53.894737 227.354948-53.894737h121.344L970.105263 680.555789V572.631579c0-94.315789-130.236632-195.368421-238.026105-195.368421z" fill="#FFBDD8" ></path><path d="M808.421053 700.631579v53.894737c-196.446316 0-323.368421 84.641684-323.368421 215.578947h-53.894737c0-163.705263 148.075789-269.473684 377.263158-269.473684z m-323.368421 107.789474v-53.894737c-158.342737 0-245.598316 0-319.649685-49.367579L158.612211 700.631579H80.842105c-21.692632 0-26.624-14.821053-26.947368-26.947368v-82.620632c84.156632-11.183158 161.684211-74.913684 161.68421-186.853053V215.578947H161.684211v161.684211H134.736842c-66.964211 0-134.736842 37.025684-134.736842 107.789474h53.894737c0-42.630737 52.870737-53.894737 80.842105-53.894737h24.629895C147.132632 504.912842 85.153684 538.947368 26.947368 538.947368H0v134.736843c0 32.498526 21.530947 80.842105 80.842105 80.842105h61.682527c32.687158 20.506947 67.125895 33.145263 105.957052 41.013895A232.879158 232.879158 0 0 0 215.578947 916.210526h53.894737c0-41.930105 14.012632-80.303158 39.424-112.505263C358.885053 808.151579 415.959579 808.421053 485.052632 808.421053z m-72.946527-342.420211L323.368421 554.738526V431.157895h-53.894737v253.682526l180.736-180.736-38.103579-38.103579zM323.368421 161.684211h-53.894737v190.032842a769.536 769.536 0 0 1 53.894737-49.098106V161.684211z m323.368421-53.894737c-72.623158 0-146.809263 23.336421-215.578947 58.637473V107.789474h-53.894737v154.138947C458.832842 205.392842 555.331368 161.684211 646.736842 161.684211c148.587789 0 269.473684 120.885895 269.473684 269.473684v235.654737L809.579789 862.315789h61.359158L970.105263 680.555789V431.157895c0-178.310737-145.057684-323.368421-323.368421-323.368421z" fill="#231F20" ></path></symbol><symbol id="icon-boar_hai" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M309.975579 804.756211l-27.136-46.592c103.073684-60.011789 183.026526-132.473263 241.475368-219.24379H350.315789l-13.473684-50.283789c58.88-33.980632 99.435789-117.571368 118.703158-165.295158H242.526316v-53.894737h538.947368v53.894737h-268.18021c-12.395789 34.088421-42.469053 106.603789-90.435369 161.68421h134.009263a680.555789 680.555789 0 0 0 46.349474-107.708631l51.092211 17.057684c-58.421895 175.265684-171.034947 309.490526-344.333474 410.381474z m192.350316-2.937264L467.806316 760.454737c88.414316-73.728 154.516211-158.773895 202.105263-259.907369l48.801684 22.959158a797.372632 797.372632 0 0 1-82.351158 137.781895c32.741053 15.009684 83.456 44.867368 137.647158 101.591579l-38.938947 37.268211c-57.236211-59.877053-109.325474-85.557895-133.766737-95.178106a850.997895 850.997895 0 0 1-98.977684 96.848842z m48.613052-536.872421l-80.842105-53.894737 29.884632-44.840421 80.842105 53.894737-29.884632 44.840421zM512 53.894737C259.395368 53.894737 53.894737 259.395368 53.894737 512s205.500632 458.105263 458.105263 458.105263c9.081263 0 17.973895-0.835368 26.947368-1.374316v-53.894736c-8.946526 0.619789-17.866105 1.374316-26.947368 1.374315-222.881684 0-404.210526-181.328842-404.210526-404.210526S289.118316 107.789474 512 107.789474s404.210526 181.328842 404.210526 404.210526c0 195.206737-139.075368 358.507789-323.368421 396.045474v54.460631c214.096842-38.346105 377.263158-225.549474 377.263158-450.533052C970.105263 259.395368 764.604632 53.894737 512 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-bilibili1" viewBox="0 0 1129 1024"><path d="M234.909 9.656a80.468 80.468 0 0 1 68.398 0 167.374 167.374 0 0 1 41.843 30.578l160.937 140.82h115.07l160.936-140.82a168.983 168.983 0 0 1 41.843-30.578A80.468 80.468 0 0 1 930.96 76.445a80.468 80.468 0 0 1-17.703 53.914 449.818 449.818 0 0 1-35.406 32.187 232.553 232.553 0 0 1-22.531 18.508h100.585a170.593 170.593 0 0 1 118.289 53.109 171.397 171.397 0 0 1 53.914 118.288v462.693a325.897 325.897 0 0 1-4.024 70.007 178.64 178.64 0 0 1-80.468 112.656 173.007 173.007 0 0 1-92.539 25.75H212.377a341.186 341.186 0 0 1-72.421-4.024A177.835 177.835 0 0 1 28.91 939.065a172.202 172.202 0 0 1-27.36-92.539V388.662a360.498 360.498 0 0 1 0-66.789A177.03 177.03 0 0 1 162.487 178.64h105.414c-16.899-12.07-31.383-26.555-46.672-39.43a80.468 80.468 0 0 1-25.75-65.984 80.468 80.468 0 0 1 39.43-63.57M216.4 321.873a80.468 80.468 0 0 0-63.57 57.937 108.632 108.632 0 0 0 0 30.578v380.615a80.468 80.468 0 0 0 55.523 80.469 106.218 106.218 0 0 0 34.601 5.632h654.208a80.468 80.468 0 0 0 76.444-47.476 112.656 112.656 0 0 0 8.047-53.109v-354.06a135.187 135.187 0 0 0 0-38.625 80.468 80.468 0 0 0-52.304-54.719 129.554 129.554 0 0 0-49.89-7.242H254.22a268.764 268.764 0 0 0-37.82 0z m0 0" fill="#20B0E3" ></path><path d="M348.369 447.404a80.468 80.468 0 0 1 55.523 18.507 80.468 80.468 0 0 1 28.164 59.547v80.468a80.468 80.468 0 0 1-16.094 51.5 80.468 80.468 0 0 1-131.968-9.656 104.609 104.609 0 0 1-10.46-54.719v-80.468a80.468 80.468 0 0 1 70.007-67.593z m416.02 0a80.468 80.468 0 0 1 86.102 75.64v80.468a94.148 94.148 0 0 1-12.07 53.11 80.468 80.468 0 0 1-132.773 0 95.757 95.757 0 0 1-12.875-57.133V519.02a80.468 80.468 0 0 1 70.007-70.812z m0 0" fill="#20B0E3" ></path></symbol><symbol id="icon-yinle" viewBox="0 0 1024 1024"><path d="M512.2976 0a531.2 531.2 0 0 0-512 548.48V960h128V548.48a398.72 398.72 0 0 1 384-411.52 398.72 398.72 0 0 1 384 411.52V960h128V548.48A531.2 531.2 0 0 0 512.2976 0z" fill="#5c8add" ></path><path d="M64.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path><path d="M704.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path></symbol><symbol id="icon-icon-test-copy" viewBox="0 0 1024 1024"><path d="M512 512m-229.517241 0a229.517241 229.517241 0 1 0 459.034482 0 229.517241 229.517241 0 1 0-459.034482 0Z" fill="#5c8add" ></path><path d="M512 1024A512 512 0 1 1 1024 512 512 512 0 0 1 512 1024z m0-141.241379A370.758621 370.758621 0 1 0 141.241379 512 370.758621 370.758621 0 0 0 512 882.758621z" fill="#5c8add" ></path></symbol><symbol id="icon-V" viewBox="0 0 1024 1024"><path d="M1012.47774251 492.58192592L544.94137566 87.22962963a49.96686561 49.96686561 0 0 0-65.88275132 0L11.63784127 492.6975097c-21.03624691 18.26223633-23.3479224 49.93219048-5.08568606 70.96843739 18.03106878 21.03624691 49.93219048 23.3479224 70.96843738 5.08568607L512 191.83294532l434.71057495 376.91868784c9.47786949 8.20644797 21.26741446 12.25188008 32.82579189 12.13629629 14.10122046 0 27.97127337-5.77918871 38.02706173-17.33756613 18.14665256-20.92066314 15.95056084-52.70620106-5.08568606-70.9684374z" fill="#5c8add" ></path><path d="M109.30613051 567.59579541V896.89396825c0 42.53482892 34.90629982 77.44112875 77.44112875 77.44112875h220.76500882V666.30433862c0-25.54401411 20.92066314-46.46467725 46.46467724-46.46467724h116.16169313c25.54401411 0 46.46467725 20.92066314 46.46467725 46.46467724V974.335097h220.76500882c42.53482892 0 77.44112875-34.90629982 77.44112874-77.44112875l0.11558377-329.29817284L512 218.18604586 109.30613051 567.59579541zM848.00203175 197.49655027h-63.91782716c-12.82979894 0-23.23233862 10.40253968-23.23233863 23.23233862v24.27259259l110.49808818 95.70336508V220.72888889h-0.11558377c0-12.82979894-10.40253968-23.23233862-23.23233862-23.23233862zM905.44716754 83.18419754s-34.90629982 56.86721693-89.11508994 100.32671603c152.68616579 13.98563668 127.83565432-133.26809171 127.83565432-133.2680917-134.07717813-10.28695591-132.92134039 102.29164021-131.072 127.83565432 20.92066314-20.92066314 49.70102293-62.64640564 92.35143562-94.89427865zM798.53217637 174.61096297c-19.64924162-16.52847972-40.56990476-43.45949912-51.203612-53.97762258 0 0 32.94137566 20.57391182 56.40488184 49.3542716 2.42725926-18.37782011 6.47269135-93.3916896-93.16052205-85.3008254 0 0-13.98563668 104.71889947 87.95925221 89.92417638z" fill="#5c8add" ></path></symbol><symbol id="icon-zhifeiji" viewBox="0 0 1167 1024"><path d="M41.201759 463.52493L1110.665064 30.117647c10.32605-4.159104 21.942857 0.860504 26.101961 11.043137 1.434174 3.728852 1.864426 7.744538 1.003921 11.616807L949.033691 978.823529c-2.151261 10.89972-12.764146 17.927171-23.663865 15.632493-2.72493-0.573669-5.306443-1.721008-7.601121-3.298599L634.80624 789.79944l-163.065546 133.951821c-16.492997 13.62465-40.87395 11.186555-54.498599-5.306443-3.011765-3.728852-5.306443-7.887955-6.884034-12.477311l-102.973669-313.080112-265.178712-91.787115c-10.469468-3.585434-16.062745-15.058824-12.333893-25.528291 1.864426-5.44986 6.023529-9.895798 11.329972-12.047059z" fill="#FCFDFC" ></path><path d="M929.385512 1023.569748c-3.155182 0-6.453782-0.286835-9.752381-1.003922-6.740616-1.434174-12.907563-4.015686-18.50084-8.031372L635.953579 825.940616l-146.142297 120.040336c-13.911485 11.473389-31.408403 16.779832-49.335574 15.058824-17.927171-1.721008-34.133333-10.32605-45.463305-24.237535-5.306443-6.453782-9.322129-13.768067-11.903642-21.79944l-98.527731-299.598879-251.697479-87.19776c-12.333894-4.302521-22.229692-13.05098-27.966386-24.811204s-6.453782-24.954622-2.151261-37.288515c4.589356-13.337815 14.771989-23.9507 27.82297-29.257143L1099.908761 3.585434c24.954622-10.039216 53.351261 2.007843 63.533894 26.819048 3.585434 8.891877 4.445938 18.644258 2.581513 28.109804L977.143495 984.560224c-4.732773 23.090196-25.098039 39.009524-47.757983 39.009524z m-294.579272-233.770308l282.962465 201.357983c2.294678 1.577591 4.87619 2.72493 7.601121 3.298599 10.89972 2.151261 21.512605-4.87619 23.663865-15.632493L1137.914364 52.777591c0.860504-3.872269 0.430252-7.887955-1.003922-11.616807-4.159104-10.32605-15.919328-15.202241-26.101961-11.043137L41.201759 463.52493c-5.306443 2.151261-9.465546 6.597199-11.47339 12.047059-1.721008 5.019608-1.434174 10.469468 0.860505 15.345658 2.294678 4.87619 6.453782 8.461625 11.473389 10.182633l265.178711 91.787115L410.214644 905.967507c1.434174 4.589356 3.872269 8.748459 6.884033 12.477311 6.597199 8.031373 15.919328 12.907563 26.101961 13.911485 10.32605 1.003922 20.365266-2.007843 28.396639-8.605042l163.208963-133.951821z" fill="#4A4A4A" ></path><path d="M307.097557 592.743978l105.698599 316.091876c6.310364 18.787675 26.532213 28.970308 45.319888 22.659944 4.159104-1.434174 7.887955-3.442017 11.186555-6.166946l164.786555-133.951821-165.360224-118.892997c297.017367-287.982073 447.462185-433.980952 451.191036-437.853222 0.573669-0.573669 2.581513-3.442017 0.430252-7.027451-1.290756-1.577591-3.298599-3.298599-7.027451-2.15126-202.218487 120.327171-404.293557 242.805602-606.22521 367.291877z" fill="#CAE0EE" ></path><path d="M446.786072 934.794398c-5.736695 0-11.329972-1.290756-16.636414-3.872269-8.891877-4.445938-15.632493-12.047059-18.787675-21.512605L305.376549 592.313725l1.003921-0.573669C507.308201 467.684034 711.391114 344.058263 912.60568 224.161345l0.286835-0.143418c3.585434-1.147339 6.310364-0.286835 8.605042 2.581513l0.143417 0.143417c2.438095 4.015686 0.573669 7.457703-0.573669 8.74846-3.872269 4.015686-155.177591 150.87507-450.043698 436.705882l165.503642 119.036414-166.220728 135.09916c-3.442017 2.868347-7.457703 5.019608-11.760225 6.453782-3.728852 1.290756-7.744538 2.007843-11.760224 2.007843z m-137.967507-341.333334l105.268348 314.944538c2.868347 8.748459 9.035294 15.77591 17.210084 19.935014 8.17479 4.159104 17.496919 4.732773 26.245378 1.864426 3.872269-1.290756 7.60112-3.298599 10.756302-5.880112l163.352381-132.804482L466.434252 672.627451l1.290756-1.147339C763.308201 384.932213 915.043775 237.642577 918.772627 233.626891c0 0 2.007843-2.294678 0.286835-5.306443-1.003922-1.290756-2.438095-2.438095-5.306443-1.577591-200.784314 119.610084-404.293557 242.94902-604.934454 366.718207z" fill="#CAE0EE" ></path><path d="M460.840974 924.898599l7.457703-253.561904 165.933894 119.896918-168.658824 135.959664c-1.290756 1.003922-3.011765 0.860504-4.015686-0.430252-0.430252-0.430252-0.717087-1.147339-0.717087-1.864426z" fill="#94C3E2" ></path><path d="M463.709322 929.344538c-1.290756 0-2.438095-0.573669-3.2986-1.577591-0.573669-0.860504-1.003922-1.864426-1.003921-2.868348l7.60112-256.286834 169.519328 122.621848-1.434174 1.147339-168.658823 135.959664c-0.860504 0.717087-1.721008 1.003922-2.72493 1.003922z m6.023529-255.282913l-7.457703 250.836974c0 0.286835 0.143417 0.717087 0.286835 1.003922 0.430252 0.573669 1.434174 0.717087 2.007843 0.286835l167.22465-134.812325-162.061625-117.315406z" fill="#94C3E2" ></path></symbol><symbol id="icon-lianjie" viewBox="0 0 1079 1024"><path d="M695.355535 432.666896c-0.553495-1.10699-0.885592-2.186305-1.383737-3.265619-0.193723-0.193723-0.193723-0.359772-0.359771-0.719543-12.508983-26.318678-39.436506-43.366319-69.325226-41.013966-39.076734 3.265619-68.439634 39.021384-65.312388 79.841627 0.857917 10.516401 3.653066 20.147211 7.998 28.83708 19.78744 46.659613 11.097571 103.448181-25.377737 141.750022l-191.094085 199.950001a118.088119 118.088119 0 0 1-171.998513 0c-47.434506-49.537786-47.434506-130.098956 0-179.636742l71.234782-74.389703-0.52582-0.553494a75.911814 75.911814 0 0 0 24.326097-61.880721c-3.127246-40.820243-37.3609-71.51153-76.437634-68.24591a69.463599 69.463599 0 0 0-46.908685 23.966325l-0.166049-0.193723-72.618519 75.856464c-103.226783 107.793115-103.226783 282.36538 0 390.158495 103.171433 107.793115 270.299193 107.793115 373.498301 0l191.619904-200.1714c80.256748-83.992838 97.636485-208.307773 52.83108-310.289193z" fill="#5c8add" ></path><path d="M1002.047012 80.865592c-103.226783-107.82079-270.382217-107.82079-373.581325 0l-191.619905 200.199075c-80.284423 83.854464-97.66416 208.197074-52.997128 310.233843 0.52582 1.079315 0.857917 2.15863 1.383737 3.26562 0.166048 0.166048 0.166048 0.359772 0.332097 0.719543 12.536658 26.291004 39.46418 43.366319 69.3529 41.013966 39.076734-3.265619 68.439634-39.021384 65.312388-79.869302a78.679288 78.679288 0 0 0-7.998-28.864755c-19.78744-46.631938-11.097571-103.448181 25.377737-141.750022l191.287808-199.839302a118.088119 118.088119 0 0 1 172.026188 0c47.434506 49.537786 47.434506 130.126631 0 179.692091l-71.234782 74.417378 0.52582 0.553495a75.939489 75.939489 0 0 0-24.353772 61.88072c3.15492 40.847917 37.3609 71.51153 76.465309 68.245911a69.463599 69.463599 0 0 0 46.908685-23.938651l0.166049 0.166048 72.646194-75.856464c103.03306-107.82079 103.03306-282.642127 0-390.269194z" fill="#5c8add" ></path></symbol><symbol id="icon-liaotian" viewBox="0 0 1171 1024"><path d="M1068.71699 0.243751H102.193768C46.228437 0.243751 0.500666 45.045267 0.500666 99.74309v696.251622c0 54.697824 45.727771 99.450589 101.693102 99.450589h329.113198l120.851966 114.465677a48.652788 48.652788 0 0 0 66.641644 0l120.851966-114.465677h329.064448c55.965331 0 101.741852-44.752765 101.741852-99.450589V99.74309C1170.458842 45.045267 1124.682321 0.243751 1068.71699 0.243751z m-439.776354 596.849784h-370.989696c-27.933915 0-50.846551-22.425133-50.846551-49.774045 0-27.348912 22.912636-49.725294 50.846551-49.725294h370.989696c27.933915 0 50.846551 22.376382 50.846551 49.725294 0 27.348912-22.912636 49.774045-50.846551 49.774045z m287.18795-211.381252H254.782171a50.456549 50.456549 0 0 1-50.846551-49.725294c0-27.397662 22.912636-49.774045 50.846551-49.774045h661.346415c27.933915 0 50.846551 22.376382 50.846551 49.774045 0 27.348912-22.912636 49.725294-50.846551 49.725294z" fill="#5C8ADD" ></path></symbol><symbol id="icon-xinfeng" viewBox="0 0 1400 1024"><path d="M1301.63733163 214.78520234a207.81921797 207.81921797 0 0 1 7.02423018 52.42036465v489.73590176a205.10753818 205.10753818 0 0 1-205.05853125 205.05853125H283.05853124A205.15654424 205.15654424 0 0 1 77.99999999 756.79444971V267.20556699a201.36672685 201.36672685 0 0 1 7.02423106-52.42036465L586.24393329 562.1905874c69.44187217 51.96297217 146.36536612 49.13694404 214.1736961 0zM1103.60303056 62.0000167H283.05853124A204.50312753 204.50312753 0 0 0 106.37462518 163.41030547l489.71956641 335.75823018c62.43397646 50.77048623 127.85733457 50.31309463 194.62019765 0L1280.28693749 163.41030547A204.68281729 204.68281729 0 0 0 1103.60303056 62.0000167z m0 0" fill="#5c8add" ></path></symbol><symbol id="icon-QQ1" viewBox="0 0 1024 1024"><path d="M0 512a512 512 0 1 0 1024 0A512 512 0 1 0 0 512z" fill="#18ACFC" ></path><path d="M500.113 228.39c118.396-1.518 178.924 61.004 201 156 3.497 15.048 0.15 34.807 0 50 27.143 5.682 33.087 60.106 10 75v1h1c8.26 14.33 19.04 28.125 26 44 7.332 16.723 9.306 35.16 14 55 4.024 17.01-2.287 51.505-10 57-0.771 0.683-2.231 1.312-3 2-14.601-3.016-30.377-16.865-38-27-3.065-4.074-5.275-9.672-10-12-0.395 21.568-12.503 41.15-22 55-3.514 5.123-14.073 13.217-14 18 3.691 2.836 8.305 2.956 13 5 10.513 4.577 25.449 13.168 32 22 2.334 3.146 5.548 7.555 7 11 16.193 38.414-36.527 48.314-63 54-27.185 5.839-77.818-10.224-92-19-8.749-5.414-16.863-18.573-29-19-3.666 2.389-14.438 1.132-20 1-16.829 32.804-101.913 47.868-148 31-14.061-5.146-43.398-17.695-38-40 4.437-18.327 19.947-29.224 35-37 5.759-2.975 18.915-4.419 22-10-13.141-8.988-24.521-28.659-31-44-3.412-8.077-4.193-25.775-9-32-7.789 12.245-32.097 36.91-52 33-3.071-4.553-7.213-9.097-9-15-4.792-15.835-1.81-40.379 2-54 8.117-29.02 16.965-50.623 32-72 4.672-6.643 11.425-12.135 16-19-8.945-9.733-6.951-37.536-1-49 4.002-7.709 9.701-7.413 10-20-1.92-3.022-0.071-8.604-1-13-4.383-20.75 3.273-47.552 9-63 19.8-53.421 53.712-90.466 105-112 11.986-5.033 25.833-7.783 39-11 5.322-1.3 11.969 0.518 16-2z" fill="#FFFFFF" ></path></symbol><symbol id="icon-rss" viewBox="0 0 1024 1024"><path d="M749.61196492 908.06119793C749.61196492 560.41848146 463.58151854 274.36328126 115.93880207 274.36328126V115.93880207c434.50388795 0 792.12239584 357.61850789 792.12239586 792.12239586zM224.55858562 690.72261555a108.91682943 108.91682943 0 0 1 108.69404499 108.74355267C333.25263061 859.29616292 284.24005737 908.06119793 224.31104736 908.06119793 164.48105265 908.06119793 115.96355592 859.41993206 115.96355592 799.46616822s48.69077351-108.71879883 108.61978351-108.74355267zM641.01693522 908.06119793h-153.96879069c0-203.60020956-167.50913289-371.13409627-371.10934246-371.13409629v-153.96879068c288.03550619 0 525.07813313 237.11688843 525.07813315 525.10288697z" fill="#FFA500" ></path></symbol><symbol id="icon-youxiang" viewBox="0 0 1024 1024"><path d="M583.60666667 972h-68.08c-8.43333333 0-15.33333333-6.9-15.33333334-15.33333333V609.52c0-8.43333333 6.9-15.33333333 15.33333334-15.33333333h68.08c8.43333333 0 15.33333333 6.9 15.33333333 15.33333333V956.66666667c0 8.43333333-6.9 15.33333333-15.33333333 15.33333333z" fill="#629FF9" ></path><path d="M294.42 167c-113.62 0-205.77333333 92-205.77333333 205.31333333v336.72h411.39333333V372.31333333c0.15333333-113.31333333-92-205.31333333-205.62-205.31333333z" fill="#2166CC" ></path><path d="M519.97333333 627H216.98666667c-25.45333333 0-46-20.54666667-46-46V393.78c0-25.45333333 20.54666667-46 46-46h302.98666666c25.45333333 0 46 20.54666667 46 46V581c0 25.45333333-20.54666667 46-46 46z" fill="#D2E4FF" ></path><path d="M565.97333333 397a49.22 49.22 0 0 0-49.37333333-49.22H220.36c-27.29333333 0-49.37333333 22.08-49.37333333 49.22v10.27333333l179.4 94.60666667c11.34666667 5.98 24.84 5.98 36.18666666 0l179.4-94.60666667v-10.27333333z" fill="#FFFFFF" ></path><path d="M730.5 167h-427.8v0.46c109.78666667 4.29333333 197.49333333 94.3 197.49333333 205.00666667v336.72h411.39333334c27.29333333 0 49.37333333-22.08 49.37333333-49.22V397c0-126.96-103.19333333-230-230.46-230z" fill="#4E8DF6" ></path><path d="M845.80666667 52H681.12666667c-9.04666667 0-16.40666667 7.36-16.40666667 16.40666667v336.72a24.67133333 24.67133333 0 1 0 49.37333333 0V134.18666667h131.71333334c9.04666667 0 16.40666667-7.36 16.40666666-16.40666667V68.40666667c0-9.04666667-7.36-16.40666667-16.40666666-16.40666667z" fill="#2166CC" ></path><path d="M896.25333333 659.81333333h-35.11333333c-8.43333333 0-15.33333333-6.9-15.33333333-15.33333333v-35.11333333c0-8.43333333 6.9-15.33333333 15.33333333-15.33333334h35.11333333c8.43333333 0 15.33333333 6.9 15.33333334 15.33333334v35.11333333c0 8.58666667-6.9 15.33333333-15.33333334 15.33333333z" fill="#FFFFFF" ></path><path d="M88.8 709.18666667l-24.22666667 131.40666666c-9.66 54.43333333 26.83333333 98.59333333 81.26666667 98.59333334h213.9c54.58666667 0 106.56666667-44.16 116.22666667-98.59333334l23.15333333-131.40666666H88.8z" fill="#2974CE" ></path></symbol><symbol id="icon-gitHub" viewBox="0 0 1049 1024"><path d="M523.6581816 52C262.83923907 52 52 262.8401375 52 523.6581816c0 208.49703047 135.09433812 384.97758117 322.50789391 447.44906532 23.42658172 4.68531653 32.01647887-10.15136894 32.01647796-22.64584583 0-10.93210574-0.78163433-48.41463703-0.78163433-87.45953855-131.18885996 28.11189824-158.5200223-56.22379738-158.52002231-56.22379739-21.08437312-54.66232469-52.3201152-68.71827336-52.3201152-68.71827335-42.94858371-28.89353348 3.12384382-28.89353348 3.12384384-28.89353348 47.63479867 3.12384382 72.62285398 48.41643391 72.62285398 48.4164339 42.16784782 71.84121875 110.10538527 51.53758242 137.43654672 39.04400399 3.90457972-30.45500618 16.3990566-51.5393793 29.67427028-63.25222094-104.64023039-10.93300418-214.74561566-51.53848086-214.74561657-232.70524742 0-51.53848086 18.74126609-93.70632867 48.4164339-126.50444187-4.68621496-11.71284164-21.08527156-60.12837711 4.6844181-124.94207075 0 0 39.82563922-12.49447688 129.62738726 48.41463704 37.48253129-10.15136894 78.08980484-15.61742227 117.91454562-15.61742137s80.43201433 5.46605242 117.91454473 15.61742137c89.80264648-60.90911391 129.62828571-48.41463703 129.62828571-48.41463704 25.76879122 64.81369363 9.37063305 113.22922911 4.68531651 124.94207075 30.45410773 32.79721477 48.41463703 74.96506258 48.41463703 126.50444187 0 181.16676656-110.10538527 220.99150644-215.52545401 232.70524742 17.1797934 14.83668547 32.01647887 42.94858371 32.01647886 87.45953946 0 63.25222094-0.78163433 114.009965-0.78163523 129.62738636 0 12.49447688 8.59079468 27.33116234 32.01737731 22.64584583 187.41265734-62.4705866 322.50699547-238.95203574 322.50699546-447.44996375C995.31636231 262.8401375 783.69369203 52 523.6581816 52z" fill="#663399" ></path><path d="M230.82365863 729.03136735c-0.7807359 2.34310703-4.68531653 3.12384382-7.80916035 1.56237113s-5.46605242-4.68531653-3.90368129-7.02842356c0.7807359-2.34220859 4.68531653-3.12384382 7.80826192-1.56147269s4.68531653 4.68531653 3.90457972 7.02752512z m18.7412661 21.08437312c-2.34220859 2.34220859-7.02752512 0.78163433-9.37063305-2.34310703-3.12294539-3.12294539-3.90457972-7.80826192-1.5614727-10.15136894 2.34220859-2.34220859 6.24678922-0.7807359 9.37063305 2.34310702 3.12384382 3.90457972 3.90457972 8.58899782 1.5614727 10.15136895zM268.30618992 777.44690281c-3.12294539 2.34220859-7.80826192 0-10.15136895-3.90457972-3.12384382-3.90457972-3.12384382-9.37063305 0-10.93210574 3.12384382-2.34310703 7.80916035 0 10.15226739 3.90457972 3.12294539 3.90368129 3.12294539 8.58899782 0 10.93210574z m25.76968965 26.55042555c-2.34220859 3.12294539-7.80916035 2.34220859-12.49447688-1.56237113-3.90457972-3.90368129-5.46605242-9.37063305-2.34220859-11.71284164 2.34220859-3.12384382 7.80826192-2.34310703 12.49447687 1.56147269 3.90368129 3.12384382 4.68531653 8.58989625 2.3422086 11.71374008z m35.1403227 14.83668637c-0.78163433 3.90457972-6.24768766 5.46605242-11.71374008 3.90457972-5.46605242-1.5614727-8.58899782-6.24768766-7.80916036-9.37063305 0.78163433-3.90457972 6.24768766-5.46605242 11.71374009-3.90457972 5.46605242 1.5614727 8.58899782 5.46605242 7.80916035 9.37063305z m38.26416562 3.12384382c0 3.90457972-4.68621496 7.02752512-10.15226738 7.02752512-5.46605242 0-10.15226738-3.12294539-10.15226739-7.02752512s4.68621496-7.02842356 10.15226739-7.02842445c5.46605242 0 10.15226738 3.12384382 10.15226738 7.02842445z m35.92016106-6.24768766c0.78163433 3.90457972-3.12384382 7.80916035-8.58899872 8.58989625-5.46695086 0.78163433-10.15226738-1.5614727-10.93390172-5.46605241-0.77983747-3.90457972 3.12384382-7.80916035 8.5907947-8.58899872 5.46605242-0.78163433 10.15136894 1.56057426 10.93210574 5.46515488z m0 0" fill="#663399" ></path></symbol><symbol id="icon-bilibili" viewBox="0 0 1024 1024"><path d="M832.61667555 181.33447111h-164.32545185l74.45617778-74.45617778c12.84020148-12.84020148 12.84020148-30.8140563 0-43.65425778-12.84020148-12.84020148-30.8140563-12.84020148-43.65425778 0L573.2882963 189.04101925H450.04420741L324.2272237 63.23617185c-10.26730667-12.84020148-25.68040297-15.40096-41.08136295-7.70654815-2.57289482 0-2.57289482 2.57289482-5.13365334 5.13365333-12.84020148 12.84020148-12.84020148 30.8140563 0 43.65425779l77.02907259 77.02907259h-164.32545185c-89.86927408 0-164.32545185 74.45617778-164.32545185 164.32545184v408.24073483c0 87.29637925 74.45617778 161.75255703 164.32545185 161.75255703h25.68040296c0 30.8140563 25.68040297 53.92156445 53.92156444 53.92156444s53.92156445-25.68040297 53.92156445-53.92156444H704.23893333c2.57289482 30.8140563 28.24116148 53.92156445 59.05521778 51.34866964 28.24116148-2.57289482 48.78791111-23.10750815 51.34866964-51.34866964h20.53461333c89.86927408 0 164.32545185-74.45617778 164.32545184-164.32545186V343.09916445c-2.56075852-89.86927408-77.02907259-161.76469333-166.88621037-161.76469334z m-5.13365333 634.19429926H200.99527111c-33.37481482 0-59.05521778-28.24116148-61.61597629-61.61597629l-2.57289482-415.94728297c0-33.37481482 28.24116148-61.6159763 61.6159763-61.61597629h626.48775111c33.37481482 0 59.05521778 28.24116148 61.61597629 61.61597629l2.57289482 415.94728297c-2.57289482 35.93557333-28.24116148 61.6159763-61.6159763 61.61597629z" fill="#ff7299" ></path><path d="M403.82919111 417.55534222l15.40096 77.0290726-205.40681481 38.50846815-15.40096-77.0290726 205.40681481-38.50846815z m197.70026667 77.0290726l15.40096-77.0290726 205.40681481 38.50846815-15.40096 77.0290726-205.40681481-38.50846815z m41.08136297 161.75255703c0 2.57289482 0 7.70654815-2.57289483 10.26730667-12.84020148 28.24116148-41.08136297 46.2150163-74.45617777 48.78791111-20.53461333 0-41.08136297-10.26730667-53.92156445-25.68040296-15.40096 15.40096-33.37481482 25.68040297-53.92156445 25.68040296-30.8140563-2.57289482-59.05521778-20.53461333-74.45617777-48.78791111 0-2.57289482-2.57289482-5.13365333-2.57289481-10.26730667 0-10.26730667 7.70654815-17.97385482 17.97385481-20.53461333h2.57289482c7.70654815 0 12.84020148 2.57289482 15.40096 10.26730666 0 0 20.53461333 28.24116148 38.50846815 28.24116149 35.94770963 0 35.94770963-30.8140563 56.48232296-53.92156445 23.10750815 25.68040297 23.10750815 53.92156445 56.48232296 53.92156445 23.10750815 0 38.50846815-28.24116148 38.50846815-28.24116149 2.57289482-5.13365333 10.26730667-10.26730667 15.40096-10.26730666 10.26730667-2.57289482 17.97385482 5.13365333 20.53461333 15.40096v5.13365333h0.0364089z" fill="#ff7299" ></path></symbol></svg>',      o = (o = document.getElementsByTagName("script"))[o.length - 1].getAttribute("data-injectcss"),      p = function (c, l) {        l.parentNode.insertBefore(c, l);      };    if (o && !c.__iconfont__svg__cssinject__) {      c.__iconfont__svg__cssinject__ = !0;      try {        document.write(          "<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>"        );      } catch (c) {        console && console.log(c);      }    }    function d() {      i || ((i = !0), a());    }    function m() {      try {        t.documentElement.doScroll("left");      } catch (c) {        return void setTimeout(m, 50);      }      d();    }    (l = function () {      var c,        l = document.createElement("div");      (l.innerHTML = v),        (v = null),        (l = l.getElementsByTagName("svg")[0]) &&          (l.setAttribute("aria-hidden", "true"),          (l.style.position = "absolute"),          (l.style.width = 0),          (l.style.height = 0),          (l.style.overflow = "hidden"),          (l = l),          (c = document.body).firstChild ? p(l, c.firstChild) : c.appendChild(l));    }),      document.addEventListener        ? ~["complete", "loaded", "interactive"].indexOf(document.readyState)          ? setTimeout(l, 0)          : ((h = function () {              document.removeEventListener("DOMContentLoaded", h, !1), l();            }),            document.addEventListener("DOMContentLoaded", h, !1))        : document.attachEvent &&          ((a = l),          (t = c.document),          (i = !1),          m(),          (t.onreadystatechange = function () {            "complete" == t.readyState && ((t.onreadystatechange = null), d());          }));  })(window);]]></content>
      
    </entry>
    
    
  
</search>
