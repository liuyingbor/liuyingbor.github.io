<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>狼唤</title>
  
  
  <link href="https://liuyingbo.com/atom.xml" rel="self"/>
  
  <link href="https://liuyingbo.com/"/>
  <updated>2023-01-30T11:35:12.190Z</updated>
  <id>https://liuyingbo.com/</id>
  
  <author>
    <name>刘英博</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity-移动端屏幕适配</title>
    <link href="https://liuyingbo.com/posts/29f6.html"/>
    <id>https://liuyingbo.com/posts/29f6.html</id>
    <published>2023-01-30T11:35:12.190Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始之前的重要信息"><a href="#开始之前的重要信息" class="headerlink" title="开始之前的重要信息"></a>开始之前的重要信息</h1><p>本教程的标签之⼀是初学者，但这不是完全初学者的教程。</p><p>虽然您不必是专业的 C# 编码⼈员，但我希望您熟悉 C#，以便您可以根据⾃⼰的需要编辑脚本。</p><h1 id="如何修复不同屏幕尺⼨的差距"><a href="#如何修复不同屏幕尺⼨的差距" class="headerlink" title="如何修复不同屏幕尺⼨的差距"></a>如何修复不同屏幕尺⼨的差距</h1><p>移动游戏开发的⼀个⼤问题是游戏中的空⽩空间和资产之间的差距。在⼤多数情况下，这是游戏背景和空⽩区域的问题。</p><p>例如，让我们看⼀下这个场景：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301902387.jpg" alt="img"> </p><p>如您所⻅，这是“游戏”选项卡的屏幕截图，该场景使⽤的参考分辨率是全⾼清，例如</p><p>1920×1080。</p><p>从上图中我们可以看到设置没有任何问题，⼀切都在它应该在的地⽅。但是，这是 Unity</p><p>编辑器的预览，让我们来看看游戏在真实设备上的样⼦。</p><p>这是在分辨率为 1920×1080 的 iPhone 6 Plus 上预览游戏的效果：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301902958.jpg" alt="img"> </p><p>这是游戏在分辨率为 1334×750 的 iPhone 7 上的样⼦：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301902310.jpg" alt="img"></p><p>这是游戏在分辨率为 1280×720 的三星 Galaxy A5 上的样⼦：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301903830.jpg" alt="img"></p><p>如您所⻅，我们的游戏在 Unity 编辑器和上述设备上看起来是⼀样的。这⾥的问题是我们只在分辨率为1920×1080或以下的设备上测试了游戏，让我们来看看我们的游戏在分辨率更⾼的设备上的表现。</p><p>这是游戏在分辨率为 2436×1125 的 iPhone 11 Pro 上的样⼦：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301903901.jpg" alt="img"></p><p>⻢上，您会注意到⼿机的左右两侧有缝隙。背景不够⻓，⽆法填补这些空⽩，这就是为什么您会看到空⽩区域或 Unity 相机的蓝⾊。</p><p>接下来，这就是游戏在分辨率为 3120×1440 的华为 Mate 20 Pro 上的样⼦：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301903242.jpg" alt="img"></p><p>这就是游戏在分辨率为 3040×1440 的三星 Galaxy Note 10+ 上的样⼦：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301903136.jpg" alt=""></p><p>我们在 iPhone 11 Pro 上遇到了同样的问题，在华为 Mate 20 Pro 和三星 Galaxy Note 10+ 上也遇到了同样的问题。当然，在其他⼿机上我们也会遇到同样的问题。</p><p>那么解决⽅法是什么？</p><h1 id="缩放背景以适合所有屏幕尺⼨"><a href="#缩放背景以适合所有屏幕尺⼨" class="headerlink" title="缩放背景以适合所有屏幕尺⼨"></a>缩放背景以适合所有屏幕尺⼨</h1><p>正如我在本文开头所说的那样，在创建移动游戏时，最困难的任务是让您的游戏在所有屏幕尺⼨上看起来都⼀样。</p><p>因为有如此多的设备具有不同的屏幕尺⼨和纵横比，所以很难让您的游戏在所有这些屏幕和纵横比上看起来都⼀样，但当然，解决这个问题并非不可能。</p><p>我们解决此问题的⽅法之⼀是使⽤⼀个脚本，该脚本将根据设备的屏幕宽度和⾼度缩放背景：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScaleToFitScreen</span> : <span class="title">MonoBehaviour</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SpriteRenderer sr;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sr = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">        <span class="comment">// world height is always camera&#x27;s orthographicSize * 2</span></span><br><span class="line">        <span class="built_in">float</span> worldScreenHeight = Camera.main.orthographicSize * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// world width is calculated by diving world height with screen heigh</span></span><br><span class="line">        <span class="comment">// then multiplying it with screen width</span></span><br><span class="line">        <span class="built_in">float</span> worldScreenWidth = worldScreenHeight / Screen.height * Screen.width;</span><br><span class="line">        <span class="comment">// to scale the game object we divide the world screen width with the</span></span><br><span class="line">        <span class="comment">// size x of the sprite, and we divide the world screen height with the</span></span><br><span class="line">        <span class="comment">// size y of the sprite</span></span><br><span class="line">        transform.localScale = <span class="keyword">new</span> Vector3(</span><br><span class="line">        &#125;</span><br><span class="line"> &#125; <span class="comment">// class</span></span><br></pre></td></tr></table></figure><p>要了解脚本在做什么，我们需要了解屏幕宽度和⾼度以及世界宽度和⾼度之间的差异。</p><p>当我们使⽤ Screen.width 或 Screen.height 时，我们会得到设备屏幕的宽度和⾼度信息。因此，如果游戏在分辨率为 1920×1080 的设备上运⾏，Screen.width 将返回 1920， Screen.height 将返回 1080。</p><p>但是，如果您尝试将这些数字⽤作游戏中精灵的比例值，那么精灵看起来会很奇怪，因为它会异常调整⼤⼩。</p><p>所以我们需要做的是将屏幕分辨率的宽度和⾼度值转换为 Unity 的屏幕宽度和⾼度的单位值。我们在上述课程的第 12 ⾏和第 16 ⾏执⾏的计算就是这样做的。</p><p>要使此脚本起作⽤，您需要将其附加到场景中的背景游戏对象。让我们来看看我们的游戏现在在我们在第⼀次初始测试中有差距的相同设备上的样⼦，从分辨率为 2436×1125 的</p><p>iPhone 11 Pro 开始：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301901158.jpg" alt="img"></p><p>您会注意到我们两侧的蓝⾊间隙现在消失了，因为背景正在缩放以适应设备的屏幕尺⼨，同时保持像素清晰的分辨率。</p><p>现在让我们看看我们的游戏在分辨率为3120×1440的华为Mate 20 Pro上的效果：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301907790.jpg" alt="img"></p><p>同样，我们⼀开始的差距现在已经消失了。最后，这是我们的游戏在分辨率为</p><p>3040×1440 的三星 Galaxy Note 10+ 上的样⼦：</p><p><a href="https://awesometuts.com/wp-content/uploads/2021/11/Img-10.jpg.webp"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301901230.jpg" alt="img"></a></p><p>不出所料，我们之前的差距现在已经消失了。但是，我们现在有⼀个不同的问题。</p><h1 id="我的游戏对象在哪⾥？"><a href="#我的游戏对象在哪⾥？" class="headerlink" title="我的游戏对象在哪⾥？"></a>我的游戏对象在哪⾥？</h1><p>为了说明我们现在遇到的问题，我将使⽤ 3040×1440 作为参考分辨率重新设计游戏。</p><p>当我说重新设计游戏时，我的意思是我将使⽤上述分辨率作为参考分辨率来安排游戏中的游戏元素。</p><p>这是游戏现在在“游戏”选项卡预览中的样⼦：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301907490.jpg" alt="img"></p><p>如果我们在分辨率为 3040×1440 的 Samsung Galaxy Note 10+ 上运⾏游戏，我们将看不到游戏有什么不同：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301907241.jpg" alt="img"></p><p>但是如果我们在分辨率较低的设备上运⾏游戏会发⽣什么，比如 iPhone 6 Plus，分辨率为 1920×1080？</p><p>好吧，让我们测试⼀下，看看结果：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301908509.jpg" alt="img"></p><p>现在你会注意到侧⾯的游戏元素被剪掉了。您可以在左侧部分看到⼀个游戏元素，⽽在右侧您⼏乎看不到另⼀个游戏元素剩下的部分：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301908772.jpg" alt="img"></p><p>这就是为什么你不能只使⽤参考分辨率设计你的游戏并保持原样，因为⼀旦你的游戏在比你设计游戏的分辨率更⾼或更低的分辨率下玩，⼀些游戏元素就会被从屏幕上切掉，有时屏幕的两侧会有空隙，正如我们在⽬前的⽰例中看到的那样。</p><p>那么解决⽅法是什么？</p><h1 id="在屏幕上锚定游戏对象"><a href="#在屏幕上锚定游戏对象" class="headerlink" title="在屏幕上锚定游戏对象"></a>在屏幕上锚定游戏对象</h1><p>正如您可以假设的那样，与我们解决背景差距问题的⽅式相同，我们将解决我们游戏元素的锚定问题，那就是使⽤⼀个脚本，具体来说是使⽤两个脚本。</p><p>第⼀个脚本称为 CameraViewportHandler：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraViewportHandler</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> Constraint &#123; Landscape, Portrait &#125; </span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> FIELDS </span></span><br><span class="line">    <span class="keyword">public</span> Color wireColor = Color.white; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> UnitsSize = <span class="number">1</span>; <span class="comment">// size of your scene in unity units</span></span><br><span class="line">    <span class="keyword">public</span> Constraint constraint = Constraint.Portrait; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CameraViewportHandler Instance; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">new</span> Camera camera; <span class="keyword">public</span> <span class="built_in">bool</span> executeInUpdate; </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> _width; <span class="keyword">private</span> <span class="built_in">float</span> _height; </span><br><span class="line">    <span class="comment">//*** bottom screen private Vector3 _bl;</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 _bc; <span class="keyword">private</span> Vector3 _br;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/*** middle screen private Vector3 _ml;</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 _mc; <span class="keyword">private</span> Vector3 _mr; </span><br><span class="line">    <span class="comment">//*** top screen private Vector3 _tl;</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 _tc; </span><br><span class="line">    <span class="keyword">private</span> Vector3 _tr; </span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> PROPERTIES </span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Width &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _width; &#125; &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Height &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _height; &#125; &#125; <span class="comment">// helper points:</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 BottomLeft &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _bl; &#125; &#125; </span><br><span class="line">    <span class="keyword">public</span> Vector3 BottomCenter &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _bc; &#125; &#125; </span><br><span class="line">    <span class="keyword">public</span> Vector3 BottomRight &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _br; &#125; &#125; </span><br><span class="line">    <span class="keyword">public</span> Vector3 MiddleLeft &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _ml; &#125; &#125; </span><br><span class="line">    <span class="keyword">public</span> Vector3 MiddleCenter &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _mc; &#125; &#125; </span><br><span class="line">    <span class="keyword">public</span> Vector3 MiddleRight &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _mr; &#125; &#125; </span><br><span class="line">    <span class="keyword">public</span> Vector3 TopLeft &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _tl; &#125; &#125; </span><br><span class="line">    <span class="keyword">public</span> Vector3 TopCenter &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _tc; &#125; &#125; </span><br><span class="line">    <span class="keyword">public</span> Vector3 TopRight &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _tr; &#125; &#125; </span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> METHODS</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        camera = GetComponent&lt;Camera&gt;(); Instance = <span class="keyword">this</span>; ComputeResolution();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ComputeResolution</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> leftX, rightX, topY, bottomY;</span><br><span class="line">        <span class="keyword">if</span> (constraint == Constraint.Landscape)</span><br><span class="line">        &#123;</span><br><span class="line">            camera.orthographicSize = <span class="number">1f</span> / camera.aspect * UnitsSize / <span class="number">2f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            camera.orthographicSize = UnitsSize / <span class="number">2f</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        _height = <span class="number">2f</span> * camera.orthographicSize; </span><br><span class="line">        _width = _height * camera.aspect; </span><br><span class="line">        <span class="built_in">float</span> cameraX, cameraY; cameraX = camera.transform.position.x; </span><br><span class="line">        cameraY = camera.transform.position.y; </span><br><span class="line">        leftX = cameraX - _width / <span class="number">2</span>; rightX = cameraX + _width / <span class="number">2</span>; </span><br><span class="line">        topY = cameraY + _height / <span class="number">2</span>; bottomY = cameraY - _height / <span class="number">2</span>; </span><br><span class="line">        <span class="comment">//*** bottom</span></span><br><span class="line">        _bl = <span class="keyword">new</span> Vector3(leftX, bottomY, <span class="number">0</span>); </span><br><span class="line">        _bc = <span class="keyword">new</span> Vector3(cameraX, bottomY, <span class="number">0</span>); </span><br><span class="line">        _br = <span class="keyword">new</span> Vector3(rightX, bottomY, <span class="number">0</span>); </span><br><span class="line">        <span class="comment">//*** middle</span></span><br><span class="line">        _ml = <span class="keyword">new</span> Vector3(leftX, cameraY, <span class="number">0</span>); </span><br><span class="line">        _mc = <span class="keyword">new</span> Vector3(cameraX, cameraY, <span class="number">0</span>); </span><br><span class="line">        _mr = <span class="keyword">new</span> Vector3(rightX, cameraY, <span class="number">0</span>); </span><br><span class="line">        <span class="comment">//*** top</span></span><br><span class="line">        _tl = <span class="keyword">new</span> Vector3(leftX, topY, <span class="number">0</span>); </span><br><span class="line">        _tc = <span class="keyword">new</span> Vector3(cameraX, topY, <span class="number">0</span>); </span><br><span class="line">        _tr = <span class="keyword">new</span> Vector3(rightX, topY, <span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR </span></span><br><span class="line"><span class="keyword">if</span> (executeInUpdate) ComputeResolution();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDrawGizmos</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.color = wireColor; </span><br><span class="line">        Matrix4x4 temp = Gizmos.matrix; </span><br><span class="line">        Gizmos.matrix = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);</span><br><span class="line">        <span class="keyword">if</span> (camera.orthographic)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> spread = camera.farClipPlane - camera.nearClipPlane; </span><br><span class="line">            <span class="built_in">float</span> center = (camera.farClipPlane + camera.nearClipPlane) * <span class="number">0.5f</span>; </span><br><span class="line">            Gizmos.DrawWireCube(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, center), <span class="keyword">new</span> Vector3(camera.orthographicSize * <span class="number">2</span> * camera.aspect, camera.orthographicSize * <span class="number">2</span>, spread));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Gizmos.DrawFrustum(Vector3.zero, camera.fieldOfView, camera.farClipPlane, camera.nearClipPlane, camera.aspect);</span><br><span class="line">        &#125; </span><br><span class="line">        Gizmos.matrix = temp;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125; <span class="comment">// class</span></span><br></pre></td></tr></table></figure><p>该脚本将根据游戏是横向模式还是纵向模式以及单位⼤⼩变量来计算相机的正交⼤⼩。您可以在类的检查器选项卡中设置所有这些值：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301925585.jpg" alt="img"></p><p>单位⼤⼩将根据您的游戏⽽有所不同，因此请务必检查从 10 到 20 之间的范围开始的不同值。</p><p>您可以选中 Execute In Update 复选框以使脚本在 Update 中执⾏，同时您在 Unity 编辑器中以立即查看您所做的更改，但您将在运⾏游戏时看到真实结果。</p><p>如果我再次在 iPhone 6 Plus 上测试游戏，我们会看到同样的结果：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301925406.jpg" alt="img"></p><p>这样做的原因是因为 CameraViewportHandler 将确保相机的 Orthographic Size 是有序的，⽆论我们在哪种屏幕尺⼨上玩游戏，但我们需要结合 CameraViewportHandler 使⽤另⼀个脚本来将我们的游戏对象定位在屏幕上正确。</p><p>该脚本称为 AnchorGameObject：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnchorGameObject</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> AnchorType</span><br><span class="line">    &#123;</span><br><span class="line">        BottomLeft, </span><br><span class="line">        BottomCenter, </span><br><span class="line">        BottomRight, </span><br><span class="line">        MiddleLeft, </span><br><span class="line">        MiddleCenter, </span><br><span class="line">        MiddleRight, </span><br><span class="line">        TopLeft, </span><br><span class="line">        TopCenter, </span><br><span class="line">        TopRight,</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> executeInUpdate; </span><br><span class="line">    <span class="keyword">public</span> AnchorType anchorType; </span><br><span class="line">    <span class="keyword">public</span> Vector3 anchorOffset; </span><br><span class="line">    IEnumerator updateAnchorRoutine; <span class="comment">//Coroutine handle so we don&#x27;t start it if it&#x27;s already running</span></span><br><span class="line">                                     </span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        updateAnchorRoutine = UpdateAnchorAsync(); </span><br><span class="line">        StartCoroutine(updateAnchorRoutine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Coroutine to update the anchor only once CameraFit.Instance is not null.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">UpdateAnchorAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">uint</span> cameraWaitCycles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (CameraViewportHandler.Instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++cameraWaitCycles; <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cameraWaitCycles &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="built_in">string</span>.Format(<span class="string">&quot;CameraAnchor found CameraFit instance after waiting &#123;0&#125; frame(s). &quot;</span> + <span class="string">&quot;You might want to check that CameraFit has an earlie execution order.&quot;</span>, cameraWaitCycles));</span><br><span class="line">        &#125; </span><br><span class="line">        UpdateAnchor(); </span><br><span class="line">        updateAnchorRoutine = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateAnchor</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (anchorType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> AnchorType.BottomLeft: SetAnchor(CameraViewportHandler.Instance.BottomLeft); </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> AnchorType.BottomCenter: SetAnchor(CameraViewportHandler.Instance.BottomCenter); </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> AnchorType.BottomRight: SetAnchor(CameraViewportHandler.Instance.BottomRight); </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> AnchorType.MiddleLeft: SetAnchor(CameraViewportHandler.Instance.MiddleLeft); </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> AnchorType.MiddleCenter: SetAnchor(CameraViewportHandler.Instance.MiddleCenter); </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> AnchorType.MiddleRight: SetAnchor(CameraViewportHandler.Instance.MiddleRight); </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> AnchorType.TopLeft: SetAnchor(CameraViewportHandler.Instance.TopLeft); </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> AnchorType.TopCenter: SetAnchor(CameraViewportHandler.Instance.TopCenter); </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> AnchorType.TopRight: SetAnchor(CameraViewportHandler.Instance.TopRight); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetAnchor</span>(<span class="params">Vector3 anchor</span>)</span> &#123;</span><br><span class="line">        Vector3 newPos = anchor + anchorOffset; <span class="keyword">if</span> (!transform.position.Equals(newPos)) &#123; transform.position = newPos; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR </span></span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (updateAnchorRoutine == <span class="literal">null</span> &amp;&amp; executeInUpdate) &#123;</span><br><span class="line">            updateAnchorRoutine = UpdateAnchorAsync(); </span><br><span class="line">            StartCoroutine(updateAnchorRoutine);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnchorGameObject 脚本的⼯作⽅式是使⽤第 7-18 ⾏声明的 AnchorType 以及第 59-91</p><p>⾏的 CameraViewportHandler 变量来设置锚点，例如游戏对象的中⼼原点。</p><p>然后您可以使⽤第 23 ⾏声明的 anchorOffset 变量来确定特定游戏对象相对于其锚点（例如中⼼原点）的偏移量。</p><p>AnchorGameObject  脚本应附加到您要定位或锚定在屏幕上的游戏对象上。</p><p>需要记住的⼀件事是，将此组合与这 3 个脚本结合使⽤时，您需要使⽤⼀个参考分辨率作为基本分辨率来设计游戏，您将使⽤该参考分辨率来锚定游戏对象。</p><p>我将使⽤与三星 Galaxy 10+ 相同的分辨率，即 3040×1440 作为参考分辨率。</p><p>⾸先，我要将脚本附加到右侧的 Altar 1 游戏对象上，并对 AnchorGameObject 脚本使⽤以下设置：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301901078.jpg" alt="img"></p><p>这会将对象的锚点设置为右中，并将其在 X 轴上偏移 -1.5，在 Y 轴上偏移 1，这会将游戏对象定位在此处：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301934468.jpg" alt=""></p><p>接下来，我要将脚本附加到我的 Altar 2 游戏对象上，并为 AnchorGameObject 脚本设置以下设置：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301934529.jpg" alt="img"></p><p>这将把游戏对象的锚点设置在左中，并在 X 轴上偏移 2，在 Y 轴上偏移 0.53，这将把游戏对象定位在这⾥：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301934696.jpg" alt="img"></p><p>现在⽆论我们以何种分辨率玩游戏，这两个游戏对象都将停留在我们刚刚放置它们的位置。</p><p>在我们测试我们的新设置之前，让我们快速看⼀下在不使⽤我们的两个脚本进⾏测试时，相同设置在分辨率为 1920×1080 的 iPhone 6 Plus 上的样⼦：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301934299.jpg" alt="img"></p><p>现在让我们使⽤刚刚使⽤两个新脚本创建的新设置在 iPhone 6 Plus 上测试我们的游戏：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202301301934674.jpg" alt="img"></p><p>现在我们的两个游戏对象并没有从屏幕上切下来，它们在游戏中清晰可⻅。</p><p>⽽且⽆论您的游戏在何种分辨率下运⾏，当您将此组合与 CameraViewportHandler 和</p><p>AnchorGameObject  脚本结合使⽤时，您的游戏对象将位于您最初放置它们的相同位置。</p><p>现在，不⾔⽽喻，这种⽅法适⽤于静态游戏，例如所有游戏玩法都发⽣在⼀个地⽅并且屏幕（例如相机）在游戏中没有移动的游戏。</p><p>如果您的游戏是动态的，例如平台游戏或塔防游戏等，您将不会遇到需要锚定游戏对象的这些问题，因为您将创建更⼤的关卡，因此⽆论摄像机在游戏中的哪个位置，它将渲染游戏那部分的关卡。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开始之前的重要信息&quot;&gt;&lt;a href=&quot;#开始之前的重要信息&quot; class=&quot;headerlink&quot; title=&quot;开始之前的重要信息&quot;&gt;&lt;/a&gt;开始之前的重要信息&lt;/h1&gt;&lt;p&gt;本教程的标签之⼀是初学者，但这不是完全初学者的教程。&lt;/p&gt;
&lt;p&gt;虽然您不必是专业</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="移动平台" scheme="https://liuyingbo.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="Android" scheme="https://liuyingbo.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>C# LINQ</title>
    <link href="https://liuyingbo.com/posts/4ac7.html"/>
    <id>https://liuyingbo.com/posts/4ac7.html</id>
    <published>2022-11-24T22:49:16.000Z</published>
    <updated>2023-01-30T11:35:12.194Z</updated>
    
    <content type="html"><![CDATA[<p>LINQ 是 Language INtegrated Query 单词的首字母缩写，翻译过来是语言集成查询。它为查询跨各种数据源和格式的数据提供了一致的模型，所以叫集成查询。由于这种查询并没有制造新的语言而只是在现有的语言基础上来实现，所以叫语言集成查询。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在 C# 中，从功能上 LINQ 可分为两类：LINQ to Object 和 LINQ to XML；从语法上 LINQ 可以分为 LINQ to Object 和 LINQ 扩展方法</p><p>纠正：</p><p>从功能上 LINQ 可分为两类：</p><ul><li>LINQ to Object，查询内存集合，直接把查询编译成 .NET 代码执行。</li><li>LINQ to Provider，查询自定义数据源，由开发者提供相应数据源的 Provider 并翻译和执行自定义查询，如 XML、JSON 等都可以作为 Provider 对应的数据源，数据源对应的 LINQ 查询叫 LINQ to &lt;数据源&gt;，比如：LINQ to XML。</li></ul><p>从语法上 LINQ 可以分为：</p><ul><li>SQL风格：语法和 SQL 相似，部分复杂查询用 SQL 风格语义会更清晰明了，比如 SelectMany 和 Join 查询。SQL 风格的可读性有绝对优势，但不支持全部标准 LINQ 函数，不支持自定义函数。纯粹的语法糖。</li><li>函数风格：以 C# 扩展方法的方式实现，扩展方法即可以是标准库提供的也可以是自己实现的，完全的原生编程风格，编译后的代码都是函数调用。支持全部标准 LINQ 函数和任何自定义函数。随着查询复杂度的提高，可读性不如 SQL 风格。</li></ul><p>感谢 @coredx 的纠正。</p><p>所有 LINQ to Object 都可以用 LINQ 扩展方法实现等同的效果，而且平时开发中用的最多的是 LINQ 扩展方法。</p><p>LINQ to Object 多用于映射数据库的查询，LINQ to XML 用于查询 XML 元素数据。使用 LINQ 查询的前提是对象必须是一个 IEnumerable 集合（注意，为了描述方便，本文说的集合都是指 IEnumerable 对象，包含字面上的 ICollection 对象）。另外，LINQ 查询大多是都是链式查询，即操作的数据源是 <code>IEnumerable&lt;T1&gt;</code> 类型，返回的是 <code>IEnumerable&lt;T2&gt;</code> 类型，T1 和 T2 可以相同，也可以不同。</p><p>形如下面这样的查询就是 LINQ to Object：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">from</span> user <span class="keyword">in</span> users</span><br><span class="line">  <span class="keyword">where</span> user.Name.Contains(<span class="string">&quot;Wang&quot;</span>)</span><br><span class="line">  <span class="keyword">select</span> user.Id;</span><br></pre></td></tr></table></figure><p>等同于使用下面的 LINQ 扩展方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = users</span><br><span class="line">  .Where(u =&gt; user.Name.Contains(<span class="string">&quot;Wang&quot;</span>))</span><br><span class="line">  .Select(u =&gt; u.id);</span><br></pre></td></tr></table></figure><p>LINQ 查询支持在语句中间根据需要定义变量，比如取出数组中平方值大于平均值的数字：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> number <span class="keyword">in</span> numbers</span><br><span class="line">            <span class="keyword">let</span> average = numbers.Average()</span><br><span class="line">            <span class="keyword">let</span> squared = Math.Pow(number, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">where</span> squared &gt; average</span><br><span class="line">            <span class="keyword">select</span> number;</span><br><span class="line"><span class="comment">// 平均值为 4.5, result 为 &#123; 3, 4, 5, 6, 7, 8, 9 &#125;</span></span><br></pre></td></tr></table></figure><p>其中的 Select 方法接收的参数用的最多的是 <code>Func&lt;TSource, TResult&gt;</code>，它还可以接收 <code>Func&lt;TSource, int, TResult&gt;</code> 参数，示例:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collectionWithRowNumber = collection.</span><br><span class="line">    .Select((item, index) =&gt; <span class="keyword">new</span> &#123; Item = item, RowNumber =index &#125;)</span><br><span class="line">    .ToList();</span><br></pre></td></tr></table></figure><p>再来看一下 LINQ to XML 的示例。假如我们有如下 XML 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Employees</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Employee</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EmpId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">EmpId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Liam<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">Sex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Employee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Employee</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EmpId</span>&gt;</span>2<span class="tag">&lt;/<span class="name">EmpId</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">Employee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Employees</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 LINQ to XML 查询所有含有指定节点值的元素：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XElement xelement = XElement.Load(<span class="string">&quot;Employees.xml&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> els = <span class="keyword">from</span> el <span class="keyword">in</span> xelement.Elements(<span class="string">&quot;Employee&quot;</span>)</span><br><span class="line">          <span class="keyword">where</span> (<span class="built_in">string</span>)el.Element(<span class="string">&quot;Sex&quot;</span>) == <span class="string">&quot;Male&quot;</span></span><br><span class="line">          <span class="keyword">select</span> el;</span><br></pre></td></tr></table></figure><p>等同于使用 LINQ 扩展方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> els = xelement.Elements(<span class="string">&quot;Employee&quot;</span>)</span><br><span class="line">    .Where(el =&gt; (<span class="built_in">string</span>)el.Element(<span class="string">&quot;Sex&quot;</span>) == <span class="string">&quot;Male&quot;</span>);</span><br></pre></td></tr></table></figure><p>LINQ to XML 操作 XML 非常方便和灵活，大家可以在具体使用的时候去探索，这里就不展开讲了。</p><p>LINQ 查询有很多方法，由于篇幅原因，就不一一列举演示了，这里只选取一些强大的查询方法，这些方法若使用非 LINQ 来实现可能会比较麻烦。</p><p>LINQ 之所以强大，是因为它可以轻松实现复杂的查询，下面我们来总结一下 C# LINQ 的强大之处。</p><h2 id="First、Last-和-Single-等"><a href="#First、Last-和-Single-等" class="headerlink" title="First、Last 和 Single 等"></a>First、Last 和 Single 等</h2><p>First、FirstOrDefault、Last、LastOrDefault、Single 和 SingleOrDefault 是快速查询集合中的第一个或最后一个元素的方法。如果集合是空的，Fist、Last 和 Single 都会报错，如果使其不报错而在空集合时使用默认值可以使用 FirstOrDefault、LastOrDefault 和 SingleOrDefault。Single/SingleOrDefault 和其它方法的区别是，它限定查询结果只有一个元素，如果查询结果集合中包含多个元素时会报错。具体看下面几个示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.First(x =&gt; x.Equals(<span class="string">&quot;b&quot;</span>)); <span class="comment">// 返回 ”b“</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.First(x =&gt; x.Equals(<span class="string">&quot;c&quot;</span>)); <span class="comment">// 抛出 InvalidOperationException 异常</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.FirstOrDefault(x =&gt; x.Equals(<span class="string">&quot;c&quot;</span>)); <span class="comment">// 返回 null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.Single(x =&gt; x.Equals(<span class="string">&quot;b&quot;</span>)); <span class="comment">// 返回 ”b“</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.Single(x =&gt; x.Equals(<span class="string">&quot;c&quot;</span>)); <span class="comment">// 抛出 InvalidOperationException 异常</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.SingleOrDefault(x =&gt; x.Equals(<span class="string">&quot;c&quot;</span>)); <span class="comment">// 返回 null</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span> &#125;.Single(); <span class="comment">// 抛出 InvalidOperationException 异常</span></span><br></pre></td></tr></table></figure><p>在实际应用中，如果要确保查询结果的唯一性（比如通过手机号查询用户），使用 Single/SingleOrDefaut，其它情况应尽量使用 First/FirstOrDefault。虽然 FirstOrDefault 也可以根据条件判断元素是否存在，但使用 Any 更高效。</p><h2 id="Except-取差集"><a href="#Except-取差集" class="headerlink" title="Except 取差集"></a>Except 取差集</h2><p>LINQ 的 Except 方法用来取差集，即取出集合中与另一个集合所有元素不同的元素。</p><p>示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] first = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] second = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; result = first.Except(second);</span><br><span class="line"><span class="comment">// result = &#123; 1, 4 &#125;</span></span><br></pre></td></tr></table></figure><p>注意 Except 方法会去除重复元素：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] second = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] third = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; result = third.Except(second);</span><br><span class="line"><span class="comment">// result = &#123; 1, 4 &#125;</span></span><br></pre></td></tr></table></figure><p>对于简单类型（int、float、string 等）使用 Except 很简单，但对于自定义类型（或者叫复合类型，下同）的 Object 如何使用 Except 呢？此时需要将自定义类型实现<code>IEquatable&lt;T&gt;</code>接口，示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">User</span> : <span class="title">IEquatable</span>&lt;<span class="title">User</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">User other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Name == other.Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Name?.GetHashCode() ?? <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> list1 = <span class="keyword">new</span> List&lt;User&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> User&#123; Name = <span class="string">&quot;User1&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> User&#123; Name = <span class="string">&quot;User2&quot;</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> list2 = <span class="keyword">new</span> List&lt;User&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> User&#123; Name = <span class="string">&quot;User2&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> User&#123; Name = <span class="string">&quot;User3&quot;</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = list1.Except(list2);</span><br><span class="line">        result.ForEach(u =&gt; Console.WriteLine(u.Name));</span><br><span class="line">        <span class="comment">// 输出：User1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SelectMany-集合降维"><a href="#SelectMany-集合降维" class="headerlink" title="SelectMany 集合降维"></a>SelectMany 集合降维</h2><p>SelectMany 可以把多维集合降维，比如把二维的集合平铺成一个一维的集合。举例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> <span class="built_in">int</span>[][]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> result = collection.SelectMany(x =&gt; x);</span><br><span class="line"><span class="comment">// result = [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>再来举个更贴合实际应用的例子。例如有如下实体类（一个部门有多个员工）：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Department</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Employee[] Employees &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们拥有一个这样的数据集合：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> departments = <span class="keyword">new</span>[]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Department()</span><br><span class="line">    &#123;</span><br><span class="line">        Employees = <span class="keyword">new</span> []</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Employee &#123; Name = <span class="string">&quot;Bob&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Employee &#123; Name = <span class="string">&quot;Jack&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> Department()</span><br><span class="line">    &#123;</span><br><span class="line">        Employees = <span class="keyword">new</span> []</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Employee &#123; Name = <span class="string">&quot;Jim&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Employee &#123; Name = <span class="string">&quot;John&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们可以使用 SelectMany 把各部门的员工查询到一个结果集中：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allEmployees = departments.SelectMany(x =&gt; x.Employees);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> emp <span class="keyword">in</span> allEmployees)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(emp.Name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次输出：Bob Jack Jim John</span></span><br></pre></td></tr></table></figure><h2 id="SelectMany-迪卡尔积运算"><a href="#SelectMany-迪卡尔积运算" class="headerlink" title="SelectMany 迪卡尔积运算"></a>SelectMany 迪卡尔积运算</h2><p>SelectMany 不光适用于单个包含多维集合对象的降维，也适用于多个集合之前的两两相互操作，比如进行迪卡尔积运算。比如我们有这样两个集合：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> list2 = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;b3&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>现在我们需要把它进行两两组合，使用普通的方法，我们需要用嵌套循环语句来实现：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = newList&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> s1 <span class="keyword">in</span> list1)</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> s2 <span class="keyword">in</span> list2)</span><br><span class="line">        result.Add(<span class="string">$&quot;<span class="subst">&#123;s1&#125;</span><span class="subst">&#123;s2&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// result = [&quot;a1b1&quot;, &quot;a1b2&quot;, &quot;a1b3&quot;, &quot;a2b1&quot;, &quot;a2b2&quot;, &quot;a2b3&quot;]</span></span><br></pre></td></tr></table></figure><p>改用 SelectMany 实现：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.SelectMany(x =&gt; list2.Select(y =&gt; <span class="string">$&quot;<span class="subst">&#123;x&#125;</span><span class="subst">&#123;y&#125;</span>&quot;</span>));</span><br><span class="line"><span class="comment">// result = [&quot;a1b1&quot;, &quot;a1b2&quot;, &quot;a1b3&quot;, &quot;a2b1&quot;, &quot;a2b2&quot;, &quot;a2b3&quot;]</span></span><br></pre></td></tr></table></figure><p>具有挑战性的问题来了，如何对 N 个集合进行迪卡尔积运算呢，比如有这样的集合数据：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>[]&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;b3&quot;</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;c1&quot;</span> &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何对上面的 arrList 中的各个集合进行两两组合呢？在电商业务尤其是零售业务中的产品组合促销中这种需求很常见。</p><p>下面是一个使用 SelectMany 的实现，需要用到递归：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> arrList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>[]&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;b3&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;c1&quot;</span> &#125;,</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = Recursion(arrList, <span class="number">0</span>, <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">        result.ForEach(x =&gt; Console.WriteLine(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">Recursion</span>(<span class="params">List&lt;<span class="built_in">string</span>[]&gt; list, <span class="built_in">int</span> start, List&lt;<span class="built_in">string</span>&gt; result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= list.Count)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.Count == <span class="number">0</span>)</span><br><span class="line">            result = list[start].ToList();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = result.SelectMany(x =&gt; list[start].Select(y =&gt; x + y)).ToList();</span><br><span class="line"></span><br><span class="line">        result = Recursion(list, start + <span class="number">1</span>, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a1b1c1</span><br><span class="line">a1b2c1</span><br><span class="line">a1b3c1</span><br><span class="line">a2b1c1</span><br><span class="line">a2b2c1</span><br><span class="line">a2b3c1</span><br></pre></td></tr></table></figure><p>类似这种集合的迪卡尔积运算操作，也可以用 LINQ to Object 来代替 SelectMany 实现：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = result.SelectMany(x =&gt; list[start].Select(y =&gt; x + y)).ToList();</span><br><span class="line"><span class="comment">// 等同使用扩展方法：</span></span><br><span class="line">result = (<span class="keyword">from</span> a <span class="keyword">in</span> result <span class="keyword">from</span> b <span class="keyword">in</span> list[start] <span class="keyword">select</span> a + b).ToList();</span><br></pre></td></tr></table></figure><p>LINQ to Object 比扩展方法看上去易读性更好，但写起来扩展方法更方便。</p><h2 id="Aggregate-聚合"><a href="#Aggregate-聚合" class="headerlink" title="Aggregate 聚合"></a>Aggregate 聚合</h2><p>Aggregate 扩展方法可以对一个集合依次执行类似累加器的操作，就像滚雪球一样把数据逐步聚集在一起。比如实现从 1 加到 10，用 Aggregate 扩展方法就很方便：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">int</span> sum = numbers.Aggregate((prevSum, current) =&gt; prevSum + current);</span><br><span class="line"><span class="comment">// sum = 55</span></span><br></pre></td></tr></table></figure><p>我们来解析一下它的执行步骤</p><ul><li>第一步，prevSum 取第一个元素的值，即 prevSum = 1</li><li>第二步，把第一步得到的 prevSum 的值加上第二个元素，即 prevSum = prevSum + 2</li><li>依此类推，第 i 步把第 i-1 得到的 prevSum 加上第 i 个元素</li></ul><p>再来看一个字符串的例子加深理解：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] stringList = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> joinedString = stringList.Aggregate((prev, current) =&gt; prev + <span class="string">&quot; &quot;</span> + current);</span><br><span class="line"><span class="comment">// joinedString = &quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure><p>Aggregate 还有一个重载方法，可以指定累加器的初始值。我们来看一个比较综合的复杂例子。假如我们有如下 1-12 的一个数字集合：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;;</span><br></pre></td></tr></table></figure><p>现在我们想做如下计算：</p><ul><li>计算集合元素的总数个数</li><li>计算值为偶数的元素个数</li><li>收集每第 4 个元素</li></ul><p>当然通过普通的循环遍历也可以实现这三个计算，但使用 Aggregate 会更简洁，下面是 Aggregate 的实现：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = items.Aggregate(<span class="keyword">new</span> &#123; Total = <span class="number">0</span>, Even = <span class="number">0</span>, FourthItems = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#125;,</span><br><span class="line">    (accum, item) =&gt;</span><br><span class="line">    <span class="keyword">new</span></span><br><span class="line">    &#123;</span><br><span class="line">        Total = accum.Total + <span class="number">1</span>,</span><br><span class="line">        Even = accum.Even + (item % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">        FourthItems = (accum.Total + <span class="number">1</span>) % <span class="number">4</span> == <span class="number">0</span> ? <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(accum.FourthItems) &#123; item &#125; : accum.FourthItems</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Total = 12</span></span><br><span class="line"><span class="comment">// Even = 6</span></span><br><span class="line"><span class="comment">// FourthItems = [4, 8, 12]</span></span><br></pre></td></tr></table></figure><p>这里为了简单起见使用匿名类型作为累加器的初始值，由于匿名类型的属性是只读的，所以在累加的过程都 new 了一个新对象。如果初始值使用的是自定义类型，那累加时就不需 new 新对象了。</p><h2 id="Join-关联查询"><a href="#Join-关联查询" class="headerlink" title="Join 关联查询"></a>Join 关联查询</h2><p>和 SQL 查询一样，LINQ 同样支持 Inner Join、Left Join、Right Join、Cross Join 和 Full Outer Join，有时候你可能看到不同的写法，其实是同一个意思，比如 Left Outer Join 就是 Left Join，Join 是 Inner Join 省略了 Inner 等。</p><p>假设我们有下面两个集合，分别表示左边的数据和右边的数据。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123; <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span> &#125;; <span class="comment">// 左边</span></span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;; <span class="comment">// 右边</span></span><br></pre></td></tr></table></figure><p>下面以此数据为例来演示各种关联查询。</p><h3 id="Inner-Join"><a href="#Inner-Join" class="headerlink" title="Inner Join"></a>Inner Join</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> result = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">              <span class="keyword">join</span> s <span class="keyword">in</span> second <span class="keyword">on</span> f <span class="keyword">equals</span> s</span><br><span class="line">              <span class="keyword">select</span> <span class="keyword">new</span> &#123; f, s &#125;;</span><br><span class="line"><span class="comment">// 等同使用扩展方法：</span></span><br><span class="line"><span class="keyword">var</span> result = first.Join(second,</span><br><span class="line">    f =&gt; f,</span><br><span class="line">    s =&gt; s,</span><br><span class="line">    (f, s) =&gt; <span class="keyword">new</span> &#123; f, s &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &#123;&quot;a&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Left-Join"><a href="#Left-Join" class="headerlink" title="Left Join"></a>Left Join</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">            <span class="keyword">join</span> s <span class="keyword">in</span> second <span class="keyword">on</span> f <span class="keyword">equals</span> s <span class="keyword">into</span> temp</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> temp.DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = f, Second = t &#125;;</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">            <span class="keyword">from</span> s <span class="keyword">in</span> second.Where(x =&gt; x == f).DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = f, Second = s &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同使用扩展方法：</span></span><br><span class="line"><span class="keyword">var</span> result = first.GroupJoin(second,</span><br><span class="line">        f =&gt; f,</span><br><span class="line">        s =&gt; s,</span><br><span class="line">        (f, s) =&gt; <span class="keyword">new</span> &#123; First = f, Second = s &#125;)</span><br><span class="line">    .SelectMany(temp =&gt; temp.Second.DefaultIfEmpty(),</span><br><span class="line">        (f, s) =&gt; <span class="keyword">new</span> &#123; First = f.First, Second = s &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &#123;&quot;a&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;b&quot;, null&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Right-Join"><a href="#Right-Join" class="headerlink" title="Right Join"></a>Right Join</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> s <span class="keyword">in</span> second</span><br><span class="line">            <span class="keyword">join</span> f <span class="keyword">in</span> first <span class="keyword">on</span> s <span class="keyword">equals</span> f <span class="keyword">into</span> temp</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> temp.DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = t, Second = s &#125;;</span><br><span class="line"><span class="comment">// 其它和 Left Join 类似</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &#123;&quot;a&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;null,&quot;d&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Cross-Join"><a href="#Cross-Join" class="headerlink" title="Cross Join"></a>Cross Join</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">            <span class="keyword">from</span> s <span class="keyword">in</span> second</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; f, s &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &#123;&quot;a&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;a&quot;,&quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;a&quot;,&quot;d&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;b&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;b&quot;,&quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;b&quot;,&quot;d&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;d&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Full-Outer-Join"><a href="#Full-Outer-Join" class="headerlink" title="Full Outer Join"></a>Full Outer Join</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftJoin = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">            <span class="keyword">join</span> s <span class="keyword">in</span> second <span class="keyword">on</span> f <span class="keyword">equals</span> s <span class="keyword">into</span> temp</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> temp.DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = f, Second = t &#125;;</span><br><span class="line"><span class="keyword">var</span> rightJoin = <span class="keyword">from</span> s <span class="keyword">in</span> second</span><br><span class="line">            <span class="keyword">join</span> f <span class="keyword">in</span> first <span class="keyword">on</span> s <span class="keyword">equals</span> f <span class="keyword">into</span> temp</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> temp.DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = t, Second = s &#125;;</span><br><span class="line"><span class="keyword">var</span> fullOuterJoin = leftJoin.Union(rightJoin);</span><br></pre></td></tr></table></figure><h3 id="根据多个键关联"><a href="#根据多个键关联" class="headerlink" title="根据多个键关联"></a>根据多个键关联</h3><p>在 SQL 中，表与表进行关联查询时 on 条件可以指定多个键的逻辑判断，用 and 或 or 连接。但 C# 的 LINQ 不支持 and 关键字，若要根据多键关联，需要把要关联的键值分别以相同的属性名放到匿名对象中，然后使用 equals 比较两个匿名对象是否相等。示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringProps = <span class="keyword">typeof</span>(<span class="built_in">string</span>).GetProperties();</span><br><span class="line"><span class="keyword">var</span> builderProps = <span class="keyword">typeof</span>(StringBuilder).GetProperties();</span><br><span class="line"><span class="keyword">var</span> query =</span><br><span class="line">    <span class="keyword">from</span> s <span class="keyword">in</span> stringProps</span><br><span class="line">    <span class="keyword">join</span> b <span class="keyword">in</span> builderProps</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">new</span> &#123; s.Name, s.PropertyType &#125; <span class="keyword">equals</span> <span class="keyword">new</span> &#123; b.Name, b.PropertyType &#125;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">    &#123;</span><br><span class="line">        s.Name,</span><br><span class="line">        s.PropertyType</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>以上均使用两个集合做为示例，LINQ 关联查询也支持多个集合关联，就像 SQL 的多表关联，只需往后继续追加 join 操作即可，不再累述。</p><p>LINQ 关联查与 SQL 相似，但使用上有很大区别。LINQ 关联查询的用法有很多，也很灵活，不用刻意去记住它们，只要熟悉简单常用的，其它的在实际用到的时候再查询相关文档。</p><h2 id="Skip-amp-Take-分页"><a href="#Skip-amp-Take-分页" class="headerlink" title="Skip &amp; Take 分页"></a>Skip &amp; Take 分页</h2><p>Skip 扩展方法用来跳过从起始位置开始的指定数量的元素读取集合；Take 扩展方法用来从集合中只读取指定数量的元素。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = <span class="keyword">new</span>[] &#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> skipTwo = values.Skip(<span class="number">2</span>);  <span class="comment">// &#123; 3, 2, 1 &#125;</span></span><br><span class="line"><span class="keyword">var</span> takeThree = values.Take(<span class="number">3</span>);  <span class="comment">// &#123; 5, 4, 3 &#125;</span></span><br><span class="line"><span class="keyword">var</span> skipOneTakeTwo = values.Skip(<span class="number">1</span>).Take(<span class="number">2</span>); <span class="comment">// &#123; 4, 3 &#125;</span></span><br></pre></td></tr></table></figure><p>Skip 与 Take 两个方法结合即可实现我们常见的分页查询：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">GetPage</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;T&gt; collection, <span class="built_in">int</span> pageNumber, <span class="built_in">int</span> pageSize</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> startIndex = (pageNumber - <span class="number">1</span>) * pageSize;</span><br><span class="line">    <span class="keyword">return</span> collection.Skip(startIndex).Take(pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用过 EF (Core) 的同学一定很熟悉。</p><p>另外，还有 SkipWhile 和 TakeWhile 扩展方法，它与 Skip 和 Take 不同的是，它们的参数是具体的条件。SkipWhile 从起始位置开始忽略元素，直到遇到不符合条件的元素则停止忽略，往后就是要查询的结果；TakeWhile 从起始位置开始读取符合条件的元素，一旦遇到不符合条件的就停止读取，即使后面还有符合条件的也不再读取。示例：</p><p>SkipWhile：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] list = &#123; <span class="number">42</span>, <span class="number">42</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = list.SkipWhile(i =&gt; i == <span class="number">42</span>);</span><br><span class="line"><span class="comment">// result: 6, 6, 6, 42</span></span><br></pre></td></tr></table></figure><p>TakeWhile：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] list = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">44</span>, <span class="number">70</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = list.TakeWhile(item =&gt; item &lt; <span class="number">50</span>).ToList();</span><br><span class="line"><span class="comment">// result = &#123; 1, 10, 40 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Zip-拉链"><a href="#Zip-拉链" class="headerlink" title="Zip 拉链"></a>Zip 拉链</h2><p>Zip 扩展方法操作的对象是两个集合，它就像拉链一样，根据位置将两个系列中的每个元素依次配对在一起。其接收的参数是一个 Func 实例，该 Func 实例允许我们成对在处理两个集合中的元素。如果两个集合中的元素个数不相等，那么多出来的将会被忽略。</p><p>示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="built_in">string</span>[] words = &#123; <span class="string">&quot;three&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;ignored&quot;</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; zip = numbers.Zip(words, (n, w) =&gt; n + <span class="string">&quot;=&quot;</span> + w);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> s <span class="keyword">in</span> zip)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3=three</span><br><span class="line">5=five</span><br><span class="line">7=seven</span><br></pre></td></tr></table></figure><h2 id="OfType-和-Cast-类型过滤与转换"><a href="#OfType-和-Cast-类型过滤与转换" class="headerlink" title="OfType 和 Cast 类型过滤与转换"></a>OfType 和 Cast 类型过滤与转换</h2><p>OfType 用于筛选集合中指定类型的元素，Cast 可以把集合转换为指定类型，但要求源类型必须可以隐式转换为目标类型。假如有如下数据：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFoo</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Foo</span> : <span class="title">IFoo</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Bar</span> : <span class="title">IFoo</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item0 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">var</span> item1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">var</span> item2 = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="keyword">var</span> item3 = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> IFoo[] &#123; item0, item1, item2, item3 &#125;;</span><br></pre></td></tr></table></figure><p>OfType 示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foos = collection.OfType&lt;Foo&gt;(); <span class="comment">// result: item0, item1</span></span><br><span class="line"><span class="keyword">var</span> bars = collection.OfType&lt;Bar&gt;(); <span class="comment">// result: item2, item3</span></span><br><span class="line"><span class="keyword">var</span> foosAndBars = collection.OfType&lt;IFoo&gt;(); <span class="comment">// result: item0, item1, item2, item3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用 Where</span></span><br><span class="line"><span class="keyword">var</span> foos = collection.Where(item =&gt; item <span class="keyword">is</span> Foo); <span class="comment">// result: item0, item1</span></span><br><span class="line"><span class="keyword">var</span> bars = collection.Where(item =&gt; item <span class="keyword">is</span> Bar); <span class="comment">// result: item2, item3</span></span><br></pre></td></tr></table></figure><p>Cast 示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bars = collection.Cast&lt;Bar&gt;();  <span class="comment">// InvalidCastException 异常</span></span><br><span class="line"><span class="keyword">var</span> foos = collection.Cast&lt;Foo&gt;();  <span class="comment">// InvalidCastException 异常</span></span><br><span class="line"><span class="keyword">var</span> foosAndBars = collection.Cast&lt;IFoo&gt;();  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h2 id="ToLookup-索引式查找"><a href="#ToLookup-索引式查找" class="headerlink" title="ToLookup 索引式查找"></a>ToLookup 索引式查找</h2><p>ToLookup 扩展方法返回的是可索引查找的数据结构，它是一个 ILookup 实例，所有元素根据指定的键进行分组并可以按键进行索引。这样说有点抽象，来看具体示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] array = &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 根据元素字符串长度创建一个查找对象</span></span><br><span class="line"><span class="keyword">var</span> lookup = array.ToLookup(item =&gt; item.Length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找字符串长度为 3 的元素</span></span><br><span class="line"><span class="keyword">var</span> result = lookup[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// result: one,two</span></span><br></pre></td></tr></table></figure><p>再来一个示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">// 创建一个奇偶查找（键为 0 和 1）</span></span><br><span class="line"><span class="keyword">var</span> lookup = array.ToLookup(item =&gt; item % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找偶数</span></span><br><span class="line"><span class="keyword">var</span> even = lookup[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// even: 2,4,6,8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找奇数</span></span><br><span class="line"><span class="keyword">var</span> odd = lookup[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// odd: 1,3,5,7</span></span><br></pre></td></tr></table></figure><h2 id="Distinct-去重"><a href="#Distinct-去重" class="headerlink" title="Distinct 去重"></a>Distinct 去重</h2><p>Distinct 方法用来去除重复项，这个容易理解。示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> distinct = array.Distinct();</span><br><span class="line"><span class="comment">// distinct = &#123; 1, 2, 3, 4, 5 &#125;</span></span><br></pre></td></tr></table></figure><p>简单类型的集合调用 Distinct 方法使用的是默认的比较器，Distinct 方法用此比较器来判断元素是否与其它元素重复，但对于自定义类型要实现去重则需要自定义比较器。示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IdEqualityComparer</span> : <span class="title">IEqualityComparer</span>&lt;<span class="title">Person</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">Person x, Person y</span>)</span> =&gt; x.Id == y.Id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params">Person p</span>)</span> =&gt; p.Id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> people = <span class="keyword">new</span> List&lt;Person&gt;();</span><br><span class="line">        <span class="keyword">var</span> distinct = people.Distinct(<span class="keyword">new</span> IdEqualityComparer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ToDictionary-字典转换"><a href="#ToDictionary-字典转换" class="headerlink" title="ToDictionary 字典转换"></a>ToDictionary 字典转换</h2><p>ToDictionary 扩展方法可以把集合 <code>IEnumerable&lt;TElement&gt;</code> 转换为 <code>Dictionary&lt;TKey, TValue&gt;</code> 结构的字典，它接收一个 <code>Func&lt;TSource, TKey&gt;</code> 参数用来返回每个元素指定的键与值。示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;User&gt; users = GetUsers();</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, User&gt; usersById = users.ToDictionary(x =&gt; x.Id);</span><br></pre></td></tr></table></figure><p>如果不用 ToDictionary，你需要这样写：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;User&gt; users = GetUsers();</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, User&gt; usersById = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, User&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (User u <span class="keyword">in</span> users)</span><br><span class="line">&#123;</span><br><span class="line">    usersById.Add(u.Id, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 ToDictionary 返回的字典数据中的值是整个元素，你也可以通过它的第二个参数来自定义字典的值。示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; userNamesById = users.ToDictionary(x =&gt; x.Id, x =&gt; x.Name);</span><br></pre></td></tr></table></figure><p>你也可以为转换的字典指定其键是否区分大小写，即自定义字典的 IComparer，示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">string</span>, User&gt; usersByCaseInsenstiveName = users.ToDictionary(x =&gt;x.Name,</span><br><span class="line">    StringComparer.InvariantCultureIgnoreCase);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user1 =usersByCaseInsenstiveName[<span class="string">&quot;liam&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> user2 =usersByCaseInsenstiveName[<span class="string">&quot;LIAM&quot;</span>];</span><br><span class="line">user1 == user2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意，字典类型要求所有键不能重复，所以在使用 ToDictionary 方法时要确保作为字典的键的元素属性不能有重复值，否则会抛出异常。</p><h2 id="其它常见扩展方法"><a href="#其它常见扩展方法" class="headerlink" title="其它常见扩展方法"></a>其它常见扩展方法</h2><p>LINQ 还有很多其它常见的扩展方法，大家在平时应该用的比较多，比如 Where、Any、All 等，这里也选几个简单举例介绍一下。</p><h3 id="Range-和-Repeat"><a href="#Range-和-Repeat" class="headerlink" title="Range 和 Repeat"></a>Range 和 Repeat</h3><p>Range 和 Repeat 用于生成简单的数字或字符串系列。示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 1-100 的数字，即结果为 [1, 2, ..., 99, 100]</span></span><br><span class="line"><span class="keyword">var</span> range = Enumerable.Range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成三个重复的字符串“a”，即结果为 [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line"><span class="keyword">var</span> repeatedValues = Enumerable.Repeat(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="Any-和-All"><a href="#Any-和-All" class="headerlink" title="Any 和 All"></a>Any 和 All</h3><p>Any 用来判断集合中是否存在任一一个元素符合条件，All 用来判断集合中是否所有元素符合条件。示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">bool</span> result = numbers.Any(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">bool</span> result = numbers.Any(x =&gt; x == <span class="number">6</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">bool</span> result = numbers.All(x =&gt; x &gt; <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">bool</span> result = numbers.All(x =&gt; x &gt; <span class="number">1</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Concat-和-Union"><a href="#Concat-和-Union" class="headerlink" title="Concat 和 Union"></a>Concat 和 Union</h3><p>Concat 用来拼接两个集合，不会去除重复元素，示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; foo = newList&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; bar = newList&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">// 通过 Enumerable 类的静态方法</span></span><br><span class="line"><span class="keyword">var</span> result = Enumerable.Concat(foo, bar).ToList(); <span class="comment">// 1,2,3,3,4,5</span></span><br><span class="line"><span class="comment">// 通过扩展方法</span></span><br><span class="line"><span class="keyword">var</span> result = foo.Concat(bar).ToList(); <span class="comment">// 1,2,3,3,4,5</span></span><br></pre></td></tr></table></figure><p>Union 也是用来拼接两个集合，与 Concat 不同的是，它会去除重复项，示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = foo.Union(bar); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure><h3 id="GroupBy-分组"><a href="#GroupBy-分组" class="headerlink" title="GroupBy 分组"></a>GroupBy 分组</h3><p>GroupBy 扩展方法用来对集合进行分组，下面是一个根据奇偶进行分组的示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> grouped = list.GroupBy(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// grouped: [1, 3, 5, 7, 9] 和 [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>还可以根据指定属性进行分组：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people = <span class="keyword">new</span> List&lt;Person&gt;();</span><br><span class="line"><span class="keyword">var</span> query = people</span><br><span class="line">    .GroupBy(x =&gt; x.Age)</span><br><span class="line">    .Select(g =&gt; &#123; Age = g.Key, Count = g.Count() &#125;);</span><br></pre></td></tr></table></figure><h3 id="DefaultIfEmpty-空替换"><a href="#DefaultIfEmpty-空替换" class="headerlink" title="DefaultIfEmpty 空替换"></a>DefaultIfEmpty 空替换</h3><p>在上面的关联查询中我们使用了 DefaultIfEmpty 扩展方法，它表示在没有查询到指定条件的元素时使用元素的默认值代替。其实 DefaultIfEmpty 还可以指定其它的默认值，示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chars = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line">chars.Where(s =&gt; s.Length &gt; <span class="number">1</span>).DefaultIfEmpty().First(); <span class="comment">// 返回 null</span></span><br><span class="line">chars.DefaultIfEmpty(<span class="string">&quot;N/A&quot;</span>).FirstOrDefault(); <span class="comment">// 返回 &quot;a&quot;</span></span><br><span class="line">chars.Where(s =&gt; s.Length &gt; <span class="number">1</span>).DefaultIfEmpty(<span class="string">&quot;N/A&quot;</span>).FirstOrDefault(); <span class="comment">// 返回 &quot;N/A&quot;</span></span><br></pre></td></tr></table></figure><h3 id="SequenceEqual-集合相等"><a href="#SequenceEqual-集合相等" class="headerlink" title="SequenceEqual 集合相等"></a>SequenceEqual 集合相等</h3><p>SequenceEqual 扩展方法用于比较集合系列各个相同位置的元素是否相等。示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] b = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] c = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> result1 = a.SequenceEqual(b); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">bool</span> result2 = a.SequenceEqual(c); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>还有一些常用和简单的扩展方法就不举例了，比如 OrderBy（排序）、Sum（求和）、Count（计数）、Reverse（反转）等，同时欢迎大家补充本文遗漏的强大或好用的 LINQ 语法糖。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LINQ 是 Language INtegrated Query 单词的首字母缩写，翻译过来是语言集成查询。它为查询跨各种数据源和格式的数据提供了一致的模型，所以叫集成查询。由于这种查询并没有制造新的语言而只是在现有的语言基础上来实现，所以叫语言集成查询。&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="C#" scheme="https://liuyingbo.com/categories/C/"/>
    
    
    <category term="C#" scheme="https://liuyingbo.com/tags/C/"/>
    
    <category term="语法" scheme="https://liuyingbo.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Unity-移动平台相关Java语法</title>
    <link href="https://liuyingbo.com/posts/fff1.html"/>
    <id>https://liuyingbo.com/posts/fff1.html</id>
    <published>2022-11-24T21:56:45.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简单</strong>了解Java语法</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Java环境：www.baidu.com</p><p>写Java编辑器推荐是IDEA</p><p>但是我们是Unity导出的Android项目所以还是用AndroidStudio</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="Java中的有符号整型"><a href="#Java中的有符号整型" class="headerlink" title="Java中的有符号整型"></a>Java中的有符号整型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.byte(1个字节，8位，-2^7 ~ 2^7 - 1，-128 ~ 127)</span></span><br><span class="line">System.out.println(<span class="string">&quot;byte位数&quot;</span> + Byte.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;byte最大值&quot;</span> + Byte.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;byte最小值&quot;</span> + Byte.MIN_VALUE);</span><br><span class="line"><span class="comment">//2.short(2个字节，16位，-2^15 ~ 2^15 - 1，-32768 ~ 32767)</span></span><br><span class="line">System.out.println(<span class="string">&quot;short位数&quot;</span> + Short.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;short最大值&quot;</span> + Short.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;short最小值&quot;</span> + Short.MIN_VALUE);</span><br><span class="line"><span class="comment">//3.int(4个字节，32位，-2^31 ~ 2^31 - 1，-2,147,483,648 ~ 2,147,483,647)</span></span><br><span class="line">System.out.println(<span class="string">&quot;int位数&quot;</span> + Integer.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;int最大值&quot;</span> + Integer.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;int最小值&quot;</span> + Integer.MIN_VALUE);</span><br><span class="line"><span class="comment">//4.long(8个字节，64位，-2^63 ~ 2^63 - 1，9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)</span></span><br><span class="line">System.out.println(<span class="string">&quot;long位数&quot;</span> + Long.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;long最大值&quot;</span> + Long.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;long最小值&quot;</span> + Long.MIN_VALUE);</span><br><span class="line"><span class="comment">//注意：Java最初设计中没有无符号类型</span></span><br><span class="line"><span class="comment">//Java 8中添加了一些和无符号类型有关的一些方法(但是一般使用较少)</span></span><br></pre></td></tr></table></figure><h3 id="Java中的浮点型"><a href="#Java中的浮点型" class="headerlink" title="Java中的浮点型"></a>Java中的浮点型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.float(4个字节，32位)</span></span><br><span class="line">System.out.println(<span class="string">&quot;float位数&quot;</span> + Float.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;float最大值&quot;</span> + Float.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;float最小值&quot;</span> + Float.MIN_VALUE);</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">.5f</span>;</span><br><span class="line">System.out.println(f);</span><br><span class="line">f = <span class="number">1.f</span>;</span><br><span class="line">System.out.println(f);</span><br><span class="line"><span class="comment">//2.double(8个字节，64位)</span></span><br><span class="line">System.out.println(<span class="string">&quot;double位数&quot;</span> + Double.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;double最大值&quot;</span> + Double.MAX_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;double最小值&quot;</span> + Double.MIN_VALUE);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.5</span>;</span><br></pre></td></tr></table></figure><h3 id="Java中的其它类型"><a href="#Java中的其它类型" class="headerlink" title="Java中的其它类型"></a>Java中的其它类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.boolean(单个boolean在编译时使用int类型，这时4个字节；boolean数组时，编译时用字节数组，所以占1个字节)</span></span><br><span class="line"><span class="comment">//默认值是false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b0</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span>[] bs;</span><br><span class="line"><span class="comment">//2.char(2个字节，16位)</span></span><br><span class="line">System.out.println(<span class="string">&quot;char位数&quot;</span> + Character.SIZE);</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(c);</span><br><span class="line"><span class="comment">//3.String(根据字符串长度而定)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><h3 id="Java中的常量"><a href="#Java中的常量" class="headerlink" title="Java中的常量"></a>Java中的常量</h3><p>关键字：final</p><p>特点：必须初始化，不能被修改</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.隐式转换：低级（字节少的）到高级（字节多的）</span></span><br><span class="line"><span class="comment">//记住一句话 大容器 可以装 小容器 不需要我们去处理</span></span><br><span class="line"><span class="comment">//byte——&gt;short——&gt;char——&gt;int——&gt;long——&gt;float——&gt;double</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> b2;</span><br><span class="line"><span class="comment">//2.显示转换：括号强转，高级到低级会丢失精度或者报错</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">40000</span>;</span><br><span class="line">s2 = (<span class="type">short</span>) i3;</span><br><span class="line">System.out.println(s2);</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">2.5f</span>;</span><br><span class="line">i3 = (<span class="type">int</span>)f2;</span><br><span class="line">System.out.println(i3);</span><br><span class="line"><span class="comment">//3.字符串转数值 包装类中的parse相关方法</span></span><br><span class="line">i3 = Integer.parseInt(<span class="string">&quot;101&quot;</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(i3);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java的变量类型和C#非常的类似</p><p>其中需要注意的是</p><p>1.Java中没有专门的无符号类型</p><p>2.Java中的常量关键字和C#不一样</p><p>3.一些关键字和方法写法不同</p><p>其它的变量相关操作表现和C#中极奇相似</p><h2 id="运算符、条件语句、循环语句、数组"><a href="#运算符、条件语句、循环语句、数组" class="headerlink" title="运算符、条件语句、循环语句、数组"></a>运算符、条件语句、循环语句、数组</h2><p>Java和C#基本一样</p><p>就把它当做C#来写即可</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="Arrays静态类"><a href="#Arrays静态类" class="headerlink" title="Arrays静态类"></a>Arrays静态类</h2><p>Arrays类是什么</p><p>Arrays类是Java提供的一个专门对数组进行操作的类</p><p>它提供了很多静态方法，共我们对数组进行处理</p><p>比如排序、查找、填充等等方法</p><p>使用它 需要导入java.util.Arrays包（类似C#中的命名空间）</p><h3 id="填充替换数组元素"><a href="#填充替换数组元素" class="headerlink" title="填充替换数组元素"></a>填充替换数组元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays.fill 方法可以帮助我们对数组进行填充</span></span><br><span class="line"><span class="comment">//它有两个重载</span></span><br><span class="line"><span class="comment">//1.Arrays.fill(数组,填充值)</span></span><br><span class="line"><span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.fill(arr, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.Arrays.fill(数组,填充起始位置(包括),填充结束位置(不包括),填充值)</span></span><br><span class="line">Arrays.fill(arr, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.fill(arr, <span class="number">1</span>, arr.length, <span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays.sort(数组) 方法可以对数组进行默认的升序排序</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Arrays.copyOf(数组，复制长度) 方法可以赋值指定数组的指定长度</span></span><br><span class="line"><span class="comment">//若长度 小于传入数组，则截取；若长度 大于传入数组，则用默认值填充</span></span><br><span class="line"><span class="type">int</span>[] arr2 = Arrays.copyOf(arr, <span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr2) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.Arrays.copyOfRange(数组，开始复制索引（包括），赋值的最后索引位置（不包括）)</span></span><br><span class="line">arr2 = Arrays.copyOfRange(arr, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : arr2) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询数组"><a href="#查询数组" class="headerlink" title="查询数组"></a>查询数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays.binarySearch(数组，搜索元素)</span></span><br><span class="line"><span class="comment">//注意：由于binarySearch内部是对数组进行二分查找</span></span><br><span class="line"><span class="comment">//所以使用前必须对数组进行排序</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="comment">//一定该记住 使用该API之前 一定概要排序</span></span><br><span class="line"><span class="comment">//如果数组当中没有想要寻找的元素 那么返回值为负数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***************&quot;</span>);</span><br><span class="line">System.out.println(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.binarySearch(数组，开始索引(包括)，结束索引(不包括)，搜索元素)</span></span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Java中如果相对数组进行填充、替换、排序、复制、查询等操作</p><p>我们可以使用Arrays类中的静态方法</p><p>填充替换：fill</p><p>排序：sort</p><p>复制：copyOf、copyOfRange</p><p>查询：binarySearch</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Java中函数和C#中函数的使用基本一致</p><p>函数的声明、重载、使用等就按照C#中的基础规则使用即可</p><p>主要区别：</p><p>1.Java中没有ref和out关键字</p><p>2.Java中可变参数写法有些许不同</p><p>3.Java中函数参数没有默认参数用法</p><p>4.Java中没有结构体，所以不存在结构体语句块</p><p>5.Java中一般使用驼峰命名法  myName（驼峰命名法）  MyName(帕斯卡命名法)</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>概念：万物皆对象，用程序来抽象（形容）对象，用面向对象的思想来编程</p><p>面向对象三大特性：封装、继承、多态</p><p>面向对象是一种编程范式</p><p>面向对象编程语言的编程思想和使用几乎是一致的</p><p>使用C#中的面向对象编程思想去写Java即可</p><p>Java中也是通过class类去封装对象的</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>Java中没有C#中的</p><p>1.成员属性（有类似自动生成的get、set方法）</p><p>2.析构函数（有类似的finalize函数）</p><p>3.索引器</p><p>4.运算符重载</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>Java中的类声明和使用和C#中基本一模一样</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="Java中继承和C-中的相同点"><a href="#Java中继承和C-中的相同点" class="headerlink" title="Java中继承和C#中的相同点"></a>Java中继承和C#中的相同点</h4><p>1.类与类之间只能单继承</p><p>2.万物之父都是Object</p><p>3.遵循里氏替换原则(可以父类装子类对象)</p><h4 id="Java中-继承的写法"><a href="#Java中-继承的写法" class="headerlink" title="Java中 继承的写法"></a>Java中 继承的写法</h4><p>//关键字：extends</p><h4 id="万物之父Object中的关键方法"><a href="#万物之父Object中的关键方法" class="headerlink" title="万物之父Object中的关键方法"></a>万物之父Object中的关键方法</h4><p>1.getClass():类似C#中的getType()</p><p>Father f = new Father();</p><p>System.out.println(f.getClass());</p><p>2.toString():将对象以字符串形式返回</p><p>3.equals():比较两个对象的内部内容，而==是判断引用地址是否相等</p><p>父子类的上下转换（里氏替换原则）</p><p>1.子类自动向上转换</p><p><code>Father f2 = new Son();</code></p><p>2.父类强制向下转换</p><p><code>Son s = (Son)f2;</code></p><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于判断对象类型，类似C#中的is关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f2 <span class="keyword">instanceof</span> Father)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;是Father类&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f2 <span class="keyword">instanceof</span> Son)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Son</span> <span class="variable">s2</span> <span class="operator">=</span> (Son)f2;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;是Son类&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>类似C#中的密封关键字</p><p>让变量无法被修改（常量）</p><p>让函数无法被重写</p><p>让类无法被继承</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="Java中的vob"><a href="#Java中的vob" class="headerlink" title="Java中的vob"></a>Java中的vob</h4><p>Java中没有vo关键字，也就是virtual(虚函数)和override(重写)</p><p>我们如果要重写基类的方法，直接在子类中实现同名方法即可</p><p>它会直接覆盖父类方法！！</p><p>Java中有类似 base 的关键字 super</p><p>重写时Java会自动补全一个@Override</p><p>它类似于注释，可有可无，主要是用来帮助我们阅读代码</p><h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><p>Java中的抽象类和抽象方法使用和C#中基本一致</p><p>关键字：abstract</p><p>抽象类不能被实例化</p><p>抽象方法在抽象类中声明，必须被实现</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>1.Java中接口中方法默认(只能)为public</p><p>2.Java中接口可以声明字段，但是默认(只能)是static和final的，也就是静态常量</p><p>3.Java中继承接口的关键字是implements，一般写在继承类之后</p><p>4.继承多个接口用逗号分隔</p><p>5.Java中不存在显示实现接口，重写不同接口的同名方式时，”两个接口共享”</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="Java中的包是什么？"><a href="#Java中的包是什么？" class="headerlink" title="Java中的包是什么？"></a>Java中的包是什么？</h3><p>Java中的包（package）类似C#中的命名空间</p><p>主要用于解决类名冲突</p><p>同名类做不同逻辑时</p><p>可以将两个类放到两个不同的包中</p><h3 id="包名规则"><a href="#包名规则" class="headerlink" title="包名规则"></a>包名规则</h3><p>多人完成，版权属于发起者</p><p>indi.发起这名.项目名.模块名….</p><p>独立完成，公开，版权属于个人</p><p>pers.个人名.项目名.模块名</p><p>独立完成，非公开，版权属于个人</p><p>priv.个人名.项目名.模块名</p><p>团队研发，版权属于团队</p><p>team.团队名.项目名.模块名</p><p>公司研发，版权属于公司</p><p>com.公司名.项目名.模块名</p><p>注意：Java中规定包名统一用小写，用.分割</p><h2 id="Java中的内部类"><a href="#Java中的内部类" class="headerlink" title="Java中的内部类"></a>Java中的内部类</h2><p>Java中的内部类的使用和C#中不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Java中的内部类在外部使用时必须伴随包裹它的外部类的出现而出现</span></span><br><span class="line"><span class="comment">//  声明语法为</span></span><br><span class="line"><span class="comment">//  外部类 outer = new 外部类();</span></span><br><span class="line"><span class="comment">//  外部类.内部类 inner = outer.new 内部类();</span></span><br><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.Test();</span><br><span class="line"><span class="comment">//2.外部类中的所有内容（包括私有）都可以直接在内部类中使用</span></span><br><span class="line"><span class="comment">//3.内部类和外部类中的同名成员，通过this 和 外部类.this来区分</span></span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类，在声明一个类对象时临时拓展该对象</p><p>但是拓展的内容一般是基于外部类的</p><p>注意：</p><p>1.不能写构造方法</p><p>2.不能定义静态成员</p><p>3.一般基于外部类已有方法实现内容</p><p>4.如果匿名类创建的对象不记录，用完一次后会马上被销毁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">outer2.Eat();</span><br><span class="line">outer2.Speak();</span><br></pre></td></tr></table></figure><h2 id="String和StringBuilder"><a href="#String和StringBuilder" class="headerlink" title="String和StringBuilder"></a>String和StringBuilder</h2><p>Java中String在使用上和C#类似，但是需要注意以下两点区别</p><p>1.直接赋值字符串，如果字符串相同，则指向同一引用;new String，即使字符串相同引用也不同</p><p>2.Java中字符串比较使用equals，用==号是比较的引用地址</p><p>Java中的StringBuilder的使用和作用和C#中基本一致</p><p>如果项目中的字符串会频繁修改，建议使用StringBuilder</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p> Java中泛型使用的基本规则和C#中一致</p><p>泛型可以代表一切类型，主要使用上就是泛型类和泛型方法</p><h3 id="Java中的泛型中的类型通配符"><a href="#Java中的泛型中的类型通配符" class="headerlink" title="Java中的泛型中的类型通配符 ?"></a>Java中的泛型中的类型通配符 ?</h3><p>泛型类名称&lt;? extends 类名&gt; 变量名 = null;</p><p>? extends 类名 表示类未知，需要使用该泛型对象时，可以单独实例化</p><p><code>TestT&lt;?&gt; obj2 = null;</code></p><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Java中的集合类就类似C#中的List和Dictionary的存在</p><p>主要用于批量存储对象，并且可以动态添加，动态删除</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202212172341179.png" alt="image-20221217234153008"></p><p>Collection接口中的方法</p><p>1.add(E e) 添加元素</p><p>2.remove(Object o) 移除元素</p><p>3.clear() 清空元素</p><p>4.isEmpty() 是否为空</p><p>5.iterator() 获取迭代器，可以用于遍历</p><p>6.size() 集合中元素个数</p><p>7.contains() 判断元素是否存在</p><p>8.toArray() 将容器中元素转为数组</p><h3 id="ArrayList和LinkedList类"><a href="#ArrayList和LinkedList类" class="headerlink" title="ArrayList和LinkedList类"></a>ArrayList和LinkedList类</h3><p>两者方法上的使用完全一致，因为他们继承相同的接口</p><p>ArrayList本质是数组，是顺序存储</p><p>LinkedList本质是链表，是链式存储</p><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>相同点：他们都不允许存储重复的元素，如果传入重复的只会记录一个</p><p>他们相对上节课的ArrayList和LinkedList最大的使用区别就是他们可以去重</p><p>都不能像ArrayList和LinkedList通过索引获取或修改元素</p><p>不同点：他们的底层数据结构不同，HashSet底层结构是哈希表，TreeSet底层结构是树</p><p>TreeSet是有序排列的（会自动将加入元素进行排序），HashSet不一定有序</p><p>TreeSet相对HashSet由于多继承了接口，所以有更多的方法可以使用</p><p>注意：TreeSet具有排序功能</p><p>元素是数字时，按照大小升序排列</p><p>元素是字符串时，按照字符的编码值升序排列</p><p>元素是自定义类时，可以继承Comparable接口 重载其中的方法</p><p>特别是compareTo方法，它用于制定排序规则</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map集合类似C#中的Dictionary字典</p><p>以键值对形式存储数据</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202212172350034.png" alt="image-20221217235027997"></p><h3 id="Map接口中的方法"><a href="#Map接口中的方法" class="headerlink" title="Map接口中的方法"></a>Map接口中的方法</h3><p>1.put(K key, V value) 添加键值对</p><p>2.containsKey(Object key) 判断是否存在键</p><p>3.containsValue(Object value) 判断是否存在值</p><p>4.get(Object key) 如果存在key，则返回对应值，否则返回null</p><p>5.keySet() 返回该集合中的所有key对象形成的Set集合</p><p>6.values() 返回该集合中所有value对象形成的Collection集合</p><p>7.size() 键值对 对数</p><p>8.isEmpty() 是否为空</p><p>9.remove(Object key) 根据键移除</p><p>10.clear() 清空容器</p><h3 id="HashMap和TreeMap之间的区别"><a href="#HashMap和TreeMap之间的区别" class="headerlink" title="HashMap和TreeMap之间的区别"></a>HashMap和TreeMap之间的区别</h3><p>相同点：他们都是以键值对形式存储数据，方法使用基本相同</p><p>不同点：</p><p>1.HashMap允许有null键和null值（但是必须保持键的唯一性）TreeMap不允许键为空</p><p>2.TreeMap中的映射关系具有一定的顺序，它会帮助我们进行排序因此在添加、删除、定位映射关系时，效率较HashMap差</p><p>3.HashMap数据结构基于哈希表，TreeMap数据结构基于树</p><p>在实际使用时，建议都使用HashMap，除非需要排序的Map时才用TreeMap</p><h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Java中的异常捕获和C#中使用基本一致 需要时直接使用即可</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//需要进行异常捕获的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NullPointerException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ex.getMessage()</span></span><br><span class="line">    <span class="comment">//捕获异常信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ex.getMessage()</span></span><br><span class="line">    <span class="comment">//捕获异常信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ex.getMessage()</span></span><br><span class="line">    <span class="comment">//捕获异常信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//不管之前的代码块是否发生异常</span></span><br><span class="line">    <span class="comment">//finally中的内容都将执行</span></span><br><span class="line">    <span class="comment">//注意：以下几种情况下finally中内容不会执行</span></span><br><span class="line">    <span class="comment">//1.finally 语句块中发生异常</span></span><br><span class="line">    <span class="comment">//2.在finally之前执行了System.exit()退出程序</span></span><br><span class="line">    <span class="comment">//3.程序所在的线程销毁</span></span><br><span class="line">    <span class="comment">//4.关闭CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Java中的常见异常类</span><br><span class="line"><span class="comment">//NullPointerException:空指针异常</span></span><br><span class="line"><span class="comment">//IOException:输入输出异常</span></span><br><span class="line"><span class="comment">//FileNotFoundException:文件为找到异常</span></span><br><span class="line"><span class="comment">//ArrayIndexOutOfBoundsException:数组越界异常</span></span><br><span class="line"><span class="comment">//NegativeArraySizeException:数组元素个数为负数抛出异常</span></span><br><span class="line"><span class="comment">//ClassCastException:类型转化异常</span></span><br><span class="line"><span class="comment">//ArithmeticException:算数异常</span></span><br><span class="line"><span class="comment">//ArrayStoreException:数组包含不兼容的值抛出的异常</span></span><br><span class="line"><span class="comment">//ClassNotFoundException:未找到相应类异常</span></span><br><span class="line"><span class="comment">//等等</span></span><br><span class="line"></span><br><span class="line">Java中自定义异常</span><br><span class="line"><span class="comment">//继承Exception异常基类</span></span><br><span class="line"><span class="comment">//实现一个有参构造函数</span></span><br><span class="line"><span class="comment">//通过throw关键字自己抛出异常对象</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;数组容量不合法&quot;</span>);</span><br><span class="line">        ex.i = i;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MyException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(ex.getMessage() + <span class="string">&quot;；数组容量为：&quot;</span> + ex.i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;异常捕获结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法中抛出异常</span><br><span class="line"><span class="comment">//如果某个方法可能发生异常，但是又不想再方法内处理这个异常</span></span><br><span class="line"><span class="comment">//想在调用这个方法的外部进行处理</span></span><br><span class="line"><span class="comment">//可以使用throws关键字在声明方法时抛出可能的异常</span></span><br><span class="line"><span class="comment">//多个异常可以使用逗号分割</span></span><br><span class="line"><span class="comment">//那么外部调用该方法时，发生对应异常时即可进行处理</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//继承时，覆盖有抛异常的方法时，该方法必须抛出相同的异常或者异常的子类</span></span><br><span class="line"><span class="comment">//如果父类中方法抛出多个异常，那么子类的覆盖方法必须抛出那些异常的子集，不能抛出新异常</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NegativeArraySizeException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;容量为负了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p><strong>Java中的lambda表达式和C#中区别很大</strong></p><p><strong>Java中没有委托和事件</strong></p><p><strong>只有通过函数式接口来存储lambda表达式来进行使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Java中 lambda表达式语法</span><br><span class="line"><span class="comment">//基本结构：</span></span><br><span class="line"><span class="comment">//(参数)-&gt;&#123;代码块&#125;</span></span><br><span class="line"><span class="comment">//基于基本结构的写法：</span></span><br><span class="line"><span class="comment">//1. ()-&gt;&#123;代码块&#125;</span></span><br><span class="line"><span class="comment">//2. ()-&gt;结果表达式（相当于返回值）;</span></span><br><span class="line"><span class="comment">//3. (参数)-&gt;&#123;代码块&#125;</span></span><br><span class="line"><span class="comment">//4. 参数-&gt;&#123;代码块&#125;</span></span><br><span class="line"><span class="comment">//5. 参数-&gt;结果表达式（相当于返回值）;</span></span><br><span class="line"><span class="comment">//6. (参数1,参数2,参数3...)-&gt;&#123;代码块&#125;</span></span><br><span class="line"><span class="comment">//7. (参数1,参数2,参数3...)-&gt;结果表达式（相当于返回值）;</span></span><br><span class="line"></span><br><span class="line">用于装载lambda表达式的函数式接口</span><br><span class="line"><span class="comment">//函数式接口指仅仅包含一个抽象方法的接口</span></span><br><span class="line"><span class="comment">//声明函数式接口后，我们可以用以下语法来使用lambda表达式</span></span><br><span class="line"><span class="comment">//接口名 变量名 = lambda表达式</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//lambda表达式的结构必须和函数式接口中声明的方法一致（返回值，参数数量）</span></span><br><span class="line"><span class="type">ITest</span> <span class="variable">t</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> i + i2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(t.Test());</span><br><span class="line"></span><br><span class="line"><span class="type">ITest2</span> <span class="variable">t2</span> <span class="operator">=</span> (a,b)-&gt;&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t2.Test(<span class="number">10</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">lambda表达式调用外部变量</span><br><span class="line"><span class="comment">//1.无法更改局部变量的值</span></span><br><span class="line"><span class="comment">//2.可以更改外部类的成员变量的值</span></span><br><span class="line">t = ()-&gt;&#123;</span><br><span class="line">    value2 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> value2;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(t.Test());</span><br></pre></td></tr></table></figure><h2 id="Java常用类库"><a href="#Java常用类库" class="headerlink" title="Java常用类库"></a>Java常用类库</h2><h3 id="常用类库指什么？"><a href="#常用类库指什么？" class="headerlink" title="常用类库指什么？"></a>常用类库指什么？</h3><p>常用类库主要指Java中为了提升我们的开发效率</p><p>预先就已经写好的一些包，这些包中提供了很多常用类</p><p>目的是方便开发人员的使用，而无需再自己去实现</p><p>主要有以下内容</p><p>1.变量类型的包装类 Integer、Double、Boolean、Character、Number等</p><p>2.存储较大数据的 BigInteger类和BigDecimal类</p><p>3.数学计算类 Math</p><p>4.随机数类 Random</p><p>等等</p><p>本节课，我主要给大家指明方向，由于这些知识只是API的使用</p><p>所以对于这些类的常用方法我只会提及，不会举例</p><p>了解他们提供的方法名，基本就知道如何使用了</p><h3 id="变量的包装类"><a href="#变量的包装类" class="headerlink" title="变量的包装类"></a>变量的包装类</h3><h4 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h4><p>   它是Byte Integer Short Long Float Double类的父类</p><p>   主要方法：</p><p>   byteValue()  以byte形式返回指定的数值</p><p>   intValue()   以int形式返回指定的数值</p><p>   floatValue() 以float形式返回指定的数值</p><p>   shortValue() 以short形式返回指定的数值</p><p>   longValue()  以long形式返回指定的数值</p><p>   doubleValue()  以double形式返回指定的数值</p><p>   所有继承Number类的子类都具备以上方法</p><h4 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h4><p>   它和Byte、Short、Long三个封装类方法基本相同</p><p>   区别就是封装的是不同的数据类型</p><p>   主要方法：</p><p>   parseInt(String str)                  将字符串转数值</p><p>   toString()                            将数值转字符串</p><p>   toBinaryString(int i)                 以二进制无符号整数形式返回一个整数参数的字符串表示形式</p><p>   toHexString(int i)                    以十六进制无符号整数形式返回一个整数参数的字符串表示形式</p><p>   toOctalString(int i)                  以八进制无符号整数形式返回一个整数参数的字符串表示形式</p><p>   equals(Object integerObj)             比较两个对象是否相等</p><p>   compareTo(Integer anotherInteger)     比较两个Integer对象，相等返回0；调用函数对象小于传入对象，返回负数；反之，返回正数</p><h4 id="Double类"><a href="#Double类" class="headerlink" title="Double类"></a>Double类</h4><p>   它和Float类的方法基本相同</p><p>   区别就是封装的是不同的数据类型</p><p>   主要方法：</p><p>   parseDouble(String str)               将字符串转数值</p><p>   toString()                            将数值转字符串</p><p>   isNaN()                               如果该double值不是数字，返回true，否则返回false</p><p>   compareTo(Double d)                   和Integer类中方法作用一致</p><p>   equals(Object doubleObj)              和Integer类中方法作用一致</p><p>   toHexString(double d)                 返回double参数的十六进制字符串表示形式</p><h4 id="Boolean类"><a href="#Boolean类" class="headerlink" title="Boolean类"></a>Boolean类</h4><p>   equals(Object obj)                    和Integer类中方法作用一致</p><p>   parseBoolean(String s)                将字符串转Boolean</p><p>   toString()                            将数值转字符串</p><p>   valueOf(String s)                     返回一个用指定的字符串表示的boolean值</p><h4 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h4><p>   compareTo(Character anotherCharacter) 比较两个Character对象，若两个对象相等则返回0</p><p>   equals(Object obj)                    和Integer类中方法作用一致</p><p>   toString()                            转字符串</p><p>   toUpperCase(char ch)                  将字符转大写</p><p>   toLowerCase(char ch)                  将字符转小写</p><p>   isUpperCase(char ch)                  判断字符是否是大写</p><p>   isLowerCase(char ch)                  判断字符是否是小写</p><p>   isLetter(char ch)                     判断字符是否是字母</p><p>   isDigit(char ch)                      判断字符是否为数字</p><h3 id="大数据类"><a href="#大数据类" class="headerlink" title="大数据类"></a>大数据类</h3><h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><p>   该类主要用于存储任意大小的整数，也就是说它可以表示任何大小的整数值而不会丢失信息</p><p>   因为传统的整形类型都有最大最小区间，而该类没有，主要用于存储大数据</p><p>   主要方法：</p><p>   add(BigInteger val)               加法</p><p>   subtract(BigInteger val)          减法</p><p>   multiply(BigInteger val)          乘法</p><p>   divide(BigInteger val)            除法</p><p>   remainder(BigInteger val)         取余</p><p>   pow(int exponent)                 计算exponent次方</p><p>   negate()                          取反</p><p>   shiftLeft(int n)                  左移n位</p><p>   shiftRight(int n)                 右移n位</p><p>   and(BigInterger val)              位与</p><p>   or(BigInteger val)                位或</p><p>   compareTo(BigInteger val)         比较，类似Integer中</p><p>   equals(Object x)                  判断数值是否相等</p><p>   min(BigInteger val)               取最小</p><p>   max(BigInteger val)               取最大、</p><h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>   该类和BigInteger用于表示大数据，但是它主要用于表示浮点数（有小数点的数值）</p><p>   它的主要方法和BigInteger类似</p><h3 id="数学计算类"><a href="#数学计算类" class="headerlink" title="数学计算类"></a>数学计算类</h3><h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><p>提供众多数学函数方法，方便我们进行数学计算</p><p>主要包含三角函数、指数函数、取整函数、最大值、最小值、平均值等等</p><p>这些方法都是静态方法，都通过Math点出使用</p><p>主要方法：</p><p>三角函数</p><p>sin(double a)                         正弦</p><p>cos(double a)                         余弦</p><p>tan(double a)                         正切</p><p>asin(double a)                        反正弦</p><p>acos(double a)                        反余弦</p><p>atan(double a)                        反正切</p><p>toRadians(double angdeg)              角度转弧度</p><p>toDegrees(double angrad)              弧度转角度</p><p>指数</p><p>exp(double a)                         获取e的a次方</p><p>log(double a)                         取自然对数</p><p>log10(double a)                       取底数为10的a的对数</p><p>sqrt(double a)                        取a的平方根</p><p>cbrt(double a)                        取a的立方根</p><p>pow(double a, double b)               取a的b次方</p><p>取整</p><p>ceil(double a)                        向上取整</p><p>floor(double a)                       向下取整</p><p>rint(double a)                        返回与a最接近的整数，如果有两个，取偶数</p><p>round(float a)                        将参数a加上0.5后返回与其最近的整数</p><p>rount(double a)                       将参数a加上0.5后返回与其最近的整数，然后强转为Long</p><p>其他</p><p>max(参数1，参数2)                      最大值</p><p>min(参数1，参数2)                      最小值</p><p>abs(参数)                             绝对值</p><h3 id="随机数类"><a href="#随机数类" class="headerlink" title="随机数类"></a>随机数类</h3><p>Random</p><p>用于生成随机数的类</p><p>主要方法：</p><p>Random r = new Random();              以当前系统时间作为随机数生成器种子</p><p>Random r = new Random(seedValue);     自己设置随机数种子</p><p>nextInt()                             返回一个随机整数</p><p>nextInt(int n)                        返回大于等于0且小于n的随机整数</p><p>nextLong()                            返回一个随机长整型</p><p>nextBoolean()                         返回一个随机布尔值</p><p>nextFloat()                           返回一个随机单精度浮点</p><p>nextDouble()                          返回一个随机双精度浮点</p><p>nextGaussian()                        返回一个概率密度为高斯分步的双精度浮点</p><h3 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h3><p>Data：日期类 获取日期时间相关方法</p><p>Calendar：日历类 比起Date更加国际化</p><p>System:系统类 有获取当前时间的方法</p><p>等等</p><p>总结</p><p>Java中提供了很多现成的类和方法供我们使用，对他们产生印象，当自己开发时有类似需求时，直接使用他们，可以提升我们的开发效率</p><p>因为无需我们自己去实现对应逻辑，直接使用即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;简单&lt;/strong&gt;了解Java语法&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;Java环境：www.baidu.com&lt;/p&gt;
&lt;p&gt;写Java编辑</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="移动平台" scheme="https://liuyingbo.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="Android" scheme="https://liuyingbo.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Unity-移动平台相关Android</title>
    <link href="https://liuyingbo.com/posts/1d0254fc.html"/>
    <id>https://liuyingbo.com/posts/1d0254fc.html</id>
    <published>2022-09-01T15:06:06.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android发布流程"><a href="#Android发布流程" class="headerlink" title="Android发布流程"></a>Android发布流程</h2><h3 id="Unity2019及以上"><a href="#Unity2019及以上" class="headerlink" title="Unity2019及以上"></a>Unity2019及以上</h3><p>发布Android准备工作</p><p>通过UnityHub安装Android平台相关工具</p><p>1.Android构建支持</p><p>2.Android SDK（安卓软件开发工具包）、NDKTools（本地开发工具包）</p><p>3.OpenJDK（Java开发工具包）</p><p>注意：Unity支持Android 5.1及以上版本</p><h3 id="Unity2019以下版本"><a href="#Unity2019以下版本" class="headerlink" title="Unity2019以下版本"></a>Unity2019以下版本</h3><p>1.Android构建支持工具安装（Unity提供下载,安装时需要关闭Unity）</p><p>2.JDK（Java开发工具包）（网络下载） JDK 必须是版本 8</p><p><a href="https://www.oracle.com/java/technologies/downloads/#jdk18-windows">https://www.oracle.com/java/technologies/downloads/#jdk18-windows</a></p><p>3.NDK (本地开发工具包)（网络下载）NDK 版本必须是 Unity2018——r16b, Unity2017——r13d</p><p>注意：NDK是可选的工具，如果之后要发il2cpp的应用程序，那么NDK是必须的，如果是Mono可以不使用它</p><p><a href="https://blog.csdn.net/momo0853/article/details/73898066">https://blog.csdn.net/momo0853/article/details/73898066</a></p><p><a href="https://developer.android.google.cn/ndk/downloads/#lts-downloads">https://developer.android.google.cn/ndk/downloads/#lts-downloads</a></p><p>4.Android SDK（安卓软件开发工具包）（网络下载或通过AndroidStudio下载）</p><p>建议通过AndroidStudio下载</p><p><a href="https://developer.android.com/studio">https://developer.android.com/studio</a></p><p>安装AndroidStudio后 通过它来安装AndroidSDK</p><p>5.Java环境变量配置</p><p>我的电脑——&gt;系统属性——&gt;查找——&gt;系统环境变量——&gt;环境变量</p><p>5-1:JAVA_HOME: 变量值为JDK在你电脑上的安装路径</p><p>安装好后可以利用%JAVA_HOME%作为JDK安装目录的统一引用路径</p><p>5-2:Path: 编辑Path属性，在原变量后追加 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</p><p>5-3:CLASSPATH: 变量值为 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</p><h3 id="发布前必修改的设置"><a href="#发布前必修改的设置" class="headerlink" title="发布前必修改的设置"></a>发布前必修改的设置</h3><p>在File —— Build Setting —— Player Setting中修改</p><p>1.公司名</p><p>2.游戏项目名</p><p>3.版本号</p><p>4.默认图标</p><p>5.Other Settings —— Package Name（必须修改设置）</p><p>6.Other Settings —— Minimum APILevel</p><h2 id="Unity发布参数"><a href="#Unity发布参数" class="headerlink" title="Unity发布参数"></a>Unity发布参数</h2><h3 id="Build-Settings-参数"><a href="#Build-Settings-参数" class="headerlink" title="Build Settings 参数"></a>Build Settings 参数</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133874.png" alt="image-20220901221824489"></p><h4 id="Texture-Compression"><a href="#Texture-Compression" class="headerlink" title="Texture Compression"></a><strong>Texture Compression</strong></h4><p><strong>纹理压缩</strong><br><strong>设置发布后的纹理压缩格式</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133057.png" alt="image-20220901221934763"></p><p>**Use Player Settings: 使用在播放器设置中设置的纹理压缩格式<br>ETC：使用ETC格式<br>ETC2：使用ETC2格式<br>ASTC：使用ASTC格式<br>DXT：使用DXT格式<br>PVRTC：使用PVRTC格式</p><p>了解格式详细信息：<a href="https://docs.unity.cn/cn/2021.3/Manual/class-TextureImporterOverride.html#android">https://docs.unity.cn/cn/2021.3/Manual/class-TextureImporterOverride.html#android</a></p><p>注意：对于安卓ETC2是常用的压缩格式，支持透明通道。但是对于老设备不支持ETC2，可以使用ETC。<br>我们可以统一设置为ETC2，在下方的ETC2 fallback中设置，如果不支持ETC2，使用哪种压缩方式**</p><h4 id="ETC2-fallback"><a href="#ETC2-fallback" class="headerlink" title="ETC2 fallback"></a><strong>ETC2 fallback</strong></h4><p><strong>ETC2回退</strong><br><strong>当Unity用于不支持ETC2的安卓设备时的RGBA纹理格式</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133278.png" alt="image-20220901222221490"></p><p>32-bit：32位<br>以全分辨率存储RGBA纹理，使用32位存储每个像素，质量最高，内存占用最多</p><p>16-bit：16位<br>以全分辨率存储RGBA纹理，使用16位存储每个像素，质量较低，纹理可能会丢失有价值的颜色信息，内存占用相对较少</p><p>32-bit, half resolution：32位，半分辨率<br>以半分辨率存储RGBA纹理，使用32位存储每个像素，由于是半分辨率，纹理会变得模糊，内存占用较小</p><p>注意：如果使用的不是ETC2压缩，大多数压缩格式，使用32-bit备用<br>取决于GPU支持什么</p><h4 id="Export-Project"><a href="#Export-Project" class="headerlink" title="Export Project"></a><strong>Export Project</strong></h4><p><strong>导出项目</strong><br><strong>勾选后，不会发布成apk，而是会将Unity项目导出为可以导入Android Studio的Gradle项目</strong></p><h4 id="Symlink-Sources"><a href="#Symlink-Sources" class="headerlink" title="Symlink Sources"></a>Symlink Sources</h4><p>符号链接源<br>当勾选Exprot Project时，才能勾选此选项。<br>决定是否在Unity和导出的Gradle项目之间共享Java和Kotlin源文件<br>启用后，对于测试和迭代Java和Kotlin代码很有用，如果你重新导出Unity项目，你在导出的项目对之前的Java和Kotlin源文件的任何更改都会保留</p><p>如果你想导出后进行二次开发，建议勾选此选项</p><h4 id="Build-App-Bundle-Google-Play"><a href="#Build-App-Bundle-Google-Play" class="headerlink" title="Build App Bundle (Google Play)"></a>Build App Bundle (Google Play)</h4><p>构建应用捆绑包<br>是否将应用程序作为Android应用捆绑包（AAB）<br>启用，发布出去是一个AAB（可以配合安卓进行二次开发）<br>禁用，发布出去是一个APK（直接就是一个可安装的应用程序）</p><h4 id="Create-symbols-zip"><a href="#Create-symbols-zip" class="headerlink" title="Create symbols.zip"></a><strong>Create symbols.zip</strong></h4><p><strong>创建 符号压缩文件</strong><br><strong>符号文件可以帮助我们调试应用程序</strong><br><strong>Unity会生成一个包含本机Unity库的符号文件的包</strong><br><strong>它包含一个表，将活动内存地址转换为我们可以使用的信息，比如方法名，我们可以利用符号包来检测调试应用程序的信息**</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133225.png" alt="image-20220901222330411"></p><p><strong>Disabled：不生成</strong><br><strong>Public：Unity生成一个公共符号为程序打包</strong><br><strong>公共符号文件包含将函数地址解析为人类可读字符串的信息，包小于调试符号的包</strong><br><strong>Debugging：Unity生成一个调试符号为程序打包</strong><br><strong>包含完整的调试信息和符号表，可以用来解析堆栈、将本机调试器附加到应用程序调试代码</strong></p><h4 id="Run-Device"><a href="#Run-Device" class="headerlink" title="Run Device"></a><strong>Run Device</strong></h4><p><strong>运行的设备</strong><br><strong>指定在哪个附加设备上测试生成</strong><br><strong>如果你连接了新设备或在列表中没有看到连接的设备</strong><br><strong>点击刷新Refresh</strong></p><h4 id="Build-to-Device"><a href="#Build-to-Device" class="headerlink" title="Build to Device"></a><strong>Build to Device</strong></h4><p><strong>构建到设备</strong><br><strong>不创建完整的构建，而是将发生修改的单个文件直接部署到设备上</strong><br><strong>相对来说更加快速，方便调试</strong></p><h4 id="Development-Build"><a href="#Development-Build" class="headerlink" title="Development Build"></a><strong>Development Build</strong></h4><p><strong>开发模式构建</strong><br><strong>是否包含脚本调试符号和性能分析器到你的项目中，如果你想要调试应用程序，请选择该选项</strong></p><h4 id="Autoconnect-Profiler"><a href="#Autoconnect-Profiler" class="headerlink" title="Autoconnect Profiler"></a><strong>Autoconnect Profiler</strong></h4><p><strong>自动连接分析器</strong><br><strong>是否自动将分析器连接到生成的应用程序</strong></p><h4 id="Deep-Profiling"><a href="#Deep-Profiling" class="headerlink" title="Deep Profiling"></a><strong>Deep Profiling</strong></h4><p><strong>深度剖析</strong><br><strong>是否启用深度剖析在分析器中，可以让分析器能够检测应用程序中每个函数调用，从而返回更加详细的分析数据</strong><br><strong>注意：该选项会降低脚本的执行速度</strong></p><h4 id="Script-Debugging"><a href="#Script-Debugging" class="headerlink" title="Script Debugging"></a><strong>Script Debugging</strong></h4><p><strong>是否允许调试应用程序的脚本文件</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242133607.png" alt="image-20220901223243427"></p><p><strong>Wait For Managed Debugger</strong><br><strong>是否等待托管调试器</strong><br><strong>程序在运行脚本代码之前是否等待调试器连接</strong></p><h4 id="Compression-Method"><a href="#Compression-Method" class="headerlink" title="Compression Method"></a>Compression Method</h4><p>压缩方法<br>Unity在构建时压缩项目中数据的方式</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134820.png" alt="image-20220901223442983"></p><p>Default：默认使用ZIP，压缩效果略好于LZ4和LZ4HC，但是数据解压速度较慢<br>LZ4：使用LZ4，这时一种快速压缩格式，相对ZIP可以显著提高Unity应用程序的加载时间<br>LZ4HC：LZ4的高压缩版本，构建速度较慢，但是对于发布版本会产生更好的结果，相对ZIP可以显著提高应用程序加载时间</p><h4 id="Max-Texture-Size"><a href="#Max-Texture-Size" class="headerlink" title="Max Texture Size"></a>Max Texture Size</h4><p>最大的纹理大小<br>用于本地开发时导入纹理的最大尺寸<br>减小最大纹理大小可以加快资源导入和平台切换</p><h4 id="Texture-Compression-1"><a href="#Texture-Compression-1" class="headerlink" title="Texture Compression"></a>Texture Compression</h4><p>纹理压缩<br>选择下面两个选项，可以加快资源导入和平台切换</p><p>No Override：使用默认设置<br>Force Fast Compressor：强制快速压缩<br>Force Uncompressed：强制解压缩</p><h3 id="Player-Settings相关"><a href="#Player-Settings相关" class="headerlink" title="Player Settings相关"></a><strong>Player Settings相关</strong></h3><h4 id="Player-基础设置"><a href="#Player-基础设置" class="headerlink" title="Player 基础设置"></a>Player <strong>基础设置</strong></h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134900.png" alt="image-20220901224319232"></p><h4 id="Icon-图标设置"><a href="#Icon-图标设置" class="headerlink" title="Icon 图标设置"></a><strong>Icon 图标设置</strong></h4><p><strong>设置在设备上显示的应用图标</strong></p><p><strong>Adaptive：运行在Android8.0及以上版本上的设备显示的应用图标</strong><br><strong>Round：运行在Android7.1及以上版本上的设备显示的应用图标</strong><br><strong>Legacy icons：运行在Android7.1以下版本上的设备显示的应用图标</strong></p><h4 id="Resolution-and-Presentation-分辨率和演示设置"><a href="#Resolution-and-Presentation-分辨率和演示设置" class="headerlink" title="Resolution and Presentation 分辨率和演示设置"></a><strong>Resolution and Presentation 分辨率和演示设置</strong></h4><h5 id="Fullscreen-Mode"><a href="#Fullscreen-Mode" class="headerlink" title="Fullscreen Mode"></a>Fullscreen Mode</h5><p>全屏模式</p><p>Fullscreen Window：<br>全屏窗口（导航栏始终处于隐藏状态）<br>会缩放应用程序内容，为了匹配纵横比，可能会有黑边</p><p>Windowed：<br>窗口模式，窗口大小取决于应用程序分辨率</p><h5 id="Resizable-Window"><a href="#Resizable-Window" class="headerlink" title="Resizable Window"></a>Resizable Window</h5><p>课调整大小的窗口</p><p>设置用户是否可以调整应用程序窗口的大小</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134540.png" alt="image-20220901225112530"></p><p>此设置可以安卓和平板电脑上的应用程序中启用多窗口功能<br>详情：<a href="https://developer.android.com/guide/topics/ui/multi-window#java">https://developer.android.com/guide/topics/ui/multi-window#java</a></p><h5 id="Hide-Navigation-Bar"><a href="#Hide-Navigation-Bar" class="headerlink" title="Hide Navigation Bar"></a><strong>Hide Navigation Bar</strong></h5><p><strong>是否隐藏顶部显示的导航栏</strong></p><h5 id="Render-outside-safe-area"><a href="#Render-outside-safe-area" class="headerlink" title="Render outside safe area"></a><strong>Render outside safe area</strong></h5><p><strong>是否应使用所有可用的屏幕控件进行渲染</strong><br><strong>包括留海区域</strong></p><h5 id="Optimized-frame-Pacing"><a href="#Optimized-frame-Pacing" class="headerlink" title="Optimized frame Pacing"></a>Optimized frame Pacing</h5><p>是否应均匀分布帧以减小帧速率的方差，启用后体验更流程</p><h4 id="Resolution-Scaling分辨率缩放"><a href="#Resolution-Scaling分辨率缩放" class="headerlink" title="Resolution Scaling分辨率缩放"></a>Resolution Scaling分辨率缩放</h4><h5 id="Resolution-Scaling-Mode"><a href="#Resolution-Scaling-Mode" class="headerlink" title="Resolution Scaling Mode"></a>Resolution Scaling Mode</h5><p>分辨率缩放模式</p><p>Disabled：禁用<br>不应用分辨率缩放，应用程序呈现为设备的本机屏幕分辨率</p><p>Fixed DPI：使用API应用分辨率缩放，使用此选项可优化性能和电池寿命</p><p>Target DPI：如果设备的本机屏幕DPI高于设置的值，Unity将降低应用程序的分辨率以匹配此设置<br>计算方式：<br>Min（Target DPI * Factor / Screen DPI，1）<br>其中Factor是在Quality质量设置中设置的 Resolution Scaling Fixed DPI Factor参数</p><h5 id="Reset-resolution-on-window-resize"><a href="#Reset-resolution-on-window-resize" class="headerlink" title="Reset resolution on window resize:"></a>Reset resolution on window resize:</h5><p>当本机窗口大小更改时，是否将屏幕分辨率设置为新的本机窗口大小<br>如果分辨率缩放模式是Fixed DPI，则将重新计算分辨率</p><h5 id="Blit-Type："><a href="#Blit-Type：" class="headerlink" title="Blit Type："></a>Blit Type：</h5><p>光高类型<br>是否使用Blit将最终图像呈现在屏幕上</p><p>Always：总是让Unity渲染到屏幕外的缓冲区，然后使用Blit将缓冲区的内容复制到设备的帧缓冲区（这和大部分设备兼容，但比不用Blit慢）</p><p>Nerver：Unity将渲染到设备操作系统提供的帧缓冲区，如果失败，会有警告信息打印到日志当中。通常比使用Blit块，但是不兼容所有设备</p><p>Auto：Unity会渲染到设备操作系统提供的帧缓冲区，如果失败，会打印到日志中，并使用Blit将最终图像呈现到屏幕上</p><h4 id="Supported-Aspect-Ratio：支持的纵横比"><a href="#Supported-Aspect-Ratio：支持的纵横比" class="headerlink" title="Supported Aspect Ratio：支持的纵横比"></a>Supported Aspect Ratio：支持的纵横比</h4><p>Orientation：屏幕取向</p><h5 id="Aspect-Ratio-Mode："><a href="#Aspect-Ratio-Mode：" class="headerlink" title="Aspect Ratio Mode："></a>Aspect Ratio Mode：</h5><p>指定应用程序支持的最大纵横比。</p><p>如果设备的纵横比大于此纵横比，Unity会将此纵横比用于应用程序，并添加黑条，使应用程序不会拉伸</p><p>Legacy Wide Screen(1.86):支持android的传统宽屏宽高比</p><p>Native Aspect Ratio:支持Android本机宽高比的宽高比</p><p>Custom:自定义纵横比</p><p>选择自定义纵横比时可以自己设置</p><h5 id="Default-Orientation："><a href="#Default-Orientation：" class="headerlink" title="Default Orientation："></a><strong>Default Orientation：</strong></h5><p><strong>默认取向</strong></p><p><strong>指定应用程序使用的屏幕方向（横屏、竖屏设置）</strong></p><p><strong>Portrait：竖屏（应用程序窗口底部和屏幕底部对齐）</strong><br><strong>Portrait Upside Down：竖屏倒置（应用程序窗口底部和屏幕顶部对齐）</strong><br><strong>Landscape Right：右横屏（应用程序窗口右侧和屏幕底部对齐）</strong><br><strong>Landscape Left：左横屏（应用程序窗口左侧和屏幕底部对齐）</strong><br><strong>Auto Rotation：自动旋转，可以旋转到你允许的任意方向，在下方勾选即可</strong></p><h5 id="Use-32-bit-Display-Buffer："><a href="#Use-32-bit-Display-Buffer：" class="headerlink" title="Use 32-bit Display Buffer："></a>Use 32-bit Display Buffer：</h5><p>显示缓冲区是否保存32位颜色值而不是16位颜色值。</p><p>如果你在后期处理效果中看到了条带效果或者需要Alpha值，请启用此设置，某些后期处理效果需要开其它，因为他们以显示缓冲区相同的格式创建渲染纹理</p><h5 id="Disable-Depth-and-Stencil："><a href="#Disable-Depth-and-Stencil：" class="headerlink" title="Disable Depth and Stencil："></a>Disable Depth and Stencil：</h5><p>是否禁用深度和模板缓冲区</p><h5 id="Render-Over-Native-UI："><a href="#Render-Over-Native-UI：" class="headerlink" title="Render Over Native UI："></a>Render Over Native UI：</h5><p>在本机UI上呈现<br>设置是否在Android或者IOS的本机UI上进行渲染<br>如果要该设置生效，需要把相机的清楚标志设置为使用Alpha值低于1的纯色</p><h5 id="Show-Loading-Indicator："><a href="#Show-Loading-Indicator：" class="headerlink" title="Show Loading Indicator："></a>Show Loading Indicator：</h5><p>显示加载指示器<br>指定加载指示器是否显示以及如何显示</p><p>Don’t Show:不显示加载指示条<br>Large:显示大的加载指示条<br>Inversed Large:显示大的加载指示条，并带有翻转颜色<br>Small:显示小的加载指示条<br>Inversed Small:显示小的加载指示条，并带有翻转颜色</p><h4 id="Splash-Image"><a href="#Splash-Image" class="headerlink" title="Splash Image:"></a>Splash Image:</h4><p>启动图像设置</p><h5 id="Virtual-Reality-Splash-Image"><a href="#Virtual-Reality-Splash-Image" class="headerlink" title="Virtual Reality Splash Image:"></a>Virtual Reality Splash Image:</h5><p>虚拟现实的初始屏幕设置</p><h5 id="Show-Splash-Screen："><a href="#Show-Splash-Screen：" class="headerlink" title="Show Splash Screen："></a>Show Splash Screen：</h5><p>是否显示启动图像（收费版本才能修改，免费版本不能改）</p><h5 id="Preview："><a href="#Preview：" class="headerlink" title="Preview："></a>Preview：</h5><p>预览</p><h5 id="Splash-Style："><a href="#Splash-Style：" class="headerlink" title="Splash Style："></a>Splash Style：</h5><p>启动风格</p><p>Dark on Light: 暗到亮<br>Light on Dark: 亮到暗</p><h5 id="Animation"><a href="#Animation" class="headerlink" title="Animation:"></a>Animation:</h5><p>启动图像动画效果</p><p>Static：静态不动的<br>Dolly：由小变大<br>Custom：自定义</p><p><strong>Draw Mode：绘制模式</strong></p><p><strong>Unity Logo Below：Unity Logo显示在前</strong><br><strong>All Sequential：所有按顺序</strong></p><p><strong>Logos：可以自己添加Logo图片按顺序显示</strong></p><h5 id="BackGround：背景相关"><a href="#BackGround：背景相关" class="headerlink" title="BackGround：背景相关"></a>BackGround：背景相关</h5><p>Overlay Opacity:<br>覆盖不透明度</p><p>Background Color:<br>背景颜色</p><p>Blur Background Image:<br>模糊背景图像</p><p>Background Image:<br>背景图像</p><p>Alternate Portrait Image:<br>备选图像</p><p>Static Splash Image:<br>静态启动图像</p><p>Scaling:<br>缩放比例</p><p>Center：<br>居中（仅缩小）：除非图像太大，否则以原始大小绘制图像，Unity会缩小图像</p><p>Scale to fit：<br>缩放以适应（填充），缩放图像，使较长尺寸完全适合屏幕大小，以黑色填充两侧空白区域</p><p>Scale to fit：<br>缩放以适应（裁剪），缩放图像，使较短的尺寸完全适合屏幕大小，将图像裁剪为较长的维度</p><h3 id="OtherSetting相关"><a href="#OtherSetting相关" class="headerlink" title="OtherSetting相关"></a>OtherSetting相关</h3><h4 id="Rendering渲染设置"><a href="#Rendering渲染设置" class="headerlink" title="Rendering渲染设置"></a>Rendering渲染设置</h4><h5 id="Unity程序员必了解的图形程序接口"><a href="#Unity程序员必了解的图形程序接口" class="headerlink" title="Unity程序员必了解的图形程序接口"></a><strong>Unity程序员必了解的图形程序接口</strong></h5><h6 id="OpenGL（Open-Graphics-Library）"><a href="#OpenGL（Open-Graphics-Library）" class="headerlink" title="OpenGL（Open Graphics Library）"></a><strong>OpenGL（Open Graphics Library）</strong></h6><p>中文翻译过来是<strong>开放图形库</strong>，它定义了一个<strong>跨平台、跨语言</strong>的编程接口规格的专业图形程序接口，可以用于3D、2D图形渲染，是一个功能强大、调用方便的底层图形库。由于它跨平台、跨语言、出现时间早，因此它的应用极其广泛！</p><h6 id="OpenGL-ES（OpenGL-for-Embedded-Systems）"><a href="#OpenGL-ES（OpenGL-for-Embedded-Systems）" class="headerlink" title="OpenGL ES（OpenGL for Embedded Systems）"></a><strong>OpenGL ES（OpenGL for Embedded Systems）</strong></h6><p>中文翻译过来是<strong>用于嵌入式系统的开放图形库</strong>，它是<strong>OpenGL的子级</strong>，<strong>主要针对手机、游戏主机</strong>等嵌入式设备而设计，免授权费、跨平台、功能完善。</p><p>GLES2.0、GLES3.0 指的就是OpenGL ES这套标准，他们也是Android和IOS手机上常用的图形处理标准。</p><p><strong>Unity在移动平台进行图形渲染处理时，就包含了OpenGL ES方案</strong></p><h6 id="Vulkan"><a href="#Vulkan" class="headerlink" title="Vulkan"></a><strong>Vulkan</strong></h6><p>“下一代”开放的图形显示API，是与DX12能够匹敌的GPU API标准。它有一套最新的图形加速API接口，目标是提供更灵活和丰富的底层操作接口，以替代OpenGL 和 OpenGL ES接口，<strong>可**</strong>以把Vulkan看做是OpenGL的升级版<strong>，目前</strong>新版本的Unity支持使用Vulkan方案**。</p><h6 id="Directx（Direct-eXtension）"><a href="#Directx（Direct-eXtension）" class="headerlink" title="Directx（Direct eXtension）"></a><strong>Directx（Direct eXtension）</strong></h6><p>中文翻译过来是直接拓展，简称DX。它是由<strong>微软</strong>公司创建的多媒体编程接口。它<strong>不跨平台</strong>，只针对微软的相关产品，被广泛使用于Windows操作系统、xBox游戏主机的图形应用程序开发中。</p><p>其中的D3D算是DX一部分，是对标OpenGL的图形程序接口</p><h6 id="WebGL（Web-Graphics-Library）"><a href="#WebGL（Web-Graphics-Library）" class="headerlink" title="WebGL（Web Graphics Library）"></a><strong>WebGL（Web Graphics Library）</strong></h6><p>中文翻译过来是网页图形库，它是<strong>针对Web端（\</strong>网页*<em>）的3D绘图协议*</em>，这个标准允许把JavaScript和OpenGL ES 2.0结合在一起，网页开发人员可以借助系统显卡在浏览器里流畅的展示3D场景和模型，可以在网页里进行3D图形开发。</p><h6 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a><strong>Metal</strong></h6><p>中文翻译过来是金属，它是<strong>苹果公司</strong>为游戏开发者提供的图形技术，该技术能够为3D图像提高10倍渲染性能，但是它不支持跨平台，主要针对IOS、macOS苹果自家的操作系统，只有苹果手机、电脑能够使用。</p><p><strong>Windows电脑：DX、OpenGL、Vulkan</strong></p><p><strong>苹果电脑：Metal、OpenGL、Vulkan</strong></p><p><strong>安卓手机：OpenGL ES、Vulkan</strong></p><p><strong>苹果手机：OpenGL ES、Vulkan、Metal</strong></p><p><strong>网站网页：Web GL</strong></p><p>如果不通过游戏引擎，我们想要在这些平台上开发游戏，那么就必须要针对不同平台学习对应的图形程序接口相关的知识。你会发现<strong>OpenGL</strong>的身影在各主流平台中都占有一席之地，由于它<strong>出现早、跨平台、跨语言</strong>，所以也是为什么在学习计算机图形学时，OpenGL是必学的内容。</p><p>我们现在使用游戏引擎开发游戏，在绝大多数情况下，不需要直接和图形程序接口打交道，但是<strong>我们在Unity当中发布应用程序时</strong>，<strong>经常会看到和他们相关的一些设置</strong>，必须要了解了他们的基本概念，才能清楚我们在设置什么。</p><p>这些<strong>图形程序接口</strong>还有不同的版本，比如DX10、DX11、DX12，比如OpenGL ES 2.0、OpenGL ES 3.0。<strong>不同的设备、不同的操作系统他们支持的版本也是不同的</strong>。比如我们进行手机游戏开发时，我们<strong>可以去查询主流移动设备支持的图形程序接口的版本，来决定在发布时，对于图形程序接口版本的兼容选择**</strong>。这样才能保证我们发布的应用程序能够支持更多的移动设备。</p><h5 id="Color-Space：色彩空间"><a href="#Color-Space：色彩空间" class="headerlink" title="Color Space：色彩空间"></a><strong>Color Space：色彩空间</strong></h5><p><strong>可以在此切换Unity中用于渲染的色彩空间</strong><br><strong>Gamman（伽马）和 Linear（线性）</strong></p><p><strong>区别：</strong><br><strong>纹理倾向于保存在伽马颜色空间中，而着色器期望使用线性颜色空间</strong><br><strong>因此，在着色器中对纹理进行采样时，基于伽马的值会导致不准确的结果</strong><br><strong>我们可以选择线性色彩空间，然后通过纹理中的 sRGB选项决定是用伽马还是线性，勾选sRGB是伽马，取消勾选是线性</strong></p><p><strong>如何选择：</strong><br><strong>线性渲染的效果相对较好一些</strong><br><strong>但并不是所有平台都支持线性渲染</strong><br><strong>支持的平台为：</strong><br><strong>Android、IOS、WebGL、Windows、Mac OS X 、Linux</strong><br><strong>当设备不支持线性渲染时，不会退回到伽马控件，而是自动退出</strong></p><p><strong>在 Android 上，线性渲染至少需要 OpenGL ES 3.0 图形 API 和 Android 4.3</strong><br><strong>在 iOS 上，线性渲染需要 Metal 图形 API</strong><br><strong>在 WebGL 上，线性渲染至少需要 WebGL 2.0 图形 API</strong></p><p><strong>确定你的应用程序运行的主流设备是否支持，如果支持则选择线性，不支持选择伽马</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134818.png" alt="image-20220901231129340"></p><p><a href="https://docs.unity.cn/cn/2021.3/Manual/LinearLighting.html">https://docs.unity.cn/cn/2021.3/Manual/LinearLighting.html</a></p><h5 id="什么是Vulkan？"><a href="#什么是Vulkan？" class="headerlink" title="什么是Vulkan？"></a><strong>什么是Vulkan？</strong></h5><p><strong>是一个跨平台的2D和3D绘图应用程序接口</strong><br><strong>在2015年游戏开发者大会（GDC）上发表</strong><br><strong>是OpenGL的下一代版本，旨在提供更低的CPU开销与更直接的GPU控制</strong></p><h5 id="Auto-Graphics-API-自动图形接口（建议选择自动）"><a href="#Auto-Graphics-API-自动图形接口（建议选择自动）" class="headerlink" title="Auto Graphics API:自动图形接口（建议选择自动）"></a><strong>Auto Graphics API:自动图形接口（建议选择自动）</strong></h5><p><strong>勾选：Unity会自动尝试使用对应图形API接口进行图形处理</strong><br><strong>默认使用Vulkan，如果设备不支持Vulkan，Unity会退到GLES3.2、GLES3.1或GLES3.0</strong></p><p><strong>不勾选：可以列表中自己对使用的图形API接口进行排序，设置使用优先级</strong></p><p><strong>下方的副选项ES3.1、ES3.1+AEP、ES3.2是三个额外的用于配置最低OpenGL ES 3.X次要版本的</strong><br><strong>注意：只有当GLES2不在列表中是，Unity才会讲额外的三个选项要求添加到Android应用清单中，在这种情况下，如果你的应用发布到GooglePlay应用商店，它将不会显示在不受支持的设备上</strong></p><h5 id="Color-Gamut-色域"><a href="#Color-Gamut-色域" class="headerlink" title="Color Gamut: 色域"></a>Color Gamut: 色域</h5><p>可以添加或删除 Android 平台用于渲染的色域<br>色域定义了可用于给定设备（如监视器或屏幕）的可能颜色范围。sRGB 色域是默认（也是必需的）色域。当定位具有宽色域显示的设备时，请使用 DisplayP3 来利用完整的显示功能。</p><p>一般的手机使用sRGB即可，如果是PC主机游戏，可以考虑添加DisplayP3</p><h5 id="Multithreaded-Rendering：多线程渲染"><a href="#Multithreaded-Rendering：多线程渲染" class="headerlink" title="Multithreaded Rendering：多线程渲染"></a><strong>Multithreaded Rendering：多线程渲染</strong></h5><p><strong>启用此选项可将图形 API 调用从 Unity 的主线程移动到单独的工作线程。这有助于提高主线程上 CPU 使用率较高的应用程序的性能。</strong></p><h5 id="Static-Batching：静态批处理"><a href="#Static-Batching：静态批处理" class="headerlink" title="Static Batching：静态批处理"></a><strong>Static Batching：静态批处理</strong></h5><p><strong>会将静态物体合并处理DC，提升性能</strong></p><h5 id="Dynamic-Batching：动态批处理"><a href="#Dynamic-Batching：动态批处理" class="headerlink" title="Dynamic Batching：动态批处理"></a><strong>Dynamic Batching：动态批处理</strong></h5><p><strong>可以动态的合并DC，提高性能</strong><br><strong>当可编程渲染管线（SPR）处于活动状态时，也就是启用了URP或者HDRP时，动态批处理不起作用</strong></p><p><strong>在使用FairyGUI时，就需要开启它，FairyGUI的DC将得到优化</strong></p><h5 id="Compute-Skinning：计算蒙皮"><a href="#Compute-Skinning：计算蒙皮" class="headerlink" title="Compute Skinning：计算蒙皮"></a><strong>Compute Skinning：计算蒙皮</strong></h5><p><strong>启用此选项可启用 DX11/ES3 GPU 计算蒙皮，从而释放 CPU 资源</strong></p><p><strong>图形接口的版本要求较高，PC上DX11、移动设备ES3</strong></p><h5 id="Graphics-Jobs-Experimental-：图形作业"><a href="#Graphics-Jobs-Experimental-：图形作业" class="headerlink" title="Graphics Jobs(Experimental)：图形作业"></a>Graphics Jobs(Experimental)：图形作业</h5><h5 id="启用后，Unity将渲染循环的图形任务移到其它CPU内核上运行的工作线程，可以减少在主线程上花费的时间"><a href="#启用后，Unity将渲染循环的图形任务移到其它CPU内核上运行的工作线程，可以减少在主线程上花费的时间" class="headerlink" title="启用后，Unity将渲染循环的图形任务移到其它CPU内核上运行的工作线程，可以减少在主线程上花费的时间"></a>启用后，Unity将渲染循环的图形任务移到其它CPU内核上运行的工作线程，可以减少在主线程上花费的时间</h5><h5 id="Texture-compression-format：纹理压缩格式"><a href="#Texture-compression-format：纹理压缩格式" class="headerlink" title="Texture compression format：纹理压缩格式"></a><strong>Texture compression format：纹理压缩格式</strong></h5><p><strong>可以在ASTC、ETC2、ETC之间进行选择</strong></p><h5 id="Normal-Map-Encoding：法线地图编码"><a href="#Normal-Map-Encoding：法线地图编码" class="headerlink" title="Normal Map Encoding：法线地图编码"></a><strong>Normal Map Encoding：法线地图编码</strong></h5><p><strong>选择 XYZ 或 DXT5nm 样式以设置法线映射编码。这会影响用于法线贴图的编码方案和压缩格式。DXT5nm 样式的法线贴图质量更高，但在着色器中解码成本更高</strong></p><h5 id="Lightmap-Encoding：光照贴图编码"><a href="#Lightmap-Encoding：光照贴图编码" class="headerlink" title="Lightmap Encoding：光照贴图编码"></a><strong>Lightmap Encoding：光照贴图编码</strong></h5><p><strong>选择“正常质量”或“高质量”以设置光照贴图编码。此设置会影响光照贴图的编码方案和压缩格式</strong></p><h5 id="Lightmap-Streaming：光照贴图流"><a href="#Lightmap-Streaming：光照贴图流" class="headerlink" title="Lightmap Streaming：光照贴图流"></a><strong>Lightmap Streaming：光照贴图流</strong></h5><p><strong>是否对光照贴图使用 Mipmap 流式处理</strong></p><h5 id="Frame-Timing-Stats：帧时序统计"><a href="#Frame-Timing-Stats：帧时序统计" class="headerlink" title="Frame Timing Stats：帧时序统计"></a>Frame Timing Stats：帧时序统计</h5><p>启用此属性可收集 CPU 和 GPU 帧时间统计信息</p><p>需要和摄像机上的动态分辨率设置结合使用（Camera组件下的Allow Dynamic Resolution选项），以确定应用程序是受 CPU 还是 GPU 限制。</p><h5 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL:"></a>OpenGL:</h5><p>Profiler GPU Recorders：是否启用OpenGL的探查GPU记录器</p><p>在OpenGL上，探查GPU记录器 会 禁用GPU探查器</p><h5 id="Virtual-Texturing：虚拟纹理"><a href="#Virtual-Texturing：虚拟纹理" class="headerlink" title="Virtual Texturing：虚拟纹理"></a>Virtual Texturing：虚拟纹理</h5><p>可在场景中具有很多高分辨率纹理时减少 GPU 内存使用量和纹理加载时间。它将纹理拆分为瓦片，然后在需要时将这些瓦片逐步上传到 GPU 内存中。</p><p>注意：虚拟纹理和安卓设备不兼容</p><h5 id="Shader-Precision-model：着色器精度模型"><a href="#Shader-Precision-model：着色器精度模型" class="headerlink" title="Shader Precision model：着色器精度模型"></a>Shader Precision model：着色器精度模型</h5><p>控制着色器中使用的采样器的默认精度</p><h5 id="360-Stereo-Capture：360-度立体捕捉"><a href="#360-Stereo-Capture：360-度立体捕捉" class="headerlink" title="360 Stereo Capture：360 度立体捕捉"></a>360 Stereo Capture：360 度立体捕捉</h5><p>Unity 是否可以捕获立体 360 度全景图像和视频</p><p>注意：360 度立体捕捉与 Android 不兼容。</p><h4 id="Vulkan-Setting"><a href="#Vulkan-Setting" class="headerlink" title="Vulkan Setting"></a>Vulkan Setting</h4><p>身份证明设置</p><p>注意：安卓平台时，不要修改这些选项</p><h5 id="SRGB-Write-Mode-SRGB-写入模式"><a href="#SRGB-Write-Mode-SRGB-写入模式" class="headerlink" title="SRGB Write Mode: SRGB 写入模式"></a>SRGB Write Mode: SRGB 写入模式</h5><p>允许呈现器在运行时切换 sRGB 写入模式，如果要暂时关闭线性到 sRGB 写入颜色转换，可以启用该选项</p><p>注意：建议不要为移动设备启用该选项<br>它会增加移动设备GPU的负担，产生负面影响</p><h5 id="Number-of-swapchain-buffers-交换链缓冲区数量"><a href="#Number-of-swapchain-buffers-交换链缓冲区数量" class="headerlink" title="Number of swapchain buffers: 交换链缓冲区数量"></a>Number of swapchain buffers: 交换链缓冲区数量</h5><p>设为2位双缓冲，设为3为三重缓冲可以和Vulkan渲染器一起使用<br>该设置可以帮助解决移动平台上的延迟问题</p><p>注意：一般情况下我们不要修改此选项，保持为3，不要在安卓设备上使用双缓冲，会产生负面影响</p><h5 id="Acquire-swapchain-image-late-as-possible：尽可能晚的获取交换链图像"><a href="#Acquire-swapchain-image-late-as-possible：尽可能晚的获取交换链图像" class="headerlink" title="Acquire swapchain image late as possible：尽可能晚的获取交换链图像"></a>Acquire swapchain image late as possible：尽可能晚的获取交换链图像</h5><p>启用后，Vulkan会延迟获取后缓冲器，直到它将帧渲染为屏幕外图像。Vulkan 使用暂存映像来实现此目的。启用此设置会导致在显示反向缓冲器时产生额外的光圈。此设置与双缓冲相结合，可以提高性能。但是，它也可能导致性能问题，因为额外的 blit 会占用带宽。</p><p>注意：安卓设备上我们不要修改该选项</p><h5 id="Recycle-command-buffers：回收命令缓冲区"><a href="#Recycle-command-buffers：回收命令缓冲区" class="headerlink" title="Recycle command buffers：回收命令缓冲区"></a>Recycle command buffers：回收命令缓冲区</h5><p>Unity 执行命令缓冲区后是回收还是释放命令缓冲区</p><h5 id="Apply-display-rotation-during-rendering："><a href="#Apply-display-rotation-during-rendering：" class="headerlink" title="Apply display rotation during rendering："></a>Apply display rotation during rendering：</h5><p>在渲染期间应用显示旋转启用此选项可在显示的本机方向上执行所有渲染。这在许多设备上具有性能优势，虽然如此，但是使用它会带来一些限制，所以还是建议大家不要修改此选项</p><h4 id="Identification：身份证明"><a href="#Identification：身份证明" class="headerlink" title="Identification：身份证明"></a>Identification：身份证明</h4><p>注意：首次发布时，一定要确保包名的正确性</p><h5 id="Override-Default-Package-Name：是否覆盖默认包名称"><a href="#Override-Default-Package-Name：是否覆盖默认包名称" class="headerlink" title="Override Default Package Name：是否覆盖默认包名称"></a>Override Default Package Name：是否覆盖默认包名称</h5><p>如果你的公司名和游戏名 不是英文，请勾选它自行设置包名</p><h5 id="Package-Name：软件包名"><a href="#Package-Name：软件包名" class="headerlink" title="Package Name：软件包名"></a>Package Name：软件包名</h5><p>相当于应用程序的ID，用于在设备和安卓应用商店中的唯一标识。<br>格式：com.公司名.产品名<br>只能包含字母数字和下划线，每段都必须以字母开头</p><h5 id="Version：版本号"><a href="#Version：版本号" class="headerlink" title="Version：版本号"></a>Version：版本号</h5><p>显示给用户看的<br>用于标识应用程序包的迭代<br>格式：数字.数字.数字。。。<br>比如：1.0、4.3.2、1.2.1等</p><h5 id="Bundle-Version-Code：内部版本号"><a href="#Bundle-Version-Code：内部版本号" class="headerlink" title="Bundle Version Code：内部版本号"></a>Bundle Version Code：内部版本号</h5><p>确定一个版本是否比另一个版本新，数字越大表示版本越新，不会显示给用户看<br>该值为整数，比如每次发布新版本时可以让数字加一</p><h5 id="Minimum-API-Level：最低API级别"><a href="#Minimum-API-Level：最低API级别" class="headerlink" title="Minimum API Level：最低API级别"></a>Minimum API Level：最低API级别</h5><p>决定应用程序运行需要的最低的API级别，如果用户手机的SDK版本低于该设置，Android系统会组织用户安装该应用程序</p><h5 id="Target-API-Level：目标API级别"><a href="#Target-API-Level：目标API级别" class="headerlink" title="Target API Level：目标API级别"></a>Target API Level：目标API级别</h5><p>用于指定应用的目标API级别<br>主要用于通知Android系统，我们已经针对目标版本进行了测试，并且系统不应该通过启用任何兼容性行为，以保持你的应用与目标版本的向前兼容性。应用程序一样可以在较低版本上运行（取决于Minimum API Level）</p><h4 id="Configuration：配置"><a href="#Configuration：配置" class="headerlink" title="Configuration：配置"></a>Configuration：配置</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134547.png" alt="image-20220901232738331"></p><h5 id="Scripting-Backend：脚本后端"><a href="#Scripting-Backend：脚本后端" class="headerlink" title="Scripting Backend：脚本后端"></a><strong>Scripting Backend：脚本后端</strong></h5><p><strong>决定Unity如何在项目中编译和执行C#代码</strong></p><p><strong>Mono：将C#编译为.Net公共中间语言CIL，并使用公共语言运行时执行中间语言</strong></p><p><strong>IL2CPP：将C#编译为CIL，再将CIL转换为C++，再将C++编译为本机代码，</strong></p><p><strong>Mono和IL2CPP的具体区别在 Unity进阶之C#知识补充当中有讲解</strong></p><h5 id="Api-Compatibility-Level：API兼容性级别"><a href="#Api-Compatibility-Level：API兼容性级别" class="headerlink" title="Api Compatibility Level：API兼容性级别"></a><strong>Api Compatibility Level：API兼容性级别</strong></h5><p><strong>决定可以在项目中使用的.Net API。该设置会影响代码和第三方库的兼容性</strong></p><p><strong>.Net Standard 2.1：和.Net Standard 2.1兼容，生成较小的版本，具有完整的跨平台支持</strong></p><p><strong>.Net Framework：和.Net Framework兼容（包含.Net Standard 2.1中的所有的内容），包含更多的API支持，但是会生成更大的包。</strong></p><p><strong>如果在使用C#的一些高级功能时遇到报错或无法使用，可以尝试切换到.Net Framework以便支持这些高级功能的使用，如果有替代方案，建议使用替代方案，尽量使用.Net Standard 2.1可以让包体更小</strong></p><h5 id="C-Compiler-Configuration：C-编译器配置"><a href="#C-Compiler-Configuration：C-编译器配置" class="headerlink" title="C++ Compiler Configuration：C++编译器配置"></a><strong>C++ Compiler Configuration：C++编译器配置</strong></h5><p><strong>只有将Scripting Backend设置为IL2CPP，才能使用该选项</strong></p><p><strong>Debug（调试模式）: 将关闭所有优化，让代码生成速度更快，但运行速度较慢，可以在这种模式下进行调试</strong></p><p><strong>Release（发布模式）：会对代码进行优化，编译后的代码运行会更快，二进制文件大小更小，但编译时间更长</strong></p><p><strong>Master（大师模式）：可实现所有可能的优化，从而压缩每一点可能的优化，发布时间比发布模式还要长，如果接受较长的发布时间，建议在发布最终版本时使用Master模式</strong></p><h5 id="Use-incremental-GC：使用增量GC"><a href="#Use-incremental-GC：使用增量GC" class="headerlink" title="Use incremental GC：使用增量GC"></a><strong>Use incremental GC：使用增量GC</strong></h5><p><strong>启用后可以使用增量垃圾回收器，它会将GC分散到多个帧上执行，可以降低在一帧中进行GC造成的卡顿。</strong></p><h5 id="Assembly-Version-Validation：程序集版本验证"><a href="#Assembly-Version-Validation：程序集版本验证" class="headerlink" title="Assembly Version Validation：程序集版本验证"></a>Assembly Version Validation：程序集版本验证</h5><p>Mono是否验证强名称程序集中的类型</p><p>强名称程序集，是对程序集进行强命名，为程序集创建唯一标识，可以防止程序集冲突</p><h5 id="Mute-Other-Audio-Sources：将其它音频源静音"><a href="#Mute-Other-Audio-Sources：将其它音频源静音" class="headerlink" title="Mute Other Audio Sources：将其它音频源静音"></a><strong>Mute Other Audio Sources：将其它音频源静音</strong></h5><p><strong>如果希望在运行Unity应用程序时停止在后台运行的应用程序中的音频，可以启用该选项，否则后台音频将和Unity中的音频一起播放</strong></p><h5 id="Target-Architectures：目标体系结构"><a href="#Target-Architectures：目标体系结构" class="headerlink" title="Target Architectures：目标体系结构"></a>Target Architectures：目标体系结构</h5><p>允许应用程序运行的CPU<br>64位环境中运行安卓应用具有性能优势<br>64位应用可以处理超过4GB的内存空间</p><p>Mono模式只能选择ARMv7<br>IL2CPP模式可以选择更多的模式</p><p>ARM就是一种微处理器硬件<br>Chrome OS是一款Google开发的基于PC的操作系统</p><p>ARMv7 32位的ARM</p><p>ARM64 64位的ARM</p><p>x86(Chrome OS) 32位</p><p>x86-64(Chrome OS) 64位</p><h5 id="Split-APKs-by-target-architecture：按目标架构拆分APK（实验性功能）"><a href="#Split-APKs-by-target-architecture：按目标架构拆分APK（实验性功能）" class="headerlink" title="Split APKs by target architecture：按目标架构拆分APK（实验性功能）"></a>Split APKs by target architecture：按目标架构拆分APK（实验性功能）</h5><p>启用后，可以为目标体系结构中选择的每个CPU架构创建单独的APK，这样在Google Play中为用户提供下载时，它会根据设备的情况下载对应版本的APK，可以让apk更小，用户下载更小的包。<br>但是主要是针对Google Play，因此面向国内的产品几乎不会使用。</p><h5 id="Target-Devices：目标设备"><a href="#Target-Devices：目标设备" class="headerlink" title="Target Devices：目标设备"></a>Target Devices：目标设备</h5><p>执行允许运行APK的目标设备</p><p>All Devices（所有设备）：允许apk在所有Android和Chrome OS设备上运行<br>Phones，Tablets，and TV Devices Only（手机、平板、电视设备）：允许apk在Android手机和平板电脑、电视上运行，但是不能在Chrome OS设备上运行<br>Chrome OS Devices Only（Chrome OS设备）：允许apk在Chrome OS设备上运行，但是不能在Android手机、平板、电视上运行</p><h5 id="Install-Location：安装位置"><a href="#Install-Location：安装位置" class="headerlink" title="Install Location：安装位置"></a><strong>Install Location：安装位置</strong></h5><p><strong>指定设备上的应用程序安装位置</strong></p><p><strong>Automatic：自动让操作系统决定，用户可以自己移动安装位置</strong></p><p><strong>Prefer External：首选外部安装，如果可以，将应用程序安装到外部存储中（SD卡），如果不能，应用程序安装到手机存储空间中</strong></p><p><strong>Force Internal：强制内部，强制将应用程序安装到手机存储空间中，用户无法将应用程序移动到外部存储中安装</strong></p><h5 id="Internet-Access：互联网接入"><a href="#Internet-Access：互联网接入" class="headerlink" title="Internet Access：互联网接入"></a><strong>Internet Access：互联网接入</strong></h5><p><strong>选择是否始终将网络权限添加到Android清单（即使你没有使用任何网路API）</strong></p><p><strong>Auto：仅当使用了网络API时才会添加互联网访问权限</strong><br><strong>Require：使用添加互联网访问权限</strong></p><h5 id="Write-Permission：写入权限"><a href="#Write-Permission：写入权限" class="headerlink" title="Write Permission：写入权限"></a><strong>Write Permission：写入权限</strong></h5><p><strong>是否启用对外部存储（SD卡）的写入访问权限，并向Android应用清单添加相应的权限</strong></p><p><strong>Internal（内部）：仅授予对内部存储的写入权限</strong><br><strong>External（外置SD卡）：启用对外部存储的写入权限</strong></p><h5 id="Filter-Touches-When-Obscured：遮挡时过滤触摸"><a href="#Filter-Touches-When-Obscured：遮挡时过滤触摸" class="headerlink" title="Filter Touches When Obscured：遮挡时过滤触摸"></a>Filter Touches When Obscured：遮挡时过滤触摸</h5><p>启用后可以丢弃在另一个可见窗口覆盖Unity应用程序时收到的触摸（触屏事件），可以放置窃听劫持</p><h5 id="Sustained-Performance-Mode：持续性能模式"><a href="#Sustained-Performance-Mode：持续性能模式" class="headerlink" title="Sustained Performance Mode：持续性能模式"></a>Sustained Performance Mode：持续性能模式</h5><p>启用此选项可在较长的时间段内设置可预测且一致的设备性能级别，而无需进行热限制。启用此设置时，整体性能可能会降低</p><h5 id="Low-Accuracy-Location：低精度定位"><a href="#Low-Accuracy-Location：低精度定位" class="headerlink" title="Low Accuracy Location：低精度定位"></a>Low Accuracy Location：低精度定位</h5><p>启用后可改为低精度值与Android位置API配合使用</p><h5 id="Chrome-OS-Input-Emulation："><a href="#Chrome-OS-Input-Emulation：" class="headerlink" title="Chrome OS Input Emulation："></a>Chrome OS Input Emulation：</h5><p>Chrome OS 操作系统的默认行为是将鼠标和触摸板输入事件转为触屏输入事件。<br>取消可禁用这个默认行为</p><h5 id="Android-TV-Compatibility：安卓电视兼容性"><a href="#Android-TV-Compatibility：安卓电视兼容性" class="headerlink" title="Android TV Compatibility：安卓电视兼容性"></a>Android TV Compatibility：安卓电视兼容性</h5><p>启用后应用程序标记为兼容Android TV</p><p>启用后出现<br>Android Game：启用后可将输出的apk标记为游戏而不是常规应用<br>Android Gamepad Support Level：安卓游戏输入板支持等级<br>可以选择玩游戏时支持的输入方式</p><h5 id="Warn-about-App-Bundle-size：警告应用程序包的大小"><a href="#Warn-about-App-Bundle-size：警告应用程序包的大小" class="headerlink" title="Warn about App Bundle size：警告应用程序包的大小"></a>Warn about App Bundle size：警告应用程序包的大小</h5><p>只有在Build Settings中勾选了Build App Bundle（Google Play）才有用<br>当应用程序包大小超过这个阈值时会收到警告</p><h5 id="Active-Input-Handling：活动输入处理"><a href="#Active-Input-Handling：活动输入处理" class="headerlink" title="Active Input Handling：活动输入处理"></a><strong>Active Input Handling：活动输入处理</strong></h5><p><strong>选择要如何处理来自用户的输入</strong></p><p><strong>Input Manager：老的输入系统，Input相关</strong><br><strong>Input System Package：新输入系统</strong><br><strong>Both：同时使用</strong></p><h4 id="Script-Compilation：脚本编译"><a href="#Script-Compilation：脚本编译" class="headerlink" title="Script Compilation：脚本编译"></a>Script Compilation：脚本编译</h4><h5 id="Scripting-Define-Symbols：脚本定义符号"><a href="#Scripting-Define-Symbols：脚本定义符号" class="headerlink" title="Scripting Define Symbols：脚本定义符号"></a>Scripting Define Symbols：脚本定义符号</h5><p>可以在此设置自定义编译标志。</p><p>再使用一些第三方内容时有时会在此处添加脚本符号<br>比如：Lua热更相关、FairyGUI相关</p><h6 id="Unity有内置的脚本符号"><a href="#Unity有内置的脚本符号" class="headerlink" title="Unity有内置的脚本符号"></a>Unity有内置的脚本符号</h6><p>这些符号能够帮助我们有选择的在编译中包含或排除部分代码</p><p>这些脚本符号可以配合多路测试 #if 进行使用<br>#if 脚本符号<br>    代码逻辑<br>#elif 脚本符号<br>    代码逻辑<br>#else<br>    代码逻辑<br>#endif</p><h6 id="平台脚本符号"><a href="#平台脚本符号" class="headerlink" title="平台脚本符号"></a>平台脚本符号</h6><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134540.png" alt="image-20220901233443206"></p><h6 id="编辑器版本脚本符号"><a href="#编辑器版本脚本符号" class="headerlink" title="编辑器版本脚本符号"></a>编辑器版本脚本符号</h6><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134858.png" alt="image-20220901233531611"></p><h6 id="其它脚本符号"><a href="#其它脚本符号" class="headerlink" title="其它脚本符号"></a>其它脚本符号</h6><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242134723.png" alt="image-20220901233603453"></p><h5 id="Additional-Compiler-Arguments：其它编译器参数"><a href="#Additional-Compiler-Arguments：其它编译器参数" class="headerlink" title="Additional Compiler Arguments：其它编译器参数"></a>Additional Compiler Arguments：其它编译器参数</h5><p>向此列表添加条目以将其他参数传递给 Roslyn 编译器。对每个附加参数使用一个新条目。<br>要创建新条目，请按“+”按钮。要删除条目，请按“-”按钮。<br>添加完所有所需参数后，单击“应用”按钮以在将来的编译中包括其他参数。“还原”按钮将此列表重置为最近应用的状态。</p><h5 id="Suppress-Common-Warnings：禁止显示常见警告"><a href="#Suppress-Common-Warnings：禁止显示常见警告" class="headerlink" title="Suppress Common Warnings：禁止显示常见警告"></a>Suppress Common Warnings：禁止显示常见警告</h5><p>禁用此设置可显示C#警告<br>CS0169：从不使用私有字段，声明了私有变量，但是从没有使用<br>CS0649：编译器检测到从未分配值的未初始化的私有或内部字段声明</p><h5 id="Allow-‘unsafe’-Code：允许使用“不安全”代码"><a href="#Allow-‘unsafe’-Code：允许使用“不安全”代码" class="headerlink" title="Allow ‘unsafe’ Code：允许使用“不安全”代码"></a><strong>Allow ‘unsafe’ Code：允许使用“不安全”代码</strong></h5><p><strong>启用对在预定义程序集中编译“unsafe”C# 代码的支持</strong></p><p><strong>unsafe 关键词的基本概念</strong></p><p>默认情况下，C#是不支持 指针 的，unsafe 关键词用于在C#表示<strong>不安全的上下文</strong>，如果<strong>想要在C#中进行任何和指针相关的操作，就必须配合unsafe关键词使用。</strong></p><p>在公共语言运行时（CLR）中，不安全代码是指无法验证的代码。</p><p>C# 中的不安全代码不一定是危险的，只是 CLR 无法验证该代码的安全性。因此，CLR 将仅执行完全信任的程序集中的不安全代码。</p><p><strong>如果你使用不安全代码，你**</strong>应该负责确保代码不会引发安全风险或指针错误**</p><p><strong>unsafe 关键词的基本使用</strong></p><p>如果想要在Unity中正常使用C#中的unsafe关键词进行程序编写，我们必须在Unity的 Player Settings 中的 Other Settings 中将 Allow unsafe Code 选项勾选上</p><p>勾选该选项后，我们就可以在Unity中使用unsafe关键词了。</p><p><strong>注意：unsafe 的使用虽然能让我们在C#中使用指针，但是会存在安全风险和稳定性风险，如果没有特殊需求，请尽量避免在C#中使用 unsafe。</strong></p><h5 id="Use-Deterministic-Compilation：使用确定性编译"><a href="#Use-Deterministic-Compilation：使用确定性编译" class="headerlink" title="Use Deterministic Compilation：使用确定性编译"></a>Use Deterministic Compilation：使用确定性编译</h5><p>启用此设置后，编译的程序集在每次编译时都是完全相同的。<br>禁用此设置可防止使用 -确定性 C# 标志进行编译</p><p>确定性编译可用于确定二进制文件是否从受信任的源编译</p><h6 id="Enable-Roslyn-Analyzers：启用罗斯林分析器"><a href="#Enable-Roslyn-Analyzers：启用罗斯林分析器" class="headerlink" title="Enable Roslyn Analyzers：启用罗斯林分析器"></a>Enable Roslyn Analyzers：启用罗斯林分析器</h6><p>禁用此设置可编译用户编写的脚本，而无需项目中可能存在的 Roslyn 分析器 DLL（ Roslyn 就是微软的.Net开源编译器，编译器支持 C# 编译，并提供丰富的代码分析 API。）</p><h4 id="Optimization：优化"><a href="#Optimization：优化" class="headerlink" title="Optimization：优化"></a>Optimization：优化</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135478.png" alt="image-20220901234125528"></p><h5 id="Prebake-Collision-Meshes：预烘焙碰撞到网格"><a href="#Prebake-Collision-Meshes：预烘焙碰撞到网格" class="headerlink" title="Prebake Collision Meshes：预烘焙碰撞到网格"></a>Prebake Collision Meshes：预烘焙碰撞到网格</h5><p>启用该选项可以在构建时将碰撞数据添加到网格</p><h5 id="Keep-Loaded-Shaders-Alive：保持加载的着色器的活动状态"><a href="#Keep-Loaded-Shaders-Alive：保持加载的着色器的活动状态" class="headerlink" title="Keep Loaded Shaders Alive：保持加载的着色器的活动状态"></a>Keep Loaded Shaders Alive：保持加载的着色器的活动状态</h5><p>启动后，不能卸载着色器</p><p>着色器加载时会造成性能开销，可能会出现卡顿现象，不允许卸载着色器可以避免卸载后重复加载</p><h4 id="Preloaded-Assets：预装资源"><a href="#Preloaded-Assets：预装资源" class="headerlink" title="Preloaded Assets：预装资源"></a><strong>Preloaded Assets：预装资源</strong></h4><p><strong>设置启动时加载的资源数组</strong><br><strong>将想要预加载的内容拖入框中</strong></p><h5 id="Strip-Engine-Code：剥离引擎代码"><a href="#Strip-Engine-Code：剥离引擎代码" class="headerlink" title="Strip Engine Code：剥离引擎代码"></a><strong>Strip Engine Code：剥离引擎代码</strong></h5><p><strong>选择IL2CPP模式才会出现的字段</strong><br><strong>如果你希望在IL2CPP模式，能够删除Unity引擎功能中没有使用的代码，可以启用该选项，可以有效的减小包体大小</strong></p><h5 id="Managed-Stripping-Level：管理剥离水平"><a href="#Managed-Stripping-Level：管理剥离水平" class="headerlink" title="Managed Stripping Level：管理剥离水平"></a><strong>Managed Stripping Level：管理剥离水平</strong></h5><p><strong>选择Unity如何剥离未使用的C#代码</strong><br><strong>在发布应用程序时，Unity会自动去除掉没有使用的代码，剥离代码可以使生成的执行文件减小，但是有可能会意外删除需要使用的代码</strong></p><p><strong>在Unity进阶之C#知识补充中讲解IL2CPP相关内容时讲解过</strong></p><p><strong>Disabled：不剥离，只有在Mono模式下才能选择</strong></p><p><strong>Minimal：最小剥离，Unity只会搜索Unity引擎未使用的.Net类库，不会删除任何用户编写的代码，该设置基本不会出现意外剥离，在使用IL2CPP模式后，该模式是默认模式</strong></p><p><strong>Low：低级剥离，处理Unity相关，玩家自己编写的代码也会被剥离，会尽量减小意外剥离发生</strong></p><p><strong>Medium：中级剥离，比起Low更多一些剥离</strong></p><p><strong>High：高级剥离，优先考虑打包大小，会最大限度剥离代码。可以采配合link.xml来手动拒绝剥离，或使用[Preserve]特性（在不希望被剥离的函数前加该特性）</strong></p><h5 id="Enable-Internal-Profiler：启用内部探查器，已经弃用的功能"><a href="#Enable-Internal-Profiler：启用内部探查器，已经弃用的功能" class="headerlink" title="Enable Internal Profiler：启用内部探查器，已经弃用的功能"></a>Enable Internal Profiler：启用内部探查器，已经弃用的功能</h5><p>用此选项以从Android SDK的设备中获取profiler数据adblogcat测试项目时输出。这仅在开发版本中可用。</p><h4 id="Vertex-Compression：顶点压缩"><a href="#Vertex-Compression：顶点压缩" class="headerlink" title="Vertex Compression：顶点压缩"></a><strong>Vertex Compression：顶点压缩</strong></h4><p><strong>选择要设置的通道，以便在顶点压缩方法下压缩网格</strong><br><strong>通常，顶点压缩用于减少内存中网格数据的大小，减小文件大小，提高CPU性能。</strong></p><h5 id="Optimize-Mesh-Data：优化网格数据"><a href="#Optimize-Mesh-Data：优化网格数据" class="headerlink" title="Optimize Mesh Data：优化网格数据"></a><strong>Optimize Mesh Data：优化网格数据</strong></h5><p><strong>启用后，构建时会从使用的网格中剥离未使用的顶点属性</strong><br><strong>它可以减少网格中的数量，也可以减小包体大小，可以减小加载时间和运行时的内存使用</strong><br><strong>但是，如果启用了该设置，运行时就不要更改材质或着色器相关设置</strong></p><p><strong>也就是说，如果你游戏会在运行时转换一些对象的着色器，就不能开启该选项。</strong></p><p><strong>比如游戏中某一个对象，如果网格使用简单漫射着色器，那么 Unity 将删除 切线矢量，因为并不需要它们。如果您想要在运行时切换到网格上的凹凸贴图着色器 ，那么您将不会得到正确的切线数据，因为此数据已被删除</strong></p><h5 id="Texture-MipMap-Stripping：贴图纹理剥离"><a href="#Texture-MipMap-Stripping：贴图纹理剥离" class="headerlink" title="Texture MipMap Stripping：贴图纹理剥离"></a><strong>Texture MipMap Stripping：贴图纹理剥离</strong></h5><p><strong>启用后会启用纹理贴图剥离，在构建时会从纹理中剥离没有使用的纹理贴图。</strong><br><strong>会根据你发布平台的质量设置进行比较来确定哪些贴图用不到。</strong><br><strong>mipmap生成的多分辨率图也会被剥离</strong></p><h5 id="Stack-Trace：堆栈跟踪"><a href="#Stack-Trace：堆栈跟踪" class="headerlink" title="Stack Trace：堆栈跟踪"></a><strong>Stack Trace：堆栈跟踪</strong></h5><p><strong>选择在特定的上下文中允许的日志记录类型</strong><br><strong>可以选择日志记录的方式</strong><br><strong>None：不记录</strong><br><strong>ScriptOnly：只在运行脚本时记录信息</strong><br><strong>Full：一直记录</strong></p><p>Error：错误信息<br>Assert：断言（用于检测非法情况的）信息<br>Warning：警告信息<br>Log：打印日志信息<br>Exception：异常信息</p><h5 id="Legacy：以前的内容"><a href="#Legacy：以前的内容" class="headerlink" title="Legacy：以前的内容"></a>Legacy：以前的内容</h5><p>Clamp BlendShapes（Deprecated）：启用 骨骼蒙皮动画中钳制混合形状权重的范围</p><h3 id="Publishing-Settings"><a href="#Publishing-Settings" class="headerlink" title="Publishing Settings"></a>Publishing Settings</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h4><h5 id="Android-中的签名是什么？"><a href="#Android-中的签名是什么？" class="headerlink" title="Android 中的签名是什么？"></a><strong>Android 中的签名是什么？</strong></h5><p>Android要求所有已安装的应用程序都使用数字证书做数字签名，数字证书的私钥由应用开发者持有，<br>Android使用证书作为标示应用程序作者的一种方式，并在应用程序之间建立信任的关系。 证书并不用来控制用户能否安装哪个应用。证书不需要由证书认证中心签名；完全可以使用自制签名证书。</p><p>没有正确签名的应用，Android系统不会安装或运行。此规则适用于在任何地方运行的Android系统，不管是在模拟器还是真实设备上。因为这个原因。在真机或模拟器上运行或者调试应用前，必须为其设置好签名。</p><p><strong>为什么要使用签名？</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135676.png" alt="img"></p><p>上图是我们在Unity中发布Android应用程序时，设置的包名</p><p>开发Android的人这么多，完全有可能把包名命名成同样的名字，这个时候该如何区分？</p><p>这时就需要签名来区分了，由于开发商可能通过使用相同的Package Name（包名）来混淆替换已经安装的程序，签名可以保证相同名字，但是签名不同的包不被替换。</p><p>举例：</p><p>比如应用程序A 和 应用程序B 的包名是相同的，如果没有签名的存在，在同一Android设备上重复安装A和B，就会导致他们之间的彼此覆盖，不能同时拥有，为了避免这种情况出现，就有了签名机制。</p><p><strong>安卓密钥库和密钥，就是用来进行Android签名的。</strong></p><h5 id="Android-应用程序清单是什么？"><a href="#Android-应用程序清单是什么？" class="headerlink" title="Android 应用程序清单是什么？"></a><strong>Android 应用程序清单是什么？</strong></h5><p>Android应用程序工程中，有一个叫做 AndroidManifest.xml 的xml文件，该文件在之后的开发中我们会经常使用和编辑，该配置文件主要用于声明应用程序的组件，并且还有以下的一些重要作用：</p><ol><li><p>确定应用程序要求的用户权限，比如：网络访问、通讯录访问、信息读取等权限</p></li><li><p>声明应用程序要求的最低API Level</p></li><li><p>声明应用程序将要使用的或要求的硬件和软件特性，比如：摄像头访问、蓝牙服务、多点触碰等</p></li><li>等等</li></ol><p>也就是说，如果我们想要在安卓游戏当中使用一些系统功能或硬件访问权限，都需要在该文件当中进行设置。</p><p><strong>Unity中如果引入Android第三方SDK，或者需要和Android进行交互，经常会对该文件进行编辑。如果我们没有这些需求，可以忽略它。</strong></p><h5 id="Gradle-是什么？"><a href="#Gradle-是什么？" class="headerlink" title="Gradle 是什么？"></a><strong>Gradle 是什么？</strong></h5><p>Gradle 是一个自动化构建开源工具，主要面向Java应用为主，也支持其它语言，比如C++、Kotlin、Swift，未来还会支持更多的语言。</p><p>它是一个基于JVM（Java虚拟机）的构建工具，是一款通用灵活的构建工具，也可以用于Android 项目的构建工作，它可以让安卓项目变得更加简洁。</p><p><strong>在Unity中简单理解Gradle，它就是用于帮助我们打包出安卓应用程序 .apk 的一个工具，在Android Studio中也使用Gradle进行应用程序打包。</strong></p><h5 id="ProGuard-和-R8-是什么？"><a href="#ProGuard-和-R8-是什么？" class="headerlink" title="ProGuard 和 R8 是什么？"></a><strong>ProGuard 和 R8 是什么？</strong></h5><p><strong>代码混淆</strong></p><p>代码混淆(Obfuscated code)，是将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式的行为。代码混淆主要用于程序源代码，也可以用于程序编译而成的中间代码。执行代码混淆的程序被称作代码混淆器。已经存在许多种功能各异的代码混淆器。</p><p>将代码中的各种元素，如变量，函数，类的名字改写成无意义的名字。比如改写成单个字母，或是简短的无意义字母组合，甚至改写成“__”这样的符号，使得阅读的人无法根据名字猜测其用途。重写代码中的部分逻辑，将其变成功能上等价，但是更难理解的形式。比如将for循环改写成while循环，将循环改写成递归，精简中间变量，等等。打乱代码的格式。比如删除空格，将多行代码挤到一行中，或者将一行代码断成多行等等。</p><p><strong>代码混淆的主要目的是提升源代码的安全性</strong>，别人反编译你的应用程序代码后，增加他们阅读分析逻辑的难度。</p><p><strong>ProGuard 和 R8 就是两种不同的代码混淆器。</strong></p><p><strong>ProGuard</strong></p><p>ProGuard是一个压缩、优化和混淆<a href="https://baike.baidu.com/item/Java字节码/13025120">J</a>ava字节码（Java源代码通常被编译为字节码）文件的免费的工具，它可以删除无用的类、字段、方法和属性。可以删除没用的注释，最大限度地优化字节码文件。它还可以使用简短的无意义的名称来重命名已经存在的类、字段、方法和属性。常常在Android开发用于混淆最终的项目，增加项目被反编译的难度。</p><p>Unity发布安卓应用程序时，默认使用的就是ProGuard来进行处理最终的代码。</p><p><strong>R8</strong></p><p>R8是相对ProGuard较新的Android混淆编译器，它可以尽可能的减小应用的大小，早期的Android Studio版本中，混淆编译器使用的是ProGuard执行编译时的代码优化，如果我们使用Android Gradle 3.4.0或更高版本构建项目时，不再使用ProGuard进行代码优化，而是采用R8编译器协同工作。</p><p>Android Sutdio 3.3版本开始，就使用R8作为代码压缩器来对代码进行混淆、压缩、优化了。</p><p>R8 相对 ProGuard来说，它可以更快地缩减代码，同时改善输出的大小。</p><p>Unity发布安卓应用程序时，我们可以选择使用R8混淆编译器进行发布处理。</p><p>大概了解了这些基本概念后，才能知道我们是在设置什么内容。</p><h4 id="Keystore-Manager：密钥管理器"><a href="#Keystore-Manager：密钥管理器" class="headerlink" title="Keystore Manager：密钥管理器"></a><strong>Keystore Manager：密钥管理器</strong></h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135085.png" alt="image-20220903120410725"></p><p><strong>可以通过密钥管理器创建、配置和加载密钥和密钥库</strong><br><strong>我们可以在Keystore Manager窗口</strong><br><strong>或</strong><br><strong>Publishing Settings 发布设置中</strong><br><strong>加载现有密钥库和密钥</strong></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135418.png" alt="image-20220903120739100"></p><p>Create New：创建新的密钥库</p><p>Anywhere：任何地方，会打开项目文件夹根目录下的文件资源管理器，这是Unity存储密钥库的默认位置</p><p>In Dedicated Location：专用位置，将密钥库文件保存到计算机中的另一个目录中</p><p>注意：为了协同开发方便，建议大家就把密钥库保存在项目文件夹下，避免其它同事无法访问密钥库</p><p>Select Existing：选择现有密钥库<br>可以指定加载现有密钥库</p><p>Password：密钥库的密码<br>Confirm password：创建密钥库时 需要重复一次密码</p><p>Existing Keys：现有密钥<br>界面的这一部分包含当前密钥库包含的密钥的只读列表</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242135636.png" alt="image-20220903120936402"></p><h4 id="Project-Keystore：项目密钥库"><a href="#Project-Keystore：项目密钥库" class="headerlink" title="Project Keystore：项目密钥库"></a><strong>Project Keystore：项目密钥库</strong></h4><p><strong>用于保存签名密钥来实现应用程序安全性的容器</strong><br><strong>如果想要加载和使用现有密钥库，我们需要：</strong></p><ol><li><strong>启动 Custom Keystore</strong></li><li><strong>在 Select 下拉列表中选择Browse，从文件系统中选择密钥库</strong></li><li><strong>输入密钥库密码</strong></li></ol><p>Custom Keystore：启用后，可以指定加载和使用现有密钥库</p><p>Select：启用Custom Keystore后，该按钮可以用来选择要使用的密钥库</p><p>Path：你选择的密钥库所在路径</p><p>Password：输入密钥库密码以加载所选的密钥库</p><h4 id="Project-Key：项目密钥"><a href="#Project-Key：项目密钥" class="headerlink" title="Project Key：项目密钥"></a><strong>Project Key：项目密钥</strong></h4><p><strong>加载密钥库后，Unity会加载该密钥库中的所有密钥</strong><br><strong>我们可以在项目密钥Project Key中设置从该密钥库中选择哪一个密钥用来作为该项目的活动密钥</strong></p><p>Alias：选择用于打开的项目的密钥</p><p>Password：密钥密码</p><h4 id="Build：构建相关"><a href="#Build：构建相关" class="headerlink" title="Build：构建相关"></a><strong>Build：构建相关</strong></h4><p><strong>默认情况下，Unity使用Unity安装提供的清单文件、Gradle模板和文件构建应用程序</strong><br><strong>如果想要自定义这些内容，你需要：</strong></p><ol><li><strong>启用Build下方的这些复选框，文件会出现到复选框的下方</strong></li><li><strong>打开新文件进行更改</strong></li><li><strong>保存修改的文件，Unity下次构建应用程序时会自动使用的文件</strong></li></ol><h5 id="Custom-Main-Manifest：自定义主清单文件"><a href="#Custom-Main-Manifest：自定义主清单文件" class="headerlink" title="Custom Main Manifest：自定义主清单文件"></a><strong>Custom Main Manifest：自定义主清单文件</strong></h5><p><strong>该清单文件是一个xml文件</strong><br><strong>我们可以在此决定一些权限设置（比如：网络、定位、拍照等权限配置），还可以设置是否启用一些安卓功能等等</strong></p><h5 id="Custom-Launcher-Manifest：自定义启动器清单"><a href="#Custom-Launcher-Manifest：自定义启动器清单" class="headerlink" title="Custom Launcher Manifest：自定义启动器清单"></a>Custom Launcher Manifest：自定义启动器清单</h5><p>该清单文件是一个xml文件<br>我们可以在此决定一些应用程序启动之前的外观和行为。（比如：图标、名称、安装位置等等）</p><h5 id="Custom-Main-Gradle-Template：自定义主Gradle构建模板"><a href="#Custom-Main-Gradle-Template：自定义主Gradle构建模板" class="headerlink" title="Custom Main Gradle Template：自定义主Gradle构建模板"></a>Custom Main Gradle Template：自定义主Gradle构建模板</h5><p>Gradle 是一个构建系统，可自动执行许多构建过程并防止许多常见的构建错误。Unity将Gradle用于所有Android版本。您可以在Unity中构建输出包（.apk，.aab），也可以从Unity导出Gradle项目，然后使用Android Studio等外部工具构建它</p><p>是一个gradle文件，包含有关如何将Android应用程序构建为库的信息</p><h5 id="Custom-Launcher-Gradle-Template：自定义启动器Gradle构建模板"><a href="#Custom-Launcher-Gradle-Template：自定义启动器Gradle构建模板" class="headerlink" title="Custom Launcher Gradle Template：自定义启动器Gradle构建模板"></a>Custom Launcher Gradle Template：自定义启动器Gradle构建模板</h5><p>是一个gradle文件，包含有关如何构建Android应用程序的说明</p><h5 id="Custom-Base-Gradle-Template：自定义基础Gradle构建模板"><a href="#Custom-Base-Gradle-Template：自定义基础Gradle构建模板" class="headerlink" title="Custom Base Gradle Template：自定义基础Gradle构建模板"></a>Custom Base Gradle Template：自定义基础Gradle构建模板</h5><p>是一个gradle文件，包含在所有其它模板和Gradle项目之间的共享配置</p><h5 id="Custom-Gradle-Properties-Template：自定义属性Gradle构建模板"><a href="#Custom-Gradle-Properties-Template：自定义属性Gradle构建模板" class="headerlink" title="Custom Gradle Properties Template：自定义属性Gradle构建模板"></a>Custom Gradle Properties Template：自定义属性Gradle构建模板</h5><p>属性文件，包含Gradle生成环境的配置设置<br>比如<br>JVM（Java虚拟机）内存配置<br>允许Gradle使用多个JVM构建的属性<br>用于选择进行缩小的工具的属性<br>构建应用程序包时不压缩本机库的属性等等</p><h5 id="Custom-Proguard-File：自定义Proguard文件"><a href="#Custom-Proguard-File：自定义Proguard文件" class="headerlink" title="Custom Proguard File：自定义Proguard文件"></a>Custom Proguard File：自定义Proguard文件</h5><p>是一个txt文件，包含缩小过程的配置设置<br>如果缩小删除了一些应该保留的Java代码，你可以添加一条规则来将这些代码保留在此文件中</p><h4 id="Minify：代码混淆和缩小相关"><a href="#Minify：代码混淆和缩小相关" class="headerlink" title="Minify：代码混淆和缩小相关"></a><strong>Minify：代码混淆和缩小相关</strong></h4><p><strong>是一种缩减、混淆和优化应用程序代码的过程</strong><br><strong>它可以减小代码大小并使代码更难以反编译</strong><br><strong>使用 Minify 设置可定义 Unity 应何时以及如何将缩小应用于构建</strong></p><p><strong>使用该功能会加长发布时间，并且还会让调试变得复杂，所以一般在最终发布时才会使用，平时发布测试应用时不需要开启。</strong></p><p>Use R8：默认情况下，Unity 使用 Proguard 进行缩小。启用此复选框可改为使用 R8。</p><p><strong>Release：如果希望 Unity 在发布构建中缩小应用程序的代码，请启用此复选框。</strong></p><p>Debug：如果希望 Unity 在调试构建中缩小应用程序的代码，请启用此复选框。</p><h4 id="Split-Application-Binary：拆分应用程序二进制文件"><a href="#Split-Application-Binary：拆分应用程序二进制文件" class="headerlink" title="Split Application Binary：拆分应用程序二进制文件"></a><strong>Split Application Binary：拆分应用程序二进制文件</strong></h4><p><strong>启用 Split Application Binary 选项可将输出包拆分为主包 (APK) 和扩展包 (OBB) 包。如果要发布大于 100 MB 的应用程序，则 Google Play 应用商店需要此功能。</strong></p><h2 id="Unity打包Android"><a href="#Unity打包Android" class="headerlink" title="Unity打包Android"></a>Unity打包Android</h2><h3 id="Unity导出APk"><a href="#Unity导出APk" class="headerlink" title="Unity导出APk"></a>Unity导出APk</h3><p>没什么可说的直接导出就行了</p><h3 id="Unity导出Android-Studio能够打开的工程"><a href="#Unity导出Android-Studio能够打开的工程" class="headerlink" title="Unity导出Android Studio能够打开的工程"></a>Unity导出Android Studio能够打开的工程</h3><p>1.设置导出基本信息：公司名、游戏名、图标、包名等关键信息</p><p>2.在File——&gt;Build Settings中，勾选 Export Project 选项</p><p>3.点击Export 导出按钮</p><h4 id="在Android-Studio中打开Unity导出的工程"><a href="#在Android-Studio中打开Unity导出的工程" class="headerlink" title="在Android Studio中打开Unity导出的工程"></a>在Android Studio中打开Unity导出的工程</h4><p>1.打开Android Studio</p><p>2.新选择 打开工程</p><p>3.选择 之前导出的对应文件夹</p><p>4.弹出提示时，使用Android Studio中的 Android SDK，可以避免打包失败</p><p>5.等待工程加载结束</p><p>6.更新Gradle版本，保证之后打包成功</p><h4 id="使用Android-Studio生成应用程序apk"><a href="#使用Android-Studio生成应用程序apk" class="headerlink" title="使用Android Studio生成应用程序apk"></a>使用Android Studio生成应用程序apk</h4><p>1.在 工具栏——&gt;Build——&gt;Build Bundle…——&gt;Build APK</p><p> 构建一次工程，保证构建成功，根据报错解决问题</p><p> 常见问题：</p><p> 1.The option ‘android.enableR8’ is deprecated 由于新版本Gradle默认使用R8混淆</p><p>   所以不需要这个选项设置了</p><p>   在Project选项中 找到 gradle.properties 删除 android.enableR8</p><p> 2.SDK Tools 版本不匹配</p><p>   更新SDK使用的路径，使用Android Studio自己的路径，或者更新SDK</p><p>2.在 工具栏——&gt;Build——&gt;Build Bundle…——&gt;Generate Signed Bundle</p><p> 发布APK，可以设置密钥库相关内容后进行打包即可</p><p>3.测试生成的apk文件</p><h2 id="Android调试相关"><a href="#Android调试相关" class="headerlink" title="Android调试相关"></a>Android调试相关</h2><h3 id="Unity进行安卓真机调试"><a href="#Unity进行安卓真机调试" class="headerlink" title="Unity进行安卓真机调试"></a>Unity进行安卓真机调试</h3><h4 id="调试指的是什么？"><a href="#调试指的是什么？" class="headerlink" title="调试指的是什么？"></a>调试指的是什么？</h4><p>安卓手机的真机调试</p><p>由于运行环境的改变（开发时在 Windows 或 MacOS，使用时在Android或IOS）</p><p>我们很多时候需要在真机上进行项目的 性能分析 和 bug处理（断点调试修复bug）</p><h4 id="准备测试用安卓手机"><a href="#准备测试用安卓手机" class="headerlink" title="准备测试用安卓手机"></a>准备测试用安卓手机</h4><p>1.安卓手机需要打开开发者模式可以根据自己的手机品牌自行搜索开启方式</p><p> 一般的操作方式：设置——&gt;关于手机——&gt;版本号（点击n次版本号）便可开启</p><p>2.完成第一步后，在手机的开发者选项中 开启 USB调试功能一般开发者选项会在：设置——&gt;系统——&gt;开发者选项中找到USB调试功能 开启它</p><p>3.将手机通过USB接入到你的电脑上，在手机上一般会弹出一个提示选择允许进行USB调试</p><h4 id="在Unity中进行调试相关设置"><a href="#在Unity中进行调试相关设置" class="headerlink" title="在Unity中进行调试相关设置"></a>在Unity中进行调试相关设置</h4><p>在 File ——&gt; Build Settings 中进行调试相关的设置</p><ol><li><p>完成知识点一相关内容后，可以在 Run Device 的设备列表中看到你的安卓设备</p><p>如果Refresh刷新后也无法看到你的设备，证明你的连接有问题，或没有开启USB调试模式</p></li><li><p>调试相关设置</p><p>剖析器 性能问题排查相关（勾选了他们，我们才能在Unity的剖析器中获取完整信息）</p><p>开启 Development Build 开发模式构建</p><p>开启 Autoconnect Profiler 自动连接分析器</p><p>开启 Deep Profiling 深度剖析</p></li></ol><p>  断点 调试相关（勾选了他们，我们才能进行断点调试）</p><p>  开启 Script Debuggins 脚本调试</p><p>  开启 Wait For Managed Debugger 等待托管调试器</p><ol><li><p>项目基本的发布设置相关内容一定要设置正确</p><p>比如：包名、项目名、公司名、密钥库等等</p></li></ol><h4 id="Unity连接安卓真机进行项目调试"><a href="#Unity连接安卓真机进行项目调试" class="headerlink" title="Unity连接安卓真机进行项目调试"></a>Unity连接安卓真机进行项目调试</h4><p>点击Build and Run</p><p>这时Unity会自动发布apk应用该程序，然后安装到设备上自动启动</p><p>这时我们就可以</p><ol><li><p>利用Unity的 剖析器来分析应用程序</p></li><li><p>进行断点调试，排查问题</p></li></ol><p>注意：如果想要断点调试，自动启动应用程序后，弹出的提示窗口 不要点击OK先在VS中 工具栏——&gt;调试——&gt;附加 Unity 调试程序——&gt;选择对应的设备再在运行的应用程序中点击ok</p><h3 id="Unity-Remote"><a href="#Unity-Remote" class="headerlink" title="Unity Remote"></a>Unity Remote</h3><h4 id="Remote是什么？"><a href="#Remote是什么？" class="headerlink" title="Remote是什么？"></a>Remote是什么？</h4><p>Remote翻译过来是远程的意思</p><p>Unity Remote是Unity提供给我们的一个可以安装到移动平台上的应用程序帮助我们进行调试的远程工具</p><p>该应用程序可以安装到 Android、IOS设备上，当我们在Unity编辑器运行项目时，移动设备上安装的Unity Remote会和Unity连接，Unity编辑器中的游戏画面会被发送到移动设备上，移动设备上的输入操作会返回到Unity编辑器运行的项目中</p><p>它的主要作用就是可以让我们省去发布安装包、安装到移动设备上的这一繁琐流程</p><p>可以直接通过Unity Remote远程连接来达到以下目的：</p><p>查看项目在设备上的视觉表现效果</p><p>测试移动设备输入逻辑是否能正常使用</p><p>设备的以下输入会被回传到Unity引擎中用于测试</p><p>触屏输入相关</p><p>GPS</p><p>陀螺仪</p><p>指南针</p><p>加速度计</p><p>相机拍照信息</p><p>等等输入信息</p><p>注意：</p><p>1.Unity引擎传递给移动设备的画面较模糊，帧率较低，我们只能看看大致的表现效果</p><p>2.我们主要通过这种方式，来测试移动设备输入相关的功能</p><p>比如：陀螺仪、GPS、触屏功能等等</p><h4 id="获取和使用Unity-Remote"><a href="#获取和使用Unity-Remote" class="headerlink" title="获取和使用Unity Remote"></a>获取和使用Unity Remote</h4><p>1.下载Unity Remote应用程序,并安装到移动设备上</p><p>2.将移动设备使用USB调试模式和电脑连接</p><p>3.在菜单栏Edit——&gt;Project Setting——&gt;Editor中设置Unity Remote的Device为任意设备</p><p>4.在移动设备运行Unity Remote</p><p>5.在Unity编辑器中启动项目，便可以进行远端调试</p><p>注意：</p><p>1.如果电脑插入多个Android设备，会自动选择第一台设备</p><p>2.Unity Remote存在的主要目的仅仅是为了快速的在设备上测试输入相关功能以及基本表现效果 如果要完整的测试，还是需要发布安装进行调试</p><h3 id="Android-Logcat"><a href="#Android-Logcat" class="headerlink" title="Android Logcat"></a>Android Logcat</h3><h4 id="Android-Logcat是什么？"><a href="#Android-Logcat是什么？" class="headerlink" title="Android Logcat是什么？"></a>Android Logcat是什么？</h4><p>Android Logcat是Unity提供的一个拓展包，引入该拓展包后，我们可以在Unity当中对Android应用程序进行调试</p><p>我们可以通过该工具获取到：</p><p>1.安卓日志打印信息</p><p>2.安卓应用程序内存统计</p><p>3.安卓屏幕截图</p><p>4.安卓屏幕录像</p><p>5.堆栈跟踪</p><p>Unity2019.4及以上版本都可以引入Android Logcat来帮助我们进行调试</p><h4 id="如何使用Android-Logcat工具"><a href="#如何使用Android-Logcat工具" class="headerlink" title="如何使用Android Logcat工具"></a>如何使用Android Logcat工具</h4><p>1.在Unity工程中引入Android Logcat包</p><p>2.连接Android设备</p><p>3.将Android Logcat连接到Android设备上点的应用程序，便可以查看相关信息</p><h4 id="Android-Logcat窗口基础知识"><a href="#Android-Logcat窗口基础知识" class="headerlink" title="Android Logcat窗口基础知识"></a>Android Logcat窗口基础知识</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136422.png" alt="image-20220903135914927"></p><h5 id="A：工具栏"><a href="#A：工具栏" class="headerlink" title="A：工具栏"></a>A：工具栏</h5><h6 id="Auto-Run：自动运行"><a href="#Auto-Run：自动运行" class="headerlink" title="Auto Run：自动运行"></a>Auto Run：自动运行</h6><p>启用后，当你构建和运行应用程序时Android Logcat窗口会连接到应用程序，显示对应的相关信息</p><h6 id="No-device：设备选择器"><a href="#No-device：设备选择器" class="headerlink" title="No device：设备选择器"></a>No device：设备选择器</h6><p>当没有Android设备连接电脑是，显示No Device，有设备时可以在这选择连接的Android设备</p><h6 id="No-Filter：过滤选择器"><a href="#No-Filter：过滤选择器" class="headerlink" title="No Filter：过滤选择器"></a>No Filter：过滤选择器</h6><p>可以指定Android设备上显示消息的应用程序，此处显示的是应用程序的包名</p><h6 id="过滤输入框"><a href="#过滤输入框" class="headerlink" title="过滤输入框"></a>过滤输入框</h6><p>用于过滤搜索消息日志，可以输入内容搜索信息</p><p>消息正文过滤：在输入框输入内容，则会自动筛选消息中存在输入字符的内容</p><p>优先级过滤：在下方点击Priority优先级，选择过滤的内容</p><p>Verbose：冗长的，所有<br>Debug：调试信息<br>Info：信息<br>Warn：警告<br>Error：错误<br>Fatal：致命的</p><p>按标签过滤：在下方点击Tag标签，选择过滤的内容</p><h6 id="Filter-Options：过滤器选项"><a href="#Filter-Options：过滤器选项" class="headerlink" title="Filter Options：过滤器选项"></a>Filter Options：过滤器选项</h6><p>决定如何使用选项过滤器输入过滤消息日志中的消息<br>Use Regular Expressions：使用正则表达式<br>Match Case：区分大小写</p><h6 id="Reconnect：重新连接"><a href="#Reconnect：重新连接" class="headerlink" title="Reconnect：重新连接"></a>Reconnect：重新连接</h6><p>重新连接到应用程序和设备，如果程序不再运行则重新连接到设备</p><h6 id="Disconnect：断开和设备的连接"><a href="#Disconnect：断开和设备的连接" class="headerlink" title="Disconnect：断开和设备的连接"></a>Disconnect：断开和设备的连接</h6><h6 id="Clear：清除消息列表中的消息日志"><a href="#Clear：清除消息列表中的消息日志" class="headerlink" title="Clear：清除消息列表中的消息日志"></a>Clear：清除消息列表中的消息日志</h6><h6 id="Tools：工具相关"><a href="#Tools：工具相关" class="headerlink" title="Tools：工具相关"></a>Tools：工具相关</h6><p>Screen Capture：屏幕捕获<br>从连接的Android设备上捕捉屏幕截图和视频</p><p>Open Terminal：开放终端<br>在Windows上打开命令调试符窗口，在macOS和Linux上打开终端</p><p>Stacktrace Utility：堆栈跟踪应用程序<br>解析自定义堆栈跟踪</p><p>Memory Window：内存窗口<br>跟踪为应用程序分配的内存</p><h5 id="B：消息日志"><a href="#B：消息日志" class="headerlink" title="B：消息日志"></a>B：消息日志</h5><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136658.png" alt="image-20220903140638857"></p><h4 id="屏幕捕获工具"><a href="#屏幕捕获工具" class="headerlink" title="屏幕捕获工具"></a>屏幕捕获工具</h4><p>屏幕捕获工具主要可以帮助我们进行游戏内截图，录屏</p><p>该工具可以帮助我们：</p><p>1.测试人员用来录制bug表现，反馈给程序人员进行解决</p><p>2.获取截屏、录屏信息，获取宣传资料</p><p>优点：直接PC端远程获取，方便快捷，便于记录bug表现效果</p><p>缺点：录制的视频不会捕获声音，录屏功能可以部分设备不支持</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136696.png" alt="image-20220903141016807"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136092.png" alt="image-20220903141109817"></p><h4 id="堆栈跟踪实用工具"><a href="#堆栈跟踪实用工具" class="headerlink" title="堆栈跟踪实用工具"></a>堆栈跟踪实用工具</h4><p>目前我们使用Android Logcat连接真机进行测试时</p><p>打印、警告、报错等等信息都会直接在主窗口中打印出来让我们进行分析</p><p>相当于它帮助我们进行了自动的堆栈跟踪解析</p><p>什么是自动堆栈跟踪解析呢？</p><p>就是我们可以在打印窗口看到具体是哪个脚本的哪行代码</p><p>出现了打印、警告、报错等等信息</p><p>而Tools(工具)中的Stacktrace Utility(堆栈跟踪实用工具)的作用是</p><p>允许我们复制粘贴自定义日志并解析堆栈跟踪</p><p>主要用于没有真机连接设备调试时</p><p>或者之后正式发布版本后</p><p>我们可以获取应用程序日志信息</p><p>将这些日志信息复制到该工具中用于翻译</p><p>(一般项目会在崩溃后，在本地存储一份崩溃日志，我们可以获取该日志)</p><p>因为这种情况下的日志信息中，不会明确指明是哪个脚本哪行代码</p><p>往往是一堆看不懂的符号,我们可以使用该工具进行翻译</p><p>比如：下面这个打印信息就是安卓的原始日志</p><p>E CRASH   :      #01  pc 01c65330  /data/app/com.CrashComp.Crash-J2Z_L0XSsSAZPkt9lab2rQ==/lib/arm/libunity.so</p><p>(DiagnosticsUtils_Bindings::ForceCrash(DiagnosticsUtils_Bindings::ForcedCrashCategory, ScriptingExceptionPtr*)+48)</p><p>这里面都是一堆特殊符号，并没有明确告诉你哪个脚本哪行代码</p><p>通过翻译后堆栈跟踪实用工具翻译后，我们就能够获取到哪个脚本哪行代码打印了输出了该信息</p><p>总而言之它该工具就是用来翻译发布后安卓应用程序的日志信息的</p><h5 id="堆栈跟踪实用工具的使用"><a href="#堆栈跟踪实用工具的使用" class="headerlink" title="堆栈跟踪实用工具的使用"></a>堆栈跟踪实用工具的使用</h5><p>使用堆栈跟踪实用工具的作用是可以翻译自己获取到的安卓日志信息</p><p>使用流程是：</p><p>1.设置项目的 so 文件路径</p><p>2.将日志信息复制到Original（初始）页签中</p><p>3.点击Resolve Stacktraces(解析堆栈跟踪)</p><p>4.在Resolved(已解析的日志)页签中查看翻译结果</p><p>注意：我们在电脑连接安卓设备通过Android Logcat进行调试时一般不使用该功能，只有当非连接调试时，获取了安卓崩溃日志后才会使用该功能</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136417.png" alt="image-20220903141656842"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136849.png" alt="image-20220903141726069"></p><h4 id="内存窗口工具"><a href="#内存窗口工具" class="headerlink" title="内存窗口工具"></a>内存窗口工具</h4><p>首先了解 RAM（运行时内存）对于我们的意义</p><p>如果应用程序出现闪退情况，往往都是因为应用程序运行时内存的使用超出了设备允许的最大内存量，而被手机系统强行关闭</p><p>注意：</p><p>不同品牌、型号的手机配置都是不同的，手机后台运行的程序数量也是不同的，所以要根据实际情况进行测试获取目标设备的内存极限值，可以选取市面上的主流机型来进行测试</p><p><strong>内存窗口工具是用于跟踪应用程序RAM（运行时内存）的分配情况的</strong></p><p>我们可以使用它来分析应用程序可能存在的内存问题</p><p>我们可以使用它 定期自动的 或者 手动的 捕获内存快照</p><p>这里的内存快照就是捕获的这一瞬间应用程序的运行时内存使用情况</p><p>根据内存快照我们可以分析内存问题</p><p>比如：</p><ol><li><p>切换场景前和切换场景后的内存快照比较，判断是否存在内存泄露</p></li><li><p>比如闪退前的内存快照，来分析设备占用多少内存时造成了闪退，确定内存瓶颈</p></li></ol><p>等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136108.png" alt="image-20220903142133235"></p><p>Auto Capture：自动捕获<br>Unity会定期捕获应用程序的内存快照<br>注意：自动捕获，可能会影响性能表现，可能会造成卡顿，如果严重影响测试，建议使用手动捕获</p><p>Manual Capture：手动捕获<br>通过点击按钮，自己手动捕获内存快照</p><p>Disabled：不启用</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136948.png" alt="image-20220903142205592"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242136572.png" alt="image-20220903142318882"></p><h3 id="Android-Debug-Brige"><a href="#Android-Debug-Brige" class="headerlink" title="Android Debug Brige"></a>Android Debug Brige</h3><p>ADB是 Android Debug Brige（安卓调试桥）的简称</p><p>它是我们调试Android设备的一套指令集</p><p>它可以让我们通过指令来进行一些操作，来获取日志信息</p><p>比如：</p><p>1.关机、重启</p><p>2.安装、启动、卸载应用程序</p><p>3.删除、移动、复制文件</p><p>4.查看日志信息</p><p>我们最常使用的就是查看日志信息的功能</p><p>之前学习的Android Logcat工具其实就是利用了ADB来获取的信息</p><p>由于Android Logcat工具只能在Unity 2019.4及其以上版本才能使用</p><p>所以对于老版本的Unity来说，我们一般使用ADB来帮助我们进行调试</p><p>注意：</p><p>使用ADB工具的前提是 电脑和安卓设备处于USB调试连接</p><h4 id="如何使用ADB？"><a href="#如何使用ADB？" class="headerlink" title="如何使用ADB？"></a>如何使用ADB？</h4><p>在Android SDK的路径中</p><p>寻找platform-tools文件夹</p><p>在其中可以找到adb.exe文件</p><p>我们需要配合命令调试符窗口（Windows）使用adb指令集</p><p>方法一：</p><p>直接在Android Logcat窗口中使用Tools中的Open Terminal（打开终端）</p><p>Window系统会自动打开命令调试符窗口</p><p>MacOS系统会自动打开终端窗口</p><p>会直接来到SDK文件夹中的platform-tools（平台工具）文件夹</p><p>在后面直接输入指令即可</p><p>adb 指令</p><p>方法二：</p><p>自己打开命令调试符窗口</p><p>输入adb.exe所在文件夹路径</p><p>比如：</p><p>D:\Android\android-sdk\platform-tools\adb 指令</p><h4 id="关键指令"><a href="#关键指令" class="headerlink" title="关键指令"></a>关键指令</h4><p>常用指令</p><p>1.显示日志信息</p><p> adb logcat</p><p>2.获取Unity相关日志信息</p><p> adb logcat -s Unity</p><p>做了解的指令</p><p>1.查看abb相关信息，比如版本号、常用命令等</p><p> adb help</p><p>2.查看adb版本</p><p> adb version</p><p>3.安装apk</p><p> adb install apk路径</p><p>4.覆盖安装</p><p> adb install -r apk路径</p><p>5.卸载应用程序</p><p> adb uninstall 应用程序包名</p><p>6.保留数据卸载应用程序</p><p> adb uninstall -k 应用程序包名</p><p>7.查看连接的主机设备</p><p> adb devices</p><p>8.从电脑上复制文件到手机</p><p> adb push 电脑上文件路径 需要复制到的手机路径</p><p>9.从手机上复制文件到电脑</p><p> adb pull 手机上文件路径 需要复制到的电脑路径</p><p>10.查看手机上安装的所有应用程序包名</p><p> adb shell pm list packages</p><p>11.截图</p><p> adb shell screencap 保存到的手机路径</p><p>12.录屏</p><p> adb shell screenrecord 保存到的手机路径</p><p>等等</p><p>更多信息</p><p><a href="https://developer.android.com/studio/command-line/adb.html">https://developer.android.com/studio/command-line/adb.html</a></p><h3 id="Android-Studio中调试应用程序"><a href="#Android-Studio中调试应用程序" class="headerlink" title="Android Studio中调试应用程序"></a>Android Studio中调试应用程序</h3><h4 id="回顾Unity导出Android-Studio工程"><a href="#回顾Unity导出Android-Studio工程" class="headerlink" title="回顾Unity导出Android Studio工程"></a>回顾Unity导出Android Studio工程</h4><p>Build Settings中进行设置</p><p>1.勾选Export Project</p><p>2.勾选Development Build</p><p>3.导出到指定目录</p><p>4.使用Android Studio打开该工程</p><p>5.更新Gradle版本</p><p>6.删除 android.enableR8</p><p>7.保证构建成功</p><h4 id="在Android-Studio中调试应用程序"><a href="#在Android-Studio中调试应用程序" class="headerlink" title="在Android Studio中调试应用程序"></a>在Android Studio中调试应用程序</h4><p>1.保证Android设备和电脑进行USB调试连接</p><p>2.菜单栏的Run页签中进行调试（若上部分Run置灰，可以重启一次Android Studio）</p><p>3.在下方的Logcat日志窗口和Profiler性能分析器窗口调试应用程序，排查问题</p><p>更多关于Android Studio调试和性能分析内容</p><p>调试：<a href="https://developer.android.google.cn/studio/debug">https://developer.android.google.cn/studio/debug</a></p><p>性能分析：<a href="https://developer.android.google.cn/studio/profile">https://developer.android.google.cn/studio/profile</a></p><p>总结</p><p>Android Studio中调试应用程序和Unity中使用 Android Logcat + Unity Profiler窗口类似</p><p>一般情况下，没有特殊需求，我们都在Unity中进行Android应用程序调试</p><p>相对Android Studio中调试来说更适合我们Unity程序员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Android发布流程&quot;&gt;&lt;a href=&quot;#Android发布流程&quot; class=&quot;headerlink&quot; title=&quot;Android发布流程&quot;&gt;&lt;/a&gt;Android发布流程&lt;/h2&gt;&lt;h3 id=&quot;Unity2019及以上&quot;&gt;&lt;a href=&quot;#Unity</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="移动平台" scheme="https://liuyingbo.com/tags/%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/"/>
    
    <category term="Android" scheme="https://liuyingbo.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Unity-网络开发（三）</title>
    <link href="https://liuyingbo.com/posts/ba9e7782.html"/>
    <id>https://liuyingbo.com/posts/ba9e7782.html</id>
    <published>2022-08-14T22:13:47.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h1><h2 id="什么是大小端模式"><a href="#什么是大小端模式" class="headerlink" title="什么是大小端模式"></a>什么是大小端模式</h2><h3 id="大端模式"><a href="#大端模式" class="headerlink" title="大端模式"></a>大端模式</h3><p>是指数据的高字节保存在内存的低地址中</p><p>而数据的低字节保存在内存的高地址中</p><p>这样的存储模式有点儿类似于把数据当作字符串顺序处理</p><p>地址由小向大增加，数据从高位往低位放</p><p>符合人类的阅读习惯</p><h3 id="小端模式"><a href="#小端模式" class="headerlink" title="小端模式"></a>小端模式</h3><p>是指数据的高字节保存在内存的高地址中</p><p>而数据的低字节保存在内存的低地址中</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>十六进制数据0x11223344</p><h3 id="大端模式存储"><a href="#大端模式存储" class="headerlink" title="大端模式存储"></a>大端模式存储</h3><p>11    22    33    44</p><p>0     1     2     3</p><p>低地址——&gt;高地址</p><h3 id="小端模式存储"><a href="#小端模式存储" class="headerlink" title="小端模式存储"></a>小端模式存储</h3><p>44    33    22    11</p><p>0     1     2     3</p><p>低地址——&gt;高地址</p><h2 id="为什么有大小端模式"><a href="#为什么有大小端模式" class="headerlink" title="为什么有大小端模式"></a>为什么有大小端模式</h2><p>大小端模式其实是计算机硬件的两种存储数据的方式</p><p>我们也可以称大小端模式为 大小端字节序</p><p>对于我们来说，大端字节序阅读起来更加方便，为什么还要有小端字节序呢？</p><p>原因是，计算机电路先处理低位字节，效率比较高</p><p>计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节</p><p>它只知道按顺序读取字节，先读第一个字节，再读第二个字节</p><p>如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节</p><p>小端字节序正好相反</p><p>因为计算机都是从低位开始的</p><p>所以，计算机的内部处理都是小端字节序</p><p>但是，我们人类的读写习惯还是大端字节序</p><p>所以，除了计算机的内部处理</p><p>其它场合几乎都是大端字节序，比如网络传输和文件存储</p><p>一般情况下，操作系统都是小端模式，而通讯协议都是大端模式</p><p>但是具体的模式，还是要根据硬件平台，开发语言来决定</p><p>主机不同，开发语言不同 可能采用的大小端模式也会不一致</p><h2 id="大小端模式对于我们的影响"><a href="#大小端模式对于我们的影响" class="headerlink" title="大小端模式对于我们的影响"></a>大小端模式对于我们的影响</h2><p>只有读取的时候，才必须区分大小端字节序，其它情况都不用考虑</p><p>因此对于我们来说，在网络传输当中我们传输的是字节数组</p><p>那么我们在收到字节数组进行解析时，就需要考虑大小端的问题</p><p>虽然TCP/IP协议规定了在网络上必须采用网络字节顺序（大端模式）</p><p>但是具体传输时采用哪种模式，都是根据前后端语言、设备决定的</p><p>在进行网络通讯时，前后端语言不同时，可能会造成大小端不统一</p><p>一般情况下</p><p>C# 和 Java/Erlang/AS3 通讯需要进行大小端转换 因为C#是小端模式 Java/Erlang/AS3是大端模式</p><p>C# 与 C++通信不需要特殊处理 他们都是小端模式</p><h2 id="大小端转换"><a href="#大小端转换" class="headerlink" title="大小端转换"></a>大小端转换</h2><h3 id="判断是大小端哪种模式"><a href="#判断是大小端哪种模式" class="headerlink" title="判断是大小端哪种模式"></a>判断是大小端哪种模式</h3><p> print(“是否是小端模式:” + BitConverter.IsLittleEndian);</p><h3 id="简单的转换API-只支持几种类型"><a href="#简单的转换API-只支持几种类型" class="headerlink" title="简单的转换API 只支持几种类型"></a>简单的转换API 只支持几种类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换为网络字节序 相当于就是转为大端模式</span></span><br><span class="line"><span class="comment">//1. 本机字节序转网络字节序</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">99</span>;</span><br><span class="line">byte[] bytes = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(i));</span><br><span class="line"><span class="comment">//2. 网络字节序转本机字节序</span></span><br><span class="line"><span class="type">int</span> receI = BitConverter.ToInt32(bytes, <span class="number">0</span>);</span><br><span class="line">receI = IPAddress.NetworkToHostOrder(receI);</span><br></pre></td></tr></table></figure><h3 id="通用的转换方式"><a href="#通用的转换方式" class="headerlink" title="通用的转换方式"></a>通用的转换方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中的倒序API</span></span><br><span class="line"><span class="comment">//如果后端需要用到大端模式 那么我们进行判断</span></span><br><span class="line"><span class="comment">//如果当前是小端模式 就进行一次 大小端转换</span></span><br><span class="line"><span class="keyword">if</span>(BitConverter.IsLittleEndian) Array.Reverse(bytes);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大小端模式会根据主机硬件环境不同、语言不同而有所区别</p><p>当我们前后端是不同语言开发且运行在不同主机上时</p><p>前后端需要对大小端字节序定下统一的规则</p><p>一般让前端迎合后端，因为字节序的转换也是会带来些许性能损耗的</p><p>网络游戏中要尽量减轻后端的负担</p><p>一般情况下</p><p>C# 和 Java/Erlang/AS3 通讯需要进行大小端转换 前端C#从小变大</p><p>C# 与 C++通信不需要特殊处理</p><p>我们不用死记硬背和谁通讯要注意大小端模式</p><p>当开发时，发现后端收到的消息和前端发的不一样</p><p>在协议统一的情况下，往往就是因为大小端造成的</p><p>这时我们再转换模式即可</p><p>注意：</p><p>Protobuf已经帮助我们解决了大小端问题</p><p>即使前后端语言不统一</p><p>使用它也不用过多考虑字节序转换的问题</p><h1 id="消息加密解密"><a href="#消息加密解密" class="headerlink" title="消息加密解密"></a>消息加密解密</h1><h2 id="什么是消息加密解密"><a href="#什么是消息加密解密" class="headerlink" title="什么是消息加密解密"></a>什么是消息加密解密</h2><p>我们在网路传输时，会把数据转换为字节数组以2进制的形式进行传输</p><p>理论上来说，如果有人截取篡改了消息，或者从前端发假消息给后端</p><p>就可能产生作弊行为</p><p>消息的加密解密 可以有效避免作弊行为的产生</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>采用一些方式对数据进行处理后，使数据从表面上看，已经不能表达出原有的意思</p><p>别人就算获取到了你的信息，也无法知道你的内容的含义和规则</p><p>这样可以让我们的数据更加的安全，降低被篡改的可能性</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>通过对加密过的数据采用某些方法，去还原原有数据，从而获取目标数据</p><p>其实就是在</p><p>发消息时，对我们的消息2进制数据进行加密（一般只对消息体加密）</p><p>收到消息时，对2进制数据进行解密（一般只对消息体解密）</p><h2 id="加密是否是100-安全？"><a href="#加密是否是100-安全？" class="headerlink" title="加密是否是100%安全？"></a>加密是否是100%安全？</h2><p>一定记住加密只是提高破解门槛，没有100%保密的数据</p><p>通过各种尝试始终是可以破解加密规则的，只是时间问题</p><p>加密只能提升一定的安全性</p><p>对于大多数情况下已经够用了，除非专门有人针对你们的产品进行破解</p><p>但是遇到这种情况 也证明你的产品已经足够成功了</p><h2 id="加密解密的相关名词解释"><a href="#加密解密的相关名词解释" class="headerlink" title="加密解密的相关名词解释"></a>加密解密的相关名词解释</h2><p>明文：待加密的报文（内容）</p><p>密文：加密后的报文（内容）</p><p>密钥：加密过程中或解密过程中输入的数据</p><p>算法：将明文和密钥相结合进行处理，生成密文的方法，叫加密算法。将密文和密钥相结合进行处理，生成明文的方法，叫解密算法</p><h2 id="了解加密算法分类"><a href="#了解加密算法分类" class="headerlink" title="了解加密算法分类"></a>了解加密算法分类</h2><h3 id="1-单向加密"><a href="#1-单向加密" class="headerlink" title="1.单向加密"></a>1.单向加密</h3><p>​    将数据进行计算变成另一种固定长度的值，这种加密是不可逆的</p><p>​    常用算法</p><p>​    MD5、SHA1、SHA256等</p><p>​    用途：这种加密在网络传输中不会使用，主要用到其它功能当中，比如密码的单向加密</p><h3 id="2-对称加密技术"><a href="#2-对称加密技术" class="headerlink" title="2.对称加密技术"></a>2.对称加密技术</h3><p>​    使用同一个密钥，对数据镜像加密和解密（用密钥对明文加密，用密钥对密文解密）</p><p>​    常用算法</p><p>​    DES、3DES、IDEA、AES等</p><p>​    优点：计算量小，加密速度快、效率高</p><p>​    缺点：如果知道了密钥和算法，就可以进行解密</p><p>​    用途：网路通讯中可以使用对称加密技术，这个密钥可以是由后端下发的，每次建立通讯后都会变化的</p><h3 id="3-非对称加密技术"><a href="#3-非对称加密技术" class="headerlink" title="3.非对称加密技术"></a>3.非对称加密技术</h3><p>​    在加密过程中，需要一对密钥，不公开的密钥称为私钥，公开的那一个密钥称为公钥</p><p>​    也可以称为公开密钥加密</p><p>​    从一对密钥中的任何一个密钥都不能计算出另一个密钥</p><p>​    使用一对密钥中的任何一个加密，只有另一个密钥才能解密。如果截获公钥加密数据，没有私钥也无法解密</p><p>​    常用算法</p><p>​    RSA、DSA等</p><p>​    优点：安全性高，即使获取到了公钥，没有私钥也无法进行解密</p><p>​    缺点：算法复杂，加密速度较慢</p><p>​    用途：对安全性要求较高的场景，并且可以接受较慢的加密速度的需求可以使用非对称加密技术</p><p>​        以后在对接一些支付SDK时经常会看到平台提供的就是非对称加密技术</p><p>关于这些加密算法</p><p>有很多的别人写好的第三发加密算法库</p><p>可以直接获取用于在程序中对数据进行加密</p><p>也可以自己基于加密算法原理来设计自己的规则</p><h2 id="用简单的异或加密感受加密的作用"><a href="#用简单的异或加密感受加密的作用" class="headerlink" title="用简单的异或加密感受加密的作用"></a>用简单的异或加密感受加密的作用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异或加密特点</span></span><br><span class="line"><span class="comment">//密钥为一个整数</span></span><br><span class="line"><span class="comment">//明文 异或 密钥 得到 密文</span></span><br><span class="line"><span class="comment">//密文 异或 密钥 得到 明文</span></span><br><span class="line"></span><br><span class="line">TestMsg msg = new TestMsg();</span><br><span class="line">msg.ListInt.Add(<span class="number">1</span>);</span><br><span class="line">msg.TestBool = <span class="literal">false</span>;</span><br><span class="line">msg.TestD = <span class="number">5.5</span>;</span><br><span class="line">msg.TestInt32 = <span class="number">99</span>;</span><br><span class="line">msg.TestMap.Add(<span class="number">1</span>, <span class="string">&quot;刘英博&quot;</span>);</span><br><span class="line">msg.TestMsg2 = new TestMsg2();</span><br><span class="line">msg.TestMsg2.TestInt32 = <span class="number">88</span>;</span><br><span class="line">msg.TestMsg3 = new TestMsg.Types.TestMsg3();</span><br><span class="line">msg.TestMsg3.TestInt32 = <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">msg.TestHeart = new GameSystemTest.HeartMsg();</span><br><span class="line">msg.TestHeart.Time = <span class="number">7777</span>;</span><br><span class="line"></span><br><span class="line">byte[] bytes = NetTool.GetProtoBytes(msg);</span><br><span class="line"><span class="comment">//异或加密算法</span></span><br><span class="line"><span class="comment">//密钥声明</span></span><br><span class="line">byte s = <span class="number">55</span>;</span><br><span class="line"><span class="comment">//异或加密</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++)</span><br><span class="line">    bytes[i] ^= s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异或解密</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++)</span><br><span class="line">    bytes[i] ^= s;</span><br><span class="line"></span><br><span class="line">TestMsg msg2 = NetTool.GetProtoMsg&lt;TestMsg&gt;(bytes);</span><br><span class="line">print(msg2.TestMsg3.TestInt32);</span><br></pre></td></tr></table></figure><h1 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h1><h2 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h2><p>Protobuf全称是 protocol-buffers（协议缓冲区）</p><p>是谷歌提供给开发者的一个开源的协议生成工具</p><p>它的主要工作原理和我们之前做的自定义协议工具类似</p><p>只不过它更加的完善，可以基于协议配置文件生成</p><p>C++、Java、C#、Objective-C、PHP、Python、Ruby、Go</p><p>等等语言的代码文件</p><p>它是商业游戏开发中常常会选择的协议生成工具</p><p>有很多游戏公司选择它作为协议工具来进行网络游戏开发</p><p>因为它通用性强，稳定性高，可以节约出开发自定义协议工具的时间</p><p>protocol-buffers官网</p><p><a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p><h2 id="Protobuf的使用流程"><a href="#Protobuf的使用流程" class="headerlink" title="Protobuf的使用流程"></a>Protobuf的使用流程</h2><p>在官网中前往下载地址</p><p> protocol-buffers官网</p><p> <a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p><p>下载protobuf-csharp然后有两种方式选择</p><h3 id="在unity中使用源码"><a href="#在unity中使用源码" class="headerlink" title="在unity中使用源码"></a>在unity中使用源码</h3><p>解压后打开csharp\src将Google.Protobuf这个文件夹直接放入到unity中</p><h3 id="在unity中使用Google-Protobuf-dll"><a href="#在unity中使用Google-Protobuf-dll" class="headerlink" title="在unity中使用Google.Protobuf.dll"></a>在unity中使用Google.Protobuf.dll</h3><p>解压后打开csharp\src中的Google.Protobuf.sln</p><p>选择Google.Protobuf右键生成 dll文件</p><p>在csharp\src\Google.Protobuf\bin\Debug路径下找到对应.net版本的Dll文件（我们使用4.5即可）</p><p>将net45中的dll文件导入到Unity工程中的Plugins插件文件夹中</p><h2 id="proto文件"><a href="#proto文件" class="headerlink" title=".proto文件"></a>.proto文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// C#中的namespace</span></span><br><span class="line">package ProtoTest</span><br><span class="line"> </span><br><span class="line">option optimize_for = SPEED;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// java文件路径</span></span><br><span class="line">option java_package = <span class="string">&quot;com.montior.proto&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// java文件名称</span></span><br><span class="line">option java_outer_classname = <span class="string">&quot;MonitorData&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 消息结果。</span></span><br><span class="line">message MsgResult &#123;</span><br><span class="line">    <span class="comment">// 结果码。</span></span><br><span class="line">    int32 code = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 错误消息。</span></span><br><span class="line">    <span class="built_in">string</span> err_msg = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 接收包</span></span><br><span class="line">message TaskProtocol &#123;</span><br><span class="line">    <span class="comment">// 数据类型</span></span><br><span class="line">    int32 packType = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 具体数据</span></span><br><span class="line">    bytes content = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 包的类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PackType</span> &#123;</span></span><br><span class="line">    LOGIN = <span class="number">0</span>;</span><br><span class="line">    CREATE_TASK = <span class="number">2</span>;</span><br><span class="line">    DELETE_TASK = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">message LoginPack&#123;</span><br><span class="line">    <span class="built_in">string</span> username = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">message LoginPack2&#123;</span><br><span class="line">    <span class="built_in">string</span> username = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">message CreateTaskPack&#123;</span><br><span class="line">    <span class="built_in">string</span> taskId = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> taskName = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.message：消息类型，类似于一个类</p><p>2.package：包名，CSharp中的命名空间，用来防止不同消息类型的冲突</p><p>3.enum：枚举，这个需要我说吗？</p><p>4.option：选项，说明下我这边用到的<br>option java_package = “com.example.foo”;// java文件路径<br>option java_outer_classname = “Ponycopter”;// java文件名称<br>option optimize_for = SPEED;//可以被设置为 SPEED, CODE_SIZE,or LITE_RUNTIME。这些值将通过如下的方式影响C++及java代码的生成：</p><p>注：以上选项，CSharp都用不着的，就是写着玩儿….</p><p>5.数据类型</p><div class="table-container"><table><thead><tr><th>protobuf 数据类型</th><th>描述</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td></tr><tr><td>double</td><td>64位浮点数</td></tr><tr><td>float</td><td>32为浮点数</td></tr><tr><td>int32</td><td>32位整数</td></tr><tr><td>uin32</td><td>无符号32位整数</td></tr><tr><td>int64</td><td>64位整数</td></tr><tr><td>uint64</td><td>64为无符号整</td></tr><tr><td>sint32</td><td>32位整数，处理负数效率更高</td></tr><tr><td>sing64</td><td>64位整数 处理负数效率更高</td></tr><tr><td>fixed32</td><td>32位无符号整数</td></tr><tr><td>fixed64</td><td>64位无符号整数</td></tr><tr><td>sfixed32</td><td>32位整数、能以更高的效率处理负数</td></tr><tr><td>sfixed64</td><td>64为整数</td></tr><tr><td>string</td><td>只能处理 ASCII字符</td></tr><tr><td>bytes</td><td>用于处理多字节的语言字符、如中文</td></tr></tbody></table></div><p>6.关键字</p><div class="table-container"><table><thead><tr><th>指定字段</th><th>说明</th></tr></thead><tbody><tr><td>required</td><td>表示是一个必须字段，必须相对于发送方，在发送消息之前必须设置该字段的值，对于接收方，必须能够识别该字段的意思。发送之前没有设置required字段或者无法识别required字段都会引发编解码异常，导致消息被丢弃。</td></tr><tr><td>optional</td><td>表示是一个可选字段，可选对于发送方，在发送消息时，可以有选择性的设置或者不设置该字段的值。对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段，消息中的其它字段正常处理。—-因为optional字段的特性，很多接口在升级版本中都把后来添加的字段都统一的设置为optional字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡。</td></tr><tr><td>repeated</td><td>表示该字段可以包含0~N个元素。其特性和optional一样，但是每一次可以包含多个值。可以看作是在传递一个数组的值。</td></tr></tbody></table></div><h2 id="Protoc"><a href="#Protoc" class="headerlink" title="Protoc"></a>Protoc</h2><p>在官网中前往下载地址</p><p> protocol-buffers官网</p><p> <a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p><p>写好 proto 文件之后用 protoc 编译器将 .proto文件编译成目标语言。</p><h3 id="Unity中protoc使用"><a href="#Unity中protoc使用" class="headerlink" title="Unity中protoc使用"></a>Unity中protoc使用</h3><p>下载Protobuf-Unity插件放入Unity工程<br><code>Protobuf-Unity下载链接</code>：<a href="https://github.com/5argon/protobuf-unity">https://github.com/5argon/protobuf-unity</a></p><p>Unity工程打开<code>Editor/Preferences/Protobuf</code>并将下载的Protoc路径填入Path to protoc中<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242132910.png" alt="在这里插入图片描述">这个插件可以遍历Unity工程目录下的所有proto文件，并生成对应的c#文件。</p><h1 id="网络管理框架"><a href="#网络管理框架" class="headerlink" title="网络管理框架"></a>网络管理框架</h1><p>一个小Demo主要是为了理解网络框架的大概流程，都是基础的C#</p><p><a href="https://github.com/liuyingbor/NetDemo">https://github.com/liuyingbor/NetDemo</a></p><p>如果想深入了解网络框架Unity商城的BestHTTP强烈推荐。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大小端模式&quot;&gt;&lt;a href=&quot;#大小端模式&quot; class=&quot;headerlink&quot; title=&quot;大小端模式&quot;&gt;&lt;/a&gt;大小端模式&lt;/h1&gt;&lt;h2 id=&quot;什么是大小端模式&quot;&gt;&lt;a href=&quot;#什么是大小端模式&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="网络" scheme="https://liuyingbo.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Unity-UniTask</title>
    <link href="https://liuyingbo.com/posts/34c3e4a1.html"/>
    <id>https://liuyingbo.com/posts/34c3e4a1.html</id>
    <published>2022-08-14T21:24:49.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UniTask"><a href="#UniTask" class="headerlink" title="UniTask"></a>UniTask</h1><p>为Unity提供一个高性能，0GC的async/await异步方案。</p><ul><li>基于值类型的<code>UniTask&lt;T&gt;</code>和自定义的 AsyncMethodBuilder 来实现0GC</li><li>使所有 Unity 的 AsyncOperations 和 Coroutines 可等待</li><li>基于 PlayerLoop 的任务( <code>UniTask.Yield</code>, <code>UniTask.Delay</code>, <code>UniTask.DelayFrame</code>, etc…) 可以替换所有协程操作</li><li>对MonoBehaviour 消息事件和 uGUI 事件进行 可等待/异步枚举 拓展</li><li>完全在 Unity 的 PlayerLoop 上运行，因此不使用Thread，并且同样能在 WebGL、wasm 等平台上运行。</li><li>带有 Channel 和 AsyncReactiveProperty的异步 LINQ，</li><li>提供一个 TaskTracker EditorWindow 以追踪所有UniTask分配来预防内存泄漏</li><li>与原生 Task/ValueTask/IValueTaskSource 高度兼容的行为</li></ul><p>有关技术细节，请参阅博客文章：<a href="https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd">UniTask v2 — Unity 的0GC async/await 以及 异步LINQ 的使用</a><br>有关高级技巧，请参阅博客文章：<a href="https://medium.com/@neuecc/extends-unitywebrequest-via-async-decorator-pattern-advanced-techniques-of-unitask-ceff9c5ee846">通过异步装饰器模式扩展 UnityWebRequest — UniTask 的高级技术</a></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>通过<a href="https://github.com/Cysharp/UniTask/releases">UniTask/releases</a>页面中提供的<a href="https://github.com/wqaetly/UniTask#upm-package">UPM 包</a>或资产包 ( <code>UniTask.*.*.*.unitypackage</code>)安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 使用UniTask所需的命名空间</span><br><span class="line">using Cysharp.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">// 你可以返回一个形如 UniTask&lt;T&gt;(或 UniTask) 的类型，这种类型事为Unity定制的，作为替代原生Task&lt;T&gt;的轻量级方案</span><br><span class="line">// 为Unity集成的 0GC，快速调用，0消耗的 async/await 方案</span><br><span class="line">async UniTask&lt;string&gt; DemoAsync()</span><br><span class="line">&#123;</span><br><span class="line">    // 你可以等待一个Unity异步对象</span><br><span class="line">    var asset = await Resources.LoadAsync&lt;TextAsset&gt;(&quot;foo&quot;);</span><br><span class="line">    var txt = (await UnityWebRequest.Get(&quot;https://...&quot;).SendWebRequest()).downloadHandler.text;</span><br><span class="line">    await SceneManager.LoadSceneAsync(&quot;scene2&quot;);</span><br><span class="line"></span><br><span class="line">    // .WithCancellation 会启用取消功能，GetCancellationTokenOnDestroy 表示获取一个依赖对象生命周期的Cancel句柄，当对象被销毁时，将会调用这个Cancel句柄，从而实现取消的功能</span><br><span class="line">    var asset2 = await Resources.LoadAsync&lt;TextAsset&gt;(&quot;bar&quot;).WithCancellation(this.GetCancellationTokenOnDestroy());</span><br><span class="line"></span><br><span class="line">    // .ToUniTask 可接收一个 progress 回调以及一些配置参数，Progress.Create是IProgress&lt;T&gt;的轻量级替代方案</span><br><span class="line">    var asset3 = await Resources.LoadAsync&lt;TextAsset&gt;(&quot;baz&quot;).ToUniTask(Progress.Create&lt;float&gt;(x =&gt; Debug.Log(x)));</span><br><span class="line"></span><br><span class="line">    // 等待一个基于帧的延时操作（就像一个协程一样）</span><br><span class="line">    await UniTask.DelayFrame(100); </span><br><span class="line"></span><br><span class="line">    // yield return new WaitForSeconds/WaitForSecondsRealtime 的替代方案</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(10), ignoreTimeScale: false);</span><br><span class="line">    </span><br><span class="line">    // 可以等待任何 playerloop 的生命周期(PreUpdate, Update, LateUpdate, 等...)</span><br><span class="line">    await UniTask.Yield(PlayerLoopTiming.PreLateUpdate);</span><br><span class="line"></span><br><span class="line">    // yield return null 替代方案</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">    await UniTask.NextFrame();</span><br><span class="line"></span><br><span class="line">    // WaitForEndOfFrame 替代方案 (需要 MonoBehaviour(CoroutineRunner))</span><br><span class="line">    await UniTask.WaitForEndOfFrame(this); // this 是一个 MonoBehaviour</span><br><span class="line"></span><br><span class="line">    // yield return new WaitForFixedUpdate 替代方案，(和 UniTask.Yield(PlayerLoopTiming.FixedUpdate) 效果一样)</span><br><span class="line">    await UniTask.WaitForFixedUpdate();</span><br><span class="line">    </span><br><span class="line">    // yield return WaitUntil 替代方案</span><br><span class="line">    await UniTask.WaitUntil(() =&gt; isActive == false);</span><br><span class="line"></span><br><span class="line">    // WaitUntil拓展，指定某个值改变时触发</span><br><span class="line">    await UniTask.WaitUntilValueChanged(this, x =&gt; x.isActive);</span><br><span class="line"></span><br><span class="line">    // 你可以直接 await 一个 IEnumerator 协程</span><br><span class="line">    await FooCoroutineEnumerator();</span><br><span class="line"></span><br><span class="line">    // 你可以直接 await 一个原生 task</span><br><span class="line">    await Task.Run(() =&gt; 100);</span><br><span class="line"></span><br><span class="line">    // 多线程示例，在此行代码后的内容都运行在一个线程池上</span><br><span class="line">    await UniTask.SwitchToThreadPool();</span><br><span class="line"></span><br><span class="line">    /* 工作在线程池上的代码 */</span><br><span class="line"></span><br><span class="line">    // 转回主线程</span><br><span class="line">    await UniTask.SwitchToMainThread();</span><br><span class="line"></span><br><span class="line">    // 获取异步的 webrequest</span><br><span class="line">    async UniTask&lt;string&gt; GetTextAsync(UnityWebRequest req)</span><br><span class="line">    &#123;</span><br><span class="line">        var op = await req.SendWebRequest();</span><br><span class="line">        return op.downloadHandler.text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var task1 = GetTextAsync(UnityWebRequest.Get(&quot;http://google.com&quot;));</span><br><span class="line">    var task2 = GetTextAsync(UnityWebRequest.Get(&quot;http://bing.com&quot;));</span><br><span class="line">    var task3 = GetTextAsync(UnityWebRequest.Get(&quot;http://yahoo.com&quot;));</span><br><span class="line"></span><br><span class="line">    // 构造一个async-wait，并通过元组语义轻松获取所有结果</span><br><span class="line">    var (google, bing, yahoo) = await UniTask.WhenAll(task1, task2, task3);</span><br><span class="line"></span><br><span class="line">    // WhenAll简写形式</span><br><span class="line">    var (google2, bing2, yahoo2) = await (task1, task2, task3);</span><br><span class="line"></span><br><span class="line">    // 返回一个异步值，或者你也可以使用`UniTask`(无结果), `UniTaskVoid`(协程，不可等待)</span><br><span class="line">    return (asset as TextAsset)?.text ?? throw new InvalidOperationException(&quot;Asset not found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UniTask-和-AsyncOperation-基础知识"><a href="#UniTask-和-AsyncOperation-基础知识" class="headerlink" title="UniTask 和 AsyncOperation 基础知识"></a>UniTask 和 AsyncOperation 基础知识</h2><p>UniTask 功能依赖于 C# 7.0( <a href="https://github.com/dotnet/roslyn/blob/master/docs/features/task-types.md">task-like custom async method builder feature</a> ) 所以需要的 Unity 最低版本是<code>Unity 2018.3</code> ，官方支持的最低版本是<code>Unity 2018.4.13f1</code>.</p><p>为什么需要 UniTask（自定义task对象）？因为原生 Task 太重，与 Unity 线程（单线程）相性不好。UniTask 不使用线程和 SynchronizationContext/ExecutionContext，因为 Unity 的异步对象由 Unity 的引擎层自动调度。它实现了更快和更低的分配，并且与Unity完全兼容。</p><p>你可以在使用 <code>using Cysharp.Threading.Tasks;</code>时对 <code>AsyncOperation</code>， <code>ResourceRequest</code>，<code>AssetBundleRequest</code>， <code>AssetBundleCreateRequest</code>， <code>UnityWebRequestAsyncOperation</code>， <code>AsyncGPUReadbackRequest</code>， <code>IEnumerator</code>以及其他的异步操作进行 await</p><p>UniTask 提供了三种模式的扩展方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">* await asyncOperation;</span><br><span class="line">* .WithCancellation(CancellationToken);</span><br><span class="line">* .ToUniTask(IProgress, PlayerLoopTiming, CancellationToken);</span><br></pre></td></tr></table></figure><p><code>WithCancellation</code>是<code>ToUniTask</code>的简化版本，两者都返回<code>UniTask</code>。有关cancellation的详细信息，请参阅：<a href="https://github.com/wqaetly/UniTask#cancellation-and-exception-handling">取消和异常处理</a>部分。</p><blockquote><p>注意：await 会在 PlayerLoop 执行await对象的相应native生命周期方法时返回（如果条件满足的话），而 WithCancellation 和 ToUniTask 是从指定的 PlayerLoop 生命周期执行时返回。有关 PlayLoop生命周期 的详细信息，请参阅：<a href="https://github.com/wqaetly/UniTask#playerloop">PlayerLoop</a>部分。</p><p>注意： AssetBundleRequest 有<code>asset</code>和<code>allAssets</code>，默认 await 返回<code>asset</code>。如果你想得到<code>allAssets</code>，你可以使用<code>AwaitForAllAssets()</code>方法。</p></blockquote><p><code>UniTask</code>可以使用<code>UniTask.WhenAll</code>和<code>UniTask.WhenAny</code>等实用函数。它们就像<code>Task.WhenAll</code>/<code>Task.WhenAny</code>。但它们会返回内容，这很有用。它们会返回值元组，因此您可以传递多种类型并解构每个结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTaskVoid LoadManyAsync()</span><br><span class="line">&#123;</span><br><span class="line">    // 并行加载.</span><br><span class="line">    var (a, b, c) = await UniTask.WhenAll(</span><br><span class="line">        LoadAsSprite(&quot;foo&quot;),</span><br><span class="line">        LoadAsSprite(&quot;bar&quot;),</span><br><span class="line">        LoadAsSprite(&quot;baz&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async UniTask&lt;Sprite&gt; LoadAsSprite(string path)</span><br><span class="line">&#123;</span><br><span class="line">    var resource = await Resources.LoadAsync&lt;Sprite&gt;(path);</span><br><span class="line">    return (resource as Sprite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想转换一个回调逻辑块，让它变成UniTask的话，可以使用 <code>UniTaskCompletionSource&lt;T&gt;</code> （<code>TaskCompletionSource&lt;T&gt;</code>的轻量级魔改版）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public UniTask&lt;int&gt; WrapByUniTaskCompletionSource()</span><br><span class="line">&#123;</span><br><span class="line">    var utcs = new UniTaskCompletionSource&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">    // 当操作完成时，调用 utcs.TrySetResult();</span><br><span class="line">    // 当操作失败时, 调用 utcs.TrySetException();</span><br><span class="line">    // 当操作取消时, 调用 utcs.TrySetCanceled();</span><br><span class="line"></span><br><span class="line">    return utcs.Task; //本质上就是返回了一个UniTask&lt;int&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以进行如下转换</p><ul><li><code>Task</code> -&gt; <code>UniTask</code>: 使用<code>AsUniTask</code></li><li><code>UniTask</code> -&gt; <code>UniTask&lt;AsyncUnit&gt;</code>: 使用 <code>AsAsyncUnitUniTask</code></li><li><code>UniTask&lt;T&gt;</code> -&gt; <code>UniTask</code>: 使用 <code>AsUniTask</code>，这两者的转换是无消耗的</li></ul><p>如果你想将异步转换为协程，你可以使用<code>.ToCoroutine()</code>，如果你只想允许使用协程系统，这很有用。</p><p>UniTask 不能await两次。<a href="http://xn--jhq010dhp3a.net/">这是与.NET</a> Standard 2.1 中引入的<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask-1?view=netcore-3.1">ValueTask/IValueTaskSource</a>相同的约束。</p><blockquote><p>永远不应在 ValueTask 实例上执行以下操作：</p><ul><li>多次await实例。</li><li>多次调用 AsTask。</li><li>在操作尚未完成时调用 .Result 或 .GetAwaiter().GetResult()，多次调用也是不允许的。</li><li>混用上述行为更是不被允许的。</li></ul><p>如果您执行上述任何操作，则结果是未定义。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var task = UniTask.DelayFrame(10);</span><br><span class="line">await task;</span><br><span class="line">await task; // 寄了, 抛出异常</span><br></pre></td></tr></table></figure><p>如果实在需要多次await一个异步操作，可以使用<code>UniTask.Lazy</code>来支持多次调用。<code>.Preserve()</code>同样允许多次调用（由UniTask内部缓存的结果）。这种方法在函数范围内有多个调用时很有用。</p><p>同样的<code>UniTaskCompletionSource</code>可以在同一个地方被await多次，或者在很多不同的地方被await。</p><h2 id="Cancellation-and-Exception-handling"><a href="#Cancellation-and-Exception-handling" class="headerlink" title="Cancellation and Exception handling"></a>Cancellation and Exception handling</h2><p>一些 UniTask 工厂方法有一个<code>CancellationToken cancellationToken = default</code>参数。Unity 的一些异步操作也有<code>WithCancellation(CancellationToken)</code>和<code>ToUniTask(..., CancellationToken cancellation = default)</code>拓展方法。</p><p>可以传递原生<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource"><code>CancellationTokenSource</code></a>给参数CancellationToken</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var cts = new CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">cancelButton.onClick.AddListener(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    cts.Cancel();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">await UnityWebRequest.Get(&quot;http://google.co.jp&quot;).SendWebRequest().WithCancellation(cts.Token);</span><br><span class="line"></span><br><span class="line">await UniTask.DelayFrame(1000, cancellationToken: cts.Token);</span><br></pre></td></tr></table></figure><p>CancellationToken 可以由<code>CancellationTokenSource</code>或 MonoBehaviour 的<code>GetCancellationTokenOnDestroy</code>扩展方法创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 这个CancellationTokenSource和this GameObject生命周期相同，当this GameObject Destroy的时候，就会执行Cancel</span><br><span class="line">await UniTask.DelayFrame(1000, cancellationToken: this.GetCancellationTokenOnDestroy());</span><br></pre></td></tr></table></figure><p>对于链式取消，所有异步方法都建议最后一个参数接受<code>CancellationToken cancellationToken</code>，并将<code>CancellationToken</code>从头传递到尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">await FooAsync(this.GetCancellationTokenOnDestroy());</span><br><span class="line"></span><br><span class="line">// ---</span><br><span class="line"></span><br><span class="line">async UniTask FooAsync(CancellationToken cancellationToken)</span><br><span class="line">&#123;</span><br><span class="line">    await BarAsync(cancellationToken);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async UniTask BarAsync(CancellationToken cancellationToken)</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(3), cancellationToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CancellationToken</code>表示异步的生命周期。您可以使用自定义的生命周期，而不是默认的 CancellationTokenOnDestroy。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class MyBehaviour : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource disableCancellation = new CancellationTokenSource();</span><br><span class="line">    CancellationTokenSource destroyCancellation = new CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    private void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        if (disableCancellation != null)</span><br><span class="line">        &#123;</span><br><span class="line">            disableCancellation.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        disableCancellation = new CancellationTokenSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnDisable()</span><br><span class="line">    &#123;</span><br><span class="line">        disableCancellation.Cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">        destroyCancellation.Cancel();</span><br><span class="line">        destroyCancellation.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当检测到取消时，所有方法都会向上游抛出并传播<code>OperationCanceledException</code>。当异常（不限于<code>OperationCanceledException</code>）没有在异步方法中处理时，它将最终传播到<code>UniTaskScheduler.UnobservedTaskException</code>。接收到的未处理异常的默认行为是将日志写入异常。可以使用<code>UniTaskScheduler.UnobservedExceptionWriteLogType</code>更改日志级别。如果要使用自定义行为，请为<code>UniTaskScheduler.UnobservedTaskException.</code>设置一个委托</p><p>而<code>OperationCanceledException</code>是一个特殊的异常，会被<code>UnobservedTaskException</code>.无视</p><p>如果要取消异步 UniTask 方法中的行为，请手动抛出<code>OperationCanceledException</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTask&lt;int&gt; FooAsync()</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">    throw new OperationCanceledException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您处理异常但想忽略（传播到全局cancellation处理的地方），请使用异常过滤器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTask&lt;int&gt; BarAsync()</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        var x = await FooAsync();</span><br><span class="line">        return x * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex) when (!(ex is OperationCanceledException)) // when (ex is not OperationCanceledException) at C# 9.0</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws/catch<code>OperationCanceledException</code>有点重，所以如果性能是一个问题，请使用<code>UniTask.SuppressCancellationThrow</code>以避免 OperationCanceledException 抛出。它将返回<code>(bool IsCanceled, T Result)</code>而不是抛出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var (isCanceled, _) = await UniTask.DelayFrame(10, cancellationToken: cts.Token).SuppressCancellationThrow();</span><br><span class="line">if (isCanceled)</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：仅当您在原方法直接调用SuppressCancellationThrow时才会抑制异常抛出。否则，返回值将被转换，且整个管道不会抑制 throws。</p><h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><p>超时是取消的一种变体。您可以通过<code>CancellationTokenSouce.CancelAfterSlim(TimeSpan)</code>设置超时并将 CancellationToken 传递给异步方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var cts = new CancellationTokenSource();</span><br><span class="line">cts.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 5sec timeout.</span><br><span class="line"></span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest().WithCancellation(cts.Token);</span><br><span class="line">&#125;</span><br><span class="line">catch (OperationCanceledException ex)</span><br><span class="line">&#123;</span><br><span class="line">    if (ex.CancellationToken == cts.Token)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(&quot;Timeout&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p><code>CancellationTokenSouce.CancelAfter</code>是一个原生的api。但是在 Unity 中你不应该使用它，因为它依赖于线程计时器。<code>CancelAfterSlim</code>是 UniTask 的扩展方法，它使用 PlayerLoop 代替。</p></blockquote><p>如果您想将超时与其他cancellation一起使用，请使用<code>CancellationTokenSource.CreateLinkedTokenSource</code>.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var cancelToken = new CancellationTokenSource();</span><br><span class="line">cancelButton.onClick.AddListener(()=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    cancelToken.Cancel(); // 点击按钮后取消</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var timeoutToken = new CancellationTokenSource();</span><br><span class="line">timeoutToken.CancelAfterSlim(TimeSpan.FromSeconds(5)); // 设置5s超时</span><br><span class="line"></span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    // 链接token</span><br><span class="line">    var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancelToken.Token, timeoutToken.Token);</span><br><span class="line"></span><br><span class="line">    await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest().WithCancellation(linkedTokenSource.Token);</span><br><span class="line">&#125;</span><br><span class="line">catch (OperationCanceledException ex)</span><br><span class="line">&#123;</span><br><span class="line">    if (timeoutToken.IsCancellationRequested)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(&quot;Timeout.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (cancelToken.IsCancellationRequested)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(&quot;Cancel clicked.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为优化减少每个调用异步方法超时的 CancellationTokenSource 分配，您可以使用 UniTask 的<code>TimeoutController</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">TimeoutController timeoutController = new TimeoutController(); // 复用timeoutController</span><br><span class="line"></span><br><span class="line">async UniTask FooAsync()</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        // 你可以通过 timeoutController.Timeout(TimeSpan) 传递到 cancellationToken.</span><br><span class="line">        await UnityWebRequest.Get(&quot;http://foo&quot;).SendWebRequest()</span><br><span class="line">            .WithCancellation(timeoutController.Timeout(TimeSpan.FromSeconds(5)));</span><br><span class="line">        timeoutController.Reset(); // 当await完成后调用Reset（停止超时计时器，并准备下一次复用）</span><br><span class="line">    &#125;</span><br><span class="line">    catch (OperationCanceledException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        if (timeoutController.IsTimeout())</span><br><span class="line">        &#123;</span><br><span class="line">            UnityEngine.Debug.Log(&quot;timeout&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想将超时与其他取消源一起使用，请使用<code>new TimeoutController(CancellationToken)</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">TimeoutController timeoutController;</span><br><span class="line">CancellationTokenSource clickCancelSource;</span><br><span class="line"></span><br><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">    this.clickCancelSource = new CancellationTokenSource();</span><br><span class="line">    this.timeoutController = new TimeoutController(clickCancelSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：UniTask 有<code>.Timeout</code>,<code>.TimeoutWithoutException</code>方法，但是，如果可能，不要使用这些，请通过<code>CancellationToken</code>. 由于<code>.Timeout</code>作用在task外部，无法停止超时任务。<code>.Timeout</code>表示超时时忽略结果。如果您将一个<code>CancellationToken</code>传递给该方法，它将从任务内部执行，因此可以停止正在运行的任务。</p><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>一些Unity的异步操作具有<code>ToUniTask(IProgress&lt;float&gt; progress = null, ...)</code>扩展方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var progress = Progress.Create&lt;float&gt;(x =&gt; Debug.Log(x));</span><br><span class="line"></span><br><span class="line">var request = await UnityWebRequest.Get(&quot;http://google.co.jp&quot;)</span><br><span class="line">    .SendWebRequest()</span><br><span class="line">    .ToUniTask(progress: progress);</span><br></pre></td></tr></table></figure><p>您不应该使用原生的<code>new System.Progress&lt;T&gt;</code>，因为它每次都会导致GC分配。改为使用<code>Cysharp.Threading.Tasks.Progress</code>。这个 progress factory 有两个方法，<code>Create</code>和<code>CreateOnlyValueChanged</code>. <code>CreateOnlyValueChanged</code>仅在进度值更新时调用。</p><p>为调用者实现 IProgress 接口会更好，因为这样可以没有 lambda 分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class Foo : MonoBehaviour, IProgress&lt;float&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void Report(float value)</span><br><span class="line">    &#123;</span><br><span class="line">        UnityEngine.Debug.Log(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public async UniTaskVoid WebRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        var request = await UnityWebRequest.Get(&quot;http://google.co.jp&quot;)</span><br><span class="line">            .SendWebRequest()</span><br><span class="line">            .ToUniTask(progress: this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PlayerLoop"><a href="#PlayerLoop" class="headerlink" title="PlayerLoop"></a>PlayerLoop</h2><p>UniTask 在自定义<a href="https://docs.unity3d.com/ScriptReference/LowLevel.PlayerLoop.html">PlayerLoop</a>上运行。UniTask 的基于 playerloop 的方法（例如<code>Delay</code>、<code>DelayFrame</code>、<code>asyncOperation.ToUniTask</code>等）接受这个<code>PlayerLoopTiming</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public enum PlayerLoopTiming</span><br><span class="line">&#123;</span><br><span class="line">    Initialization = 0,</span><br><span class="line">    LastInitialization = 1,</span><br><span class="line"></span><br><span class="line">    EarlyUpdate = 2,</span><br><span class="line">    LastEarlyUpdate = 3,</span><br><span class="line"></span><br><span class="line">    FixedUpdate = 4,</span><br><span class="line">    LastFixedUpdate = 5,</span><br><span class="line"></span><br><span class="line">    PreUpdate = 6,</span><br><span class="line">    LastPreUpdate = 7,</span><br><span class="line"></span><br><span class="line">    Update = 8,</span><br><span class="line">    LastUpdate = 9,</span><br><span class="line"></span><br><span class="line">    PreLateUpdate = 10,</span><br><span class="line">    LastPreLateUpdate = 11,</span><br><span class="line"></span><br><span class="line">    PostLateUpdate = 12,</span><br><span class="line">    LastPostLateUpdate = 13</span><br><span class="line">    </span><br><span class="line">#if UNITY_2020_2_OR_NEWER</span><br><span class="line">    TimeUpdate = 14,</span><br><span class="line">    LastTimeUpdate = 15,</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它表示何时运行，您可以检查<a href="https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae">PlayerLoopList.md</a>到 Unity 的默认 playerloop 并注入 UniTask 的自定义循环。</p><p><code>PlayerLoopTiming.Update</code>与协程中的<code>yield return null</code>类似，但在 Update(Update 和 uGUI 事件(button.onClick, etc…) 前被调用（在<code>ScriptRunBehaviourUpdate</code>时被调用），yield return null 在<code>ScriptRunDelayedDynamicFrameRate</code>时被调用。<code>PlayerLoopTiming.FixedUpdate</code>类似于<code>WaitForFixedUpdate</code>。</p><blockquote><p><code>PlayerLoopTiming.LastPostLateUpdate</code>不等同于协程的<code>yield return new WaitForEndOfFrame()</code>. 协程的 WaitForEndOfFrame 似乎在 PlayerLoop 完成后运行。一些需要协程结束帧(<code>Texture2D.ReadPixels</code>, <code>ScreenCapture.CaptureScreenshotAsTexture</code>, <code>CommandBuffer</code>, 等) 的方法在 async/await 时无法正常工作。在这些情况下，请将 MonoBehaviour(coroutine runner) 传递给<code>UniTask.WaitForEndOfFrame</code>. 例如，<code>await UniTask.WaitForEndOfFrame(this);</code>是<code>yield return new WaitForEndOfFrame()</code>轻量级0GC的替代方案。</p></blockquote><p><code>yield return null</code>和<code>UniTask.Yield</code>相似但不同。<code>yield return null</code>总是返回下一帧但<code>UniTask.Yield</code>返回下一个调用。也就是说，<code>UniTask.Yield(PlayerLoopTiming.Update)</code>在 <code>PreUpdate</code>上调用，它返回相同的帧。<code>UniTask.NextFrame()</code>保证返回下一帧，您可以认为它的行为与<code>yield return null</code>一致.</p><blockquote><p>UniTask.Yield(without CancellationToken) 是一种特殊类型，返回<code>YieldAwaitable</code>并在 YieldRunner 上运行。它是最轻量和最快的。</p></blockquote><p><code>AsyncOperation</code>在原生生命周期返回。例如，await <code>SceneManager.LoadSceneAsync</code>在<code>EarlyUpdate.UpdatePreloading</code>时返回，在此之后，加载的场景的<code>Start</code>方法调用自<code>EarlyUpdate.ScriptRunDelayedStartupFrame</code>。同样的，<code>await UnityWebRequest</code>在<code>EarlyUpdate.ExecuteMainThreadJobs</code>时返回.</p><p>在 UniTask 中，await 直接使用原生生命周期，<code>WithCancellation</code>和<code>ToUniTask</code>可以指定使用的原生生命周期。这通常不会有问题，但是<code>LoadSceneAsync</code>在等待之后，它会导致开始和继续的不同顺序。所以建议不要使用<code>LoadSceneAsync.ToUniTask</code>。</p><p>在堆栈跟踪中，您可以检查它在 playerloop 中的运行位置。</p><p><a href="https://user-images.githubusercontent.com/46207/83735571-83caea80-a68b-11ea-8d22-5e22864f0d24.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025464.png" alt="image"></a></p><p>默认情况下，UniTask 的 PlayerLoop 初始化在<code>[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]</code>.</p><p>在 BeforeSceneLoad 中调用方法的顺序是不确定的，所以如果你想在其他 BeforeSceneLoad 方法中使用 UniTask，你应该尝试在此之前初始化它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// AfterAssembliesLoaded 表示将会在 BeforeSceneLoad之前调用</span><br><span class="line">[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]</span><br><span class="line">public static void InitUniTaskLoop()</span><br><span class="line">&#123;</span><br><span class="line">    var loop = PlayerLoop.GetCurrentPlayerLoop();</span><br><span class="line">    Cysharp.Threading.Tasks.PlayerLoopHelper.Initialize(ref loop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您导入 Unity 的<code>Entities</code>包，则会将自定义playerloop重置为默认值<code>BeforeSceneLoad</code>并注入 ECS 的循环。当 Unity 在 UniTask 的 initialize 方法之后调用 ECS 的 inject 方法时，UniTask 将不再工作。</p><p>为了解决这个问题，您可以在 ECS 初始化后重新初始化 UniTask PlayerLoop。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 获取ECS Loop.</span><br><span class="line">var playerLoop = ScriptBehaviourUpdateOrder.CurrentPlayerLoop;</span><br><span class="line"></span><br><span class="line">// 设置UniTask PlayerLoop</span><br><span class="line">PlayerLoopHelper.Initialize(ref playerLoop);</span><br></pre></td></tr></table></figure><p>您可以通过调用<code>PlayerLoopHelper.IsInjectedUniTaskPlayerLoop()</code>来诊断 UniTask 的PlayerLoop是否准备就绪。并且<code>PlayerLoopHelper.DumpCurrentPlayerLoop</code>还会将所有当前PlayerLoop记录到控制台。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">    UnityEngine.Debug.Log(&quot;UniTaskPlayerLoop ready? &quot; + PlayerLoopHelper.IsInjectedUniTaskPlayerLoop());</span><br><span class="line">    PlayerLoopHelper.DumpCurrentPlayerLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以通过删除未使用的 PlayerLoopTiming 注入来稍微优化循环成本。您可以在初始化时调用<code>PlayerLoopHelper.Initialize(InjectPlayerLoopTimings)</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var loop = PlayerLoop.GetCurrentPlayerLoop();</span><br><span class="line">PlayerLoopHelper.Initialize(ref loop, InjectPlayerLoopTimings.Minimum); // 最小化 is Update | FixedUpdate | LastPostLateUpdate</span><br></pre></td></tr></table></figure><p><code>InjectPlayerLoopTimings</code>有三个预设，<code>All</code>，<code>Standard</code>（除 LastPostLateUpdate 外），<code>Minimum</code>（<code>Update | FixedUpdate | LastPostLateUpdate</code>）。默认为全部，您可以组合自定义注入时间，例如<code>InjectPlayerLoopTimings.Update | InjectPlayerLoopTimings.FixedUpdate | InjectPlayerLoopTimings.PreLateUpdate</code>.</p><p>使用未注入<code>PlayerLoopTiming</code>的<a href="https://github.com/dotnet/roslyn-analyzers/blob/master/src/Microsoft.CodeAnalysis.BannedApiAnalyzers/BannedApiAnalyzers.Help.md">Microsoft.CodeAnalysis.BannedApiAnalyzers</a>可能会出错。例如，您可以为<code>InjectPlayerLoopTimings.Minimum</code>设置<code>BannedSymbols.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TXT</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.Initialization; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastInitialization; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.EarlyUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastEarlyUpdate; Isn&#x27;t injected this PlayerLoop in this project.d</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastFixedUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.PreLateUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastPreLateUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.PostLateUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.TimeUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br><span class="line">F:Cysharp.Threading.Tasks.PlayerLoopTiming.LastTimeUpdate; Isn&#x27;t injected this PlayerLoop in this project.</span><br></pre></td></tr></table></figure><p>您可以将<code>RS0030</code>严重性配置为错误。</p><p><a href="https://user-images.githubusercontent.com/46207/109150837-bb933880-77ac-11eb-85ba-4fd15819dbd0.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025420.png" alt="image"></a></p><p>image</p><h2 id="async-void-与-async-UniTaskVoid-对比"><a href="#async-void-与-async-UniTaskVoid-对比" class="headerlink" title="async void 与 async UniTaskVoid 对比"></a>async void 与 async UniTaskVoid 对比</h2><p><code>async void</code>是一个原生的 C# 任务系统，因此它不能在 UniTask 系统上运行。也最好不要使用它。<code>async UniTaskVoid</code>是<code>async UniTask</code>的轻量级版本，因为它没有等待完成并立即向<code>UniTaskScheduler.UnobservedTaskException</code>报告错误. 如果您不需要等待（即发即弃），那么使用<code>UniTaskVoid</code>会更好。不幸的是，要解除警告，您需要在尾部添加<code>Forget()</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTaskVoid FireAndForgetMethod()</span><br><span class="line">&#123;</span><br><span class="line">    // do anything...</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Caller()</span><br><span class="line">&#123;</span><br><span class="line">    FireAndForgetMethod().Forget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UniTask 也有<code>Forget</code>方法，类似<code>UniTaskVoid</code>且效果相同。但是如果你完全不需要使用<code>await</code>，<code>UniTaskVoid</code>会更高效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public async UniTask DoAsync()</span><br><span class="line">&#123;</span><br><span class="line">    // do anything...</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Caller()</span><br><span class="line">&#123;</span><br><span class="line">    DoAsync().Forget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用注册到事件的异步 lambda，请不要使用<code>async void</code>. 相反，您可以使用<code>UniTask.Action</code> 或 <code>UniTask.UnityAction</code>，两者都通过<code>async UniTaskVoid</code> lambda 创建委托。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">Action actEvent;</span><br><span class="line">UnityAction unityEvent; // UGUI特供</span><br><span class="line"></span><br><span class="line">// 这样是不好的: async void</span><br><span class="line">actEvent += async () =&gt; &#123; &#125;;</span><br><span class="line">unityEvent += async () =&gt; &#123; &#125;;</span><br><span class="line"></span><br><span class="line">// 这样是可以的: 通过lamada创建Action</span><br><span class="line">actEvent += UniTask.Action(async () =&gt; &#123; await UniTask.Yield(); &#125;);</span><br><span class="line">unityEvent += UniTask.UnityAction(async () =&gt; &#123; await UniTask.Yield(); &#125;);</span><br></pre></td></tr></table></figure><p><code>UniTaskVoid</code>也可以用在 MonoBehaviour 的<code>Start</code>方法中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">class Sample : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    async UniTaskVoid Start()</span><br><span class="line">    &#123;</span><br><span class="line">        // async init code.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UniTaskTracker"><a href="#UniTaskTracker" class="headerlink" title="UniTaskTracker"></a>UniTaskTracker</h2><p>对于检查（泄露的）UniTasks 很有用。您可以在<code>Window -&gt; UniTask Tracker</code>中打开跟踪器窗口。</p><p><a href="https://user-images.githubusercontent.com/46207/83527073-4434bf00-a522-11ea-86e9-3b3975b26266.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025674.png" alt="image"></a></p><ul><li>Enable AutoReload(Toggle) - 自动重新加载。</li><li>Reload - 重新加载视图（重新扫描内存中UniTask实例，并刷新界面）。</li><li>GC.Collect - 调用 GC.Collect。</li><li>Enable Tracking(Toggle) - 开始跟踪异步/等待 UniTask。性能影响：低。</li><li>Enable StackTrace(Toggle) - 在任务启动时捕获 StackTrace。性能影响：高。</li></ul><p>UniTaskTracker 仅用于调试用途，因为启用跟踪和捕获堆栈跟踪很有用，但会对性能产生重大影响。推荐的用法是启用跟踪和堆栈跟踪以查找任务泄漏并在完成时禁用它们。</p><h2 id="外部拓展"><a href="#外部拓展" class="headerlink" title="外部拓展"></a>外部拓展</h2><p>默认情况下，UniTask 支持 TextMeshPro（<code>BindTo(TMP_Text)</code>和<code>TMP_InputField</code>，并且TMP_InputField有同原生uGUI <code>InputField</code>类似的事件扩展）、DOTween（<code>Tween</code>作为等待）和Addressables（<code>AsyncOperationHandle``AsyncOperationHandle&lt;T&gt;</code>作为等待）。</p><p>在单独的 asmdef 中定义，如<code>UniTask.TextMeshPro</code>, <code>UniTask.DOTween</code>, <code>UniTask.Addressables</code>.</p><p>从包管理器导入包时，会自动启用 TextMeshPro 和 Addressables 支持。但是对于 DOTween 支持，需要<code>com.demigiant.dotween</code>从<a href="https://openupm.com/packages/com.demigiant.dotween/">OpenUPM</a>导入或定义<code>UNITASK_DOTWEEN_SUPPORT</code>以启用它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 动画序列</span><br><span class="line">await transform.DOMoveX(2, 10);</span><br><span class="line">await transform.DOMoveZ(5, 20);</span><br><span class="line"></span><br><span class="line">// 并行，并传递cancellation用于取消</span><br><span class="line">var ct = this.GetCancellationTokenOnDestroy();</span><br><span class="line"></span><br><span class="line">await UniTask.WhenAll(</span><br><span class="line">    transform.DOMoveX(10, 3).WithCancellation(ct),</span><br><span class="line">    transform.DOScale(10, 3).WithCancellation(ct));</span><br></pre></td></tr></table></figure><p>DOTween 支持的默认行为( <code>await</code>, <code>WithCancellation</code>, <code>ToUniTask</code>) await tween 被终止。它适用于 Complete(true/false) 和 Kill(true/false)。但是如果你想重用tweens ( <code>SetAutoKill(false)</code>)，它就不能按预期工作。如果您想等待另一个时间点，Tween 中存在以下扩展方法，<code>AwaitForComplete</code>, <code>AwaitForPause</code>, <code>AwaitForPlay</code>, <code>AwaitForRewind</code>, <code>AwaitForStepComplete</code>。</p><h2 id="AsyncEnumerable-和-Async-LINQ"><a href="#AsyncEnumerable-和-Async-LINQ" class="headerlink" title="AsyncEnumerable 和 Async LINQ"></a>AsyncEnumerable 和 Async LINQ</h2><p>Unity 2020.2 支持 C# 8.0，因此您可以使用<code>await foreach</code>. 这是异步时代的新更新符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// Unity 2020.2, C# 8.0</span><br><span class="line">await foreach (var _ in UniTaskAsyncEnumerable.EveryUpdate(token))</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(&quot;Update() &quot; + Time.frameCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C# 7.3 环境中，您可以使用该<code>ForEachAsync</code>方法以几乎相同的方式工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// C# 7.3(Unity 2018.3~)</span><br><span class="line">await UniTaskAsyncEnumerable.EveryUpdate(token).ForEachAsync(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(&quot;Update() &quot; + Time.frameCount);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>UniTaskAsyncEnumerable 实现异步 LINQ，类似于 LINQ 的<code>IEnumerable&lt;T&gt;</code>或 Rx 的 <code>IObservable&lt;T&gt;</code>。所有标准 LINQ 查询运算符都可以应用于异步流。例如，以下代码表示如何将 Where 过滤器应用于每两次单击运行一次的按钮单击异步流。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">await okButton.OnClickAsAsyncEnumerable().Where((x, i) =&gt; i % 2 == 0).ForEachAsync(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Fire and Forget 风格（例如，事件处理），你也可以使用<code>Subscribe</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">okButton.OnClickAsAsyncEnumerable().Where((x, i) =&gt; i % 2 == 0).Subscribe(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Async LINQ 在 时启用<code>using Cysharp.Threading.Tasks.Linq;</code>，并且<code>UniTaskAsyncEnumerable</code>在<code>UniTask.Linq</code>asmdef 中定义。</p><p>它更接近 UniRx（Reactive Extensions），但 UniTaskAsyncEnumerable 是pull-base的异步流，而 Rx 是基于push-base异步流。请注意，尽管相似，但特征不同，并且细节的行为也随之不同。</p><p><code>UniTaskAsyncEnumerable</code>是类似的入口点<code>Enumerable</code>。除了标准查询运算符之外，还有其他 Unity 生成器，例如<code>EveryUpdate</code>、<code>Timer</code>、<code>TimerFrame</code>、<code>Interval</code>、<code>IntervalFrame</code>和<code>EveryValueChanged</code>。并且还添加了额外的 UniTask 原始查询运算符，如<code>Append</code>, <code>Prepend</code>, <code>DistinctUntilChanged</code>, <code>ToHashSet</code>, <code>Buffer</code>, <code>CombineLatest</code>, <code>Do</code>, <code>Never</code>, <code>ForEachAsync</code>, <code>Pairwise</code>, <code>Publish</code>, <code>Queue</code>, <code>Return</code>, <code>SkipUntil</code>, <code>TakeUntil</code>, <code>SkipUntilCanceled</code>, <code>TakeUntilCanceled</code>, <code>TakeLast</code>, <code>Subscribe</code>。</p><p>以 Func 作为参数的方法具有三个额外的重载，<code>***Await</code>, <code>***AwaitWithCancellation</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">Select(Func&lt;T, TR&gt; selector)</span><br><span class="line">SelectAwait(Func&lt;T, UniTask&lt;TR&gt;&gt; selector)</span><br><span class="line">SelectAwaitWithCancellation(Func&lt;T, CancellationToken, UniTask&lt;TR&gt;&gt; selector)</span><br></pre></td></tr></table></figure><p>如果在 func 方法内部使用<code>async</code>，请使用<strong><em>Awaitor `</em></strong>AwaitWithCancellation`。</p><p>如何创建异步迭代器：C# 8.0 支持异步迭代器（<code>async yield return</code>），但它只允许<code>IAsyncEnumerable&lt;T&gt;</code>并且当然需要 C# 8.0。UniTask 支持<code>UniTaskAsyncEnumerable.Create</code>创建自定义异步迭代器的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// IAsyncEnumerable, C# 8.0 异步迭代器. ( 不要这样用，因为IAsyncEnumerable不被UniTask控制).</span><br><span class="line">public async IAsyncEnumerable&lt;int&gt; MyEveryUpdate([EnumeratorCancellation]CancellationToken cancelationToken = default)</span><br><span class="line">&#123;</span><br><span class="line">    var frameCount = 0;</span><br><span class="line">    await UniTask.Yield();</span><br><span class="line">    while (!token.IsCancellationRequested)</span><br><span class="line">    &#123;</span><br><span class="line">        yield return frameCount++;</span><br><span class="line">        await UniTask.Yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UniTaskAsyncEnumerable.Create 并用 `await writer.YieldAsync` 代替 `yield return`.</span><br><span class="line">public IUniTaskAsyncEnumerable&lt;int&gt; MyEveryUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    // writer(IAsyncWriter&lt;T&gt;) has `YieldAsync(value)` method.</span><br><span class="line">    return UniTaskAsyncEnumerable.Create&lt;int&gt;(async (writer, token) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        var frameCount = 0;</span><br><span class="line">        await UniTask.Yield();</span><br><span class="line">        while (!token.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            await writer.YieldAsync(frameCount++); // instead of `yield return`</span><br><span class="line">            await UniTask.Yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可等待事件"><a href="#可等待事件" class="headerlink" title="可等待事件"></a>可等待事件</h2><p>所有 uGUI 组件都实现<code>***AsAsyncEnumerable</code>了异步事件流的转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">async UniTask TripleClick()</span><br><span class="line">&#123;</span><br><span class="line">    // 默认情况下，使用了button.GetCancellationTokenOnDestroy 来管理异步生命周期</span><br><span class="line">    await button.OnClickAsync();</span><br><span class="line">    await button.OnClickAsync();</span><br><span class="line">    await button.OnClickAsync();</span><br><span class="line">    Debug.Log(&quot;Three times clicked&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更高效的方法</span><br><span class="line">async UniTask TripleClick()</span><br><span class="line">&#123;</span><br><span class="line">    using (var handler = button.GetAsyncClickEventHandler())</span><br><span class="line">    &#123;</span><br><span class="line">        await handler.OnClickAsync();</span><br><span class="line">        await handler.OnClickAsync();</span><br><span class="line">        await handler.OnClickAsync();</span><br><span class="line">        Debug.Log(&quot;Three times clicked&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用异步LINQ</span><br><span class="line">async UniTask TripleClick(CancellationToken token)</span><br><span class="line">&#123;</span><br><span class="line">    await button.OnClickAsAsyncEnumerable().Take(3).Last();</span><br><span class="line">    Debug.Log(&quot;Three times clicked&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用异步LINQ</span><br><span class="line">async UniTask TripleClick(CancellationToken token)</span><br><span class="line">&#123;</span><br><span class="line">    await button.OnClickAsAsyncEnumerable().Take(3).ForEachAsync(_ =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Every clicked&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Debug.Log(&quot;Three times clicked, complete.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有 MonoBehaviour 消息事件都可以转换异步流<code>AsyncTriggers</code>，可以通过<code>using Cysharp.Threading.Tasks.Triggers;</code>进行启用，.AsyncTrigger 可以使用 UniTaskAsyncEnumerable 来创建，通过<code>GetAsync***Trigger</code>触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var trigger = this.GetOnCollisionEnterAsyncHandler();</span><br><span class="line">await trigger.OnCollisionEnterAsync();</span><br><span class="line">await trigger.OnCollisionEnterAsync();</span><br><span class="line">await trigger.OnCollisionEnterAsync();</span><br><span class="line"></span><br><span class="line">// every moves.</span><br><span class="line">await this.GetAsyncMoveTrigger().ForEachAsync(axisEventData =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>AsyncReactiveProperty</code>,<code>AsyncReadOnlyReactiveProperty</code>是 UniTask 的 ReactiveProperty 版本。将异步流值绑定到 Unity 组件（Text/Selectable/TMP/Text）<code>BindTo</code>的<code>IUniTaskAsyncEnumerable&lt;T&gt;</code>扩展方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">var rp = new AsyncReactiveProperty&lt;int&gt;(99);</span><br><span class="line"></span><br><span class="line">// AsyncReactiveProperty 本身是 IUniTaskAsyncEnumerable, 可以通过LINQ进行查询</span><br><span class="line">rp.ForEachAsync(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(x);</span><br><span class="line">&#125;, this.GetCancellationTokenOnDestroy()).Forget();</span><br><span class="line"></span><br><span class="line">rp.Value = 10; // 推送10给所有订阅者</span><br><span class="line">rp.Value = 11; // 推送11给所有订阅者</span><br><span class="line"></span><br><span class="line">// WithoutCurrent 忽略初始值</span><br><span class="line">// BindTo 绑定 stream value 到 unity 组件.</span><br><span class="line">rp.WithoutCurrent().BindTo(this.textComponent);</span><br><span class="line"></span><br><span class="line">await rp.WaitAsync(); // 一直等待，直到下一个值被设置</span><br><span class="line"></span><br><span class="line">// 同样支持ToReadOnlyAsyncReactiveProperty</span><br><span class="line">var rp2 = new AsyncReactiveProperty&lt;int&gt;(99);</span><br><span class="line">var rorp = rp.CombineLatest(rp2, (x, y) =&gt; (x, y)).ToReadOnlyAsyncReactiveProperty(CancellationToken.None);</span><br></pre></td></tr></table></figure><p>在序列中的异步处理完成之前，pull-based异步流不会获取下一个值。这可能会从按钮等推送类型的事件中溢出数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 在3s完成前，无法获取event</span><br><span class="line">await button.OnClickAsAsyncEnumerable().ForEachAwaitAsync(async x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(3));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它很有用（防止双击），但有时没用。</p><p>使用该<code>Queue()</code>方法还将在异步处理期间对事件进行排队。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">// 异步处理中对message进行排队</span><br><span class="line">await button.OnClickAsAsyncEnumerable().Queue().ForEachAwaitAsync(async x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(3));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或使用<code>Subscribe</code>, fire and forget 风格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">button.OnClickAsAsyncEnumerable().Subscribe(async x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    await UniTask.Delay(TimeSpan.FromSeconds(3));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><code>Channel</code>与<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.channels?view=netcore-3.1">System.Threading.Tasks.Channels</a>相同，类似于 GoLang Channel。</p><p>目前只支持多生产者、单消费者无界渠道。它可以由<code>Channel.CreateSingleConsumerUnbounded&lt;T&gt;()</code>.</p><p>对于 producer(<code>.Writer</code>)，用<code>TryWrite</code>推送值和<code>TryComplete</code>完成通道。对于 consumer(<code>.Reader</code>)，使用<code>TryRead</code>、<code>WaitToReadAsync</code>、<code>ReadAsync</code>和<code>Completion</code>，<code>ReadAllAsync</code>来读取队列的消息。</p><p><code>ReadAllAsync</code>返回<code>IUniTaskAsyncEnumerable&lt;T&gt;</code> 查询 LINQ 运算符。Reader 只允许单消费者，但使用<code>.Publish()</code>查询运算符来启用多播消息。例如，制作 pub/sub 实用程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class AsyncMessageBroker&lt;T&gt; : IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    Channel&lt;T&gt; channel;</span><br><span class="line"></span><br><span class="line">    IConnectableUniTaskAsyncEnumerable&lt;T&gt; multicastSource;</span><br><span class="line">    IDisposable connection;</span><br><span class="line"></span><br><span class="line">    public AsyncMessageBroker()</span><br><span class="line">    &#123;</span><br><span class="line">        channel = Channel.CreateSingleConsumerUnbounded&lt;T&gt;();</span><br><span class="line">        multicastSource = channel.Reader.ReadAllAsync().Publish();</span><br><span class="line">        connection = multicastSource.Connect(); // Publish returns IConnectableUniTaskAsyncEnumerable.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Publish(T value)</span><br><span class="line">    &#123;</span><br><span class="line">        channel.Writer.TryWrite(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IUniTaskAsyncEnumerable&lt;T&gt; Subscribe()</span><br><span class="line">    &#123;</span><br><span class="line">        return multicastSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Dispose()</span><br><span class="line">    &#123;</span><br><span class="line">        channel.Writer.TryComplete();</span><br><span class="line">        connection.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Unity 的<code>[UnityTest]</code>属性可以测试协程（IEnumerator）但不能测试异步。<code>UniTask.ToCoroutine</code>将 async/await 桥接到协程，以便您可以测试异步方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">[UnityTest]</span><br><span class="line">public IEnumerator DelayIgnore() =&gt; UniTask.ToCoroutine(async () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var time = Time.realtimeSinceStartup;</span><br><span class="line"></span><br><span class="line">    Time.timeScale = 0.5f;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        await UniTask.Delay(TimeSpan.FromSeconds(3), ignoreTimeScale: true);</span><br><span class="line"></span><br><span class="line">        var elapsed = Time.realtimeSinceStartup - time;</span><br><span class="line">        Assert.AreEqual(3, (int)Math.Round(TimeSpan.FromSeconds(elapsed).TotalSeconds, MidpointRounding.ToEven));</span><br><span class="line">    &#125;</span><br><span class="line">    finally</span><br><span class="line">    &#123;</span><br><span class="line">        Time.timeScale = 1.0f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>UniTask 自己的单元测试是使用 Unity Test Runner 和<a href="https://github.com/Cysharp/RuntimeUnitTestToolkit">Cysharp/RuntimeUnitTestToolkit</a>编写的，以与 CI 集成并检查 IL2CPP 是否正常工作。</p><h2 id="线程池限制"><a href="#线程池限制" class="headerlink" title="线程池限制"></a>线程池限制</h2><p>大多数 UniTask 方法在单个线程 (PlayerLoop) 上运行，只有<code>UniTask.Run</code>（<code>Task.Run</code>等效）和<code>UniTask.SwitchToThreadPool</code>在线程池上运行。如果您使用线程池，它将无法与 WebGL 等平台兼容。</p><p><code>UniTask.Run</code>现在已弃用。你可以改用<code>UniTask.RunOnThreadPool</code>。并且还要考虑是否可以使用<code>UniTask.Create</code>或<code>UniTask.Void</code>。</p><h2 id="IEnumerator-ToUniTask-限制"><a href="#IEnumerator-ToUniTask-限制" class="headerlink" title="IEnumerator.ToUniTask 限制"></a>IEnumerator.ToUniTask 限制</h2><p>您可以将协程（IEnumerator）转换为 UniTask（或直接等待），但它有一些限制。</p><ul><li>不支持<code>WaitForEndOfFrame</code>，<code>WaitForFixedUpdate</code>，<code>Coroutine</code></li><li>Loop生命周期与<code>StartCoroutine</code>不一样，它使用指定<code>PlayerLoopTiming</code>的并且默认情况下，<code>PlayerLoopTiming.Update</code>在 MonoBehaviour<code>Update</code>和<code>StartCoroutine</code>的循环之前运行。</li></ul><p>如果您想要从协程到异步的完全兼容转换，请使用<code>IEnumerator.ToUniTask(MonoBehaviour coroutineRunner)</code>重载。它在参数 MonoBehaviour 的实例上执行 StartCoroutine 并等待它在 UniTask 中完成。</p><h2 id="关于UnityEditor"><a href="#关于UnityEditor" class="headerlink" title="关于UnityEditor"></a>关于UnityEditor</h2><p>UniTask 可以像编辑器协程一样在 Unity 编辑器上运行。但是，有一些限制。</p><ul><li>UniTask.Delay 的 DelayType.DeltaTime、UnscaledDeltaTime 无法正常工作，因为它们无法在编辑器中获取 deltaTime。因此在 EditMode 上运行，会自动将 DelayType 更改为<code>DelayType.Realtime</code>等待正确的时间。</li><li>所有 PlayerLoopTiming 都在<code>EditorApplication.update</code>生命周期上运行。</li><li>带<code>-quit</code>的<code>-batchmode</code>带不起作用，因为 Unity<code>EditorApplication.update</code>在单帧后不会运行并退出。相反，不要使用<code>-quit</code>并手动退出<code>EditorApplication.Exit(0)</code>.</li></ul><h2 id="与原生Task-API对比"><a href="#与原生Task-API对比" class="headerlink" title="与原生Task API对比"></a>与原生Task API对比</h2><p>UniTask 有许多原生的 Task-like API。此表显示了一一对应的 API 是什么。</p><p>使用原生类型。</p><div class="table-container"><table><thead><tr><th>.NET Type</th><th>UniTask Type</th></tr></thead><tbody><tr><td><code>IProgress&lt;T&gt;</code></td><td>—</td></tr><tr><td><code>CancellationToken</code></td><td>—</td></tr><tr><td><code>CancellationTokenSource</code></td><td>—</td></tr></tbody></table></div><p>使用 UniTask 类型.</p><div class="table-container"><table><thead><tr><th>.NET Type</th><th>UniTask Type</th></tr></thead><tbody><tr><td><code>Task</code>/<code>ValueTask</code></td><td><code>UniTask</code></td></tr><tr><td><code>Task&lt;T&gt;</code>/<code>ValueTask&lt;T&gt;</code></td><td><code>UniTask&lt;T&gt;</code></td></tr><tr><td><code>async void</code></td><td><code>async UniTaskVoid</code></td></tr><tr><td><code>+= async () =&gt; &#123; &#125;</code></td><td><code>UniTask.Void</code>, <code>UniTask.Action</code>, <code>UniTask.UnityAction</code></td></tr><tr><td>—</td><td><code>UniTaskCompletionSource</code></td></tr><tr><td><code>TaskCompletionSource&lt;T&gt;</code></td><td><code>UniTaskCompletionSource&lt;T&gt;</code>/<code>AutoResetUniTaskCompletionSource&lt;T&gt;</code></td></tr><tr><td><code>ManualResetValueTaskSourceCore&lt;T&gt;</code></td><td><code>UniTaskCompletionSourceCore&lt;T&gt;</code></td></tr><tr><td><code>IValueTaskSource</code></td><td><code>IUniTaskSource</code></td></tr><tr><td><code>IValueTaskSource&lt;T&gt;</code></td><td><code>IUniTaskSource&lt;T&gt;</code></td></tr><tr><td><code>ValueTask.IsCompleted</code></td><td><code>UniTask.Status.IsCompleted()</code></td></tr><tr><td><code>ValueTask&lt;T&gt;.IsCompleted</code></td><td><code>UniTask&lt;T&gt;.Status.IsCompleted()</code></td></tr><tr><td><code>new Progress&lt;T&gt;</code></td><td><code>Progress.Create&lt;T&gt;</code></td></tr><tr><td><code>CancellationToken.Register(UnsafeRegister)</code></td><td><code>CancellationToken.RegisterWithoutCaptureExecutionContext</code></td></tr><tr><td><code>CancellationTokenSource.CancelAfter</code></td><td><code>CancellationTokenSource.CancelAfterSlim</code></td></tr><tr><td><code>Channel.CreateUnbounded&lt;T&gt;(false)&#123; SingleReader = true &#125;</code></td><td><code>Channel.CreateSingleConsumerUnbounded&lt;T&gt;</code></td></tr><tr><td><code>IAsyncEnumerable&lt;T&gt;</code></td><td><code>IUniTaskAsyncEnumerable&lt;T&gt;</code></td></tr><tr><td><code>IAsyncEnumerator&lt;T&gt;</code></td><td><code>IUniTaskAsyncEnumerator&lt;T&gt;</code></td></tr><tr><td><code>IAsyncDisposable</code></td><td><code>IUniTaskAsyncDisposable</code></td></tr><tr><td><code>Task.Delay</code></td><td><code>UniTask.Delay</code></td></tr><tr><td><code>Task.Yield</code></td><td><code>UniTask.Yield</code></td></tr><tr><td><code>Task.Run</code></td><td><code>UniTask.RunOnThreadPool</code></td></tr><tr><td><code>Task.WhenAll</code></td><td><code>UniTask.WhenAll</code></td></tr><tr><td><code>Task.WhenAny</code></td><td><code>UniTask.WhenAny</code></td></tr><tr><td><code>Task.CompletedTask</code></td><td><code>UniTask.CompletedTask</code></td></tr><tr><td><code>Task.FromException</code></td><td><code>UniTask.FromException</code></td></tr><tr><td><code>Task.FromResult</code></td><td><code>UniTask.FromResult</code></td></tr><tr><td><code>Task.FromCanceled</code></td><td><code>UniTask.FromCanceled</code></td></tr><tr><td><code>Task.ContinueWith</code></td><td><code>UniTask.ContinueWith</code></td></tr><tr><td><code>TaskScheduler.UnobservedTaskException</code></td><td><code>UniTaskScheduler.UnobservedTaskException</code></td></tr></tbody></table></div><h2 id="池化配置"><a href="#池化配置" class="headerlink" title="池化配置"></a>池化配置</h2><p>UniTask 积极缓存异步promise对象以实现零分配（有关技术细节，请参阅博客文章<a href="https://medium.com/@neuecc/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd">UniTask v2 — Unity 的零分配异步/等待，使用异步 LINQ</a>）。默认情况下，它缓存所有promise ，但您可以配置<code>TaskPool.SetMaxPoolSize</code>为您的值，该值表示每种类型的缓存大小。<code>TaskPool.GetCacheSizeInfo</code>返回池中当前缓存的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">foreach (var (type, size) in TaskPool.GetCacheSizeInfo())</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(type + &quot;:&quot; + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Profiler下的分配"><a href="#Profiler下的分配" class="headerlink" title="Profiler下的分配"></a>Profiler下的分配</h2><p>在 UnityEditor 中，分析器显示编译器生成的 AsyncStateMachine 的分配，但它只发生在调试（开发）构建中。C# 编译器将 AsyncStateMachine 生成为 Debug 构建的类和 Release 构建的结构。</p><p>Unity 从 2020.1 开始支持代码优化选项（右，页脚）。</p><p><a href="https://user-images.githubusercontent.com/46207/89967342-2f944600-dc8c-11ea-99fc-0b74527a16f6.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025362.png" alt="img"></a></p><p>您可以将 C# 编译器优化更改为 release 以删除开发版本中的 AsyncStateMachine 分配。此优化选项也可以通过设置<code>Compilation.CompilationPipeline-codeOptimization</code>和<code>Compilation.CodeOptimization</code>。</p><h2 id="UniTaskSynchronizationContext"><a href="#UniTaskSynchronizationContext" class="headerlink" title="UniTaskSynchronizationContext"></a>UniTaskSynchronizationContext</h2><p>Unity 的默认 SynchronizationContext( <code>UnitySynchronizationContext</code>) 在性能方面表现不佳。UniTask 绕过<code>SynchronizationContext</code>(和<code>ExecutionContext</code>) 因此它不使用它，但如果存在<code>async Task</code>，则仍然使用它。<code>UniTaskSynchronizationContext</code>是<code>UnitySynchronizationContext</code>性能更好的替代品。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class SyncContextInjecter</span><br><span class="line">&#123;</span><br><span class="line">    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]</span><br><span class="line">    public static void Inject()</span><br><span class="line">    &#123;</span><br><span class="line">        SynchronizationContext.SetSynchronizationContext(new UniTaskSynchronizationContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个可选的选择，并不总是推荐；<code>UniTaskSynchronizationContext</code>性能不如<code>async UniTask</code>，并且不是完整的 UniTask 替代品。它也不保证与<code>UnitySynchronizationContext</code>完全兼容</p><h2 id="API-References"><a href="#API-References" class="headerlink" title="API References"></a>API References</h2><p>UniTask 的 API 参考由<a href="https://dotnet.github.io/docfx/">DocFX</a>和<a href="https://github.com/Cysharp/DocfxTemplate">Cysharp/DocfXTemplate托管在</a><a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.html">cysharp.github.io/UniTask</a>上。</p><p>例如，UniTask 的工厂方法可以在<a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.UniTask.html#methods-1">UniTask#methods</a>中看到。UniTaskAsyncEnumerable 的工厂/扩展方法可以在<a href="https://cysharp.github.io/UniTask/api/Cysharp.Threading.Tasks.Linq.UniTaskAsyncEnumerable.html#methods-1">UniTaskAsyncEnumerable#methods</a>中看到。</p><h2 id="UPM-Package"><a href="#UPM-Package" class="headerlink" title="UPM Package"></a>UPM Package</h2><h3 id="通过-git-URL-安装"><a href="#通过-git-URL-安装" class="headerlink" title="通过 git URL 安装"></a>通过 git URL 安装</h3><p>需要支持 git 包路径查询参数的 unity 版本（Unity &gt;= 2019.3.4f1，Unity &gt;= 2020.1a21）。您可以添加<code>https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask</code>到包管理器</p><p><strong><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025718.png" alt="img"></strong></p><p><a href="https://user-images.githubusercontent.com/46207/83702872-e0f17c80-a648-11ea-8183-7469dcd4f810.png"><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192025621.png" alt="image"></a></p><p>或添加<code>&quot;com.cysharp.unitask&quot;: &quot;https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask&quot;</code>到<code>Packages/manifest.json</code>.</p><p>如果要设置目标版本，UniTask 使用<code>*.*.*</code>发布标签，因此您可以指定一个版本，如<code>#2.1.0</code>. 例如<code>https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask#2.1.0</code>.</p><h3 id="通过-OpenUPM-安装"><a href="#通过-OpenUPM-安装" class="headerlink" title="通过 OpenUPM 安装"></a>通过 OpenUPM 安装</h3><p>该软件包在<a href="https://openupm.com/">openupm 注册表</a>中可用。建议通过<a href="https://github.com/openupm/openupm-cli">openupm-cli</a>安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CODE</span><br><span class="line">openupm add com.cysharp.unitask</span><br></pre></td></tr></table></figure><h2 id="NET-Core"><a href="#NET-Core" class="headerlink" title=".NET Core"></a>.NET Core</h2><p>对于 .NET Core，请使用 NuGet。</p><blockquote><p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/UniTask">UniTask</a></p></blockquote><p>.NET Core 版本的 UniTask 是 Unity UniTask 的子集，移除了 PlayerLoop 依赖的方法。</p><p>它以比标准 Task/ValueTask 更高的性能运行，但在使用时应注意忽略 ExecutionContext/SynchronizationContext。<code>AysncLocal</code>也不起作用，因为它忽略了 ExecutionContext。</p><p>如果您在内部使用 UniTask，但将 ValueTask 作为外部 API 提供，您可以编写如下（受<a href="https://github.com/mgravell/PooledAwait">PooledAwait</a>启发）代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CSHARP</span><br><span class="line">public class ZeroAllocAsyncAwaitInDotNetCore</span><br><span class="line">&#123;</span><br><span class="line">    public ValueTask&lt;int&gt; DoAsync(int x, int y)</span><br><span class="line">    &#123;</span><br><span class="line">        return Core(this, x, y);</span><br><span class="line"></span><br><span class="line">        static async UniTask&lt;int&gt; Core(ZeroAllocAsyncAwaitInDotNetCore self, int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            // do anything...</span><br><span class="line">            await Task.Delay(TimeSpan.FromSeconds(x + y));</span><br><span class="line">            await UniTask.Yield();</span><br><span class="line"></span><br><span class="line">            return 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UniTask 不会返回到原生 SynchronizationContext，但可以使用 `ReturnToCurrentSynchronizationContext`来让他返回</span><br><span class="line">public ValueTask TestAsync()</span><br><span class="line">&#123;</span><br><span class="line">    await using (UniTask.ReturnToCurrentSynchronizationContext())</span><br><span class="line">    &#123;</span><br><span class="line">        await UniTask.SwitchToThreadPool();</span><br><span class="line">        // do anything..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.NET Core 版本允许用户在与Unity共享代码时（例如<a href="https://github.com/Cysharp/MagicOnion/">CysharpOnion</a>），像使用接口一样使用UniTask。.NET Core 版本的 UniTask 可以提供丝滑的代码共享体验。</p><p>WhenAll 等实用方法作为 UniTask 的补充，由<a href="https://github.com/Cysharp/ValueTaskSupplement">Cysharp/ValueTaskSupplement</a>提供。</p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>此仓库基于MIT协议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UniTask&quot;&gt;&lt;a href=&quot;#UniTask&quot; class=&quot;headerlink&quot; title=&quot;UniTask&quot;&gt;&lt;/a&gt;UniTask&lt;/h1&gt;&lt;p&gt;为Unity提供一个高性能，0GC的async/await异步方案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="异步" scheme="https://liuyingbo.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Unity-网络开发（一）</title>
    <link href="https://liuyingbo.com/posts/c7963808.html"/>
    <id>https://liuyingbo.com/posts/c7963808.html</id>
    <published>2022-05-16T15:06:06.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络基本概念"><a href="#网络基本概念" class="headerlink" title="网络基本概念"></a>网络基本概念</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络的作用"><a href="#网络的作用" class="headerlink" title="网络的作用"></a>网络的作用</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108375.png" alt="image-20220516152347078"></p><p>在没有网络之前，每个人的设备（电脑等）都是彼此孤立的，网络的出现让设备之间可以相互通信</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108998.png" alt="image-20220516152329903"></p><p>网络是由若干设备和连接这些设备的链路构成，各种设备 间接或者直接通过介质相连</p><p>设备之间想要进行信息传递时，将想要传递的数据编码为2进制数值便可以被有效的传输。这些数据是以电脉冲的形式进行传输的</p><p>线缆中的电压是在高低状态之间进行变化的，因而</p><p>二进制中1是通过产生一个正电压来传输的，二进制中0是通过产生一个负电压来传输的</p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108704.png" alt="image-20220516165921984"></p><p>局域网（Local Area Network，简称LAN）</p><p>是按照范围划分而来的名称，是指在某一个小区域内由多台设备互联成的计算机组，可以是家里的两台设备组成</p><p>也可以是学校、公司里的上千台设备组成，特点是分布地区范围有限，覆盖范围一般是方圆几千米之内</p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>以太网是一种计算机局域网技术，是目前应用最普遍的局域网技术</p><p>IEEE组织（电气与电子工程师协会）的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容</p><p>说人话：</p><p>局域网中设备的连接规范，数据的传输规范等等规则，都是基于以太网的技术标准来完成的</p><p>所以，简单理解以太网就是网络连接的一种规则（协议）</p><h3 id="以太网-网络拓扑结构"><a href="#以太网-网络拓扑结构" class="headerlink" title="以太网 网络拓扑结构"></a>以太网 网络拓扑结构</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108930.png" alt="image-20220516165946400"></p><p>概念：</p><p>用传输媒体把计算机等各种设备互相连接起来的物理布局，是指设备互连过程中构成的几何形状</p><h3 id="局域网-1"><a href="#局域网-1" class="headerlink" title="局域网"></a>局域网</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108975.png" alt="image-20220516160851306"></p><p>城域网（Metropolitan Area Network，简称MAN）</p><p>是在一个城市范围内所建立的网络通常覆盖一个城市，从几十公里到一百公里不等，可能会有多种介质用户的数量也比局域网更多</p><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108468.png" alt="image-20220516160917725"></p><p>广域网（Wide Area Network，简称WAN）</p><p>又称外网、公网，是连接不同地区局域网或城域网设备通信的远程网，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，形成国际性的远程网络</p><p>注意：广域网并不等同于互联网</p><h3 id="互联网（因特网）"><a href="#互联网（因特网）" class="headerlink" title="互联网（因特网）"></a>互联网（因特网）</h3><p>互联网，如果作为名词理解的话，就是互相联网，让各种设备处于同一网络环境下，只要设备互相连接网络了，那么设备之间就可以进行通信</p><p>它一般泛指彼此能够通信的设备组成的网络，但是目前我们往往提到的互联网，大部分时候都是指代的因特网，你可以把互联网作为名词理解，也可以将互联网理解为因特网的代称</p><p>互联网（internet，音译为因特网）</p><p>又称国际网络，指的是网络与网络之间所串连成的庞大网络，这些网络以一组通用的协议（规则）相连，形成逻辑上的单一巨大国际网络。</p><p>互联网目前已经把200多个国家和地区的大部分设备连接了起来，形成了一个遍布全世界的网络。所以在一定程度上也可以说，互联网等同于广域网，广域网包含了互联网。互联网使用的技术，在广域网上一定有，但是某些广域网的技术，互联网上不一定有比如军用的广域网，普通老百姓是不会使用的</p><p>互联网（因特网）的本质就是人为定义的一系列协议（规则）总称为“互联网协议”</p><p>主要功能：</p><p>定义计算机如何接入互联网，以及接入互联网的计算机的通信标准，也就是为我们的设备定义连入标准，并且为传输的2进制数据定义一些传输规则，只要遵守这些规则来进行网络连接和数据传输，我们的各种设备就可以通过网络进行通讯，进行信息的交换</p><p>简单理解因特网：</p><p>它是国际上最大的互联网，所以当我们提到互联网时一般都代指因特网</p><p>它是指当前全球最大的、开放的、有众多网络互相连接而成的特定的计算机网络</p><p>它采用TCP/IP协议簇作为通信的规则，提供了包括万维网（WWW）、文件传输（FTP）、电子邮件（E-mail）、远程登录（Telnet）等等服务</p><p>只要我们的设备和应用程序遵守这套因特网的互联网规则，那么我们就可以在这个庞大的网络体系当中畅游</p><h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><p>万维网（World Wide Web，简称WWW，也称Web、3W等）</p><p>它是存储在因特网的计算机当中，数量巨大的文档（页面）的集合</p><p>它是无数个网络站点和网页的集合，是构成因特网的主要部分</p><p>我们平时用浏览器看到的内容就属于万维网，他们本质上就是一个个的文档（页面）</p><p>如果把因特网看做是网络的基础，那么万维网就可以被看做是对因特网的应用，是利用因特网规则的一种信息传递和呈现的手段，可以认为万维网就是网站和页面的统称</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>网络：由若干设备和连接这些设备的链路构成，设备间可以相互通信</p></li><li><p>局域网：指某一个小区域内由多台设备互联成的计算机组</p></li><li><p>以太网：网络连接的一种规则，定义了连接传输规范</p></li><li><p>城域网：是在一个城市范围内所建立的网络，几十到一百公里</p></li><li><p>广域网：是连接不同地区、城市、国家的远程网络，几十到几千公里</p></li><li><p>互联网（因特网）：是目前国际上最大的互联网，定义了通信规则等</p></li><li><p>万维网：是基于因特网的网站和网页的统称</p></li></ol><h2 id="IP、端口、Mac地址"><a href="#IP、端口、Mac地址" class="headerlink" title="IP、端口、Mac地址"></a>IP、端口、Mac地址</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>只要通过网络连接，我们的设备之间就可以进行信息的传递</p><p>当传递消息时，如何准确的将信息传递到目标设备？</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108598.png" alt="image-20220516165747856"></p><p>基本概念：</p><p>IP地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址</p><p>IP地址是IP协议提供的一种统一的地址格式，IP地址是设备在网络中的具体地址</p><p>IP地址就像是设备的家庭住址一样，被用来给互联网上的电脑一个编号，用于定位</p><p>我们可以用打电话举例子，IP地址就好像是电话号码，我们需要知道对方设备的电话号码，才能联系到对方</p><h4 id="按协议分类（目前常用的还是IPv4的规则）："><a href="#按协议分类（目前常用的还是IPv4的规则）：" class="headerlink" title="按协议分类（目前常用的还是IPv4的规则）："></a>按协议分类（目前常用的还是IPv4的规则）：</h4><h5 id="1-IPv4："><a href="#1-IPv4：" class="headerlink" title="1.IPv4："></a>1.IPv4：</h5><p>互联网协议第四版，由四个数组成，每个数取值范围是0~255</p><p>每个数用 . 来分隔，它的数量是有限的 0.0.0.0~255.255.255.255</p><p>相当于是由4个字节表示，一个字节八位，255的2进制数则是 1111 1111</p><p>A类：0.x.x.x~127.x.x.x （32位2进制最高位为0，适用于网内主机数达1600万台的大型网络）</p><p>B类：128.x.x.x~191.x.x.x（32位2进制最高2位为10，适用于中等规模网络，每个网络能容纳6万台设备）</p><p>C类：192.x.x.x~223.x.x.x（32位2进制最高3位为110，适用小规模局域网，每个网内最多只包含254台设备）</p><p>D类：224.x.x.x~239.x.x.x（32位2进制最高4位为1110，属于特殊类型IP，一般为广播地址）</p><p>E类：240.x.x.x~255.x.x.x（32位2进制最高5位为11110，作为特殊使用）</p><h5 id="2-IPv6："><a href="#2-IPv6：" class="headerlink" title="2.IPv6："></a>2.IPv6：</h5><p>互联网协议第六版，由八个数组成，每个数取值范围是0~65535</p><p>每个数用 : 来分隔，它是为了解决IPv4的有限性而设计的（几乎无限）</p><p>0:0:0:0:0:0:0:0~65535:65535:65535:65535:65535:65535:65535:65535</p><h4 id="按使用范围分类："><a href="#按使用范围分类：" class="headerlink" title="按使用范围分类："></a>按使用范围分类：</h4><h5 id="1-公网IP："><a href="#1-公网IP：" class="headerlink" title="1.公网IP："></a>1.公网IP：</h5><p>用于连接外网，想要和远程设备进行通信时使用的IP地址</p><p>查看方式：百度搜索IP地址查询 便可以查看到公网IP</p><h5 id="2-私网IP："><a href="#2-私网IP：" class="headerlink" title="2.私网IP："></a>2.私网IP：</h5><p>也称局域网IP，私网IP不能上网，只用于局域网内通信</p><p>查看方式：1.在windows操作系统中打开命令提示符窗口</p><p>然后输入指令ipconfig查看本机的IP地址信息</p><p>快捷方式：运行窗口（win+R）-&gt; 打开cmd -&gt; ipconfig</p><p>2.在mac操作系统中打开终端窗口</p><p>然后输入指令ifconfig查看本机的IP地址信息</p><p>也可以在网络设置窗口上直接查看IP地址</p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>通过IP地址我们可以在网络上找到一台设备，但是我们想要和设备通信，本质上是和运行在设备上的某一个应用程序进行通信，而一台设备上可能运行n个应用程序，而端口号就是用来区分这些应用程序的，让我们可以明确到底是和哪一个应用程序进行通信</p><p>基本概念：</p><p>IP地址决定了设备在网络中的具体地址，而端口是不同应用程序在该设备上的门牌号码，一台设备上不同的应用程序想要进行通信就必须对应一个唯一的端口号</p><p>使用规则：</p><p>端口号的取值范围是0~65535</p><p>我们在进行网络程序开发时，需要自己为应用程序设置端口号，端口号不能和其它应用程序相同，避免产生冲突一般选择1024以上的端口进行使用，1024以下的一般由IANA互联网数字分配机构管理</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242108935.png" alt="image-20220516170203510"></p><h3 id="Mac地址"><a href="#Mac地址" class="headerlink" title="Mac地址"></a>Mac地址</h3><p>基本概念：Mac地址（Media Access Control Address）</p><p>直译为媒体存取控制地址，也称局域网地址，Mac地址，以太网地址，物理地址</p><p>它是用来确认网络设备位置的地址，在OSI模型中，第三层网络层负责IP地址，第二层数据链路层，则负责Mac地址，Mac地址是用于在网络中唯一标识一个网卡的，一台设备可以有多个网卡，每个网卡都会有一个唯一的Mac地址</p><p>在早期的网络中，只用Mac地址便可以实现两台设备间的通信，但随着设备的增多，Mac地址虽然具备唯一性但是并不携带位置信息，如果通过广播方式查找设备，会给网络造成巨大负担。所以才有了IP地址来定位网络中的设备</p><p>MAC地址就像身份证号，IP地址就好像你的住址。</p><p>MAC地址是物理层面上通信的基础，IP地址是逻辑层面上通信的基础</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109437.png" alt="image-20220516170335933"></p><p>总结：</p><p>在互联中寻找一台指定设备就好像在现实世界中去找朋友串门</p><p>你必须要知道朋友的地址在哪里</p><p>IP地址 = 朋友的住址（某街某小区某栋楼）</p><p>端口 = 朋友住所具体的门牌号 （具体哪个应用程序）</p><p>在网络通信中</p><p>我们通过IP地址 以及 端口号定位想要通信的远端计算机中的某一个应用程序</p><p>IP地址 = 设备在外网中位置</p><p>端口 = 运行在该设备上的应用程序位置</p><p>Mac地址 = 设备进行网络通信的唯一标识，设备真正进行物理信息传输用来定位的标识</p><h2 id="客户端和服务端"><a href="#客户端和服务端" class="headerlink" title="客户端和服务端"></a>客户端和服务端</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>名词角度解释含义</p><p>客户端：</p><p>用户使用的设备（计算机、手机、平板等等）</p><p>客户端应用程序：</p><p>用户使用的设备上安装的应用程序，用户会直接使用操作的内容</p><p>比如各种游戏、聊天软件、外卖软件等等</p><p>往往提到客户端都泛指的是客户端应用程序</p><p>基本概念：</p><p>客户端（Client，或称为用户端、前端）是指与服务端相对应，为客户提供本地服务的应用程序</p><p>我们在设备上（计算机、手机等）使用的所有软件和应用几乎都是客户端应用程序</p><p>比如：</p><p>各种浏览器，游戏，外卖应用程序（美团，饿了么），通讯软件（QQ、微信、陌陌）等等</p><p>他们都可以统称为客户端应用程序（简称客户端）</p><p>说人话：</p><p>用户在设备上（计算机、手机、平板）运行使用的应用程序就是客户端应用程序（简称客户端）</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>名词角度解释含义</p><p>服务端：</p><p>为客户端提供服务的设备，一般是一台性能较好的计算机</p><p>服务端应用程序：</p><p>为客户端提供服务的应用程序，该应用程序是运行在服务端设备上的</p><p>往往在软件开发中提到的服务端或服务器都是泛指服务端应用程序</p><p>基本概念：</p><p>服务端（Server，或称为服务器、后端）是为客户端服务的，服务的内容诸如向客户端提供资源，保存客户端数据等等</p><p>它是一种有针对性的服务程序，往往一个服务端都是针对性的为某类客户端提供服务</p><p>它往往是一台运行在远端的计算机，客户端和服务端通过网络进行通信</p><p>比如：</p><p>某游戏服务端它只为该游戏的客户端提供服务（消息转发、信息保存、逻辑处理等等）</p><p>某外卖服务端它只为该外卖的客户端提供服务（分派订单、查看订单、查看配送进度等等）</p><p>说人话：服务端应用程序运行在远端的一台计算机上，客户端通过网络和服务端进行通讯</p><p>服务端为客户端提供各种服务</p><h3 id="网络游戏开发中的客户端和服务端"><a href="#网络游戏开发中的客户端和服务端" class="headerlink" title="网络游戏开发中的客户端和服务端"></a>网络游戏开发中的客户端和服务端</h3><p>单机游戏：</p><p>只有客户端，没有服务端，不存在玩家之间的交互，数据存储在本地</p><p>网络游戏：</p><p>有客户端和服务端，玩家之间可以进行交互（信息同步，信息交换），静态（不变的）数据存储在客户端，动态（要变的）数据存储在服务端</p><p>网络游戏开发中的客户端：</p><p>Unity、UE、Cocos、Egret、Laya、Flash等等游戏引擎开发的游戏都属于客户端应用程序，他们都是被用户直接操作的，主要功能就是游戏玩法、UI交互、美术表现、本地数据保存等等</p><p>网络游戏开发中的服务端：</p><p>C++、Java、C#、Go等等语言开发的运行在远端计算机上为游戏客户端提供服务的软件都属于服务端应用程序，它的主要功能就是消息转发、数据保存、逻辑处理等等</p><p>总结：</p><ol><li>客户端</li></ol><p>用户在设备上（计算机、手机、平板）运行使用的应用程序就是客户端应用程序（简称客户端）</p><ol><li>服务端</li></ol><p>服务端应用程序运行在远端的一台计算机上，客户端通过网络和服务端进行通讯，服务端为客户端</p><p>提供各种服务</p><ol><li>网络游戏开发中的客户端和服务端</li></ol><p>我们用Unity开发的应用程序就是游戏客户端应用程序</p><p>后端程序员可以使用C++、C#、Java、Go等等语言进行服务端程序开发，为游戏客户端提供服务</p><p>客户端和服务端之前通过互联网进行信息交换</p><h2 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h2><h3 id="数据通信模型-1"><a href="#数据通信模型-1" class="headerlink" title="数据通信模型"></a>数据通信模型</h3><p>在早期的计算机网络中，为了有效的利用计算机，一般将数据通信模型分为</p><p>分散式（Decentralized）</p><p>集中式（Centralized）</p><p>分布式（Distributed）</p><p>这三种方式决定了数据在网络环境中的管理方式</p><h4 id="分散式"><a href="#分散式" class="headerlink" title="分散式"></a>分散式</h4><p>在分散式系统中，用户只负责管理自己的计算机系统，各自独立的系统之间没有资源或信息的交换和共享。就类似一台台没有联网的设备</p><p>这种模式由于存在大量共享数据的重复存储，除了引起数据冗余之外，也容易导致一个组织内各部门数据的不一致性。</p><p>同时还会造成硬件、支持和运营维护等成本的大量增加，因此早被淘汰</p><h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><p>在集中式环境中，用一台主计算机保存一个组织的全部数据，而用户则通过设备连接到这台计算机系统并和它通信，从而达到访问数据的目的</p><p>优点：方便数据共享、消除了数据的冗余和不一致性</p><p>缺点：可靠性不如分散式，主机出现故障所有系统全部瘫痪</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>分布式是分散式和集中式的混合，类似我们学习过的计算机网络，是分散式的水平交互和集中式的垂直控制相结合的一种模式，它兼具了分散式和集中式的优点</p><p>方便数据共享、消除了数据的冗余和不一致性，同样也加强了容错性</p><p>例如：</p><p>比如一般的企业管理系统就是一个典型的集中式和分布式的综合体现</p><p>所有数据用专用的数据库集中存储，属于集中式</p><p>而对数据的处理则由各个部门的软件分别控制，属于分布式</p><h3 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h3><p>C/S(Client/Server)模型也叫C/S模式</p><p>就是我们上节课学习的客户端和服务端模式，它是目前大多数网络通信采用的模型</p><p>从程序的角度来说，客户端和服务端打交道，相当于是两个应用程序（进程）在打交道</p><h3 id="B-S模型"><a href="#B-S模型" class="headerlink" title="B/S模型"></a>B/S模型</h3><p>B/S(Browse/Server)模型也叫B/S模式</p><p>它是一种基于Web的通信模型，使用HTTP超文本传送协议通信，B/S是一种特殊的C/S模型，特殊之处就是这种模型的客户端不需要我们自己开发，一般是某种浏览器，比如IE、Chrome、QQ浏览器、360浏览器等等，B/S模型的优点就是单台计算机可以访问任何一个Web服务器</p><p>简单的说就是Web服务端可以随意变，但是客户端是通用的，我们不需要针对不同的服务端专门提供客户端应用程序了</p><h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><p>P2P(Peer-to-Peer)模型也叫对等互联</p><p>每个联网的设备同时运行一个应用程序的客户端（Client）和服务端（Server）部分，也就是说一个应用程序同时作为客户端和服务端</p><p>优点是通信方便，成本低，缺点是可靠性不如C/S模型</p><p>总结</p><p>对于网络游戏开发来说，我们采用C/S模型来进行前后端开发，在服务端的布局上往往使用的是分布式的形式进行管理</p><p>比如服务端的用户数据使用集中式进行管理，玩家的数据都存储在数据库应用（SQL Server、MySQL）中，服务端应用程序使用分布式进行管理，账号服务器、游戏服务器、聊天服务器、跨服PVP服务器等分布式管理，这些服务端应用程序都使用数据库中的数据分别进行逻辑处理</p><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h2 id="网络协议概述"><a href="#网络协议概述" class="headerlink" title="网络协议概述"></a>网络协议概述</h2><h3 id="网络协议概述-1"><a href="#网络协议概述-1" class="headerlink" title="网络协议概述"></a>网络协议概述</h3><p>协议的字面意思：</p><p>经过谈判、协商而制定的共同承认、共同遵守的文件</p><p>网络协议的基本概念：</p><p>网络协议是计算机网络中进行数据交换而建立的规则、标准或约定的集合</p><p>指的是计算机网络中互相通信的对等实体之间交换信息时所必须遵守的规则的集合</p><p>说人话：</p><p>如果你想要在网络环境中进行通信，那么网络协议就是你必须遵守的规则</p><p>OSI模型是网络通信的基本规则</p><p>TCP/IP协议是基于OSI模型的工业实现</p><p>说人话：</p><p>OSI模型是国际组织定义的一套理论基础，主要用于定义网络通信的规则</p><p>TCP/IP协议是基于这套理论基础真正实现的通信规则</p><p>网络通信API底层都是基于TCP/IP协议的</p><p>总结：</p><p>2进制数据应该如何加工，如何准确</p><p>的传递到目标设备当中，在数据传递过程中具体的规则标准是什么</p><p>而这些规则标准都是由网络协议制定的</p><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><h3 id="OSI模型是什么"><a href="#OSI模型是什么" class="headerlink" title="OSI模型是什么"></a>OSI模型是什么</h3><p>OSI（Open System Interconnection Reference Model）开放式系统互联通信参考模型，简称OSI模型</p><p>它是一种概念模型</p><p>由ISO（International Organization for Standardization）国际标准化组织提出，是一个试图使各种设备在世界范围内互联为网络的标准框架，不同公司都按照统一的标准来控制网络互联通信，那么各设备之间就能够达到真正的互联通信了</p><p>说人话：</p><p>OSI模型是人为定义的一个标准（规范），它制定了设备之间相互连接相互通信的标准（规范）</p><p>各公司按照这个标准设计的规则（协议），就可以让不同设备利用互联网进行互联通信</p><h3 id="OSI模型的规则"><a href="#OSI模型的规则" class="headerlink" title="OSI模型的规则"></a>OSI模型的规则</h3><p>由于互联网协议（规则）很庞大，很复杂，所以OSI模型采用了分而治之的设计方法，把网络的功能划分为不同的多个模块，以分层的形式有机地组合在了一起</p><p>OSI模型将复杂的互联网实现 分成了好几层（部分），每一层都有自己的功能，就好像建筑物一样，从上到下有很多层构成，每一层都要靠下一层的支持用户接触到的都只是最上面的一层，感受不到下面层级的复杂性</p><p>OSI模型把互联通信的过程抽象的分成了七个层级</p><p>1.应用层</p><p>2.表示层</p><p>3.会话层</p><p>4.传输层</p><p>5.网络层</p><p>6.数据链路层</p><p>7.物理层</p><p>不同层级的职能各有不同，这7个层级就是在两台计算机互联通信时必经的7个步骤</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109287.png" alt="image-20220516172955696"></p><h3 id="OSI模型每层的职能"><a href="#OSI模型每层的职能" class="headerlink" title="OSI模型每层的职能"></a>OSI模型每层的职能</h3><p>第一部分：从地基开始</p><p>物理层—&gt;数据链路层—&gt;网络层—&gt;传输层</p><p>第二部分：从屋顶开始</p><p>应用层—&gt;表示层—&gt;会话层</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109922.png" alt="image-20220516173120258"></p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>电脑要联网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p>功能：</p><p>它就是把电脑连接起来的物理手段，它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。物理层将2进制数据利用电脉冲，在物理媒介上实现比特流的传输，它的主要功能是，定义传输模式、定义传输速率、比特同步、比特编码等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109896.png" alt="image-20220516173248105"></p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>物理层用物理硬件来传输0和1，但是单纯的0和1没有任何意义</p><p>必须规定解读方式，比如多少个电信号算一组？每个信号位的意义？</p><p>这就是数据链路层的意义，它在物理层的上方确定0和1的分组方式，并且明确信息是发送给哪台计算机的网卡（Mac地址）</p><p>功能：</p><p>将想要发送的信息构成一个数据包，叫做“帧”，每一个帧分为两个部分：标头Head+数据Data，标头包含数据包的一些说明项</p><p>比如：发送方和接收方的Mac地址，数据类型等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109712.png" alt="image-20220516173306909"></p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>通过Mac地址定位一台计算机，理论上是可行的，但是效率非常低下，我们之前学习过IP地址、端口、Mac地址，我们知道我们是通过IP地址，快速的定位网络上的设备的，而网络层的主要功能就和IP地址有关系</p><p>功能：</p><p>IP选址、路由选择</p><p>在网络环境中，两台设备之间可能会经过很多个数据链路，也可能还要经过很多通信子网</p><p>网络层的主要作用就是选择一条合适的路径用于通信。它会在上一层的数据基础上添加标头</p><p>包含信息：IP地址、版本、长度等等信息</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109490.png" alt="image-20220516173416163"></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>有了Mac地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信了，但是如果没有端口号，我们无法准确的在应用程序之间进行通信。传输层的功能，就是建立端口到端口的通信</p><p>功能：</p><p>建立、管理和维护端到端的连接</p><p>传输层也称运输层，传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务。它也会在上一层的数据基础上添加标头</p><p>包含信息：发送方接收方的端口信息、协议信息等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109795.png" alt="image-20220516173509663"></p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层为最上层，和用户直接打交道的可以联网的应用程序就属于这一层，比如浏览器，游戏等等</p><p>功能：</p><p>为应用程序提供服务，我们可以根据自己要传递的信息，决定使用哪一种协议（规则）来处理数据，进行传输</p><p>我们程序员主要开发的也是这一层，它会在原始数据的基础上添加标头</p><p>包含信息：协议信息等等</p><p>常用的协议（规则）：</p><p>FTP，HTTP，SMTP等等</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109710.png" alt="image-20220516173623087"></p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>不同操作系统的应用层代码和数据可能规范都不一样，为了让信息可以在各操作系统和设备中通用，表示层做的事情就很重要了</p><p>功能：</p><p>数据格式转化、代码转换、数据加密</p><p>为了让不同设备之间能够有统一的规则，表示层会把数据转换为能与各系统格式，兼容并且适合传输的格式，表示层就像是个翻译，会把数据相关信息，翻译成国际通用的规则</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109213.png" alt="image-20220516173637261"></p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>有了准备好的上层数据，那么这些数据最终就是希望被传递的内容，那么在信息传递时我们需要对其进行管理，比如消息是否发送完毕，对方是否收到，是否断开连接等等，会话层的主要工作就是完成这些内容</p><p>功能：</p><p>建立、管理和维护会话，它主要负责数据传输中设置和维护，网络中两台设备之间的通信连接。它不参与具体的传输，主要提供包括访问验证和会话管理，在内的建立和维护应用之间通信的机制</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109808.png" alt="image-20220516173855746"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242109012.png" alt="image-20220516173905252"></p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><h3 id="TCP-IP协议是什么"><a href="#TCP-IP协议是什么" class="headerlink" title="TCP/IP协议是什么"></a>TCP/IP协议是什么</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol）</p><p>TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议，是指能够在多个不同网络间实现信息传输的协议簇，它是一个工业标准（就是实际会使用的标准）</p><p>TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等等协议构成的协议簇 ，只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议，用于互联网的通信协议（规则）</p><p>说人话：</p><p>TCP/IP协议是一系列规则（协议）的统称，他们定义了消息在网络间进行传输的规则，是供已连接互联网的设备进行通信的通信规则</p><p>比如：在传输文件时我们使用其中的FTP文件传输协议；在传输电子邮件时我们使用其中的SMTP邮件传输协议；在定位远端计算机位置时我们使用其中的IP互联网协议地址</p><h3 id="TCP-IP协议的规则"><a href="#TCP-IP协议的规则" class="headerlink" title="TCP/IP协议的规则"></a>TCP/IP协议的规则</h3><p>TCP/IP网络结构体系实际上是基于OSI七层模型设计出来的。</p><p>OSI七层模型只是一个概念模型，它主要用于描述、讨论和理解单个网络功能，而TCP/IP协议是为了解决一组特定的问题而设计的，它是基于互联网开发的标准协议（规则）</p><p>说人话：</p><p>OSI模型只是一个基本概念，而TCP/IP协议是基于这个概念的具体实现</p><p>TCP/IP协议把互联通信的过程抽象的分成了四个层级</p><p>1.应用层</p><p>2.传输层</p><p>3.网络层</p><p>4.网络接口层（数据链路层）</p><p>这四层是基于OSI七层模型进行设计的</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242110763.png" alt="image-20220516182605652"></p><h3 id="TCP-IP协议每层的职能"><a href="#TCP-IP协议每层的职能" class="headerlink" title="TCP/IP协议每层的职能"></a>TCP/IP协议每层的职能</h3><p>应用层头：</p><p>协议头（FTP、HTTP等协议）</p><p>一般决定传输信息的类型</p><p>传输层头：</p><p>协议端口头（TCP或UDP协议）</p><p>一般决定传输信息的规则以及端口</p><p>网路层头：</p><p>IP头，决定传输路线</p><p>网络接口层头尾：</p><p>产生帧（消息分段），决定最终路线</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122503.png" alt="image-20221124212209466"></p><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><h3 id="TCP-IP协议中的重要协议"><a href="#TCP-IP协议中的重要协议" class="headerlink" title="TCP/IP协议中的重要协议"></a>TCP/IP协议中的重要协议</h3><p>应用层协议：</p><p>HTTP协议：超文本传输协议</p><p>HTTPS协议：加密的超文本传输协议</p><p>FTP协议：文件传输协议</p><p>DNS：域名系统</p><p>传输层协议：</p><p>TCP协议：传输控制协议</p><p>UDP协议：用户数据报协议</p><p>网络层协议：</p><p>IP协议</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242110419.png" alt="image-20220516182904884"></p><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP：传输控制协议</p><p>UDP：用户数据报协议</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122969.png" alt="image-20220516182924119"></p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接，并且在消息传送过程中是有顺序的，并且是不会丢包（丢弃消息）的，如果某一条消息在传送过程中失败了，会重新发送消息，直到成功</p><p>它的特点是：</p><p>1.面向连接 —— 两者之间必须建立可靠的连接</p><p>2.一对一 —— 只能是1对1的建立连接</p><p>3.可靠性高 —— 消息传送失败会重新发送，不允许丢包</p><p>4.有序的 —— 是按照顺序进行消息发送的</p><h4 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h4><p>TCP协议中有一个重要概念：三次握手，四次挥手</p><p>三次握手建立连接</p><p>第一次握手（C—&gt;S）</p><p>TCP连接请求，告诉服务器我要和你建立连接</p><p>第二次握手（S—&gt;C）</p><p>TCP授予连接，告诉客户端准了，来吧</p><p>第三次握手（C—&gt;S）</p><p>TCP确认连接，告诉服务器，来就来</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122311.png" alt="image-20220516183057213"></p><p>四次挥手断开连接</p><p>第一次挥手（C—&gt;S）</p><p>告诉服务器我数据发完了，你如果还有消息就快发完</p><p>第二次挥手（S—&gt;C）</p><p>告诉客户端我知道了，请继续等待我的消息</p><p>第三次挥手（S—&gt;C）</p><p>告诉客户端消息发完了，你可以正式断开连接了</p><p>第四次挥手（C—&gt;S）</p><p>告诉服务器我等一会如果没有收到你回复我就断开了</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122681.png" alt="image-20220516183152714"></p><p>TCP有了这三次握手，四次挥手的规则，可以提供可靠的服务，通过TCP连接传送的数据，可以做到无差错、不丢失、不重复、且按顺序到达，它让服务器和客户端之间的数据传递变得更加的可靠</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP（User Datagram Protocol，用户数据报协议）是一种无需建立连接就可以发送封装的IP数据包的方法，提供面向事务的简单不可靠信息传送服务</p><p>它的特点是：</p><p>1.无连接 —— 两者之间无需建立连接</p><p>2.可靠性低 —— 消息可能在传送过程中丢失，丢失后不会重发</p><p>3.传输效率高 —— 由于它的可靠性低并且也无需建立连接，所以传输效率上更高一些</p><p>4.n对n —— TCP只能1对1连接进行消息传递，而UDP由于无连接所以可以n对n</p><p>UDP协议不像TCP协议需要建立连接有三次握手和四次挥手，当使用UDP协议发送信息时会直接把信息数据扔到网络上，所以也就造成了UDP的不可靠性，信息在这个传递过程中是有可能丢失的，虽然UDP是一个不靠谱的协议，但是由于它不需要建立连接，也不会像TCP协议那样携带更多的信息，所以它具有更好的传输效率</p><p>它具有资源消耗小，处理速度快的特点</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122739.png" alt="image-20220516183402307"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP：</p><p>更可靠，保证数据的正确性和有序性（三次握手四次挥手）</p><p>适合对信息准确性要求高，效率要求较低的使用场景</p><p>比如：游戏开发，文件传输，远程登录等等</p><p>UDP：</p><p>更效率，传输更快，资源消耗更少</p><p>适合对实时性要求高的使用场景</p><p>比如：直播，即时通讯，游戏开发等等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络基本概念&quot;&gt;&lt;a href=&quot;#网络基本概念&quot; class=&quot;headerlink&quot; title=&quot;网络基本概念&quot;&gt;&lt;/a&gt;网络基本概念&lt;/h1&gt;&lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="网络" scheme="https://liuyingbo.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Unity-网络开发（二）</title>
    <link href="https://liuyingbo.com/posts/f780d4d0.html"/>
    <id>https://liuyingbo.com/posts/f780d4d0.html</id>
    <published>2022-05-16T15:06:06.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><h2 id="网络游戏通信方案概述"><a href="#网络游戏通信方案概述" class="headerlink" title="网络游戏通信方案概述"></a>网络游戏通信方案概述</h2><h3 id="弱联网和强联网游戏"><a href="#弱联网和强联网游戏" class="headerlink" title="弱联网和强联网游戏"></a>弱联网和强联网游戏</h3><p>网络游戏是以C/S模型为基础进行开发的由客户端和服务端组成</p><p>弱联网游戏：</p><p>这种游戏不会频繁的进行数据通信，客户端和服务端之间每次连接只处理一次请求，服务端处理完客户端的请求后返回数据后就断开连接了</p><p>强联网游戏：</p><p>这种游戏会频繁的和服务端进行通信，会一直和服务端保持连接状态，不停的和服务器之间交换数据通过之前的知识我们知道，网络游戏是以C/S模型为基础进行开发的由客户端和服务端组成</p><p>弱联网游戏代表：</p><p>一般的三消类休闲游戏、卡牌游戏等都会是弱联网游戏，这些游戏的核心玩法都由客户端完成，客户端处理完成后只是告诉服务端一个结果，服务端验证结果即可，不需要随时通信</p><p>比如：开心消消乐、刀塔传奇、我叫MT等等</p><p>强联网游戏代表：</p><p>一般的MMORPG（角色扮演）、MOBA（多人在线竞技游戏）、ACT（动作游戏）等等都会是强联网游戏，这些游戏的部分核心逻辑是由服务端进行处理，客户端和服务端之间不停的在同步信息</p><p>比如：王者荣耀、守望先锋、和平精英等等</p><h3 id="长连接和短连接游戏"><a href="#长连接和短连接游戏" class="headerlink" title="长连接和短连接游戏"></a>长连接和短连接游戏</h3><p>长连接和短连接游戏是按照网络游戏通信特点来划分的</p><p>弱联网游戏——&gt;短连接游戏</p><p>强联网游戏——&gt;长连接游戏</p><p>短连接游戏：</p><p>需要传输数据时，建立连接，传输数据，获得响应，断开连接</p><p>通信特点：需要通信时再连接，通信完毕断开连接</p><p>通信方式：HTTP超文本传输协议、HTTPS安全的超文本传输协议（他们本质上是TCP协议）</p><p>长连接游戏：不管是否需要传输数据，客户端与服务器一直处于连接状态，除非一端主动断开，或</p><p>者出现意外情况（客户端关闭或服务端崩溃等）</p><p>通信特点：连接一直建立，可以实时的传输数据</p><p>通信方式：TCP传输控制协议 或 UDP用户数据报协议</p><h3 id="Socket、HTTP、FTP"><a href="#Socket、HTTP、FTP" class="headerlink" title="Socket、HTTP、FTP"></a>Socket、HTTP、FTP</h3><p>Socket：网络套接字，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制</p><p>主要用于制作长连接游戏（强联网游戏）</p><p>Http/Https：(安全的)超文本传输协议，是一个简单的请求-响应协议，它通常运行在TCP协议之上，它指定了客户端可能发送给服务端什么样的信息以及得到什么样的响应。</p><p>主要用于制作短连接游戏（弱联网游戏），也可以用来进行资源下载</p><p>FTP：文件传输协议，是用于在网络上进行文件传输的一套标准协议，可以利用它来进行网络上资源的下载和上传。它也是基于TCP的传输，是面向连接的，为文件传输提供了可靠的保证</p><h2 id="网络通信基础"><a href="#网络通信基础" class="headerlink" title="网络通信基础"></a>网络通信基础</h2><h3 id="IP地址和端口类"><a href="#IP地址和端口类" class="headerlink" title="IP地址和端口类"></a>IP地址和端口类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region IPAddress类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net;</span></span><br><span class="line"><span class="comment">//类名：IPAddress</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化IP信息的方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.用byte数组进行初始化</span></span><br><span class="line">byte[] ipAddress = <span class="keyword">new</span> byte[] &#123; <span class="number">118</span>, <span class="number">102</span>, <span class="number">111</span>, <span class="number">11</span> &#125;;</span><br><span class="line">IPAddress ip1 = <span class="keyword">new</span> <span class="built_in">IPAddress</span>(ipAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.用long长整型进行初始化</span></span><br><span class="line"><span class="comment">//4字节对应的长整型 一般不建议大家使用</span></span><br><span class="line">IPAddress ip2 = <span class="keyword">new</span> <span class="built_in">IPAddress</span>(<span class="number">0x79666F0B</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.推荐使用的方式 使用字符串转换</span></span><br><span class="line">IPAddress ip3 = IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;118.102.111.11&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊IP地址</span></span><br><span class="line"><span class="comment">//127.0.0.1代表本机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一些静态成员</span></span><br><span class="line"><span class="comment">//获取可用的IPv6地址</span></span><br><span class="line"><span class="comment">//IPAddress.IPv6Any</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region IPEndPoint类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net;</span></span><br><span class="line"><span class="comment">//类名：IPEndPoint</span></span><br><span class="line"><span class="comment">//IPEndPoint类将网络端点表示为IP地址和端口号，表现为IP地址和端口号的组合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(<span class="number">0x79666F0B</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">IPEndPoint ipPoint2 = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;118.102.111.11&quot;</span>), <span class="number">8080</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//程序表示IP信息</span></span><br><span class="line">IPAddress ip = IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;IPv4地址&quot;</span>);</span><br><span class="line"><span class="comment">//程序表示通信目标</span></span><br><span class="line">IPEndPoint point = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(ip, <span class="number">8080</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>域名解析也叫域名指向、服务器设置、域名配置以及反向IP登记等等，说得简单点就是将好记的域名解析成IP，IP地址是网络上标识站点的数字地址，但是IP地址相对来说记忆困难，所以为了方便记忆，采用域名来代替IP地址标识站点地址。</p><p>比如 我们要登录一个网页 www.baidu.com 这个就是域名 我们可以通过记忆域名来记忆一个远端服务器的地址，而不是记录一个复杂的IP地址</p><p>域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成，我们在进行通信时有时会有需求通过域名获取IP</p><p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务，它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网，是因特网上解决网上机器命名的一种系统，因为IP地址记忆不方便，就采用了域名系统来管理名字和IP的对应关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region IPHostEntry类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//类名：IPHostEntry</span></span><br><span class="line"><span class="comment">//主要作用：域名解析后的返回值 可以通过该对象获取IP地址、主机名等等信息</span></span><br><span class="line"><span class="comment">//该类不会自己声明，都是作为某些方法的返回值返回信息，我们主要通过该类对象获取返回的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取关联IP       成员变量:AddressList</span></span><br><span class="line"><span class="comment">//获取主机别名列表  成员变量:Aliases</span></span><br><span class="line"><span class="comment">//获取DNS名称      成员变量:HostName</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region Dns类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//类名：Dns</span></span><br><span class="line"><span class="comment">//主要作用：Dns是一个静态类，提供了很多静态方法，可以使用它来根据域名获取IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//1.获取本地系统的主机名</span></span><br><span class="line"><span class="built_in">print</span>(Dns.<span class="built_in">GetHostName</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取指定域名的IP信息</span></span><br><span class="line"><span class="comment">//根据域名获取</span></span><br><span class="line"><span class="comment">//同步获取</span></span><br><span class="line"><span class="comment">//注意：由于获取远程主机信息是需要进行网路通信，所以可能会阻塞主线程</span></span><br><span class="line">IPHostEntry entry = Dns.<span class="built_in">GetHostEntry</span>(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entry.AddressList.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;IP地址：&quot;</span> + entry.AddressList[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entry.Aliases.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;主机别名&quot;</span> + entry.Aliases[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;DNS服务器名称&quot;</span> + entry.HostName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步获取</span></span><br><span class="line"><span class="built_in">GetHostEntry</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><p>如果不知道对方的IP地址，想通过域名和对方进行通信，可以通过Dns类通过域名得到IP地址后再和对方建立连接并通信</p><h3 id="序列化和反序列化2进制数据"><a href="#序列化和反序列化2进制数据" class="headerlink" title="序列化和反序列化2进制数据"></a>序列化和反序列化2进制数据</h3><h4 id="网络通信中传输的数据"><a href="#网络通信中传输的数据" class="headerlink" title="网络通信中传输的数据"></a>网络通信中传输的数据</h4><p>在网络通信中</p><p>把想要传递的类对象信息序列化为2进制数据（一般为byte字节数组）</p><p>再将该2进制数据通过网络传输给远端设备</p><p>远端设备获取到该2进制数据后再将其反序列化为对应的类对象</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242122585.png" alt="image-20220518003846852"></p><p>序列化：</p><p>将类对象信息转换为可保存或传输的格式的过程</p><p>反序列化：</p><p>与序列化相对，将保存或传输过来的格式转换为类对象的过程</p><p>比如</p><p>将C#类对象序列化为xml、json、2进制三种格式的数据保存在本地，达到持久化的目的，再将保存在本地的持久化数据文件反序列化为C#类对象</p><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>字符编码（英语：Character encoding）也称字集码</p><p>是把字符集中的字符，编码为指定集合中某一对象，以便文本在计算机中存储或通过网络进行传递。</p><p><strong>说人话：计算机里只能存数字（2机制），所以如果文字字符想要进行存储的话，就需要把对应的文字字符转换为数字才能进行处理，而字符编码就是文字字符在计算机中和数值的对应关系，是人为定义的一种映射规则。</strong>比如</p><p>ASCII码（一种字符编码规则）中 数值65 用来映射 字符A</p><p>我们存储 A 这个字符，本质上存在内存中的是数值65对应的2进制是0100 0001</p><p>常见的一些字符编码规则有</p><p><strong>每个国家针对自己国家语言制定的编码规则（因为语言文字的数量各不相同）</strong></p><p><strong>ASCII码（美国）、GB2312编码（中国）、Shift_JIS编码（日本）、Euc-kr（韩国）等等</strong></p><p>世界通用的编码规则（把所有语言统一到一套编码里）</p><p><strong>Unicode编码 以及 基于Unicode实现的编码规则</strong></p><p><strong>UTF-8、UTF-16、UTF-32</strong></p><h4 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h4><p>假设我们的一个文件是采用中国制定的GB2312编码进行编辑存储的，而此时我们并不使用GB2312这个编码规则去读取文件，而是采用其它的规则，比如日本制定的Shift_JIS编码读取该文件，那么<strong>由于编码格式的存读不统一就会造成乱码的出现。因为不同的编码规则，字符和数值的映射关系是不同的。</strong></p><p>比如：130这个数值在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)，在中文编码中又会代表另一个符号。</p><h4 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a><strong>ASCII码</strong></h4><p>在计算机内部，所有的信息最终都是一个二进制值。</p><p>一个二进制数就是一位（bit），有0和1两种状态。一个字节（byte）是8个二进制数组成的，所以1 byte = 8 bit。</p><p>也就是说一个字节一共可以用来表示256种不同的状态，从00000000到11111111。如果每一个状态都代表一个符号的话，那么一个字节可以用来表示256个符号。</p><p>上个世界60年代，美国制定了一套算是最早的字符编码，制定了一套基于英文字符与二进制位之间的对应关系。这套标准被称为ASCII码，一直使用到今天。</p><p>ASCII码一共规定了128个字符的编码。比如：</p><p>字符 A = 65（十进制数）= 0100 0001（二进制数）</p><p>字符 1 = 49（十进制数）= 0011 0001（二进制数）等等</p><p>下图为ASCII码的对照表</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123917.png" alt="img"></p><p>这128个字符的编码规则，只占用了一个字节的后面7位，最前面的一位统一规定为0。  </p><p>英文国家使用128个字符编码就足够了，但是如果用来表示其它国家的语言，128个符号是远远不够的，于是乎就出现了非ASCII码们。</p><h4 id="非ASCII码"><a href="#非ASCII码" class="headerlink" title="非ASCII码"></a><strong>非ASCII码</strong></h4><p>非ASCII码基本都是基于ASCII码进行的扩充，他们都保留了ASCII码0~127这段编码的规范。也就是说非ASCII码的前面部分往往是和ASCII码的规则是相同的。</p><p>对于一些欧洲国家，他们使用一个字节便可以表示完自己所有的文字，他们利用了字节中闲置的最高位编入新的符号，因为我们知道ASCII码的编码规则是：一个字节中的8位，只占用了一个字节的后面7位，最前面的一位统一规定为0。所以这些语言系统中文字较少的国家让最前面的一位可以为1，他们就可以为自己的文字在128~255这一段加入新的对应规则。</p><p>比如：130这个数值在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)</p><p>这种一个字节就把字符表示完的做法只适用于语言系统中文字较少的国家，因为他们的语言的字母是有限的。</p><p>对于使用象形文字的国家来说，一个字节完全不够用！比如中国，我们的汉字多达10万左右，一个字节最多也只能表示256种符号，是远远不够的。所以必须使用多个字节来表示一个符号。比如我们前面提到的中国的简体中文GB2312编码，是使用两个字节表示一个汉字，所以理论上来说可以表示256x256=65536个符号。</p><p>所以所谓的非ASCII码，就是指的除了ASCII码以外的编码格式，每个国家都至少有1种针对自己语言文字的编码格式，每一个编码格式中 数值和字符的对应关系都可能不相同。这也就造成了前面说到的乱码问题。在全世界范围内进行网络通信时，如果每个国家都使用不统一的编码格式，那么出现乱码的情况将随处可见。</p><p>因此随着互联网的发展，人们决定要制定一套全世界统一的的编码规则，将世界上所有的符号都纳入其中，为每一个符号赋予独一无二的编码（2进制数值）。那么这样就不会出现乱码问题，影响信息的传递了。</p><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><strong>Unicode</strong></h4><p>Unicode可以理解为是 Unique Code 的简写，翻译过来是“唯一的编码”。</p><p>它出现的主要原因就是用来解决乱码问题的，它将世界上所有的符号都纳入其中，每一个符号都为其分配一个独一无二的二进制数表示它，那么乱码问题就会消失。</p><p>Unicode是一个很大的集合，现在的规模可以容纳100多万个符号，每个符号对应的二进制数都不一样。这样就确保了不同语言的字符不会再有冲突。</p><p>那么这样可能就存在一个问题，就是有的符号用1个字节8位就可以表示了，有的符号可能需要使用2个字节16位甚至3个字节24位才能表示。就比如说ASCII码，它的存储规则就是一个字节存储一个字符，那么当我们使用Unicode编码时，到底用几个字节来存储字符呢？</p><p>因此我们需要注意：<strong>Unicode编码只是一个符号集，它只规定符号和二进制的对应关系，并没有规定这个二进制数值应该如何存储。</strong></p><p><strong>而UTF-8、UTF-16、UTF-32三种编码格式才是基于Unicode实现的具体编码方案</strong></p><p>UTF-8编码：可变字节编码方案，可以根据实际情况使用1个、2个、3个、4个字节来存储字符</p><p>UTF-16编码：可变字节编码方案，可以根据实际情况使用2个、4个字节来存储字符</p><p>UTF-32编码：固定字节编码方案，用4个字节来存储字符</p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><strong>UTF-8</strong></h4><p>UTF-8是Unicode的实现方式之一，它的最大特点是：它是一种变长的编码方式，可以使用1~4个字节表示一个字符，根据不同的符号而变化字节的长度。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123273.png" alt="img"></p><p><strong>Unicode是世界上所有符号对应二进制数据的关系集合</strong></p><p><strong>UTF-8是Unicode的实现方式之一：UTF-8 = Unicode符号集 + 变长的编码规则</strong></p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region 非字符串类型转字节数组</span></span><br><span class="line"><span class="comment">//关键类：BitConverter</span></span><br><span class="line"><span class="comment">//所在命名空间：System</span></span><br><span class="line"><span class="comment">//主要作用：除字符串的其它常用类型和字节数组相互转换</span></span><br><span class="line"></span><br><span class="line">byte[] bytes = BitConverter.<span class="built_in">GetBytes</span>(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 字符串类型转字节数组</span></span><br><span class="line"><span class="comment">//关键类：Encoding</span></span><br><span class="line"><span class="comment">//所在命名空间：System.Text</span></span><br><span class="line"><span class="comment">//主要作用：将字符串类型和字节数组相互转换，并且决定转换时使用的字符编码类型，网络通信时建议大家使用UTF-8类型</span></span><br><span class="line">byte[] byte2 = Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;的卡萨福利卡决胜巅峰卡视角的副驾驶的&quot;</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 如何将一个类对象转换为二进制</span></span><br><span class="line"><span class="comment">//注意：网络通信中我们不能直接使用数据持久化2进制知识点中的</span></span><br><span class="line"><span class="comment">//BinaryFormatter 2进制格式化类</span></span><br><span class="line"><span class="comment">//因为客户端和服务器使用的语言可能不一样，BinaryFormatter是C#的序列化规则，和其它语言之间的兼容性不好</span></span><br><span class="line"><span class="comment">//如果使用它，那么其它语言开发的服务器无法对其进行反序列化</span></span><br><span class="line"><span class="comment">//我们需要自己来处理将类对象数据序列化为字节数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单纯的转换一个变量为字节数组非常的简单</span></span><br><span class="line"><span class="comment">//但是我们如何将一个类对象携带的所有信息放入到一个字节数组中呢</span></span><br><span class="line"><span class="comment">//我们需要做以下几步</span></span><br><span class="line"><span class="comment">//1.明确字节数组的容量（注意：在确定字符串字节长度时要考虑解析时如何处理）</span></span><br><span class="line">PlayerInfo info = <span class="keyword">new</span> <span class="built_in">PlayerInfo</span>();</span><br><span class="line">info.lev = <span class="number">10</span>;</span><br><span class="line">info.name = <span class="string">&quot;刘英博&quot;</span>;</span><br><span class="line">info.atk = <span class="number">88</span>;</span><br><span class="line">info.sex = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//得到的 这个Info数据 如果转换成 字节数组 那么字节数组容器需要的容量</span></span><br><span class="line"><span class="type">int</span> indexNum = <span class="built_in">sizeof</span>(<span class="type">int</span>) + <span class="comment">//lev int类型  4</span></span><br><span class="line">               <span class="built_in">sizeof</span>(<span class="type">int</span>) + <span class="comment">//代表 name字符串转换成字节数组后 数组的长度 4</span></span><br><span class="line">               Encoding.UTF8.<span class="built_in">GetBytes</span>(info.name).Length + <span class="comment">//字符串具体字节数组的长度</span></span><br><span class="line">               <span class="built_in">sizeof</span>(<span class="type">short</span>) + <span class="comment">//atk short类型 2</span></span><br><span class="line">               <span class="built_in">sizeof</span>(<span class="type">bool</span>); <span class="comment">//sex bool类型 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.申明一个装载信息的字节数组容器</span></span><br><span class="line">byte[] playerBytes = <span class="keyword">new</span> byte[indexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将对象中的所有信息转为字节数组并放入该容器当中（可以利用数组中的CopeTo方法转存字节数组）</span></span><br><span class="line"><span class="comment">//CopyTo方法的第二个参数代表 从容器的第几个位置开始存储</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;<span class="comment">//从 playerBytes数组中的第几个位置去存储数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等级</span></span><br><span class="line">BitConverter.<span class="built_in">GetBytes</span>(info.lev).<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//姓名</span></span><br><span class="line">byte[] strBytes = Encoding.UTF8.<span class="built_in">GetBytes</span>(info.name);</span><br><span class="line"><span class="type">int</span> num = strBytes.Length;</span><br><span class="line"><span class="comment">//存储的是姓名转换成字节数组后 字节数组的长度</span></span><br><span class="line">BitConverter.<span class="built_in">GetBytes</span>(num).<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="comment">//存储字符串的字节数组</span></span><br><span class="line">strBytes.<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//攻击力</span></span><br><span class="line">BitConverter.<span class="built_in">GetBytes</span>(info.atk).<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += <span class="built_in">sizeof</span>(<span class="type">short</span>);</span><br><span class="line"><span class="comment">//性别</span></span><br><span class="line">BitConverter.<span class="built_in">GetBytes</span>(info.sex).<span class="built_in">CopyTo</span>(playerBytes, index);</span><br><span class="line">index += <span class="built_in">sizeof</span>(<span class="type">bool</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><p>BitConverter转换非字符串的类型的变量为字节数组</p><p>Encoding.UTF8转换字符串类型的变量为字节数组（注意：为了考虑反序列化，我们在转存2进制，序列化字符串之前，先序列化字符串字节数组的长度）</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region 字节数组转非字符串类型</span></span><br><span class="line"><span class="comment">//关键类：BitConverter</span></span><br><span class="line"><span class="comment">//所在命名空间：System</span></span><br><span class="line"><span class="comment">//主要作用：除字符串的其它常用类型和字节数组相互转换</span></span><br><span class="line">byte[] bytes = BitConverter.<span class="built_in">GetBytes</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> i = BitConverter.<span class="built_in">ToInt32</span>(bytes, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">print</span>(i);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 字节数组转字符串类型</span></span><br><span class="line"><span class="comment">//关键类：Encoding</span></span><br><span class="line"><span class="comment">//所在命名空间：System.Text</span></span><br><span class="line"><span class="comment">//主要作用：将字符串类型和字节数组相互转换，并且决定转换时使用的字符编码类型，网络通信时建议大家使用UTF-8类型</span></span><br><span class="line">byte[] bytes2 = Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;123123空间大撒了房间阿斯利康放大镜&quot;</span>);</span><br><span class="line">string str = Encoding.UTF8.<span class="built_in">GetString</span>(bytes2, <span class="number">0</span>, bytes2.Length);</span><br><span class="line"><span class="built_in">print</span>(str);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 如何将二进制数据转为一个类对象</span></span><br><span class="line"><span class="comment">//1.获取到对应的字节数组</span></span><br><span class="line">PlayerInfo info = <span class="keyword">new</span> <span class="built_in">PlayerInfo</span>();</span><br><span class="line">info.lev = <span class="number">10</span>;</span><br><span class="line">info.name = <span class="string">&quot;刘英博&quot;</span>;</span><br><span class="line">info.atk = <span class="number">88</span>;</span><br><span class="line">info.sex = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">byte[] playerBytes = info.<span class="built_in">GetBytes</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.将字节数组按照序列化时的顺序进行反序列化(将对应字节分组转换为对应类型变量)</span></span><br><span class="line">PlayerInfo info2 = <span class="keyword">new</span> <span class="built_in">PlayerInfo</span>();</span><br><span class="line"><span class="comment">//等级</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">info2.lev = BitConverter.<span class="built_in">ToInt32</span>(playerBytes, index);</span><br><span class="line">index += <span class="number">4</span>;</span><br><span class="line"><span class="built_in">print</span>(info2.lev);</span><br><span class="line"><span class="comment">//姓名的长度</span></span><br><span class="line"><span class="type">int</span> length = BitConverter.<span class="built_in">ToInt32</span>(playerBytes, index);</span><br><span class="line">index += <span class="number">4</span>;</span><br><span class="line"><span class="comment">//姓名字符串</span></span><br><span class="line">info2.name = Encoding.UTF8.<span class="built_in">GetString</span>(playerBytes, index, length);</span><br><span class="line">index += length;</span><br><span class="line"><span class="built_in">print</span>(info2.name);</span><br><span class="line"><span class="comment">//攻击力</span></span><br><span class="line">info2.atk = BitConverter.<span class="built_in">ToInt16</span>(playerBytes, index);</span><br><span class="line">index += <span class="number">2</span>;</span><br><span class="line"><span class="built_in">print</span>(info2.atk);</span><br><span class="line"><span class="comment">//性别</span></span><br><span class="line">info2.sex = BitConverter.<span class="built_in">ToBoolean</span>(playerBytes, index);</span><br><span class="line">index += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print</span>(info2.sex);</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><p>BitConverter转换字节数组为非字符串的类型的变量</p><p>Encoding.UTF8转换字节数组为字符串类型的变量（注意：先读长度，再读字符串）</p><h2 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h2><h3 id="Socket概述"><a href="#Socket概述" class="headerlink" title="Socket概述"></a>Socket概述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region Socket套接字的作用</span></span><br><span class="line"><span class="comment">//它是C#提供给我们用于网络通信的一个类（在其它语言当中也有对应的Socket类）</span></span><br><span class="line"><span class="comment">//类名：Socket</span></span><br><span class="line"><span class="comment">//命名空间：System.Net.Sockets</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Socket套接字是支持TCP/IP网络通信的基本操作单位</span></span><br><span class="line"><span class="comment">//一个套接字对象包含以下关键信息</span></span><br><span class="line"><span class="comment">//1.本机的IP地址和端口</span></span><br><span class="line"><span class="comment">//2.对方主机的IP地址和端口</span></span><br><span class="line"><span class="comment">//3.双方通信的协议信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个Sccket对象表示一个本地或者远程套接字信息</span></span><br><span class="line"><span class="comment">//它可以被视为一个数据通道</span></span><br><span class="line"><span class="comment">//这个通道连接与客户端和服务端之间</span></span><br><span class="line"><span class="comment">//数据的发送和接受均通过这个通道进行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般在制作长连接游戏时，我们会使用Socket套接字作为我们的通信方案</span></span><br><span class="line"><span class="comment">//我们通过它连接客户端和服务端，通过它来收发消息</span></span><br><span class="line"><span class="comment">//你可以把它抽象的想象成一根管子，插在客户端和服务端应用程序上，通过这个管子来传递交换信息</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region Socket的类型</span></span><br><span class="line"><span class="comment">//Socket套接字有3种不同的类型</span></span><br><span class="line"><span class="comment">//1.流套接字</span></span><br><span class="line"><span class="comment">//  主要用于实现TCP通信，提供了面向连接、可靠的、有序的、数据无差错且无重复的数据传输服务</span></span><br><span class="line"><span class="comment">//2.数据报套接字</span></span><br><span class="line"><span class="comment">//  主要用于实现UDP通信，提供了无连接的通信服务，数据包的长度不能大于32KB，不提供正确性检查，不保证顺序，可能出现重发、丢失等情况</span></span><br><span class="line"><span class="comment">//3.原始套接字（不常用，不深入讲解）</span></span><br><span class="line"><span class="comment">//  主要用于实现IP数据包通信，用于直接访问协议的较低层，常用于侦听和分析数据包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Socket的构造函数 我们可以申明不同类型的套接字</span></span><br><span class="line"><span class="comment">//Socket s = new Socket()</span></span><br><span class="line"><span class="comment">//参数一：AddressFamily 网络寻址 枚举类型，决定寻址方案</span></span><br><span class="line"><span class="comment">//  常用：</span></span><br><span class="line"><span class="comment">//  1.InterNetwork  IPv4寻址</span></span><br><span class="line"><span class="comment">//  2.InterNetwork6 IPv6寻址</span></span><br><span class="line"><span class="comment">//  做了解：</span></span><br><span class="line"><span class="comment">//  1.UNIX          UNIX本地到主机地址 </span></span><br><span class="line"><span class="comment">//  2.ImpLink       ARPANETIMP地址</span></span><br><span class="line"><span class="comment">//  3.Ipx           IPX或SPX地址</span></span><br><span class="line"><span class="comment">//  4.Iso           ISO协议的地址</span></span><br><span class="line"><span class="comment">//  5.Osi           OSI协议的地址</span></span><br><span class="line"><span class="comment">//  7.NetBios       NetBios地址</span></span><br><span class="line"><span class="comment">//  9.Atm           本机ATM服务地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数二：SocketType 套接字枚举类型，决定使用的套接字类型</span></span><br><span class="line"><span class="comment">//  常用：</span></span><br><span class="line"><span class="comment">//  1.Dgram         支持数据报，最大长度固定的无连接、不可靠的消息(主要用于UDP通信)</span></span><br><span class="line"><span class="comment">//  2.Stream        支持可靠、双向、基于连接的字节流（主要用于TCP通信）</span></span><br><span class="line"><span class="comment">//  做了解：</span></span><br><span class="line"><span class="comment">//  1.Raw           支持对基础传输协议的访问</span></span><br><span class="line"><span class="comment">//  2.Rdm           支持无连接、面向消息、以可靠方式发送的消息</span></span><br><span class="line"><span class="comment">//  3.Seqpacket     提供排序字节流的面向连接且可靠的双向传输</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数三：ProtocolType 协议类型枚举类型，决定套接字使用的通信协议</span></span><br><span class="line"><span class="comment">//  常用：</span></span><br><span class="line"><span class="comment">//  1.TCP           TCP传输控制协议</span></span><br><span class="line"><span class="comment">//  2.UDP           UDP用户数据报协议</span></span><br><span class="line"><span class="comment">//  做了解：</span></span><br><span class="line"><span class="comment">//  1.IP            IP网际协议</span></span><br><span class="line"><span class="comment">//  2.Icmp          Icmp网际消息控制协议</span></span><br><span class="line"><span class="comment">//  3.Igmp          Igmp网际组管理协议</span></span><br><span class="line"><span class="comment">//  4.Ggp           网关到网关协议</span></span><br><span class="line"><span class="comment">//  5.IPv4          Internet协议版本4</span></span><br><span class="line"><span class="comment">//  6.Pup           PARC通用数据包协议</span></span><br><span class="line"><span class="comment">//  7.Idp           Internet数据报协议</span></span><br><span class="line"><span class="comment">//  8.Raw           原始IP数据包协议</span></span><br><span class="line"><span class="comment">//  9.Ipx           Internet数据包交换协议</span></span><br><span class="line"><span class="comment">//  10.Spx          顺序包交换协议</span></span><br><span class="line"><span class="comment">//  11.IcmpV6       用于IPv6的Internet控制消息协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、3参数的常用搭配：</span></span><br><span class="line"><span class="comment">//       SocketType.Dgram  +  ProtocolType.Udp  = UDP协议通信（常用，主要学习）</span></span><br><span class="line"><span class="comment">//       SocketType.Stream  +  ProtocolType.Tcp  = TCP协议通信（常用，主要学习）</span></span><br><span class="line"><span class="comment">//       SocketType.Raw  +  ProtocolType.Icmp  = Internet控制报文协议（了解）</span></span><br><span class="line"><span class="comment">//       SocketType.Raw  +  ProtocolType.Raw  = 简单的IP包通信（了解）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们必须掌握的</span></span><br><span class="line"><span class="comment">//TCP流套接字</span></span><br><span class="line">Socket socketTcp = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//UDP数据报套接字</span></span><br><span class="line">Socket socketUdp = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region Socket的常用属性</span></span><br><span class="line"><span class="comment">//1.套接字的连接状态</span></span><br><span class="line"><span class="keyword">if</span>(socketTcp.Connected)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取套接字的类型</span></span><br><span class="line"><span class="built_in">print</span>(socketTcp.SocketType);</span><br><span class="line"><span class="comment">//3.获取套接字的协议类型</span></span><br><span class="line"><span class="built_in">print</span>(socketTcp.ProtocolType);</span><br><span class="line"><span class="comment">//4.获取套接字的寻址方案</span></span><br><span class="line"><span class="built_in">print</span>(socketTcp.AddressFamily);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.从网络中获取准备读取的数据数据量</span></span><br><span class="line"><span class="built_in">print</span>(socketTcp.Available);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.获取本机EndPoint对象(注意 ：IPEndPoint继承EndPoint)</span></span><br><span class="line"><span class="comment">//socketTcp.LocalEndPoint as IPEndPoint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.获取远程EndPoint对象</span></span><br><span class="line"><span class="comment">//socketTcp.RemoteEndPoint as IPEndPoint</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region Socket的常用方法</span></span><br><span class="line"><span class="comment">//1.主要用于服务端</span></span><br><span class="line"><span class="comment">//  1-1:绑定IP和端口</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>);</span><br><span class="line">socketTcp.<span class="built_in">Bind</span>(ipPoint);</span><br><span class="line"><span class="comment">//  1-2:设置客户端连接的最大数量</span></span><br><span class="line">socketTcp.<span class="built_in">Listen</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//  1-3:等待客户端连入</span></span><br><span class="line">socketTcp.<span class="built_in">Accept</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.主要用于客户端</span></span><br><span class="line"><span class="comment">//  1-1:连接远程服务端</span></span><br><span class="line">socketTcp.<span class="built_in">Connect</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;118.12.123.11&quot;</span>), <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.客户端服务端都会用的</span></span><br><span class="line"><span class="comment">//  1-1:同步发送和接收数据</span></span><br><span class="line"><span class="comment">//  1-2:异步发送和接收数据</span></span><br><span class="line"><span class="comment">//  1-3:释放连接并关闭Socket，先与Close调用</span></span><br><span class="line">socketTcp.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line"><span class="comment">//  1-4:关闭连接，释放所有Socket关联资源</span></span><br><span class="line">socketTcp.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><h4 id="服务端和客户端需要做什么"><a href="#服务端和客户端需要做什么" class="headerlink" title="服务端和客户端需要做什么"></a>服务端和客户端需要做什么</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123242.png" alt="image-20220521151533548"></p><h4 id="TCP协议三次握手的体现"><a href="#TCP协议三次握手的体现" class="headerlink" title="TCP协议三次握手的体现"></a>TCP协议三次握手的体现</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123581.png" alt="image-20220521151638515"></p><h4 id="TCP协议四次挥手的体现"><a href="#TCP协议四次挥手的体现" class="headerlink" title="TCP协议四次挥手的体现"></a>TCP协议四次挥手的体现</h4><p><img src="/Users/liuyingbo/Library/Application Support/typora-user-images/image-20220521151714969.png" alt="image-20220521151714969"></p><h4 id="TCP基本API"><a href="#TCP基本API" class="headerlink" title="TCP基本API"></a>TCP基本API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region 实现服务端基本逻辑</span></span><br><span class="line"><span class="comment">//1.创建套接字Socket（TCP）</span></span><br><span class="line">Socket socketTcp = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line"><span class="comment">//2.用Bind方法将套接字与本地地址绑定</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>);</span><br><span class="line">    socketTcp.<span class="built_in">Bind</span>(ipPoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;绑定报错&quot;</span> + e.Message);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.用Listen方法监听</span></span><br><span class="line">socketTcp.<span class="built_in">Listen</span>(<span class="number">1024</span>);</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;服务端绑定监听结束，等待客户端连入&quot;</span>);</span><br><span class="line"><span class="comment">//4.用Accept方法等待客户端连接</span></span><br><span class="line"><span class="comment">//5.建立连接，Accept返回新套接字</span></span><br><span class="line">Socket socketClient = socketTcp.<span class="built_in">Accept</span>();</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;有客户端连入了&quot;</span>);</span><br><span class="line"><span class="comment">//6.用Send和Receive相关方法收发数据</span></span><br><span class="line"><span class="comment">//发送</span></span><br><span class="line">socketClient.<span class="built_in">Send</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;欢迎连入服务端&quot;</span>));</span><br><span class="line"><span class="comment">//接受</span></span><br><span class="line">byte[] result = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//返回值为接受到的字节数</span></span><br><span class="line"><span class="type">int</span> receiveNum = socketClient.<span class="built_in">Receive</span>(result);</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;接受到了&#123;0&#125;发来的消息：&#123;1&#125;&quot;</span>,</span><br><span class="line">    socketClient.RemoteEndPoint.<span class="built_in">ToString</span>(),</span><br><span class="line">    Encoding.UTF8.<span class="built_in">GetString</span>(result, <span class="number">0</span>, receiveNum));</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.用Shutdown方法释放连接</span></span><br><span class="line">socketClient.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line"><span class="comment">//8.关闭套接字</span></span><br><span class="line">socketClient.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 实现客户端基本逻辑</span></span><br><span class="line"><span class="comment">//1.创建套接字Socket</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line"><span class="comment">//2.用Connect方法与服务端相连</span></span><br><span class="line"><span class="comment">//确定服务端的IP和端口</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    socket.<span class="built_in">Connect</span>(ipPoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (SocketException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.ErrorCode == <span class="number">10061</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;服务器拒绝连接&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;连接服务器失败&quot;</span> + e.ErrorCode);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.用Send和Receive相关方法收发数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">byte[] receiveBytes = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> receiveNum = socket.<span class="built_in">Receive</span>(receiveBytes);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;收到服务端发来的消息：&quot;</span> + Encoding.UTF8.<span class="built_in">GetString</span>(receiveBytes, <span class="number">0</span>, receiveNum));</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">socket.<span class="built_in">Send</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;你好，我是客户端&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.用Shutdown方法释放连接</span></span><br><span class="line">socket.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line"><span class="comment">//5.关闭套接字</span></span><br><span class="line">socket.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h4 id="如何区分消息"><a href="#如何区分消息" class="headerlink" title="如何区分消息"></a>如何区分消息</h4><p>为发送的信息添加标识，比如添加消息ID</p><p>在所有发送的消息的头部加上消息ID(int、short、byte、long都可以，根据实际情况选择)</p><p>举例说明：</p><p>如果选用int类型作为消息ID的类型</p><p>前4个字节为消息ID</p><p>后面的字节为数据类的内容</p><p>####<strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></p><p>这样每次收到消息时，先把前4个字节取出来解析为消息ID</p><p>再根据ID进行消息反序列化即可</p><h4 id="分包、黏包"><a href="#分包、黏包" class="headerlink" title="分包、黏包"></a>分包、黏包</h4><h5 id="什么是分包、黏包？"><a href="#什么是分包、黏包？" class="headerlink" title="什么是分包、黏包？"></a>什么是分包、黏包？</h5><p>分包、黏包指在网络通信中由于各种因素（网络环境、API规则等）造成的消息与消息之间出现的两种状态</p><p>分包：一个消息分成了多个消息进行发送</p><p>黏包：一个消息和另一个消息黏在了一起</p><p>注意：分包和黏包可能同时发生</p><h5 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h5><p>为消息添加头部，头部记录消息的长度</p><p>当我们接收到消息时，通过消息长度来判断是否分包、黏包</p><p>对消息进行拆分处理、合并处理</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123236.png" alt="分包黏包解决方案图"></p><h4 id="心跳消息"><a href="#心跳消息" class="headerlink" title="心跳消息"></a>心跳消息</h4><p>客户端主动断开连接会调用socket的 ShutDown和Close方法，但是通过调用这两个方法后 服务器端无法得知客户端已经主动断开</p><p>客户端尝试使用Disconnect方法主动断开连接，Socket当中有一个专门在客户端使用的方法，客户端调用该方法和服务器端断开连接</p><p>服务器端可以通过Conected属性判断连接状态决定是否释放Socket</p><p>但是由于服务器端Conected变量表示的是上一次收发消息是否成功，所以服务器端无法准确判断客户端的连接状态，因此 我们需要自定义一条退出消息 用于准确断开和客户端之间的连接</p><h5 id="什么是心跳消息？"><a href="#什么是心跳消息？" class="headerlink" title="什么是心跳消息？"></a>什么是心跳消息？</h5><p>所谓心跳消息，就是在长连接中，客户端和服务端之间定期发送的一种特殊的数据包，用于通知对方自己还在线，以确保长连接的有效性</p><p>由于其发送的时间间隔往往是固定的持续的，就像是心跳一样一直存在，所以我们称之为心跳消息</p><h5 id="为什么需要心跳消息？"><a href="#为什么需要心跳消息？" class="headerlink" title="为什么需要心跳消息？"></a>为什么需要心跳消息？</h5><p>1.避免非正常关闭客户端时，服务器无法正常收到关闭连接消息，通过心跳消息我们可以自定义超时判断，如果超时没有收到客户端消息，证明客户端已经断开连接</p><p>2.避免客户端长期不发送消息，防火墙或者路由器会断开连接，我们可以通过心跳消息一直保持活跃状态</p><h5 id="实现心跳消息"><a href="#实现心跳消息" class="headerlink" title="实现心跳消息"></a>实现心跳消息</h5><p>客户端：定时发送消息</p><p>服务器：不停检测上次收到某客户端消息的时间，如果超时则认为连接已经断开</p><p>心跳消息是长连接项目中必备的一套逻辑规则，通过它可以帮助我们在服务器端及时的释放掉失效的socket，可以有效避免当客户端非正常关闭时，服务器端不能及时判断连接已断开</p><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><h4 id="服务端和客户端需要做什么-1"><a href="#服务端和客户端需要做什么-1" class="headerlink" title="服务端和客户端需要做什么"></a>服务端和客户端需要做什么</h4><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123022.png" alt="image-20220521160007101"></p><h4 id="UDP相对TCP的区别"><a href="#UDP相对TCP的区别" class="headerlink" title="UDP相对TCP的区别"></a>UDP相对TCP的区别</h4><p><img src="/Users/liuyingbo/Library/Application Support/typora-user-images/image-20220521160026008.png" alt="image-20220521160026008"></p><h4 id="UDP的分包、黏包问题"><a href="#UDP的分包、黏包问题" class="headerlink" title="UDP的分包、黏包问题"></a>UDP的分包、黏包问题</h4><h5 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h5><p>UDP本身作为无连接的不可靠的传输协议（适合频繁发送较小的数据包），不会对数据包进行合并发送，一端发送什么数据，直接就发出去了，他不会对数据合并，因此在UDP当中不会出现黏包问题（除非你手动进行黏包）</p><h5 id="分包问题"><a href="#分包问题" class="headerlink" title="分包问题"></a>分包问题</h5><p>由于UDP是不可靠的连接，消息传递过程中可能出现无序、丢包等情况，所以如果允许UDP进行分包，那后果将会是灾难性的，比如分包的后半段丢包或者比上半段先发来，我们在处理消息时将会非常困难，因此为了避免其分包，我们建议在发送UDP消息时控制消息的大小在MTU（最大传输单元）范围内</p><p>MTU（Maximum Transmission Unit）最大传输单元，用来通知对方所能接受数据服务单元的最大尺寸</p><p>不同操作系统会提供用户一个默认值</p><p>以太网和802.3对数据帧的长度限制，其最大值分别是1500字节和1492字节</p><p>由于UDP包本身带有一些信息，因此建议：</p><p>1.局域网环境下：1472字节以内（1500减去UDP头部28为1472）</p><p>2.互联网环境下：548字节以内（老的ISP拨号网络的标准值为576减去UDP头部28为548）</p><p>只要遵守这个规则，就不会出现自动分包的情况</p><p>如果想要发送的消息确实比较大，要大于548字节或1472字节这个限制呢？比如我们要发一个5000字节的数据，他是一条完整消息，我们可以进行手动分包，将5000拆分成多个消息，每个消息不超过限制，但是手动分包的前提是要解决UDP的丢包和无序问题，我们可以将不可靠的UDP通信实现为可靠的UDP通信</p><p>比如：在消息中加入序号、消息总包数、自己的包ID、长度等等信息，并且实现消息确认、消息重发等功能</p><h4 id="UDP基本API"><a href="#UDP基本API" class="headerlink" title="UDP基本API"></a>UDP基本API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region 实现UDP服务端通信 收发字符串</span></span><br><span class="line"><span class="comment">//1.创建套接字</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line"><span class="comment">//2.绑定本机地址</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8081</span>);</span><br><span class="line">socket.<span class="built_in">Bind</span>(ipPoint);</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;服务器开启&quot;</span>);</span><br><span class="line"><span class="comment">//3.接受消息</span></span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[<span class="number">512</span>];</span><br><span class="line"><span class="comment">//这个变量主要是用来记录 谁发的信息给你 传入函数后 在内部 它会帮助我们进行赋值</span></span><br><span class="line">EndPoint remoteIpPoint2 = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.Any, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> length = socket.<span class="built_in">ReceiveFrom</span>(bytes, ref remoteIpPoint2);</span><br><span class="line">Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;IP:&quot;</span> + (remoteIpPoint2 as IPEndPoint).Address.<span class="built_in">ToString</span>() +</span><br><span class="line">    <span class="string">&quot;port:&quot;</span> + (remoteIpPoint2 as IPEndPoint).Port +</span><br><span class="line">    <span class="string">&quot;发来了&quot;</span> +</span><br><span class="line">    Encoding.UTF8.<span class="built_in">GetString</span>(bytes, <span class="number">0</span>, length));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.发送到指定目标</span></span><br><span class="line"><span class="comment">//由于我们先收 所以 我们已经知道谁发了消息给我 我直接发给它就行了</span></span><br><span class="line">socket.<span class="built_in">SendTo</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;欢迎发送消息给服务器&quot;</span>), remoteIpPoint2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.释放关闭</span></span><br><span class="line">socket.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line">socket.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 实现UDP客户端通信 收发字符串</span></span><br><span class="line"><span class="comment">//1.创建套接字</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> <span class="built_in">Socket</span>(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.绑定本机地址</span></span><br><span class="line">IPEndPoint ipPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>);</span><br><span class="line">socket.<span class="built_in">Bind</span>(ipPoint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.发送到指定目标</span></span><br><span class="line">IPEndPoint remoteIpPoint = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.<span class="built_in">Parse</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8081</span>);</span><br><span class="line"><span class="comment">//指定要发送的字节数 和 远程计算机的 IP和端口</span></span><br><span class="line">socket.<span class="built_in">SendTo</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;我来了&quot;</span>), remoteIpPoint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.接受消息</span></span><br><span class="line">byte[] bytes = <span class="keyword">new</span> byte[<span class="number">512</span>];</span><br><span class="line"><span class="comment">//这个变量主要是用来记录 谁发的信息给你 传入函数后 在内部 它会帮助我们进行赋值</span></span><br><span class="line">EndPoint remoteIpPoint2 = <span class="keyword">new</span> <span class="built_in">IPEndPoint</span>(IPAddress.Any, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> length = socket.<span class="built_in">ReceiveFrom</span>(bytes, ref remoteIpPoint2);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;IP:&quot;</span> + (remoteIpPoint2 as IPEndPoint).Address.<span class="built_in">ToString</span>() +</span><br><span class="line">    <span class="string">&quot;port:&quot;</span> + (remoteIpPoint2 as IPEndPoint).Port +</span><br><span class="line">    <span class="string">&quot;发来了&quot;</span> +</span><br><span class="line">    Encoding.UTF8.<span class="built_in">GetString</span>(bytes, <span class="number">0</span>, length));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.释放关闭</span></span><br><span class="line">socket.<span class="built_in">Shutdown</span>(SocketShutdown.Both);</span><br><span class="line">socket.<span class="built_in">Close</span>();</span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h2 id="文件传输FTP"><a href="#文件传输FTP" class="headerlink" title="文件传输FTP"></a>文件传输FTP</h2><h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3><h4 id="FTP是什么"><a href="#FTP是什么" class="headerlink" title="FTP是什么"></a>FTP是什么</h4><p>FTP（File Transfer Protocol）</p><p>文件传输协议，是支持Internet文件传输的各种规则所组成的集合，这些规则使Internet用户可以把文件从一台主机拷贝到另一台主机上，</p><p>除此之外，FTP还提供登录、目录查询以及其他会话控制等功能</p><p>说人话：FTP文件传输协议就是一个在网络中上传下载文件的一套规则</p><h4 id="FTP的工作原理"><a href="#FTP的工作原理" class="headerlink" title="FTP的工作原理"></a>FTP的工作原理</h4><p>划重点：FTP的本质是TCP通信</p><p>通过FTP传输文件，双发至少需要建立两个TCP连接</p><p>一个称为控制连接，用于传输FTP命令</p><p>一个称为数据连接，用于传输文件数据</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242123585.png" alt="image-20220521174749538"></p><p>FTP的数据连接和控制连接方向一般是相反的</p><p>举例说明：</p><p>用户使用FTP客户端连接FTP服务区请求下载文件</p><p>控制连接方向：客户端主动连接服务器告知其下载命令</p><p>数据连接方向：服务端主动连接客户端下发数据</p><p>当客户端和FTP服务器建立控制连接后</p><p>需要告诉服务器采用那种传输模式</p><p>1.主动模式(Port模式)：服务器主动连接客户端，然后传输文件</p><p>2.被动模式(Passive模式)：客户端主动连接服务器，即控制连接和数据连接都由客户端发起</p><p>一般情况下主动模式会受到客户端防火墙影响，所以被动模式使用较多</p><p>在使用FTP进行数据传输时，有两种数据传输方式</p><p>1.ASCII传输方式</p><p>以ASCII编码方式传输数据，适用于传输，仅包含英文的命令和参数或者英文文本文件</p><p>2.二进制传输方式（建议使用该方式）</p><p>可以指定采用哪种编码传输命令和文件数据，如果传输的文件不是英文文件则应该采用该方式</p><p>一般情况下，使用FTP传输文件时，客户端必须先登录服务器，获得相应权限后才能上传或下载文件</p><p>服务器也可以允许用户匿名登录FTP，不需要都拥有一个合法账号</p><p>在实际学习过程中，我们并不需要利用FTP原理来实现FTP通信，FTP工作原理相关知识点，主要做了解</p><p>C#中实现了FTP通信需要用到的相关类</p><p>FtpWebRequest、FtpWebResponse、NetworkCredential</p><h3 id="搭建FTP服务器"><a href="#搭建FTP服务器" class="headerlink" title="搭建FTP服务器"></a>搭建FTP服务器</h3><p>在实际商业项目开发当中，如果需要用FTP来进行文件传输，那么FTP服务器的解决方案都是由后端程序员来完成的，不管它使用哪种方式来搭建FTP服务器，只要能正常上传下载内容并且保证安全性即可</p><p>可以使用Serv-U，具体方式自行百度</p><h3 id="FTP相关API"><a href="#FTP相关API" class="headerlink" title="FTP相关API"></a>FTP相关API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region NetworkCredential类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//NetworkCredential通信凭证类</span></span><br><span class="line"><span class="comment">//用于在Ftp文件传输时，设置账号密码</span></span><br><span class="line">NetworkCredential n = <span class="keyword">new</span> <span class="built_in">NetworkCredential</span>(<span class="string">&quot;liuyingbo&quot;</span>, <span class="string">&quot;liuyingbo123&quot;</span>);</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region FtpWebRequest类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//Ftp文件传输协议客户端操作类</span></span><br><span class="line"><span class="comment">//主要用于：上传、下载、删除服务器上的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要方法</span></span><br><span class="line"><span class="comment">//1.Create 创建新的WebRequest，用于进行Ftp相关操作</span></span><br><span class="line">FtpWebRequest req = FtpWebRequest.<span class="built_in">Create</span>(<span class="keyword">new</span> <span class="built_in">Uri</span>(<span class="string">&quot;ftp://127.0.0.1/Test.txt&quot;</span>)) as FtpWebRequest;</span><br><span class="line"><span class="comment">//2.Abort  如果正在进行文件传输，用此方法可以终止传输</span></span><br><span class="line">req.<span class="built_in">Abort</span>();</span><br><span class="line"><span class="comment">//3.GetRequestStream  获取用于上传的流</span></span><br><span class="line">Stream s = req.<span class="built_in">GetRequestStream</span>();</span><br><span class="line"><span class="comment">//4.GetResponse  返回FTP服务器响应</span></span><br><span class="line"><span class="comment">//FtpWebResponse res = req.GetResponse() as FtpWebResponse;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要成员</span></span><br><span class="line"><span class="comment">//1.Credentials 通信凭证，设置为NetworkCredential对象</span></span><br><span class="line">req.Credentials = n;</span><br><span class="line"><span class="comment">//2.KeepAlive bool值，当完成请求时是否关闭到FTP服务器的控制连接（默认为true，不关闭）</span></span><br><span class="line">req.KeepAlive = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//3.Method  操作命令设置</span></span><br><span class="line"><span class="comment">//  WebRequestMethods.Ftp类中的操作命令属性</span></span><br><span class="line"><span class="comment">//  DeleteFile  删除文件</span></span><br><span class="line"><span class="comment">//  DownloadFile    下载文件    </span></span><br><span class="line"><span class="comment">//  ListDirectory   获取文件简短列表</span></span><br><span class="line"><span class="comment">//  ListDirectoryDetails    获取文件详细列表</span></span><br><span class="line"><span class="comment">//  MakeDirectory   创建目录</span></span><br><span class="line"><span class="comment">//  RemoveDirectory 删除目录</span></span><br><span class="line"><span class="comment">//  UploadFile  上传文件</span></span><br><span class="line">req.Method = WebRequestMethods.Ftp.DownloadFile;</span><br><span class="line"><span class="comment">//4.UseBinary 是否使用2进制传输</span></span><br><span class="line">req.UseBinary = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//5.RenameTo    重命名</span></span><br><span class="line"><span class="comment">//req.RenameTo = &quot;myTest.txt&quot;;</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region FtpWebResponse类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//它是用于封装FTP服务器对请求的响应</span></span><br><span class="line"><span class="comment">//它提供操作状态以及从服务器下载数据</span></span><br><span class="line"><span class="comment">//我们可以通过FtpWebRequest对象中的GetResponse()方法获取</span></span><br><span class="line"><span class="comment">//当使用完毕时，要使用Close释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过它来真正的从服务器获取内容</span></span><br><span class="line">FtpWebResponse res = req.<span class="built_in">GetResponse</span>() as FtpWebResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重要方法：</span></span><br><span class="line"><span class="comment">//1.Close:释放所有资源</span></span><br><span class="line">res.<span class="built_in">Close</span>();</span><br><span class="line"><span class="comment">//2.GetResponseStream：返回从FTP服务器下载数据的流</span></span><br><span class="line">Stream stream = res.<span class="built_in">GetResponseStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//重要成员：</span></span><br><span class="line"><span class="comment">//1.ContentLength:接受到数据的长度</span></span><br><span class="line"><span class="built_in">print</span>(res.ContentLength);</span><br><span class="line"><span class="comment">//2.ContentType：接受数据的类型</span></span><br><span class="line"><span class="built_in">print</span>(res.ContentType);</span><br><span class="line"><span class="comment">//3.StatusCode:FTP服务器下发的最新状态码</span></span><br><span class="line"><span class="built_in">print</span>(res.StatusCode);</span><br><span class="line"><span class="comment">//4.StatusDescription:FTP服务器下发的状态代码的文本</span></span><br><span class="line"><span class="built_in">print</span>(res.StatusDescription);</span><br><span class="line"><span class="comment">//5.BannerMessage:登录前建立连接时FTP服务器发送的消息</span></span><br><span class="line"><span class="built_in">print</span>(res.BannerMessage);</span><br><span class="line"><span class="comment">//6.ExitMessage:FTP会话结束时服务器发送的消息</span></span><br><span class="line"><span class="comment">//7.LastModified:FTP服务器上的文件的上次修改日期和时间</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//通过C#提供的这3个类</span></span><br><span class="line"><span class="comment">//我们便可以完成客户端向FTP服务器</span></span><br><span class="line"><span class="comment">//操作文件的需求，比如</span></span><br><span class="line"><span class="comment">//上传、下载、删除文件</span></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><h4 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h4><p>HTTP（HyperText Transfer Protocol）</p><p>超文本传输协议，是因特网上应用最为广泛的一种网络传输协议。最初设计HTTP的，目的是为了提供一种发布和接收由文本文件组成的HTML页面的方法，后来发展到除了文本数据外，还可以传输图片、音频、视频、压缩文件以及各种程序文件等。</p><p>HTTP主要用于超文本传输，因此相对FTP显得更简单一些，目前常见的HTTP标准是HTTP/1.1.</p><p>说人话：HTTP超文本传输协议就是一个在网络中上传下载文件的一套规则</p><h4 id="HTTP的工作原理"><a href="#HTTP的工作原理" class="headerlink" title="HTTP的工作原理"></a>HTTP的工作原理</h4><p>划重点：HTTP的本质也是TCP通信</p><p>HTTP定义了Web客户端（一般指浏览器）如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。</p><p>HTTP客户端首先与服务器建立TCP连接，然后客户端通过套接字发送HTTP请求，并通过套接字接收HTTP响应，由于HTTP采用TCP传输数据，因此不会丢包、不会乱序。</p><p>HTTP的工作原理主要有以下三个特点</p><h5 id="HTTP是以TCP方式工作"><a href="#HTTP是以TCP方式工作" class="headerlink" title="HTTP是以TCP方式工作"></a>HTTP是以TCP方式工作</h5><p>在HTTP/1.0中，客户端和服务器建立TCP连接后，发送一个请求到服务器，服务器发送一个应答给客户端，然后立即断开TCP连接，他们的主要步骤为：</p><p>1.客户端与服务端建立TCP连接</p><p>2.客户端向服务端发出请求</p><p>3.若服务端接受请求，则回送响应码和所需的信息</p><p>4.客户端与服务端断开TCP连接</p><p>需要注意，HTTP/1.1 支持持久连接，即客户端和服务端建立连接后，可以发送请求和接收应答，然后迅速地发送另一个请求和接收另一个应答。</p><p>持久连接也使得在得到上一个请求的应答之前能够发送多个请求，这就是HTTP/1.1与HTTP/1.0的明显不同之处，除此之外，HTTP/1.1可以发送的请求类型也比HTTP/1.0多。</p><p>目前市面上的Web服务器软件和浏览器软件基本都是支持HTTP/1.1版本的，目前使用的基本上都是HTTP/1.1版本</p><h5 id="HTTP是无状态的"><a href="#HTTP是无状态的" class="headerlink" title="HTTP是无状态的"></a>HTTP是无状态的</h5><p>无状态指：客户端发送一次请求后，服务端并没有存储关于该客户端的任何状态信息，即使客户端再次请求同一个对象，服务端仍会重新发送这个对象，不会在意之前是否已经向客户端发送过这个对象</p><p>说人话：HTTP通信就是客户端要什么来什么，想要多少来多少，服务端不会因为你要过了而不给你，不会记录你要过的状态</p><h5 id="HTTP使用元信息作为标头"><a href="#HTTP使用元信息作为标头" class="headerlink" title="HTTP使用元信息作为标头"></a>HTTP使用元信息作为标头</h5><p>HTTP通过添加标头（header）的方式向服务端提供本次HTTP请求的相关信息，即在主要数据前添加一部分额外信息，称为元信息（metainformation）元信息里主要包含：传送的对象属于哪种类型，采用的是哪种编码等等</p><p>说人话：HTTP的元信息标头，类似我们讲解Socket通信时用于区分消息类型、处理分包黏包时，在消息体前方加的自定义信息。在HTTP协议中，它也定义了类似的规则，在头部包含了一些额外信息</p><h4 id="HTTP协议的请求类型和响应状态码"><a href="#HTTP协议的请求类型和响应状态码" class="headerlink" title="HTTP协议的请求类型和响应状态码"></a>HTTP协议的请求类型和响应状态码</h4><p>请求类型：</p><p>HTTP/1.0中：</p><p>GET、POST、HEAD</p><p>HTTP/1.1中：</p><p>GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</p><p>响应状态码：</p><p>1xx、2xx、3xx、4xx、5xx</p><div class="table-container"><table><thead><tr><th>请求方法名说明</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>请求获取特定的资源，比如请求一个Web页面或请求获取一个资源</td></tr><tr><td>POST</td><td>请求提交数据进行处理，比如请求上传一个文件</td></tr><tr><td>HEAD</td><td>请求获取和GET一致的内容，但是不会返回具体内容，只会返回消息头</td></tr><tr><td>PUT</td><td>向指定位置上传最新内容</td></tr><tr><td>DELETE</td><td>删除指定资源</td></tr><tr><td>OPTIONS</td><td>返回服务器针对特定资源支持的HTTP请求方法</td></tr><tr><td>TRACE</td><td>回显服务端收到的请求</td></tr><tr><td>CONNECT</td><td>预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table></div><p>每一种请求方法，其实就是在HTTP请求的头部信息包含的内容不同而已内容发送的格式为：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242131363.png" alt="image-20221124213110318"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242131974.png" alt="image-20221124213118941"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242131611.png" alt="image-20221124213123578"></p><p>客户端向服务端发送请求后，服务端会返回HTTP响应</p><p>HTTP响应的一般格式为：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242131203.png" alt="image-20221124213152161"></p><p>状态行中主要内容有：</p><p>\1. HTTP版本号</p><p>\2. 3位数字组成的状态码</p><p>1xx消息：请求已被服务端接收，继续处理</p><p>2xx成功：请求已成功被服务端理解并接收</p><p>3xx重定向：需要后续操作才能完成这一请求</p><p>4xx请求错误：请求含有语法错误或者无法被执行</p><p>5xx服务器错误：服务端在处理某个正确请求时发生错误</p><div class="table-container"><table><thead><tr><th>编号</th><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>找到资源，一切正常</td></tr><tr><td>304</td><td>NOT MODIFIED</td><td>资源在上次请求后没有任何修改（常用语缓存机制）</td></tr><tr><td>401</td><td>UNAUTHORIZED</td><td>客户端无权访问该资源，通常需要输入用户名和密码</td></tr><tr><td>403</td><td>FORBIDDEN</td><td>客户端未授权，通常是401后输入了错误用户名密码</td></tr><tr><td>404</td><td>NOT FOUND</td><td>指定位置不存在申请的资源</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>不支持请求的方法</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不能识别请求或者没有实现指定的请求</td></tr></tbody></table></div><h3 id="搭建HTTP服务器"><a href="#搭建HTTP服务器" class="headerlink" title="搭建HTTP服务器"></a>搭建HTTP服务器</h3><p>www.baidu.com</p><h3 id="C-中HTTP类"><a href="#C-中HTTP类" class="headerlink" title="C#中HTTP类"></a>C#中HTTP类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region HttpWebRequest类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//HttpWebRequest是主要用于发送客户端请求的类</span></span><br><span class="line"><span class="comment">//主要用于：发送HTTP客户端请求给服务器，可以进行消息通信、上传、下载等等操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要方法</span></span><br><span class="line"><span class="comment">//1.Create 创建新的WebRequest，用于进行HTTP相关操作</span></span><br><span class="line">HttpWebRequest req = HttpWebRequest.<span class="built_in">Create</span>(<span class="keyword">new</span> <span class="built_in">Uri</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/&quot;</span>)) as HttpWebRequest;</span><br><span class="line"><span class="comment">//2.Abort  如果正在进行文件传输，用此方法可以终止传输 </span></span><br><span class="line">req.<span class="built_in">Abort</span>();</span><br><span class="line"><span class="comment">//3.GetRequestStream  获取用于上传的流</span></span><br><span class="line">Stream s = req.<span class="built_in">GetRequestStream</span>();</span><br><span class="line"><span class="comment">//4.GetResponse  返回HTTP服务器响应</span></span><br><span class="line">HttpWebResponse res = req.<span class="built_in">GetResponse</span>() as HttpWebResponse;</span><br><span class="line"><span class="comment">//5.Begin/EndGetRequestStream 异步获取用于上传的流</span></span><br><span class="line"><span class="comment">//req.BeginGetRequestStream()</span></span><br><span class="line"><span class="comment">//6.Begin/EndGetResponse 异步获取返回的HTTP服务器响应</span></span><br><span class="line"><span class="comment">//req.BeginGetResponse()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要成员</span></span><br><span class="line"><span class="comment">//1.Credentials 通信凭证，设置为NetworkCredential对象</span></span><br><span class="line">req.Credentials = <span class="keyword">new</span> <span class="built_in">NetworkCredential</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//2.PreAuthenticate 是否随请求发送一个身份验证标头,一般需要进行身份验证时需要将其设置为true</span></span><br><span class="line">req.PreAuthenticate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Headers 构成标头的名称/值对的集合</span></span><br><span class="line"><span class="comment">//req.Headers</span></span><br><span class="line"><span class="comment">//4.ContentLength 发送信息的字节数 上传信息时需要先设置该内容长度</span></span><br><span class="line">req.ContentLength = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//5.ContentType 在进行POST请求时，需要对发送的内容进行内容类型的设置</span></span><br><span class="line"><span class="comment">//6.Method  操作命令设置</span></span><br><span class="line"><span class="comment">//  WebRequestMethods.Http类中的操作命令属性</span></span><br><span class="line"><span class="comment">//  Get     获取请求，一般用于获取数据</span></span><br><span class="line"><span class="comment">//  Post    提交请求，一般用于上传数据，同时可以获取</span></span><br><span class="line"><span class="comment">//  Head    获取和Get一致的内容，只是只会返回消息头，不会返回具体内容</span></span><br><span class="line"><span class="comment">//  Put     向指定位置上传最新内容</span></span><br><span class="line"><span class="comment">//  Connect 表示与代理一起使用的 HTTP CONNECT 协议方法，该代理可以动态切换到隧道</span></span><br><span class="line"><span class="comment">//  MkCol   请求在请求 URI（统一资源标识符）指定的位置新建集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//了解该类的更多信息</span></span><br><span class="line"><span class="comment">//https://docs.microsoft.com/zh-cn/dotnet/api/system.net.httpwebrequest?view=net-6.0</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region HttpWebResponse类</span></span><br><span class="line"><span class="comment">//命名空间：System.Net</span></span><br><span class="line"><span class="comment">//它主要用于获取服务器反馈信息的类</span></span><br><span class="line"><span class="comment">//我们可以通过HttpWebRequest对象中的GetResponse()方法获取</span></span><br><span class="line"><span class="comment">//当使用完毕时，要使用Close释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要方法：</span></span><br><span class="line"><span class="comment">//1.Close:释放所有资源</span></span><br><span class="line"><span class="comment">//2.GetResponseStream：返回从FTP服务器下载数据的流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重要成员：</span></span><br><span class="line"><span class="comment">//1.ContentLength:接受到数据的长度</span></span><br><span class="line"><span class="comment">//2.ContentType：接受数据的类型</span></span><br><span class="line"><span class="comment">//3.StatusCode:HTTP服务器下发的最新状态码</span></span><br><span class="line"><span class="comment">//4.StatusDescription:HTTP服务器下发的状态代码的文本</span></span><br><span class="line"><span class="comment">//5.BannerMessage:登录前建立连接时HTTP服务器发送的消息</span></span><br><span class="line"><span class="comment">//6.ExitMessage:HTTP会话结束时服务器发送的消息</span></span><br><span class="line"><span class="comment">//7.LastModified:HTTP服务器上的文件的上次修改日期和时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//了解该类的更多信息</span></span><br><span class="line"><span class="comment">//https://docs.microsoft.com/zh-cn/dotnet/api/system.net.httpwebresponse?view=net-6.0</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region NetworkCredential、Uri、Stream、FileStream类</span></span><br><span class="line"><span class="comment">//这些类我们在学习Ftp时已经使用过了</span></span><br><span class="line"><span class="comment">//在HTTP通讯时使用方式不变</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//Http相关通讯类的使用和Ftp非常类似</span></span><br><span class="line"><span class="comment">//只有一些细节上的区别</span></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h4 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h4><p>Get — 一般从指定的资源请求数据,主要用于获取数据</p><p>Post — 一般向指定的资源提交想要被处理的数据，主要用于上传数据</p><p>相同点:</p><p>Get和Post都可以传递一些额外的参数数据给服务端</p><p>不同点:</p><p>1.在传递参数时，Post相对Get更加的安全，因为Post看不到参数<br>    Get传递的参数都包含在连接中（URL资源定位地址），是暴露式的 ?参数名=参数值&amp;参数名=参数值<br>    Post传递的参数放在请求数据中，不会出现在URL中，是隐藏式的</p><p>2.Get在传递数据时有大小的限制，因为它主要是在连接中拼接参数，而URL的长度是有限制的（最大长度一般为2048个字符）<br>    Post在传递数据时没有限制</p><p>3.在浏览器中Get请求能被缓存，Post不能缓存</p><p>4.传输次数可能不同<br>    Get:  建立连接——&gt;请求行、请求头、请求数据一次传输——&gt;获取响应——&gt;断开连接<br>    Post: 建立连接——&gt;传输可能分两次——&gt;请求行，请求头第一次传输——&gt;请求数据第二次传输——&gt;获取响应——&gt;断开</p><p>但是由于他们的这些特点<br>我们在实际使用时建议Get用于获取，Post用于上传<br>如果想要传递一些不想暴露在外部的参数信息，建议使用Post，它更加的安全</p><h4 id="Post如何携带额外参数"><a href="#Post如何携带额外参数" class="headerlink" title="Post如何携带额外参数"></a>Post如何携带额外参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region Post如何携带额外参数</span></span><br><span class="line"><span class="comment">//关键点：将Content-Type设置为 application/x-www-form-urlencoded 键值对类型</span></span><br><span class="line">HttpWebRequest req = HttpWebRequest.<span class="built_in">Create</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/&quot;</span>) as HttpWebRequest;</span><br><span class="line">req.Method = WebRequestMethods.Http.Post;</span><br><span class="line">req.Timeout = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//设置上传的内容的类型</span></span><br><span class="line">req.ContentType = <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们要上传的数据</span></span><br><span class="line">string str = <span class="string">&quot;Name=liuyingbo&amp;ID=2&quot;</span>;</span><br><span class="line">byte[] bytes = Encoding.UTF8.<span class="built_in">GetBytes</span>(str);</span><br><span class="line"><span class="comment">//我们在上传之前一定要设置内容的长度</span></span><br><span class="line">req.ContentLength = bytes.Length;</span><br><span class="line"><span class="comment">//上传数据</span></span><br><span class="line">Stream stream = req.<span class="built_in">GetRequestStream</span>();</span><br><span class="line">stream.<span class="built_in">Write</span>(bytes, <span class="number">0</span>, bytes.Length);</span><br><span class="line">stream.<span class="built_in">Close</span>();</span><br><span class="line"><span class="comment">//发送数据 得到响应结果</span></span><br><span class="line">HttpWebResponse res = req.<span class="built_in">GetResponse</span>() as HttpWebResponse;</span><br><span class="line"><span class="built_in">print</span>(res.StatusCode);</span><br><span class="line"></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h4 id="ContentType类型"><a href="#ContentType类型" class="headerlink" title="ContentType类型"></a>ContentType类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region ContentType的常用类型</span></span><br><span class="line"><span class="comment">//ContentType的构成：</span></span><br><span class="line"><span class="comment">//内容类型;charset=编码格式;boundary=边界字符串</span></span><br><span class="line"><span class="comment">//text/html;charset=utf-8;boundary=自定义字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中内容类型有：</span></span><br><span class="line"><span class="comment">//文本类型text：</span></span><br><span class="line"><span class="comment">//text/plain 没有特定子类型就是它（重要）</span></span><br><span class="line"><span class="comment">//text/html</span></span><br><span class="line"><span class="comment">//text/css</span></span><br><span class="line"><span class="comment">//text/javascript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图片类型image：</span></span><br><span class="line"><span class="comment">//image/gif</span></span><br><span class="line"><span class="comment">//image/png</span></span><br><span class="line"><span class="comment">//image/jpeg</span></span><br><span class="line"><span class="comment">//image/bm</span></span><br><span class="line"><span class="comment">//image/webp</span></span><br><span class="line"><span class="comment">//image/x-icon</span></span><br><span class="line"><span class="comment">//image/vnd.microsoft.icon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//音频类型audio：</span></span><br><span class="line"><span class="comment">//audio/midi</span></span><br><span class="line"><span class="comment">//audio/mpeg</span></span><br><span class="line"><span class="comment">//audio/webm</span></span><br><span class="line"><span class="comment">//audio/ogg</span></span><br><span class="line"><span class="comment">//audio/wav</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视频类型video:</span></span><br><span class="line"><span class="comment">//video/webm</span></span><br><span class="line"><span class="comment">//video/ogg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制类型application:</span></span><br><span class="line"><span class="comment">//application/octet-stream 没有特定子类型就是它（重要）</span></span><br><span class="line"><span class="comment">//application/x-www-form-urlencoded 传递参数时使用键值对形式（重要）</span></span><br><span class="line"><span class="comment">//application/pkcs12</span></span><br><span class="line"><span class="comment">//application/xhtml+xml</span></span><br><span class="line"><span class="comment">//application/xml</span></span><br><span class="line"><span class="comment">//application/pdf</span></span><br><span class="line"><span class="comment">//application/vnd.mspowerpoint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复合内容multipart:</span></span><br><span class="line"><span class="comment">//multipart/form-data  复合内容，有多种内容组合（重要）</span></span><br><span class="line"><span class="comment">//multipart/byteranges  特殊的复合文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关于ContentType更多内容可以前往</span></span><br><span class="line"><span class="comment">//https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type</span></span><br><span class="line"><span class="comment">//关于媒体类型可以前往</span></span><br><span class="line"><span class="comment">//https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region ContentType中对于我们来说重要的类型</span></span><br><span class="line"><span class="comment">//1.通用2进制类型</span></span><br><span class="line"><span class="comment">//application/octet-stream</span></span><br><span class="line"><span class="comment">//2.通用文本类型</span></span><br><span class="line"><span class="comment">//text/plain </span></span><br><span class="line"><span class="comment">//3.键值对参数</span></span><br><span class="line"><span class="comment">//application/x-www-form-urlencoded</span></span><br><span class="line"><span class="comment">//4.复合类型（传递的信息有多种类型组成,比如有键值对参数,有文件信息等等,上传资源服务器时需要用该类型）</span></span><br><span class="line"><span class="comment">//multipart/form-data</span></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure><h3 id="Unity中的HTTP类"><a href="#Unity中的HTTP类" class="headerlink" title="Unity中的HTTP类"></a>Unity中的HTTP类</h3><h4 id="WWW类"><a href="#WWW类" class="headerlink" title="WWW类"></a>WWW类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region WWW类的作用</span></span><br><span class="line"><span class="comment">//WWW是Unity提供给我们简单的访问网页的类</span></span><br><span class="line"><span class="comment">//我们可以通过该类下载和上传一些数据</span></span><br><span class="line"><span class="comment">//在使用http协议时，默认的请求类型是Get，如果想要Post上传，需要配合下节课学习的WWWFrom类使用</span></span><br><span class="line"><span class="comment">//它主要支持的协议</span></span><br><span class="line"><span class="comment">//1.http://和https:// 超文本传输协议</span></span><br><span class="line"><span class="comment">//2.ftp:// 文件传输协议（但仅限于匿名下载）</span></span><br><span class="line"><span class="comment">//3.file:// 本地文件传输协议，可以使用该协议异步加载本地文件（PC、IOS、Android都支持）</span></span><br><span class="line"><span class="comment">//我们本节课主要学习利用WWW来进行数据的下载或加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//1.该类一般配合协同程序使用</span></span><br><span class="line"><span class="comment">//2.该类在较新Unity版本中会提示过时，但是仍可以使用，新版本将其功能整合进了UnityWebRequest类（之后讲解）</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region WWW类的常用方法和变量</span></span><br><span class="line"><span class="meta">#region 常用方法</span></span><br><span class="line"><span class="comment">//1.WWW：构造函数，用于创建一个WWW请求</span></span><br><span class="line">WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/test.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//2.GetAudioClip：从下载数据返回一个音效切片AudioClip对象</span></span><br><span class="line"><span class="comment">//www.GetAudioClip()</span></span><br><span class="line"><span class="comment">//3.LoadImageIntoTexture：用下载数据中的图像来替换现有的一个Texture2D对象</span></span><br><span class="line"><span class="comment">//Texture2D tex = new Texture2D(100, 100);</span></span><br><span class="line"><span class="comment">//www.LoadImageIntoTexture(tex);</span></span><br><span class="line"><span class="comment">//4.LoadFromCacheOrDownload：从缓存加载AB包对象，如果该包不在缓存则自动下载存储到缓存中，以便以后直接从本地缓存中加载</span></span><br><span class="line"><span class="comment">//WWW.LoadFromCacheOrDownload(&quot;http://192.168.50.109:8000/Http_Server/test.assetbundle&quot;, 1);</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 常用变量</span></span><br><span class="line"><span class="comment">//1.assetBundle：如果加载的数据是AB包，可以通过该变量直接获取加载结果</span></span><br><span class="line"><span class="comment">//www.assetBundle</span></span><br><span class="line"><span class="comment">//2.audioClip：如果加载的数据是音效切片文件，可以通过该变量直接获取加载结果</span></span><br><span class="line"><span class="comment">//www.GetAudioClip</span></span><br><span class="line"><span class="comment">//3.bytes：以字节数组的形式获取加载到的内容</span></span><br><span class="line"><span class="comment">//www.bytes</span></span><br><span class="line"><span class="comment">//4.bytesDownloaded：过去已下载的字节数</span></span><br><span class="line"><span class="comment">//www.bytesDownloaded</span></span><br><span class="line"><span class="comment">//5.error：返回一个错误消息，如果下载期间出现错误，可以通过它获取错误信息</span></span><br><span class="line"><span class="comment">//www.error != null</span></span><br><span class="line"><span class="comment">//6.isDone：判断下载是否已经完成</span></span><br><span class="line"><span class="comment">//www.isDone</span></span><br><span class="line"><span class="comment">//7.movie：如果下载的视频，可以获取一个MovieTexture类型结果</span></span><br><span class="line"><span class="comment">//www.GetMovieTexture()</span></span><br><span class="line"><span class="comment">//8.progress:下载进度</span></span><br><span class="line"><span class="comment">//www.progress</span></span><br><span class="line"><span class="comment">//9.text：如果下载的数据是字符串，以字符串的形式返回内容</span></span><br><span class="line"><span class="comment">//www.text</span></span><br><span class="line"><span class="comment">//10.texture：如果下载的数据是图片，以Texture2D的形式返回加载结果</span></span><br><span class="line"><span class="comment">//www.texture</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 利用WWW类来异步下载或加载文件</span></span><br><span class="line"><span class="meta">#region 1.下载HTTP服务器上的内容</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadHttp</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 2.下载FTP服务器上的内容（FTP服务器一定要支持匿名账户）</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadFtp</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 3.本地内容加载（一般移动平台加载数据都会使用该方式）</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadLocal</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//Unity中的WWW类比使用C#中的Http相关类更加的方便</span></span><br><span class="line"><span class="comment">//建议大家使用Unity当中为我们封装好的类来处理下载、加载相关逻辑</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">DownLoadHttp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建WWW对象</span></span><br><span class="line">    WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F8cc2b9a7868b266800f98d42fc5d257021e75103.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1654745686&amp;t=b7691b6e546367610e4331039d1a10ec&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.就是等待加载结束</span></span><br><span class="line">    <span class="keyword">while</span> (!www.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">        <span class="built_in">print</span>(www.progress);</span><br><span class="line">        yield <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">    <span class="built_in">print</span>(www.progress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用加载结束后的资源</span></span><br><span class="line">    <span class="keyword">if</span> (www.error == null)</span><br><span class="line">    &#123;</span><br><span class="line">        image.texture = www.texture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(www.error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">DownLoadFtp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建WWW对象</span></span><br><span class="line">    WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;ftp://127.0.0.1/test.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.就是等待加载结束</span></span><br><span class="line">    <span class="keyword">while</span> (!www.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">        <span class="built_in">print</span>(www.progress);</span><br><span class="line">        yield <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">    <span class="built_in">print</span>(www.progress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用加载结束后的资源</span></span><br><span class="line">    <span class="keyword">if</span> (www.error == null)</span><br><span class="line">    &#123;</span><br><span class="line">        image.texture = www.texture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(www.error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">DownLoadLocal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建WWW对象</span></span><br><span class="line">    WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;file://&quot;</span> + Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.就是等待加载结束</span></span><br><span class="line">    <span class="keyword">while</span> (!www.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">        <span class="built_in">print</span>(www.progress);</span><br><span class="line">        yield <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(www.bytesDownloaded);</span><br><span class="line">    <span class="built_in">print</span>(www.progress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用加载结束后的资源</span></span><br><span class="line">    <span class="keyword">if</span> (www.error == null)</span><br><span class="line">    &#123;</span><br><span class="line">        image.texture = www.texture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(www.error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WWWForm类"><a href="#WWWForm类" class="headerlink" title="WWWForm类"></a>WWWForm类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region WWWFrom类的作用</span></span><br><span class="line"><span class="comment">//上节课学习了使用WWW类来下载数据</span></span><br><span class="line"><span class="comment">//如果想要使用WWW上传数据时，就需要配合WWWFrom类进行使用了</span></span><br><span class="line"><span class="comment">//而WWWFrom主要就是用于集成数据的，我们可以设置上传的参数或者2进制数据</span></span><br><span class="line"><span class="comment">//当结合WWWFrom上传数据时</span></span><br><span class="line"><span class="comment">//它主要用到的请求类型是Post</span></span><br><span class="line"><span class="comment">//它使用Http协议进行上传处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//使用WWW结合WWWFrom上传数据一般需要配合后端程序制定上传规则</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region WWWFrom类的常用方法和变量</span></span><br><span class="line"><span class="comment">//该类当中我们主要就使用方法，相关变量很少使用，我们主要就着重讲解方法</span></span><br><span class="line"><span class="comment">//1.WWWForm：构造函数</span></span><br><span class="line">WWWForm data = <span class="keyword">new</span> <span class="built_in">WWWForm</span>();</span><br><span class="line"><span class="comment">//2.AddBinaryData：添加二进制数据</span></span><br><span class="line"><span class="comment">//data.AddBinaryData()</span></span><br><span class="line"><span class="comment">//3.AddField：添加字段</span></span><br><span class="line"><span class="comment">//data.AddField()</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region WWW结合WWWFrom对象来异步上传数据</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">UpLoadData</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//WWW结合WWWFrom上传数据</span></span><br><span class="line"><span class="comment">//需要配合后端服务器来指定上传规则</span></span><br><span class="line"><span class="comment">//也就是说我们上传的数据，后端需要知道收到数据后应该如何处理</span></span><br><span class="line"><span class="comment">//通过这种方式我们没办法像C#类当中完成文件的上传</span></span><br><span class="line"><span class="comment">//但是该方式非常适合用于制作短连接游戏的前端网络层</span></span><br><span class="line"><span class="comment">//我们可以对WWW进行二次封装，专门用于上传自定义消息给对应的Web服务器</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">UpLoadData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WWWForm data = <span class="keyword">new</span> <span class="built_in">WWWForm</span>();</span><br><span class="line">        <span class="comment">//上传的数据 对应的后端程序 必须要有处理的规则 才能生效</span></span><br><span class="line">        data.<span class="built_in">AddField</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;liuyingbo&quot;</span>, Encoding.UTF8);</span><br><span class="line">        data.<span class="built_in">AddField</span>(<span class="string">&quot;Age&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        data.<span class="built_in">AddBinaryData</span>(<span class="string">&quot;file&quot;</span>, File.<span class="built_in">ReadAllBytes</span>(Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>), <span class="string">&quot;testtest.png&quot;</span>, <span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line">        WWW www = <span class="keyword">new</span> <span class="built_in">WWW</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">        yield <span class="keyword">return</span> www;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (www.error == null)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">            <span class="comment">//www.bytes</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;上传失败&quot;</span> + www.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#region UnityWebRequest是什么？</span></span><br><span class="line"><span class="comment">//UnityWebRequest是一个Unity提供的一个模块化的系统类</span></span><br><span class="line"><span class="comment">//用于构成HTTP请求和处理HTTP响应</span></span><br><span class="line"><span class="comment">//它主要目标是让Unity游戏和Web服务端进行交互</span></span><br><span class="line"><span class="comment">//它将之前WWW的相关功能都集成在了其中</span></span><br><span class="line"><span class="comment">//所以新版本中都建议使用UnityWebRequest类来代替WWW类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//它在使用上和WWW很类似</span></span><br><span class="line"><span class="comment">//主要的区别就是UnityWebRequest把下载下来的数据处理单独提取出来了</span></span><br><span class="line"><span class="comment">//我们可以根据自己的需求选择对应的数据处理对象来获取数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//1.UnityWebRequest和WWW一样，需要配合协同程序使用</span></span><br><span class="line"><span class="comment">//2.UnityWebRequest和WWW一样，支持http、ftp、file协议下载或加载资源</span></span><br><span class="line"><span class="comment">//3.UnityWebRequest能够上传文件到HTTP资源服务器</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region UnityWebRequest类的常用操作</span></span><br><span class="line"><span class="comment">//1.使用Get请求获取文本或二进制数据</span></span><br><span class="line"><span class="comment">//2.使用Get请求获取纹理数据</span></span><br><span class="line"><span class="comment">//3.使用Get请求获取AB包数据</span></span><br><span class="line"><span class="comment">//4.使用Post请求发送数据</span></span><br><span class="line"><span class="comment">//5.使用Put请求上传数据</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnityWebRequest req = UnityWebRequest.<span class="built_in">Get</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//就会等待 服务器端响应后 断开连接后 再继续执行后面的内容</span></span><br><span class="line">    yield <span class="keyword">return</span> req.<span class="built_in">SendWebRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果处理成功 结果就是成功枚举</span></span><br><span class="line">    <span class="keyword">if</span>(req.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文本 字符串</span></span><br><span class="line">        <span class="built_in">print</span>(req.downloadHandler.text);</span><br><span class="line">        <span class="comment">//字节数组</span></span><br><span class="line">        byte[] bytes = req.downloadHandler.data;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;字节数组长度&quot;</span> + bytes.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;获取失败:&quot;</span> + req.result + req.error + req.responseCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结 </span></span><br><span class="line"><span class="comment">//UnityWebRequest使用上和WWW类很类似</span></span><br><span class="line"><span class="comment">//我们需要注意的是</span></span><br><span class="line"><span class="comment">//1.获取文本或二进制数据时</span></span><br><span class="line"><span class="comment">//  使用UnityWebRequest.Get</span></span><br><span class="line"><span class="comment">//2.获取纹理图片数据时</span></span><br><span class="line"><span class="comment">//  使用UnityWebRequestTexture.GetTexture</span></span><br><span class="line"><span class="comment">//  以及DownloadHandlerTexture.GetContent</span></span><br><span class="line"><span class="comment">//3.获取AB包数据时</span></span><br><span class="line"><span class="comment">//  使用UnityWebRequestAssetBundle.GetAssetBundle</span></span><br><span class="line"><span class="comment">//  以及DownloadHandlerAssetBundle.GetContent</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 上传相关数据类</span></span><br><span class="line"><span class="comment">//父接口</span></span><br><span class="line"><span class="comment">//IMultipartFormSection</span></span><br><span class="line"><span class="comment">//数据相关类都继承该接口</span></span><br><span class="line"><span class="comment">//我们可以用父类装子类</span></span><br><span class="line">List&lt;IMultipartFormSection&gt; dataList = <span class="keyword">new</span> <span class="built_in">List</span>&lt;IMultipartFormSection&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类数据</span></span><br><span class="line"><span class="comment">//MultipartFormDataSection</span></span><br><span class="line"><span class="comment">//1.二进制字节数组</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(Encoding.UTF8.<span class="built_in">GetBytes</span>(<span class="string">&quot;123123123123123&quot;</span>)));</span><br><span class="line"><span class="comment">//2.字符串</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(<span class="string">&quot;12312312312312312dsfasdf&quot;</span>));</span><br><span class="line"><span class="comment">//3.参数名，参数值（字节数组，字符串），编码类型，资源类型（常用）</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;liuyingbo&quot;</span>, Encoding.UTF8, <span class="string">&quot;application/....&quot;</span>));</span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(<span class="string">&quot;Msg&quot;</span>, <span class="keyword">new</span> byte[<span class="number">1024</span>], <span class="string">&quot;appl.....&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//MultipartFormFileSection</span></span><br><span class="line"><span class="comment">//1.字节数组</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(File.<span class="built_in">ReadAllBytes</span>(Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.文件名，字节数组（常用）</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;上传的文件.png&quot;</span>, File.<span class="built_in">ReadAllBytes</span>(Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>)));</span><br><span class="line"><span class="comment">//3.字符串数据，文件名（常用）</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;12312313212312&quot;</span>, <span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="comment">//4.字符串数据，编码格式，文件名（常用）</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;12312313212312&quot;</span>, Encoding.UTF8, <span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.表单名，字节数组，文件名，文件类型</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;file&quot;</span>, <span class="keyword">new</span> byte[<span class="number">1024</span>], <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//6.表单名，字符串数据，编码格式，文件名</span></span><br><span class="line">dataList.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;123123123&quot;</span>, Encoding.UTF8, <span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 知识点二 Post发送相关</span></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">Upload</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 知识点三 Put上传相关</span></span><br><span class="line"><span class="comment">//注意：Put请求类型不是所有的web服务器都认，必须要服务器处理该请求类型那么才能有相应</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//我们可以利用Post上传数据或上传文件</span></span><br><span class="line"><span class="comment">//Put主要用于上传文件，但是必须资源服务器支持Put请求类型</span></span><br><span class="line"><span class="comment">//为了通用性，我们可以统一使用Post请求类型进行数据和资源的上传</span></span><br><span class="line"><span class="comment">//它的使用和之前的WWW类似，只要前后端制定好规则就可以相互通信了</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">Upload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//准备上传的数据 </span></span><br><span class="line">    List&lt;IMultipartFormSection&gt; data = <span class="keyword">new</span> <span class="built_in">List</span>&lt;IMultipartFormSection&gt;();</span><br><span class="line">    <span class="comment">//键值对相关的 信息 字段数据</span></span><br><span class="line">    data.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormDataSection</span>(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;liuyingbo&quot;</span>));</span><br><span class="line">    <span class="comment">//PlayerMsg msg = new PlayerMsg();</span></span><br><span class="line">    <span class="comment">//data.Add(new MultipartFormDataSection(&quot;Msg&quot;, msg.Writing()));</span></span><br><span class="line">    <span class="comment">//添加一些文件上传文件</span></span><br><span class="line">    <span class="comment">//传2进制文件</span></span><br><span class="line">    data.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;TestTest123.png&quot;</span>, File.<span class="built_in">ReadAllBytes</span>(Application.streamingAssetsPath + <span class="string">&quot;/test.png&quot;</span>)));</span><br><span class="line">    <span class="comment">//传文本文件</span></span><br><span class="line">    data.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">MultipartFormFileSection</span>(<span class="string">&quot;123123123123123&quot;</span>, <span class="string">&quot;Test123.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    UnityWebRequest req = UnityWebRequest.<span class="built_in">Post</span>(<span class="string">&quot;http://192.168.50.109:8000/Http_Server/&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    req.<span class="built_in">SendWebRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!req.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(req.uploadProgress);</span><br><span class="line">        <span class="built_in">print</span>(req.uploadedBytes);</span><br><span class="line">        yield <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(req.uploadProgress);</span><br><span class="line">    <span class="built_in">print</span>(req.uploadedBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (req.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        <span class="comment">//req.downloadHandler.data</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;上传失败&quot;</span> + req.error + req.responseCode + req.result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#region 高级操作指什么？</span></span><br><span class="line"><span class="comment">//在常用操作中我们使用的是Unity为我们封装好的一些方法</span></span><br><span class="line"><span class="comment">//我们可以方便的进行一些指定类型的数据获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如</span></span><br><span class="line"><span class="comment">//下载数据时：</span></span><br><span class="line"><span class="comment">//1.文本和2进制</span></span><br><span class="line"><span class="comment">//2.图片</span></span><br><span class="line"><span class="comment">//3.AB包</span></span><br><span class="line"><span class="comment">//如果我们想要获取其它类型的数据应该如何处理呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上传数据时：</span></span><br><span class="line"><span class="comment">//1.可以指定参数和值</span></span><br><span class="line"><span class="comment">//2.可以上传文件</span></span><br><span class="line"><span class="comment">//如果想要上传一些基于HTTP规则的其它数据应该如何处理呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//高级操作就是用来处理 常用操作不能完成的需求的</span></span><br><span class="line"><span class="comment">//它的核心思想就是：UnityWebRequest中可以将数据处理分离开</span></span><br><span class="line"><span class="comment">//比如常规操作中我们用到的</span></span><br><span class="line"><span class="comment">//DownloadHandlerTexture 和 DownloadHandlerAssetBundle两个类</span></span><br><span class="line"><span class="comment">//就是用来将2进制字节数组转换成对应类型进行处理的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以高级操作时指 让你按照规则来实现更多的数据获取、上传等功能</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region UnityWebRequest类的更多内容</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequest.Get(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequestTexture.GetTexture(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequestAssetBundle.GetAssetBundle(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequest.Put()</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = UnityWebRequest.Post</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//req.isDone</span></span><br><span class="line"><span class="comment">//req.downloadProgress;</span></span><br><span class="line"><span class="comment">//req.downloadedBytes;</span></span><br><span class="line"><span class="comment">//req.uploadProgress;</span></span><br><span class="line"><span class="comment">//req.uploadedBytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//req.SendWebRequest()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更多内容</span></span><br><span class="line"><span class="comment">//1.构造函数</span></span><br><span class="line"><span class="comment">//UnityWebRequest req = new UnityWebRequest();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.请求地址</span></span><br><span class="line"><span class="comment">//req.url = &quot;服务器地址&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.请求类型</span></span><br><span class="line"><span class="comment">//req.method = UnityWebRequest.kHttpVerbPOST;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.进度</span></span><br><span class="line"><span class="comment">//req.downloadProgress</span></span><br><span class="line"><span class="comment">//req.uploadProgress</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.超时设置</span></span><br><span class="line"><span class="comment">//req.timeout = 2000;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.上传、下载的字节数</span></span><br><span class="line"><span class="comment">//req.downloadedBytes</span></span><br><span class="line"><span class="comment">//req.uploadedBytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.重定向次数 设置为0表示不进行重定向 可以设置次数</span></span><br><span class="line"><span class="comment">//req.redirectLimit = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8.状态码、结果、错误内容</span></span><br><span class="line"><span class="comment">//req.result</span></span><br><span class="line"><span class="comment">//req.error</span></span><br><span class="line"><span class="comment">//req.responseCode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//9.下载、上传处理对象</span></span><br><span class="line"><span class="comment">//req.downloadHandler</span></span><br><span class="line"><span class="comment">//req.uploadHandler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更多内容</span></span><br><span class="line"><span class="comment">//https://docs.unity.cn/cn/2020.3/ScriptReference/Networking.UnityWebRequest.html</span></span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 自定义获取数据DownloadHandler相关类</span></span><br><span class="line"><span class="comment">//关键类：</span></span><br><span class="line"><span class="comment">//1.DownloadHandlerBuffer 用于简单的数据存储，得到对应的2进制数据。</span></span><br><span class="line"><span class="comment">//2.DownloadHandlerFile 用于下载文件并将文件保存到磁盘（内存占用少）。</span></span><br><span class="line"><span class="comment">//3.DownloadHandlerTexture 用于下载图像。</span></span><br><span class="line"><span class="comment">//4.DownloadHandlerAssetBundle 用于提取 AssetBundle。</span></span><br><span class="line"><span class="comment">//5.DownloadHandlerAudioClip 用于下载音频文件。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadTex</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadAB</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上的这些类，其实就是Unity帮助我们实现好的，用于解析下载下来的数据的类</span></span><br><span class="line"><span class="comment">//使用对应的类处理下载数据，他们就会在内部将下载的数据处理为对应的类型，方便我们使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DownloadHandlerScript 是一个特殊类。就其本身而言，不会执行任何操作。</span></span><br><span class="line"><span class="comment">//但是，此类可由用户定义的类继承。此类接收来自 UnityWebRequest 系统的回调，</span></span><br><span class="line"><span class="comment">//然后可以使用这些回调在数据从网络到达时执行完全自定义的数据处理。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">StartCoroutine</span>(<span class="built_in">DownLoadCustomHandler</span>());</span><br><span class="line"><span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#region 总结</span></span><br><span class="line"><span class="comment">//我们可以自己设置UnityWebRequest当中的下载处理对象</span></span><br><span class="line"><span class="comment">//当设置后，下载数据后它会使用该对象中对应的函数处理数据</span></span><br><span class="line"><span class="comment">//让我们更方便的获取我们想要的数据</span></span><br><span class="line"><span class="comment">//方便我们对数据下载或获取进行拓展</span></span><br><span class="line"><span class="meta">#endregion</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络通信&quot;&gt;&lt;a href=&quot;#网络通信&quot; class=&quot;headerlink&quot; title=&quot;网络通信&quot;&gt;&lt;/a&gt;网络通信&lt;/h1&gt;&lt;h2 id=&quot;网络游戏通信方案概述&quot;&gt;&lt;a href=&quot;#网络游戏通信方案概述&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="网络" scheme="https://liuyingbo.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Unity-中英对照汉化</title>
    <link href="https://liuyingbo.com/posts/430e30ec.html"/>
    <id>https://liuyingbo.com/posts/430e30ec.html</id>
    <published>2022-05-09T15:56:17.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192014911.png" alt="在这里插入图片描述"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>把汉化包zh-cn.po用记事本打开，复制内容到word编辑</p><p>word软件主窗口<br>编辑–替换，打开查找替换窗口</p><p>点击高级，选中使用通配符</p><p>查找内容：<code>(msgid\ &quot;)(*)(&quot;^13msgstr &quot;)(*)(&quot;^13)</code></p><p>替换为：<code>\1\2\3\2 \4\5</code></p><p>全部替换完之后，复制全部内容到记事本<br>记事本中文件–另存为zh-cn.po就OK了</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h3 id="汉化包中的一段内容"><a href="#汉化包中的一段内容" class="headerlink" title="汉化包中的一段内容"></a>汉化包中的一段内容</h3><p>#: Editor/Mono/Inspector/AudioMixerControllerInspector.cs:1<br>msgid “ Threshold Volume”<br>msgstr “阈值音量”</p><p>查找内容<br>msgid “ Threshold Volume”<br>msgstr “阈值音量”<br>替换为<br>msgid “ Threshold Volume”<br>msgstr “ Threshold Volume阈值音量”</p><h3 id="拆分解释"><a href="#拆分解释" class="headerlink" title="拆分解释"></a>拆分解释</h3><p>(msgid\ “)(<em>)(“13)(msgstr “)(\</em>)(“13)<br>（）括号内为需要查找的文本内容，一个括号对应一个替换文本的元素即，<br>第一个(msgid\ “)对应替换\1<br>第二个(*)对应\2<br>(”^13)对应\3<br>以此类推</p><p>(msgid\ “)这一段在查找中会找到第二行的msgid “<br>需要查找的msgid “之中有个空格，需要用\来避免编译</p><p>(msgid\ “)(<em>)(“^13)这一段有三个元素<br>(</em>)代表所有文本<br>(”^13)代表”加上一个换行<br>这一段就表示找到msgid “开头，然后到”行末端结尾的一整行<br>并且分为了3个元素，在替换的时候用\序号调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;演示&quot;&gt;&lt;a href=&quot;#演示&quot; class=&quot;headerlink&quot; title=&quot;演示&quot;&gt;&lt;/a&gt;演示&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/20</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity-Addressable</title>
    <link href="https://liuyingbo.com/posts/e4c6c43a.html"/>
    <id>https://liuyingbo.com/posts/e4c6c43a.html</id>
    <published>2022-04-20T10:30:27.000Z</published>
    <updated>2023-01-30T11:35:12.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Profile-概述窗口配置"><a href="#Profile-概述窗口配置" class="headerlink" title="Profile 概述窗口配置"></a>Profile 概述窗口配置</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144110.png" alt="image-20220512235308487"></p><p>BuildTarget：构建目标，可以在这里设置是哪个平台，默认是你激活哪个平台就是哪个平台<br>LocalBuildPath：本地构建路径，默认在项目的Library库文件夹中<br>LocalLoadPath：本地加载路径，在哪里加载本地已有的资源<br>RemoteBuildPath：远程构建路径<br>RemoteLoadPath：远程加载路径，在哪里下载远程内容和目录</p><p>注意：<br>1.一般情况下，不要去修改本地构建和加载路径默认值<br>2.当我们针对不同平台远程分发内容时，通过多个配置文件最方便。如果你想要最终的发布包包含所有内容，那么一个默认配置就够了</p><h3 id="AddressableAssetSettings-可寻址资源数据设置"><a href="#AddressableAssetSettings-可寻址资源数据设置" class="headerlink" title="AddressableAssetSettings 可寻址资源数据设置"></a>AddressableAssetSettings 可寻址资源数据设置</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144015.png" alt="image-20220512235703317"></p><p>概述配置<br>Profile In Use：可以在这选择使用的是哪一套配置文件<br>Manage Profiles：点击它会打开管理配置文件窗口</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144370.png" alt="image-20220512235744419"></p><p>Diagnostics:诊断<br>Send Profiler Events：启用分析器事件，启用它后我们可以在Event Viewer窗口查看Addressable相关信息<br>Log Runtime Exceptions：记录运行时加载相关的异常</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144647.png" alt="image-20220512235758863"></p><p>目录相关设置，将资源的地址映射到其物理位置<br>Player Version Override：重写用于制定远程目录名称的时间戳<br>如果不设置默认使用时间戳作为远程目录命名</p><p>Compress Local Catalog：在压缩的AssetBundle文件中生成目录。可以压缩大小，但是会增加生成和加载的时间</p><p>Optimize Catalog Size：通过为内部ID创建查找表来减小目录的大小。会增加加载目录所需的时间</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144208.png" alt="image-20220512235829322"></p><p>Content Update：内容更新</p><p>Disable Catalog Update on Startup：当可寻址系统在运行时初始化时，禁用自动检查更新的远程目录。您可以手动检查更新的目录。</p><p>Content State Build Path：在何处生成由默认生成脚本生成的内容状态文件。</p><p>Build Remote Catalog：构建远程目录<br>勾选后会出现新选项</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144960.png" alt="image-20220512235843681"></p><p>Build &amp; Load Paths：<br>在何处生成和加载远程目录。从列表中选择一个配置文件路径，如果要分别设置生成路径和加载路径，请选择<custom>。<br>仅在启用生成远程目录时可见。</p><p>Build Path：远程构建路径，在何处构建远程目录。通常，应该使用RemoteBuildPath配置文件变量。<br>仅当将生成和加载路径设置为<custom>时显示。</p><p>Load Path：远程加载路径，用于访问远程目录的URL。通常，应该使用RemoteLoadPath配置文件变量。<br>仅当将生成和加载路径设置为<custom>时显示。</p><p>Path Preview：路径预览</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144880.png" alt="image-20220512235907623"></p><p>Custom Certificeate handle：用于自定义证书处理的类。该列表包含项目中扩展UnityEngine的所有类。网络。证书管理员。</p><p>Max Concurrent Web Requests：系统对超过此限制的任何请求进行队列处理</p><p>Catalog Download Timeout：等待目录文件下载的时间为多少秒。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144501.png" alt="image-20220513000829808"></p><p>生成构建相关设置</p><p>Ignore Invalid/Unsupported Files in Build：忽略生成中无效不受支持的文件，如果启用，Addressable生成脚本将排除无效或不受支持的文件，而不是中止生成</p><p>Unique Bundle IDs：唯一约束ID，是否为每个构建中的包生成一个唯一的名称</p><p>Contiguous Bundles：连续捆绑，生成更高效的捆绑包布局。如果您有Addressables 1.12.1或更早版本生成的捆绑包，请禁用此选项以最小化捆绑包更改</p><p>Non-Recursive Dependency Calculation：非递归依赖计算，不使用递归计算依赖项</p><p>Shader Bundle Naming Prefix：着色器包命名前缀</p><p>MonoScript Bundle Naming Prefix：Mono脚本包命名前缀</p><p>Strip Unity Version From AssetBundles：从AssetBUndles中剥离Unity版本，决定是否从包头中删除版本信息</p><p>Disable Visible Sub Asset Representations：禁用可见子资源，如果您不直接使用子对象(Sprite、子网格等)，则启用此选项可以提高构建时间</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144022.png" alt="image-20220513000001837"></p><p>构建和编辑器模式脚本<br>在编辑器中进入播放模式时，选择Addressable系统如何加载资产<br>这些脚本处理默认的构建进程，并提供不同的方式在编辑模式下访问数据<br>我们可以在AddressableAssetData/DataBuilders文件夹中找到这些脚本<br>如果要为他们自定义脚本，那么对应的脚本需要时BuildScriptBase的子类，并且继承IDataBuilder<br>Use Asset Database：使用资源数据库<br>Simulate Groups：模拟组<br>Use Existing Build：使用现有版本<br>Default Build Scripts:默认生成脚本</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144527.png" alt="image-20220513000018046"></p><p>资源组模板</p><p>Packed Asset：打包资源<br>定义可用于创建新组的模板列表<br>创建新模板时，必须先将其添加到此列表中，然后才能使用它</p><p>Addressables包包含一个模板<br>其中包含默认构建脚本使用的模式。您可以在AddressableAssetData/AssetGroupTemplates文件夹中找到该模板。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144161.png" alt="image-20220513000041149"></p><p>初始化对象列表<br>配置初始化对象</p><p>可以在Project右键Create&gt;Addressables&gt;Initialization(初始化)&gt;Cache Initialization Setting（缓存初始化设置）</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144224.png" alt="image-20220513000924257"></p><p>Compress Bundles：是否压缩包<br>Cache Directory Override：缓存目录覆盖<br>[Obsolete]Expiration Delay：过期延迟（过时了）<br>Limit Cache Size：限制缓存的大小<br>Maximum Cache Size：最大缓存大小</p><h3 id="Packed-Assets-打包资源数据配置"><a href="#Packed-Assets-打包资源数据配置" class="headerlink" title="Packed Assets 打包资源数据配置"></a>Packed Assets 打包资源数据配置</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242144296.png" alt="image-20220513001009620"></p><p>Build &amp; Load Paths：配置文件路径对，定义可寻址构建系统在哪个路径为此组创建内容，以及可寻址系统在运行时在何处加载这些内容</p><p>Build Path：打包路径<br>LocalBuildPath-本地路径<br>RemoteBuildPath-远程路径</p><p>Load Path：加载路径<br>LocalLoadPath-本地路径<br>RemoteLoadPath-远程路径</p><p>Path Preview：路径预览</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242145809.png" alt="image-20220513001032183"></p><p>Asset Bundle Compression：AB包的压缩方式，默认为LZ4，它通常是最有效的选项，建议使用</p><p>Uncompressed：不压缩，包较大，不推荐</p><p>LZ4：压缩，相对LZMA大一点点，建议使用，用什么解压什么，内存占用低</p><p>LZMA：压缩最小，解压慢，用一个资源要解压所有</p><p>Include In Build：包含在构建中，是否在内容生成中包含此组中的资源。如果取消勾选，那么在选择打包时，不会打包该组内容</p><p>Force Unique Provider：强制唯一提供者，Addressable是否对此组使用资源提供程序类的唯一实例。如果您有此组中的资产类型的自定义提供程序实现，并且这些提供程序的实例不能在组之间共享，则启用此选项。</p><p>Use Asset Bundle Cache：使用AB包缓存，是否缓存远程分发的包</p><p>Asset Bundle CRC：是否在加载前验证AB包的完整性</p><p>Disabled：永远不检查完整性<br>Enabled，Including Cached：检查完整性，包括缓存也检查<br>Enabled，Excluding Cached：检查完整性，但是不检查缓存的包</p><p>Use UnityWebRequest for Local Asset Bundle：<br>加载AB包时，使用UnityWebRequestAssetBundle.GetAssetBundle而不是AssetBundle.LoadFromFileAsync</p><p>Request Timeout：下载远程包时超时的间隔时间</p><p>Use Http Chunked Transfer：下载包时是否使用HTTP/1.1块传输编码方法。<br>在2019.3+中被废弃和忽略</p><p>Http Redirect Limit：下载包时允许重定向的次数。无限制设置为-1</p><p>Retry Count：重试失败下载的次数</p><p>Include Addresses in Catalog：是否将地址字符串包括在目录中。如果不使用地址字符串在组中加载资产，则可以通过不包括它们来减小目录的大小。</p><p>Include GUIDs in Catalog：是否在目录中包含GUID字符串。您必须包含guid字符串才能使用资产参考。如果不使用AssetReferences或GUID字符串在组中加载资产，则可以通过不包括它们来减小目录的大小。</p><p>Include Labels in Catalog：是否在目录中包含标签字符串。如果不使用标签在组中加载资产，则可以通过不包括这些资产来缩小目录的大小。</p><p>Internal Asset Naming Mode：如何在内部命名目录中的资源</p><p>Full Path：全路径<br>FileName：文件名<br>GUID：资源的Guid字符串<br>Dynamic：Addressables根据组中的资源选择最小的内部名称</p><p>Internal Bundle Id Mode    ：确定如何构造资产绑定的内部ID。例如，当您设置群GUID选项，Addressables通过将组名与包guid字符串组合来创建包ID。</p><p>Group Guid：组的Guid<br>Group Guid Project Id Hash：组的ID和工程ID的哈希<br>Group Guid Project Id Entries Hash：组的ID和工程ID项的哈希</p><p>Cache Clear Behavior：确定安装的应用程序何时从缓存中清除AB包</p><p>Clear When Space Is Needed In Cache：在缓存中需要空间时清除<br>Clear When When new Version Loaded：加载新版本时清楚</p><p>Bundle Mode：打包模式，如何将此组中的资产打包到包中</p><p>Pack Together：创建包含所有资产的单个包<br>Pack Separately：为组中的每个主要资产创建一个包。如精灵图片中的精灵图片被包装在一起。添加到组中的文件夹中的资产也打包在一起<br>Pack Together by Label：为共享相同标签组合的资产创建一个包</p><p>Bundle Naming Mode：如何构造AB包的文件名</p><p>Filename：文件名<br>Append Hash to Filename：将哈希附加到文件名<br>Use Hash of AssetBundle：使用AB包的哈希<br>Use Hash of FileName：使用文件名的哈希</p><p>Asset Load Mode：资源加载模式</p><p>Requested Asset And Dependencies：请求的资源和依赖项<br>All Packed Assets And Dependencies：所有包中的资源和依赖项</p><p>Asset Provider：资源提供者<br>定义提供程序类Addressable用于从该组生成的AssetBundles加载资产。将此选项设置为Bundles供应商的资产除非您有一个自定义提供程序实现来从资产绑定中提供资产。</p><p>Asset Bundle Provider：AB包提供器<br>定义由该组生成的提供程序类Addressable用于加载AssetBundles。将此选项设置为资产束提供者除非您有一个自定义提供程序实现来提供资产绑定。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242145042.png" alt="image-20220513001612615"></p><p>内容更新限制</p><p>Add Schema（添加模式）<br>你可以将任意数量的架构模式分配给一个组</p><p>Content Packing Loading：内容打包加载相关<br>Content Update Restriction：内容更新限制<br>Resources and Built In Scenes：在内置数据中显示哪些类型的内置资源，可以选择是否显示 资源和内置场景</p><p>我们甚至可以通过继承AddressableAssetGroupSchema<br>定义自己的架构模式</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242145113.png" alt="image-20220513001644897"></p><p>Can Change Post Release：可以改变发行后内容，该模式不移动任何资源，如果包中的任何资源发生了更改，则重新构建整个包</p><p>Cannot Change Post Release：无法改变发布后内容，如果包中任何资源已经改变，则[检查内容更新限制]工具会将其移动到为更新创建的新组中。在进行更新构建时，从这个新组创建的AssetBundles中的资产将覆盖现有包中的版本。</p><h2 id="异步资源加载方式"><a href="#异步资源加载方式" class="headerlink" title="异步资源加载方式"></a>异步资源加载方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;GameObject&gt; handle;</span><br><span class="line">   <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="meta">#region 知识点一 回顾目前动态异步加载的使用方式</span></span><br><span class="line">       <span class="comment">//handle = Addressables.LoadAssetAsync&lt;GameObject&gt;(&quot;Cube&quot;);</span></span><br><span class="line">       <span class="comment">//通过事件监听的方式 结束时使用资源</span></span><br><span class="line">       <span class="comment">//handle.Completed += (obj) =&gt;</span></span><br><span class="line">       <span class="comment">//&#123;</span></span><br><span class="line">       <span class="comment">//    if (handle.Status == AsyncOperationStatus.Succeeded)</span></span><br><span class="line">       <span class="comment">//    &#123;</span></span><br><span class="line">       <span class="comment">//        print(&quot;事件创建对象&quot;);</span></span><br><span class="line">       <span class="comment">//        Instantiate(obj.Result);</span></span><br><span class="line">       <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//&#125;;</span></span><br><span class="line">       <span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">#region 知识点二 3种使用异步加载资源的方式</span></span><br><span class="line">       <span class="comment">//1.事件监听（目前学习过的）</span></span><br><span class="line">       <span class="comment">//2.协同程序</span></span><br><span class="line">       <span class="comment">//3.异步函数（async和await ）</span></span><br><span class="line">       <span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">#region 知识点三 通过协程使用异步加载</span></span><br><span class="line">       <span class="comment">//StartCoroutine(LoadAsset());</span></span><br><span class="line">       <span class="meta">#endregion</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">#region 知识点四 通过异步函数async和await加载</span></span><br><span class="line">       <span class="comment">//注意：WebGL平台不支持异步函数语法</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//单任务等待</span></span><br><span class="line">       <span class="built_in">Load</span>();</span><br><span class="line">       <span class="comment">//多任务等待</span></span><br><span class="line">       <span class="meta">#endregion</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">IEnumerator <span class="title">LoadAsset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       handle = Addressables.<span class="built_in">LoadAssetAsync</span>&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">       <span class="comment">//一定是没有加载成功 再去 yield return</span></span><br><span class="line">       <span class="keyword">if</span>(!handle.IsDone)</span><br><span class="line">           yield <span class="keyword">return</span> handle;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//加载成功 那么久可以使用了</span></span><br><span class="line">       <span class="keyword">if</span> (handle.Status == AsyncOperationStatus.Succeeded)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;协同程序创建对象&quot;</span>);</span><br><span class="line">           <span class="built_in">Instantiate</span>(handle.Result);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           Addressables.<span class="built_in">Release</span>(handle);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">async <span class="type">void</span> <span class="title">Load</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       handle = Addressables.<span class="built_in">LoadAssetAsync</span>&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line"></span><br><span class="line">       AsyncOperationHandle&lt;GameObject&gt; handle2 = Addressables.<span class="built_in">LoadAssetAsync</span>&lt;GameObject&gt;(<span class="string">&quot;Sphere&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//单任务等待</span></span><br><span class="line">       <span class="comment">//await handle.Task;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//多任务等待</span></span><br><span class="line">       await Task.<span class="built_in">WhenAll</span>(handle.Task, handle2.Task);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;异步函数的形式加载的资源&quot;</span>);</span><br><span class="line">       <span class="built_in">Instantiate</span>(handle.Result);</span><br><span class="line">       <span class="built_in">Instantiate</span>(handle2.Result);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Addressables资源管理器"><a href="#Addressables资源管理器" class="headerlink" title="Addressables资源管理器"></a>Addressables资源管理器</h2><p>```c++<br>using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEngine.AddressableAssets;<br>using UnityEngine.ResourceManagement.AsyncOperations;</p><p>//可寻址资源 信息<br>public class AddressablesInfo<br>{<br>    //记录 异步操作句柄<br>    public AsyncOperationHandle handle;<br>    //记录 引用计数<br>    public uint count;</p><pre><code>public AddressablesInfo(AsyncOperationHandle handle)&#123;    this.handle = handle;    count += 1;&#125;</code></pre><p>}</p><p>public class AddressablesMgr<br>{<br>    private static AddressablesMgr instance = new AddressablesMgr();<br>    public static AddressablesMgr Instance =&gt; instance;</p><pre><code>//有一个容器 帮助我们存储 异步加载的返回值public Dictionary&lt;string, AddressablesInfo&gt; resDic = new Dictionary&lt;string, AddressablesInfo&gt;();private AddressablesMgr() &#123; &#125;//异步加载资源的方法public void LoadAssetAsync&lt;T&gt;(string name, Action&lt;AsyncOperationHandle&lt;T&gt;&gt; callBack)&#123;    //由于存在同名 不同类型资源的区分加载    //所以我们通过名字和类型拼接作为 key    string keyName = name + &quot;_&quot; + typeof(T).Name;    AsyncOperationHandle&lt;T&gt; handle;    //如果已经加载过该资源    if (resDic.ContainsKey(keyName))    &#123;        //获取异步加载返回的操作内容        handle = resDic[keyName].handle.Convert&lt;T&gt;();        //要使用资源了 那么引用计数+1        resDic[keyName].count += 1;        //判断 这个异步加载是否结束        if(handle.IsDone)        &#123;            //如果成功 就不需要异步了 直接相当于同步调用了 这个委托函数 传入对应的返回值            callBack(handle);        &#125;        //还没有加载完成        else        &#123;            //如果这个时候 还没有异步加载完成 那么我们只需要 告诉它 完成时做什么就行了            handle.Completed += (obj) =&gt; &#123;                if (obj.Status == AsyncOperationStatus.Succeeded)                    callBack(obj);            &#125;;        &#125;        return;    &#125;    //如果没有加载过该资源    //直接进行异步加载 并且记录    handle = Addressables.LoadAssetAsync&lt;T&gt;(name);    handle.Completed += (obj)=&gt; &#123;        if (obj.Status == AsyncOperationStatus.Succeeded)            callBack(obj);        else        &#123;            Debug.LogWarning(keyName + &quot;资源加载失败&quot;);            if(resDic.ContainsKey(keyName))                resDic.Remove(keyName);        &#125;    &#125;;    AddressablesInfo info = new AddressablesInfo(handle);    resDic.Add(keyName, info);&#125;//释放资源的方法 public void Release&lt;T&gt;(string name)&#123;    //由于存在同名 不同类型资源的区分加载    //所以我们通过名字和类型拼接作为 key    string keyName = name + &quot;_&quot; + typeof(T).Name;    if(resDic.ContainsKey(keyName))    &#123;        //释放时 引用计数-1        resDic[keyName].count -= 1;        //如果引用计数为0  才真正的释放        if(resDic[keyName].count == 0)        &#123;            //取出对象 移除资源 并且从字典里面移除            AsyncOperationHandle&lt;T&gt; handle = resDic[keyName].handle.Convert&lt;T&gt;();            Addressables.Release(handle);            resDic.Remove(keyName);        &#125;    &#125;&#125;//异步加载多个资源 或者 加载指定资源public void LoadAssetAsync&lt;T&gt;(Addressables.MergeMode mode, Action&lt;T&gt; callBack, params string[] keys)&#123;    //1.构建一个keyName  之后用于存入到字典中    List&lt;string&gt; list = new List&lt;string&gt;(keys);    string keyName = &quot;&quot;;    foreach (string key in list)        keyName += key + &quot;_&quot;;    keyName += typeof(T).Name;    //2.判断是否存在已经加载过的内容     //存在做什么    AsyncOperationHandle&lt;IList&lt;T&gt;&gt; handle;    if (resDic.ContainsKey(keyName))    &#123;        handle = resDic[keyName].handle.Convert&lt;IList&lt;T&gt;&gt;();        //要使用资源了 那么引用计数+1        resDic[keyName].count += 1;        //异步加载是否结束        if (handle.IsDone)        &#123;            foreach (T item in handle.Result)                callBack(item);        &#125;        else        &#123;            handle.Completed += (obj) =&gt;            &#123;                //加载成功才调用外部传入的委托函数                if(obj.Status == AsyncOperationStatus.Succeeded)                &#123;                    foreach (T item in handle.Result)                        callBack(item);                &#125;            &#125;;        &#125;        return;    &#125;    //不存在做什么    handle = Addressables.LoadAssetsAsync&lt;T&gt;(list, callBack, mode);    handle.Completed += (obj) =&gt;    &#123;        if(obj.Status == AsyncOperationStatus.Failed)        &#123;            Debug.LogError(&quot;资源加载失败&quot; + keyName);            if (resDic.ContainsKey(keyName))                resDic.Remove(keyName);        &#125;    &#125;;    AddressablesInfo info = new AddressablesInfo(handle);    resDic.Add(keyName, info);&#125;public void LoadAssetAsync&lt;T&gt;(Addressables.MergeMode mode, Action&lt;AsyncOperationHandle&lt;IList&lt;T&gt;&gt;&gt; callBack, params string[] keys)&#123;&#125;public void Release&lt;T&gt;(params string[] keys)&#123;    //1.构建一个keyName  之后用于存入到字典中    List&lt;string&gt; list = new List&lt;string&gt;(keys);    string keyName = &quot;&quot;;    foreach (string key in list)        keyName += key + &quot;_&quot;;    keyName += typeof(T).Name;    if(resDic.ContainsKey(keyName))    &#123;        resDic[keyName].count -= 1;        if(resDic[keyName].count == 0)        &#123;            //取出字典里面的对象            AsyncOperationHandle&lt;IList&lt;T&gt;&gt; handle = resDic[keyName].handle.Convert&lt;IList&lt;T&gt;&gt;();            Addressables.Release(handle);            resDic.Remove(keyName);        &#125;    &#125;&#125;//清空资源public void Clear()&#123;    foreach (var item in resDic.Values)    &#123;        Addressables.Release(item.handle);    &#125;    resDic.Clear();    AssetBundle.UnloadAllAssetBundles(true);    Resources.UnloadUnusedAssets();    GC.Collect();&#125;</code></pre><p>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;h3 id=&quot;Profile-概述窗口配置&quot;&gt;&lt;a href=&quot;#Profile-概述窗口配置&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity-Camera</title>
    <link href="https://liuyingbo.com/posts/cd157359.html"/>
    <id>https://liuyingbo.com/posts/cd157359.html</id>
    <published>2022-03-29T23:17:58.000Z</published>
    <updated>2023-01-30T11:35:12.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摄像机组件"><a href="#摄像机组件" class="headerlink" title="摄像机组件"></a>摄像机组件</h2><p>照相机是玩家观察世界的装置，屏幕空间点按像素定义，屏幕的左下为（0,0）；右上是（pixelwidth，pixelHeight），z位置在照相机的世界单位中。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192033981" alt="img"></p><p>相机组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Clear Flags ：</span><br><span class="line">清除标识：确定了屏幕哪些部分将被清除，方便多个摄像机画不同的游戏元素</span><br><span class="line">Background:背景色</span><br><span class="line">Culling Mask:包含或省略要由相机呈现的对象层。在检查器中将图层分配给您的对象。</span><br><span class="line">Projection:  切换相机的功能来模拟透视。</span><br><span class="line">    Perspective(透视):  相机将完整地呈现透视物体。拍摄角度为0-180°（最高）</span><br><span class="line">Field of View: 设置为“正交”时，“相机”的视口大小。</span><br><span class="line">Orthographic(正交):  相机将统一渲染对象，没有视角。注：正交模式下不支持延迟渲染。正向渲染总是被使用。</span><br><span class="line">Size:设置为“正交”时，“相机”的视口大小。</span><br><span class="line">Cliping Planes:从相机到开始和停止渲染的距离。</span><br><span class="line">     Near ：相对于相机的最近点将出现绘图。</span><br><span class="line">     Far  ：相对于相机的最远点将出现绘图。</span><br><span class="line">ViewportRect：视口矩形 四个值指示屏幕上的相机视图将被绘制的位置。在视口坐标中测量（值为0-1）。</span><br><span class="line">Depth:相机的位置按照画图顺序。具有较大值的相机将被绘制在具有较小值的相机之上。</span><br><span class="line">Rendering Path:用于定义相机将使用什么渲染方法的选项</span><br><span class="line">    渲染路径 ：定义什么绘制方法被用于相机的选项</span><br><span class="line">    Use Graphics Settings 使用玩家设置：在玩家设置（Player Settings.）相机使用哪个渲染路径。 </span><br><span class="line">     Forward 正向渲染：所有对象每材质渲染只渲染一次,快速渲染</span><br><span class="line">     Deferred 延迟照明：所有物体将在无光照的环境渲染一次，然后在渲染队列尾部将物体的光照一起渲染出来。</span><br><span class="line">    Legacy Vertex Lit 顶点光照 ：所有被这个相机渲染的物体都将渲染成Vertex-Lit物体。</span><br><span class="line">    Legacy Deferred : 旧的延迟光照 </span><br><span class="line">Target Texture : 目标纹理:渲染纹理 （Render Texture）包含相机视图输出。这会使相机渲染在屏幕上的能力被禁止。可用于实现画中画或者画面特效。</span><br><span class="line">Occlusion Culling : 是否剔除物体背向摄像机的部分</span><br><span class="line">Allow HDR:高动态光照渲染，启动相机高动态范围渲染功能。让场景更真实。</span><br><span class="line">Allow MSAA: 这台相机应该使用MSAA渲染目标吗？如果当前质量设置MSAA级别支持，将只使用MSAA。</span><br><span class="line">Allow Dynamic Resolution：动态分辨率缩放。</span><br><span class="line">如果相机使用动态分辨率渲染，则为<span class="literal">true</span>，否则为<span class="literal">false</span>。即使此属性为<span class="literal">true</span>，动态分辨率也只能在当前图形设备支持的情况下使用。</span><br><span class="line">Target Display:设置此摄像机的目标显示。</span><br><span class="line">此设置使摄像机呈现在指定的显示中。显示器（例如监视器）支持的最大数目是8. </span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192033445" alt="img"></p><h3 id="Clear-Flags"><a href="#Clear-Flags" class="headerlink" title="Clear Flags"></a>Clear Flags</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Clear Flags ：</span><br><span class="line">清除标识：确定了屏幕哪些部分将被清除，方便多个摄像机画不同的游戏元素</span><br><span class="line">Skybox  ：</span><br><span class="line">天空盒：这是默认设置。屏幕上的任何空的部分将显示当前相机的天空盒。</span><br><span class="line">如果当前的相机没有设置天空盒，它会默认在渲染设置（Render Settings ）选择天空盒</span><br><span class="line">Solid Color ：</span><br><span class="line">纯色，屏幕上的空白部分将显示当前摄像机的背景色</span><br><span class="line">Depth Only ：</span><br><span class="line">深度相机，只渲染采集到的画面</span><br><span class="line">如果你想绘制一个玩家的枪，又不让它内部环境被裁剪，你会设置深度为<span class="number">0</span>的相机绘制环境，</span><br><span class="line">和另一个深度为<span class="number">1</span>的相机单独绘制武器。武器相机的清除标志（Clear Flags ）应设置 为depth only。</span><br><span class="line">Don<span class="symbol">&#x27;t</span> Clear ：</span><br><span class="line">不清除，此模式不清除颜色或深度缓存。每帧的渲染画面叠加在上一帧画面之上。</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192032367" alt="img"></p><h3 id="Culling-Mask"><a href="#Culling-Mask" class="headerlink" title="Culling Mask"></a>Culling Mask</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Culling Mask:包含或省略要由相机呈现的对象层。在检查器中将图层分配给您的对象。</span><br><span class="line"><span class="built_in">Nothing</span>:什么层都不剔除</span><br><span class="line">Everything:什么层都剔除</span><br><span class="line">Default:默认层剔除</span><br><span class="line">TransparentFX:隐形层,系统不会渲染贴图和模型</span><br><span class="line">Ignore Raycast:射线层剔除</span><br><span class="line">Water:水层剔除</span><br><span class="line">UI：UI层剔除</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192032199" alt="img"></p><h3 id="Rendering-Path"><a href="#Rendering-Path" class="headerlink" title="Rendering Path"></a>Rendering Path</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Rendering Path:用于定义相机将使用什么渲染方法的选项</span><br><span class="line">渲染路径 ：定义什么绘制方法被用于相机的选项</span><br><span class="line">Use Graphics Settings 使用玩家设置：在玩家设置（Player Settings.）相机使用哪个渲染路径。 </span><br><span class="line">  Forward 正向渲染：所有对象每材质渲染只渲染一次,快速渲染</span><br><span class="line">  Deferred 延迟照明：所有物体将在无光照的环境渲染一次，然后在渲染队列尾部将物体的光照一起渲染出来。</span><br><span class="line">Legacy Vertex Lit 顶点光照 ：所有被这个相机渲染的物体都将渲染成Vertex-Lit物体。</span><br><span class="line">Legacy Deferred : 旧的延迟光照 </span><br><span class="line">Traget Texture 目标纹理:渲染纹理 （Render Texture）包含相机视图输出。</span><br><span class="line">这会使相机渲染在屏幕上的能力被禁止。可用于实现画中画或者画面特效与</span><br><span class="line">Occlusion Culling : 是否剔除物体背向摄像机的部分</span><br><span class="line">Allow HDR:高动态光照渲染，启动相机高动态范围渲染功能。让场景更真实。</span><br><span class="line">Allow MSAA: 这台相机应该使用MSAA渲染目标吗？如果当前质量设置MSAA级别支持，将只使用MSAA。</span><br><span class="line">Allow Dynamic Resolution：动态分辨率缩放。</span><br><span class="line">如果相机使用动态分辨率渲染，则为<span class="literal">true</span>，否则为<span class="literal">false</span>。即使此属性为<span class="literal">true</span>，动态分辨率也只能在当前图形设备支持的情况下使用。</span><br><span class="line">Target Display:设置此摄像机的目标显示。</span><br><span class="line">此设置使摄像机呈现在指定的显示中。显示器（例如监视器）支持的最大数目是8. </span><br></pre></td></tr></table></figure><h2 id="Camera实例"><a href="#Camera实例" class="headerlink" title="Camera实例"></a>Camera实例</h2><ul><li>aspect ： 获取或者设置Camera视口的宽高比例值。例如：camera.aspect =2.0f,则视口的宽度、高度 = 2.0f，当硬件显示器屏幕的宽度与高度比例不为2.0f时,视图的显示将会发生变形。aspect只处理摄像机camera可以看到的视图的宽高比例，而硬件显示屏的作用只是把摄像机camera看到的内容显示出来，当硬件显示屏的宽高比例与aspect的比例值不同时，视图将发生变形。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">aspect</span> : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;默认值&quot;</span> + Camera.main.aspect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">10f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 1.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetAspect</span>();</span><br><span class="line">            Camera.main.aspect = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">60f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 2.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetAspect</span>();</span><br><span class="line">            Camera.main.aspect = <span class="number">2.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">110f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 3.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetAspect</span>();</span><br><span class="line">            Camera.main.aspect = <span class="number">3.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">160f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 0.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetAspect</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cameraToWorldMatrix : 变换矩阵</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cameratoworldmatrix</span> : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Camera旋转前位置&quot;</span> + transform.position);</span><br><span class="line">        Matrix4x4 m = Camera.main.cameraToWorldMatrix;</span><br><span class="line">        <span class="comment">// 向量的位置转换为世界坐标中的位置</span></span><br><span class="line">        <span class="comment">//v3 的值为沿着Camera局部坐标系的-z轴方向前移5个单位的位置在世界坐标系中的位置</span></span><br><span class="line">        Vector3 v3 = m.<span class="built_in">MultiplyPoint</span>(Vector3.forward * <span class="number">5.0f</span>);</span><br><span class="line">        <span class="comment">//v4 的值为沿着Camera世界坐标系的-z轴方向前移5个单位的位置在世界坐标系中的位置</span></span><br><span class="line">        Vector3 v4 = m.<span class="built_in">MultiplyPoint</span>(transform.forward * <span class="number">5.0f</span>);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;旋转前，V3坐标值：&quot;</span>+v3);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;旋转前，V4坐标值：&quot;</span>+v4);</span><br><span class="line">        <span class="comment">// 将摄像机沿着Y轴正向旋转90度（此时摄像机局部坐标系的z轴方向和世界坐标的X轴方向一致），</span></span><br><span class="line">        transform.<span class="built_in">Rotate</span>(Vector3.up * <span class="number">90f</span>);</span><br><span class="line">        m = Camera.main.cameraToWorldMatrix;</span><br><span class="line">        v3 = m.<span class="built_in">MultiplyPoint</span>(Vector3.forward * <span class="number">5.0f</span>);</span><br><span class="line">        v4 = m.<span class="built_in">MultiplyPoint</span>(transform.forward * <span class="number">5.0f</span>);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;旋转后， v3坐标值&quot;</span>+v3);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;旋转后， v4坐标值&quot;</span>+v4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CullingMask 按层渲染，此属性用于按层（GameObject.layer）有选择性地渲染场景中的物体。通过cullingMask可以使得当前摄像机有选择性地渲染场景中的部分物体，默认cullingMask =-1即渲染场景中的任何物体，cullingMask = 0时不渲染场景中的任何物体。若只渲染2,3,4，可以使用cullingMask = （1&lt;&lt;2）+ (1&lt;&lt;3)+(1&lt;&lt;4)来进行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cullingMask</span> : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;默认值&quot;</span> + Camera.main.aspect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">10f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;CullingMask = -1&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.cullingMask = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">60f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;CullingMask = 0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">           Camera.main.cullingMask = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">110f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 3.0&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.cullingMask =<span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">160f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 1&lt;&lt;8&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.cullingMask =<span class="number">1</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//渲染第8层与第0层</span></span><br><span class="line">       <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10f</span>, <span class="number">160f</span>, <span class="number">200f</span>, <span class="number">45f</span>), <span class="string">&quot;aspect = 0&amp;&amp;8&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 注意运算符优先排序</span></span><br><span class="line">            Camera.main.cullingMask =<span class="number">1</span>+（<span class="number">1</span> &lt;&lt; <span class="number">8</span>）;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>eventMask属性：按层响应事件，选择哪个层（layer）的物体可以响应鼠标事件</li></ul><blockquote><p>1.必须满足两个条件：</p><ul><li>1.物体在摄像机的视野范围内。</li><li>2.在2的layer次方的值与eventMask进行运算（&amp;）后结果仍为2的layer次方的值，如：defalult ,layer值为0，2的0次方=1，如果1与eventMask进行与运算后扔为1，则此物体响应鼠标事件。由于EventMask为奇数时，与1的与运算结果都为1，所以若物体层为defalut并且eventMask为奇数时物体会响应鼠标事件。</li></ul><p>2.如果想要多个不同层的物体响应鼠标事件，则需要把所有层的2的layer次方值相加，再与eventMask做与运算。例如，2个物体，layer值分贝为1,3，当event与9进行与运算后结果仍为9，则这两个物体都会响应鼠标事件。</p><p>3.此属性有一个特殊情况，但固体layer选择IgnoreRaycast(其为系统内置，值为2)时，无论EventMask值为多少，物体都无法响应鼠标事件。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventMask_ts</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> is_rotate = <span class="literal">false</span>;<span class="comment">//控制物体旋转</span></span><br><span class="line">    <span class="keyword">public</span> Camera c;<span class="comment">//指向场景中摄像机</span></span><br><span class="line">    <span class="comment">//记录摄像机的eventMask值，可以在程序运行时在Inspector面板中修改其值的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> eventMask_now = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//记录当前物体的层</span></span><br><span class="line">    <span class="built_in">int</span> layer_now;</span><br><span class="line">    <span class="built_in">int</span> layerTemp;<span class="comment">//记录2的layer次方的值</span></span><br><span class="line">    <span class="built_in">int</span> ad;<span class="comment">//记录与运算（&amp;）的结果</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//记录当前对象的层，可以在程序运行时在Inspector面板中选择不同的层</span></span><br><span class="line">        layer_now = gameObject.layer;</span><br><span class="line">        <span class="comment">//求2的layer_now次方的值</span></span><br><span class="line">        layerTemp= (<span class="built_in">int</span>)Mathf.Pow(<span class="number">2.0f</span>, layer_now);</span><br><span class="line">        <span class="comment">//与运算（&amp;）</span></span><br><span class="line">        ad = eventMask_now &amp; layerTemp;</span><br><span class="line">        c.eventMask = eventMask_now;</span><br><span class="line">        <span class="comment">//当is_rotate为true时旋转物体</span></span><br><span class="line">        <span class="keyword">if</span> (is_rotate)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.Rotate(Vector3.up * <span class="number">15.0f</span> * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当鼠标左键按下时，物体开始旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnMouseDown</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        is_rotate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当鼠标左键抬起时，物体结束旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnMouseUp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        is_rotate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;当前对象的layer值为：&quot;</span> + layer_now + <span class="string">&quot; , 2的layer次方的值为&quot;</span> + layerTemp);</span><br><span class="line">        GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;当前摄像机eventMask的值为：&quot;</span> + eventMask_now);</span><br><span class="line">        GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">500.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;根据算法，当eventMask的值与&quot;</span> + layerTemp+ <span class="string">&quot;进行与运算（&amp;）后， 若结果为&quot;</span> + tp + <span class="string">&quot;，则物体相应OnMousexxx方法，否则不响应！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ad == tp)</span><br><span class="line">        &#123;</span><br><span class="line">            str = <span class="string">&quot; ,所以物体会相应OnMouseDown方法！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str = <span class="string">&quot; ,所以物体不会相应OnMouseDown方法！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        GUI.Label(<span class="keyword">new</span> Rect(<span class="number">10.0f</span>, <span class="number">160.0f</span>, <span class="number">500.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;而当前eventMask与&quot;</span> + layerTemp+ <span class="string">&quot;进行与运算（&amp;）的结果为&quot;</span> + ad + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LayerCullDistances:层消隐的距离</li></ul><blockquote><p>摄像机可以通过基于层（GameObject.layer）的方式来设置不同层物体的消隐距离，但这个距离必须小于或者等于摄像机的farClipPlane才有效。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LayerCullDistances</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 拿到要消除的物体</span></span><br><span class="line">    <span class="keyword">public</span> Transform obj;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义大小为32的一维数组，用来存储所有层的剔除距离</span></span><br><span class="line">        <span class="type">float</span>[] distances = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">//设置第12层的剔除距离</span></span><br><span class="line">        distances[<span class="number">11</span>] = Vector3.<span class="built_in">Distance</span>(transform.position,obj.position);</span><br><span class="line">        <span class="comment">//将数组赋给摄像机的layerCullDistances，首先这个获取的是layer所有的层距离</span></span><br><span class="line">        Camera.main.layerCullDistances = distances;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//摄像机远离物体,会发现设置了蹭的</span></span><br><span class="line">        transform.<span class="built_in">Translate</span>(transform.right * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>layerCullSpherical:基于球面距离剔除</li></ul><blockquote><p>基于球面距离的剔除方式。属性默认为false，即不使用球面剔除，表示只要有一点没有超出物体所在层的远视口平面，物体就是可见的。当设置此属性为True时，只要物体的世界坐标点Position与摄像机的距离大于所在层的剔除距离，物体就不可见。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">layerCullSpherical</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform cb1, cb2, cb3;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义大小为32的一维数组，用来存储所有层的剔除距离</span></span><br><span class="line">        <span class="type">float</span>[] distances = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">//设置第9层的剔除距离</span></span><br><span class="line">        distances[<span class="number">8</span>] = Vector3.<span class="built_in">Distance</span>(transform.position, cb1.position);</span><br><span class="line">        <span class="comment">//将数组赋给摄像机的layerCullDistances</span></span><br><span class="line">        Camera.main.layerCullDistances = distances;</span><br><span class="line">        <span class="comment">//打印出三个物体距离摄像机的距离</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Cube1距离摄像机的距离：&quot;</span> + Vector3.<span class="built_in">Distance</span>(transform.position, cb1.position));</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Cube2距离摄像机的距离：&quot;</span> + Vector3.<span class="built_in">Distance</span>(transform.position, cb2.position));</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Cube3距离摄像机的距离：&quot;</span> + Vector3.<span class="built_in">Distance</span>(transform.position, cb3.position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//使用球形距离剔除</span></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">20.0f</span>, <span class="number">180.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;使用球形距离剔除&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.layerCullSpherical = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取消球形距离剔除</span></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">70.0f</span>, <span class="number">180.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;取消球形距离剔除&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.layerCullSpherical = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>orthographic :摄像机投影模式</li></ul><blockquote><p>用来设置相机投影模式， 模式有两种：正交投影（orthographic）,与透视投影模式（perspective）若值为true,正交模式，反之投影模式。正交模式下：物体在视口的代销至于正交视口的大小有关，与摄像机到物体的距离无关，主要呈现2D效果。透视模式下，有远小近大的效果。呈现3D效果</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class orthographic : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    float <span class="built_in">len</span> = <span class="number">5.5</span>f;</span><br><span class="line">    void OnGUI()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.Button(<span class="built_in">new</span> Rect(<span class="number">10.0</span>f, <span class="number">10.0</span>f, <span class="number">120.0</span>f, <span class="number">45.0</span>f), <span class="string">&quot;正交投影&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.orthographic = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">len</span> = <span class="number">4.5</span>f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.Button(<span class="built_in">new</span> Rect(<span class="number">150.0</span>f, <span class="number">10.0</span>f, <span class="number">120.0</span>f, <span class="number">45.0</span>f), <span class="string">&quot;透视投影&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.orthographic = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">len</span> = <span class="number">60.0</span>f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Camera.main.orthographic)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//正交投影模式下，物体没有远大近小的效果，</span></span><br><span class="line">            <span class="comment">//orthographicSize的大小无限制，当orthographicSize为负数时视口的内容会颠倒，</span></span><br><span class="line">            <span class="comment">//orthographicSize的绝对值为摄像机视口的高度值，即上下两条边之间的距离</span></span><br><span class="line">            <span class="built_in">len</span> = GUI.HorizontalSlider(<span class="built_in">new</span> Rect(<span class="number">10.0</span>f, <span class="number">60.0</span>f, <span class="number">300.0</span>f, <span class="number">45.0</span>f), <span class="built_in">len</span>, <span class="number">-20.0</span>f, <span class="number">20.0</span>f);</span><br><span class="line">            Camera.main.orthographicSize = <span class="built_in">len</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//透视投影模式下，物体有远大近小的效果，</span></span><br><span class="line">            <span class="comment">//fieldOfViewd的取值范围为1.0-179.0</span></span><br><span class="line">            <span class="built_in">len</span> = GUI.HorizontalSlider(<span class="built_in">new</span> Rect(<span class="number">10.0</span>f, <span class="number">60.0</span>f, <span class="number">300.0</span>f, <span class="number">45.0</span>f), <span class="built_in">len</span>, <span class="number">1.0</span>f, <span class="number">179.0</span>f);</span><br><span class="line">            Camera.main.fieldOfView = <span class="built_in">len</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实时显示len大小</span></span><br><span class="line">        GUI.Label(<span class="built_in">new</span> Rect(<span class="number">320.0</span>f, <span class="number">60.0</span>f, <span class="number">120.0</span>f, <span class="number">45.0</span>f), <span class="built_in">len</span>.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>pixelRect：摄像机渲染区间<br> 设置Camera被渲染到屏幕中的坐标位置。以实际像素大小来设置显示视口的位置。如下图：A为原始平面大小，B为变换后的视口大小，则X0的值为视口右移的像素大小，Y0的值为视口上移的像素大小，w为Camera.pixelWidth,h的值为Camera.pixelHeight。这里要注意：Screen.width和Screen.height为模拟硬件屏幕的宽高值，不随Camera.pixelWidth和Camera.pixelHeight的改变而改变。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192032327" alt="img"></p><p>pixelRect</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PixelRect</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> which_change = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">float</span> temp_x = <span class="number">0.0f</span>, temp_y = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Screen.width和Screen.height为模拟硬件屏幕的宽高值,</span></span><br><span class="line">        <span class="comment">//其返回值不随camera.pixelWidth和camera.pixelHeight的改变而改变</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Screen.width:&quot;</span> + Screen.width);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Screen.height:&quot;</span> + Screen.height);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;pixelWidth:&quot;</span> + Camera.main.pixelWidth);</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;pixelHeight:&quot;</span> + Camera.main.pixelHeight);</span><br><span class="line">        <span class="comment">//通过改变Camera的坐标位置而改变视口的区间</span></span><br><span class="line">        <span class="keyword">if</span> (which_change == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.pixelWidth &gt; <span class="number">1.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_x += Time.deltaTime * <span class="number">20.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取消以下注释察看平移状况</span></span><br><span class="line">            <span class="comment">//if (Camera.main.pixelHeight &gt; 1.0f)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    temp_y += Time.deltaTime * 20.0f;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            Camera.main.pixelRect = <span class="keyword">new</span> <span class="built_in">Rect</span>(temp_x, temp_y, Camera.main.pixelWidth, Camera.main.pixelHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过改变Camera的视口宽度和高度来改变视口的区间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (which_change == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.pixelWidth &gt; <span class="number">1.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_x = Camera.main.pixelWidth - Time.deltaTime * <span class="number">20.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取消以下注释察看平移状况</span></span><br><span class="line">            <span class="comment">//if (camera.pixelHeight &gt; 1.0f)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    temp_y = camera.pixelHeight - Time.deltaTime * 20.0f;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            Camera.main.pixelRect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, temp_x, temp_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口改变方式1&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">0</span>;</span><br><span class="line">            temp_x = <span class="number">0.0f</span>;</span><br><span class="line">            temp_y = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口改变方式2&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">1</span>;</span><br><span class="line">            temp_x = <span class="number">0.0f</span>;</span><br><span class="line">            temp_y = Camera.main.pixelHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口还原&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>projectionMatrix属性：自定义投影矩阵<br> 此属性的功能是设置摄像机的自定义投影矩阵。此属性常在一些特效场景下用到，在切换变换矩阵是通常需要先用Camera.ResetProjectionMatrix()重置Camera的变换矩阵。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectionMatrix</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform sp, cb;</span><br><span class="line">    <span class="keyword">public</span> Matrix4x4 originalProjection;</span><br><span class="line">    <span class="type">float</span> q=<span class="number">0.1f</span>;<span class="comment">//晃动振幅</span></span><br><span class="line">    <span class="type">float</span> p=<span class="number">1.5f</span>;<span class="comment">//晃动频率</span></span><br><span class="line">    <span class="type">int</span> which_change = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//记录原始投影矩阵</span></span><br><span class="line">        originalProjection = Camera.main.projectionMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sp.<span class="built_in">RotateAround</span>(cb.position, cb.up, <span class="number">45.0f</span> * Time.deltaTime);</span><br><span class="line">        Matrix4x4 pr = originalProjection;</span><br><span class="line">        <span class="keyword">switch</span> (which_change)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment">//绕摄像机X轴晃动</span></span><br><span class="line">                pr.m11 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">//绕摄像机Y轴晃动</span></span><br><span class="line">                pr.m01 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="comment">//绕摄像机Z轴晃动</span></span><br><span class="line">                pr.m10 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="comment">//绕摄像机左右移动</span></span><br><span class="line">                pr.m02 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="comment">//摄像机视口放缩运动</span></span><br><span class="line">                pr.m00 += Mathf.<span class="built_in">Sin</span>(Time.time * p) * q;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置Camera的变换矩阵</span></span><br><span class="line">        Camera.main.projectionMatrix = pr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;绕摄像机X轴晃动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;绕摄像机Y轴晃动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;绕摄像机Z轴晃动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">160.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;绕摄像机左右移动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">210.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口放缩运动&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetProjectionMatrix</span>();</span><br><span class="line">            which_change = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Rect属性：摄像机视图的位置和大小</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rect</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> which_change = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">float</span> temp_x = <span class="number">0.0f</span>, temp_y = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//视口平移</span></span><br><span class="line">        <span class="keyword">if</span> (which_change == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.rect.x &lt; <span class="number">1.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//沿着X轴平移</span></span><br><span class="line">                temp_x = Camera.main.rect.x + Time.deltaTime * <span class="number">0.2f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取消下面注释察看平移的变化</span></span><br><span class="line">            <span class="comment">//if (camera.rect.y&lt; 1.0f)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//沿着Y轴平移</span></span><br><span class="line">            <span class="comment">//    temp_y = camera.rect.y + Time.deltaTime * 0.2f;</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(temp_x, temp_y, Camera.main.rect.width, Camera.main.rect.height);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//视口放缩</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (which_change == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.rect.width &gt; <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//沿着X轴放缩</span></span><br><span class="line">                temp_x = Camera.main.rect.width - Time.deltaTime * <span class="number">0.2f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Camera.main.rect.height &gt; <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//沿着Y轴放缩</span></span><br><span class="line">                temp_y = Camera.main.rect.height - Time.deltaTime * <span class="number">0.2f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(Camera.main.rect.x, Camera.main.rect.y, temp_x, temp_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口平移&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//重置视口</span></span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">0</span>;</span><br><span class="line">            temp_y = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口放缩&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;视口还原&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.rect = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">            which_change = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>RenderingPath : 渲染路径</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192033051" alt="img"></p><h3 id="RenderingPath"><a href="#RenderingPath" class="headerlink" title="RenderingPath"></a>RenderingPath</h3></li></ul><blockquote><p>用于获取和设置摄像机渲染路径。Unity中渲染路径RenderingPath为枚举类型<br> VertexLit:使用顶点光照。最低消耗的渲染路径，不支持实时阴影，适用于移动及老式设备。<br> forward:使用正向光照，基于着色器的渲染路径。支持逐像素计算光照（包括法线贴图和灯光Cookies）和来自一个平行光的实时阴影。<br> DeferredLighting:使用延迟光照，支持实时阴影，计算消耗大，对硬件要求高，不支持移动设备，仅专业版可用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">renderingPath</span>: MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">120.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;UsePlayerSettings&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.renderingPath = RenderingPath.UsePlayerSettings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">120.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;VertexLit&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.renderingPath = RenderingPath.VertexLit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">120.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;Forward&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.renderingPath = RenderingPath.Forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">160.0f</span>, <span class="number">120.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;DeferredLighting&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.renderingPath = RenderingPath.DeferredLighting;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>WorldToCameramatrix：变换矩阵</li></ul><blockquote><p>返回或设置当前从世界坐标系到当前Camera自身坐标系的变换矩阵。重设矩阵时，摄像机的Transform组件数据不会同步更新。如果想回到Transform的可控状态，需要调用ResetWorldToCameraMatrix方法重置摄像机旋转矩阵。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldToCameraMatrix</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Camera c_test;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;更改变换矩阵&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用c_test的变换矩阵</span></span><br><span class="line">            Camera.main.worldToCameraMatrix = c_test.worldToCameraMatrix;</span><br><span class="line">            <span class="comment">//也可使用如下代码实现同样功能</span></span><br><span class="line">            <span class="comment">// camera.CopyFrom(c_test);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">200.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;重置变换矩阵&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetWorldToCameraMatrix</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RenderToCubMap：生成Cubemap静态贴图。</li><li>RenderWithShader:使用其他shader渲染<br> 使用指定shader来代替当前物体的shader渲染一帧。当replacementTag为空时会替换视口中所有物体的shader</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RenderWithShader</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> is_use = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_use)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用高光shader：Specular来渲染Camera</span></span><br><span class="line">            Camera.main.<span class="built_in">RenderWithShader</span>(Shader.<span class="built_in">Find</span>(<span class="string">&quot;Specular&quot;</span>), <span class="string">&quot;RenderType&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;使用RenderWithShader启用高光&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//RenderWithShader每调用一次只渲染一帧，所以不可将其直接放到这儿</span></span><br><span class="line">            <span class="comment">//camera.RenderWithShader(Shader.Find(&quot;Specular&quot;), &quot;RenderType&quot;);</span></span><br><span class="line">            is_use = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;使用SetReplacementShader启用高光&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//SetReplacementShader方法用来替换已有shader，调用一次即可</span></span><br><span class="line">            Camera.main.<span class="built_in">SetReplacementShader</span>(Shader.<span class="built_in">Find</span>(<span class="string">&quot;Specular&quot;</span>), <span class="string">&quot;RenderType&quot;</span>);</span><br><span class="line">            is_use = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">110.0f</span>, <span class="number">300.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;关闭高光&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Camera.main.<span class="built_in">ResetReplacementShader</span>();</span><br><span class="line">            is_use = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SetReplacementShader 使用指定的shader来替换物体当前的shader,被替换后每一帧都会替换shader来渲染物体,与上面的方法刚好不同。</li><li>ScreenPointToRay:近视口到屏幕的射线</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScreenPointToRay_ts</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Ray ray;</span><br><span class="line">    RaycastHit hit;</span><br><span class="line">    Vector3 v3 = <span class="keyword">new</span> Vector3(Screen.width / <span class="number">2.0f</span>, Screen.height / <span class="number">2.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    Vector3 hitpoint = Vector3.zero;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//射线沿着屏幕X轴从左向右循环扫描</span></span><br><span class="line">        v3.x = v3.x &gt;= Screen.width ? <span class="number">0.0f</span> : v3.x + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="comment">//生成射线</span></span><br><span class="line">        ray = Camera.main.ScreenPointToRay(v3);</span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(ray, <span class="keyword">out</span> hit, <span class="number">100.0f</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//绘制线，在Scene视图中可见</span></span><br><span class="line">            Debug.DrawLine(ray.origin, hit.point, Color.green);</span><br><span class="line">            <span class="comment">//输出射线探测到的物体的名称</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;射线探测到的物体名称：&quot;</span> + hit.transform.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ScreenToViewPortPoint 坐标系转换<br> 实现坐标点从屏幕坐标系向摄像机视口的单元化坐标系转换。但是是像素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScreenToViewportPoint_ts</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        transform.position = <span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        transform.rotation = Quaternion.identity;</span><br><span class="line">        <span class="comment">//从屏幕的实际坐标点向视口的单位化比例值转换</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;1:&quot;</span> + Camera.main.<span class="built_in">ScreenToViewportPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(Screen.width / <span class="number">2.0f</span>, Screen.height / <span class="number">2.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//从视口的单位化比例值向屏幕的实际坐标点转换</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;2:&quot;</span> + Camera.main.<span class="built_in">ViewportToScreenPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;屏幕宽：&quot;</span> + Screen.width + <span class="string">&quot;  屏幕高：&quot;</span> + Screen.height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ScreenToworldPoint : 坐标系转换，从屏幕坐标系到世界坐标系，实际单位像素组值，而非比例值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScreenToWorldPoint_ts</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        transform.position = <span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        Camera.main.fieldOfView = <span class="number">60.0f</span>;</span><br><span class="line">        Camera.main.aspect = <span class="number">16.0f</span> / <span class="number">10.0f</span>;</span><br><span class="line">        <span class="comment">//Z轴前方100处对应的屏幕的左下角的世界坐标值</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;1:&quot;</span> + Camera.main.<span class="built_in">ScreenToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//Z轴前方100处对应的屏幕的中间的世界坐标值</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;2:&quot;</span> + Camera.main.<span class="built_in">ScreenToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(Screen.width / <span class="number">2.0f</span>, Screen.height / <span class="number">2.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//Z轴前方100处对应的屏幕的右上角的世界坐标值</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;3:&quot;</span> + Camera.main.<span class="built_in">ScreenToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(Screen.width, Screen.height, <span class="number">100.0f</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ViewPortToWorldpoint 视口坐标点向世界坐标点转换。</li></ul><blockquote><p>此方法的返回值受当前摄像机在世界坐标系的位置Camera的FieldOfView的值以及Position的共同影响</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">ViewportToWorldPoint</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        transform.position = <span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        Camera.main.fieldOfView = <span class="number">60.0f</span>;</span><br><span class="line">        Camera.main.aspect = <span class="number">16.0f</span> / <span class="number">10.0f</span>;</span><br><span class="line">        <span class="comment">//屏幕左下角</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;1:&quot;</span> + Camera.main.<span class="built_in">ViewportToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//屏幕中间</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;2:&quot;</span> + Camera.main.<span class="built_in">ViewportToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">        <span class="comment">//屏幕右上角</span></span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;3:&quot;</span> + Camera.main.<span class="built_in">ViewportToWorldPoint</span>(<span class="keyword">new</span> <span class="built_in">Vector3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">100.0f</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>WorldToScreenPoint：世界坐标转成屏幕坐标。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldToScreenPoint</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform cb, sp;</span><br><span class="line">    <span class="keyword">public</span> Texture2D t2;</span><br><span class="line">    Vector3 v3 = Vector3.zero;</span><br><span class="line">    <span class="type">float</span> sg;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//记录屏幕高度</span></span><br><span class="line">        sg = Screen.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//sp绕着cb的Y轴旋转</span></span><br><span class="line">        sp.<span class="built_in">RotateAround</span>(cb.position, cb.up, <span class="number">30.0f</span> * Time.deltaTime);</span><br><span class="line">        <span class="comment">//获取sp在屏幕上的坐标点</span></span><br><span class="line">        v3 = Camera.main.<span class="built_in">WorldToScreenPoint</span>(sp.position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//绘制纹理</span></span><br><span class="line">        GUI.<span class="built_in">DrawTexture</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, sg - v3.y, v3.x, sg), t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>WorldToViewPoint：从世界坐标转换屏幕单位化坐标中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorldToViewportPoint</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform cb, sp;</span><br><span class="line">    <span class="keyword">public</span> Texture2D t2;</span><br><span class="line">    Vector3 v3 = Vector3.zero;</span><br><span class="line">    <span class="type">float</span> sw, sh;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//记录屏幕的宽度和高度</span></span><br><span class="line">        sw = Screen.width;</span><br><span class="line">        sh = Screen.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//物体sp始终绕cb的Y轴旋转</span></span><br><span class="line">        sp.<span class="built_in">RotateAround</span>(cb.position, cb.up, <span class="number">30.0f</span> * Time.deltaTime);</span><br><span class="line">        <span class="comment">//记录sp映射到屏幕上的比例值</span></span><br><span class="line">        v3 = Camera.main.<span class="built_in">WorldToViewportPoint</span>(sp.position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//绘制纹理，由于方法WorldToViewportPoint的返回值的y分量是从屏幕下方向上方递增的，</span></span><br><span class="line">        <span class="comment">//所以需要先计算1.0f - v3.y的值，然后再和sh相乘。</span></span><br><span class="line">        GUI.<span class="built_in">DrawTexture</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">0.0f</span>, sh * (<span class="number">1.0f</span> - v3.y), sw * v3.x, sh), t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SetTargetBuffers:重设摄像机到TargetTexture的渲染</li></ul><blockquote><p>SetTargetBuffers(RenderBuffer colorBuffer,RenderBuffer depthBuffer)其中参数ColorBuffer为纹理颜色缓存，depthBuffer为纹理的深度缓存。</p><p>SetTargetBuffers(RenderBuffer [] colorBuffer,RenderBuffer depthBuffer)其中参数ColorBuffer为纹理颜色缓存，depthBuffer为纹理的深度缓存,这个方法可以将摄像机的渲染一次赋给多个colorBuffer.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTargetBuffers</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明两个RendererTexture变量</span></span><br><span class="line">    <span class="keyword">public</span> RenderTexture RT_1, RT_2;</span><br><span class="line">    <span class="keyword">public</span> Camera c;<span class="comment">//指定Camera</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnGUI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//设置RT_1的buffer为摄像机c的渲染</span></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">10.0f</span>, <span class="number">180.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;set target buffers&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            c.<span class="built_in">SetTargetBuffers</span>(RT_1.colorBuffer, RT_1.depthBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置RT_2的buffer为摄像机c的渲染，此时RT_1的buffer变为场景中Camera1的渲染</span></span><br><span class="line">        <span class="keyword">if</span> (GUI.<span class="built_in">Button</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">10.0f</span>, <span class="number">60.0f</span>, <span class="number">180.0f</span>, <span class="number">45.0f</span>), <span class="string">&quot;Reset target buffers&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            c.<span class="built_in">SetTargetBuffers</span>(RT_2.colorBuffer, RT_2.depthBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><img src="/Users/liuyingbo/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Temp/ScreenCapture/企业微信截图_f4c33210-6f3a-4c09-b711-e773ec9f2ba6.png" alt="企业微信截图_f4c33210-6f3a-4c09-b711-e773ec9f2ba6"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192034641.png" alt="image-20220329232239750"></p><p>通过两个相机组合，一个透视相机一个正交相机，设置遮挡剔除实现3D麻将牌桌效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摄像机组件&quot;&gt;&lt;a href=&quot;#摄像机组件&quot; class=&quot;headerlink&quot; title=&quot;摄像机组件&quot;&gt;&lt;/a&gt;摄像机组件&lt;/h2&gt;&lt;p&gt;照相机是玩家观察世界的装置，屏幕空间点按像素定义，屏幕的左下为（0,0）；右上是（pixelwidth，pixelH</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity解析Json</title>
    <link href="https://liuyingbo.com/posts/fa97511a.html"/>
    <id>https://liuyingbo.com/posts/fa97511a.html</id>
    <published>2022-03-22T22:13:59.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h2><h3 id="一、Unity自带的Json库"><a href="#一、Unity自带的Json库" class="headerlink" title="一、Unity自带的Json库"></a>一、Unity自带的Json库</h3><p>官方API：<a href="https://docs.unity3d.com/ScriptReference/JsonUtility.html">https://docs.unity3d.com/ScriptReference/JsonUtility.html</a></p><p>在Unity中使用JsonUtility类对Json进行解析，此类包含三个重要方法，下面进行详解。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023677.png" alt="img"></p><h3 id="二、FromJson方法（反序列化）"><a href="#二、FromJson方法（反序列化）" class="headerlink" title="二、FromJson方法（反序列化）"></a>二、FromJson方法（反序列化）</h3><p>将Json转换为object</p><p>返回值是一个Object，<strong>需要在对应的类或结构体前标记Serializable属性（没标记好像也行 序列化不成功可能就是因为没有标记）</strong>。object类型必须支持序列化，其中的字段也必须支持序列化（比如私有类型、标记了NonSerialized属性的类型等不可序列化字段会被忽视）。</p><p>只有普通的类/结构体才行， 继承自UnityEngine.Object (比如 MonoBehaviour 或 ScriptableObject)的类则不行。</p><p>使用string的此函数可以在后台线程调用，但使用TextAsset的此函数只可以在主线程调用。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[System.Serializable]</span><br><span class="line">public class PlayerInfo</span><br><span class="line">&#123;</span><br><span class="line">    public string name;</span><br><span class="line">    public int lives;</span><br><span class="line">    public float health;</span><br><span class="line"></span><br><span class="line">    public static PlayerInfo CreateFromJSON(string jsonString)</span><br><span class="line">    &#123;</span><br><span class="line">        return JsonUtility.FromJson&lt;PlayerInfo&gt;(jsonString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Given JSON input:</span><br><span class="line">    // &#123;&quot;name&quot;:&quot;Dr Charles&quot;,&quot;lives&quot;:3,&quot;health&quot;:0.8&#125;</span><br><span class="line">    // this example will return a PlayerInfo object with</span><br><span class="line">    // name == &quot;Dr Charles&quot;, lives == 3, and health == 0.8f.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、ToJson（序列化）"><a href="#三、ToJson（序列化）" class="headerlink" title="三、ToJson（序列化）"></a>三、ToJson（序列化）</h3><p>将object转换为Json</p><div class="table-container"><table><thead><tr><th>obj</th><th>要转换为Json的object</th></tr></thead><tbody><tr><td>prettyPrint</td><td>如果为true，则格式化输出以确保可读性。如果为false，则将输出格式化为最小大小。默认值为false。</td></tr></tbody></table></div><p>　　</p><p>　　返回值是json格式的string。</p><p>　　传入的object必须是支持序列化的：这个object必须继承自MonoBehaviour、ScriptableObject（其他引擎类型使用<a href="https://docs.unity3d.com/ScriptReference/EditorJsonUtility.ToJson.html">EditorJsonUtility.Tojson</a>）,或者是标记Serializable属性的普通类/结构体。想要包含的字段也必须是支持序列化的，不支持序列化的字段如private、static以及标记了NonSerialized属性的字段等会被忽略。</p><p>　　传入的object不能是基本数据类型如int,float，也不能为数组。想要序列化基本数据类型或者数组，就需要将它们写入一个类或结构体中，再将类/结构体实例化的对象传入即可。</p><div class="table-container"><table><thead><tr><th>直接传入一个数组，序列化失败</th><th><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023012.png" alt="img"></th><th><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/2275552-20210408124909857-1652065208.png" alt="img"></th></tr></thead><tbody><tr><td>将数组写进类中，将类实例化对象传入，序列化成功</td><td><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023104.png" alt="img"> <img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023165.png" alt="img"></td><td><img src="https://cdn.jsdelivr.net/gh/liuyingbor/imgHosting/img/2275552-20210408125022417-1750796703.png" alt="img"></td></tr></tbody></table></div><p>　　此函数可以在后台线程中执行，但此函数执行过程中不要去修改传入的object的值。</p><h3 id="四、FromJsonOverwrite"><a href="#四、FromJsonOverwrite" class="headerlink" title="四、FromJsonOverwrite"></a>四、FromJsonOverwrite</h3><p>　　此函数和FromJson非常类似，只有一点不同：此函数要把Json中的数据读入一个已经存在的对象中，覆盖该对象原来的数据。（FromJson是返回一个新创建的对象）</p><h3 id="五、遇到不支持序列化的类型怎么办？"><a href="#五、遇到不支持序列化的类型怎么办？" class="headerlink" title="五、遇到不支持序列化的类型怎么办？"></a>五、遇到不支持序列化的类型怎么办？</h3><p>　　JsonUtilty类能力有限，并不能序列化/反序列化所有类型的数据，比如字典类型。这个时候就要实现Unity提供给我们的一个接口：ISerializationCallbackReceiver</p><p>具体说明见官方文档：<a href="https://docs.unity3d.com/cn/current/ScriptReference/ISerializationCallbackReceiver.html">https://docs.unity3d.com/cn/current/ScriptReference/ISerializationCallbackReceiver.html</a></p><h2 id="Unity中Json库性能对比测试"><a href="#Unity中Json库性能对比测试" class="headerlink" title="Unity中Json库性能对比测试"></a>Unity中Json库性能对比测试</h2><h3 id="类库大小对比"><a href="#类库大小对比" class="headerlink" title="类库大小对比:"></a><strong>类库大小对比:</strong></h3><div class="table-container"><table><thead><tr><th>类库</th><th style="text-align:center">文件类型</th><th style="text-align:right">大小</th></tr></thead><tbody><tr><td>NewtonsoftJson</td><td style="text-align:center">.dll</td><td style="text-align:right">353KB</td></tr><tr><td>LitJson</td><td style="text-align:center">.dll</td><td style="text-align:right">56KB</td></tr><tr><td>SimpleJSON</td><td style="text-align:center">.cs</td><td style="text-align:right">68KB</td></tr></tbody></table></div><h3 id="解析时间对比："><a href="#解析时间对比：" class="headerlink" title="解析时间对比："></a><strong>解析时间对比：</strong></h3><p>执行次数：10000次</p><div class="table-container"><table><thead><tr><th>测试方法</th><th style="text-align:center">NewtonsoftJson</th><th style="text-align:center">LitJson</th><th style="text-align:right">SimpleJSON</th></tr></thead><tbody><tr><td>测试1</td><td style="text-align:center">114ms</td><td style="text-align:center">158ms</td><td style="text-align:right">52ms</td></tr><tr><td>测试2</td><td style="text-align:center">136ms</td><td style="text-align:center">288ms</td><td style="text-align:right">126ms</td></tr><tr><td>测试3</td><td style="text-align:center">263ms</td><td style="text-align:center">542ms</td><td style="text-align:right">169ms</td></tr><tr><td>测试4</td><td style="text-align:center">333ms</td><td style="text-align:center">747ms</td><td style="text-align:right">200ms</td></tr></tbody></table></div><h3 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a><strong>测试代码：</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> LitJson;</span><br><span class="line"><span class="keyword">using</span> SimpleJSON;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json.Linq;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> JsonTest</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ZhangYu 2019-07-11</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;para&gt;</span>Blog：https://segmentfault.com/a/1190000019731298<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JsonTest</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> count = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> Stopwatch watch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        watch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> json1 = <span class="string">&quot;&#123;\&quot;id\&quot;:10001,\&quot;name\&quot;:\&quot;test\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> json2 = <span class="string">&quot;[1,2,3,4,5,6,7,8,9,10]&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> json3 = <span class="string">&quot;&#123;\&quot;id\&quot;:10000,\&quot;username\&quot;:\&quot;zhangyu\&quot;,\&quot;password\&quot;:\&quot;123456\&quot;,\&quot;nickname\&quot;:\&quot;冰封百度\&quot;,\&quot;age\&quot;:20,\&quot;gender\&quot;:1,\&quot;phone\&quot;:12345678910,\&quot;email\&quot;:\&quot;zhangyu@xx.com\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> json4 = <span class="string">&quot;[\&quot;test2\&quot;,[[\&quot;key1\&quot;,    \&quot;id\&quot;],[\&quot;key2\&quot;,    \&quot;hp\&quot;],[\&quot;key3\&quot;,    \&quot;mp\&quot;],[\&quot;key4\&quot;,    \&quot;exp\&quot;],[\&quot;key5\&quot;,    \&quot;money\&quot;],[\&quot;key6\&quot;,    \&quot;point\&quot;],[\&quot;key7\&quot;,    \&quot;age\&quot;],[\&quot;key8\&quot;,    \&quot;sex\&quot;]]]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        JsonParseTest(json1);</span><br><span class="line">        JsonParseTest(json2);</span><br><span class="line">        JsonParseTest(json3);</span><br><span class="line">        JsonParseTest(json4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">JsonParseTest</span>(<span class="params"><span class="built_in">string</span> json</span>)</span> &#123;</span><br><span class="line">        print(<span class="string">&quot;json:&quot;</span> + json);</span><br><span class="line">        <span class="built_in">bool</span> isArray = json[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        NewtonsoftJsonTest(json, isArray);</span><br><span class="line">        LiteJsonTest(json);</span><br><span class="line">        SimpleJsonTest(json);</span><br><span class="line">        print(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NewtonsoftJsonTest</span>(<span class="params"><span class="built_in">string</span> json, <span class="built_in">bool</span> isArray</span>)</span> &#123;</span><br><span class="line">        watch.Reset();</span><br><span class="line">        watch.Start();</span><br><span class="line">        <span class="keyword">if</span> (isArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                JArray jArray = JArray.Parse(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                JObject jObj = JObject.Parse(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        watch.Stop();</span><br><span class="line">        print(<span class="string">&quot;NewtonsoftJson Parse Time(ms):&quot;</span> + watch.ElapsedMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LiteJsonTest</span>(<span class="params"><span class="built_in">string</span> json</span>)</span> &#123;</span><br><span class="line">        watch.Reset();</span><br><span class="line">        watch.Start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            JsonData jData = JsonMapper.ToObject(json);</span><br><span class="line">        &#125;</span><br><span class="line">        watch.Stop();</span><br><span class="line">        print(<span class="string">&quot;LiteJson Parse Time(ms):&quot;</span> + watch.ElapsedMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SimpleJsonTest</span>(<span class="params"><span class="built_in">string</span> json</span>)</span> &#123;</span><br><span class="line">        watch.Reset();</span><br><span class="line">        watch.Start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            JSONNode jNode = JSON.Parse(json);</span><br><span class="line">        &#125;</span><br><span class="line">        watch.Stop();</span><br><span class="line">        print(<span class="string">&quot;SimpleJson Parse Time(ms):&quot;</span> + watch.ElapsedMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023414.png" alt="解析时间对比"></p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h3><p>SimpleJSON获胜!<br>SimpleJSON以体积最小，速度最快，集成最容易的优势胜出<br>SimpleJSON针对Unity在持续优化，更新较快，而且体积小，速度快，有源码，推荐SimpleJSON<br>NewtonsoftJson因为体积太大被淘汰，按理来说，这么大的类库肯定支持更多功能，可惜现有的项目并没有太过复杂的json，无法检验。<br>LitJson体积也小巧，使用也很方便，可惜速度完全没有优势。</p><h2 id="NewtonsoftJson使用"><a href="#NewtonsoftJson使用" class="headerlink" title="NewtonsoftJson使用"></a>NewtonsoftJson使用</h2><p>正好项目中用到了所以就以Newtonsoft.Json为例子，更多功能看官方文档吧。</p><p>官方文档：<a href="https://www.newtonsoft.com/json。">https://www.newtonsoft.com/json。</a></p><p>对于要在 JSON 字符串之间进行转换的简单场景， <a href="https://www.newtonsoft.com/json/help/html/Overload_Newtonsoft_Json_JsonConvert_SerializeObject.htm">SerializeObject</a>和 <a href="https://www.newtonsoft.com/json/help/html/Overload_Newtonsoft_Json_JsonConvert_DeserializeObject.htm">反序列化对象</a> JsonConvert 上的方法为 JsonSerializer 提供了一个易于使用的包装器。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">product.Name = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">product.ExpiryDate = <span class="keyword">new</span> DateTime(<span class="number">2008</span>, <span class="number">12</span>, <span class="number">28</span>);</span><br><span class="line">product.Price = <span class="number">3.99</span>M;</span><br><span class="line">product.Sizes = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Small&quot;</span>, <span class="string">&quot;Medium&quot;</span>, <span class="string">&quot;Large&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> output = JsonConvert.SerializeObject(product);</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  &quot;Name&quot;: &quot;Apple&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;ExpiryDate&quot;: &quot;2008-12-28T00:00:00&quot;,</span></span><br><span class="line"><span class="comment">//  &quot;Price&quot;: 3.99,</span></span><br><span class="line"><span class="comment">//  &quot;Sizes&quot;: [</span></span><br><span class="line"><span class="comment">//    &quot;Small&quot;,</span></span><br><span class="line"><span class="comment">//    &quot;Medium&quot;,</span></span><br><span class="line"><span class="comment">//    &quot;Large&quot;</span></span><br><span class="line"><span class="comment">//  ]</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">Product deserializedProduct = JsonConvert.DeserializeObject&lt;Product&gt;(output);</span><br></pre></td></tr></table></figure><p>SerializeObject 和 DeserializeObject 都具有采用<a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_JsonSerializerSettings.htm">JsonSerializerSettings</a>对象的重载。JsonSerializerSettings 允许您使用下面列出的许多 JsonSerializer 设置，同时仍然使用简单的序列化方法。</p><p>为了更好地控制对象的序列化方式，可以直接使用<a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_JsonSerializer.htm">JsonSerializer 。</a><a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_JsonTextReader.htm">JsonSerializer 能够通过JsonTextReader</a> 和<a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_JsonTextWriter.htm">JsonTextWriter</a>直接读取 JSON 文本并将其写入流。也可以使用其他类型的 JsonWriters，例如 <a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Linq_JTokenReader.htm">JTokenReader</a> / <a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Linq_JTokenWriter.htm">JTokenWriter</a>将您的对象与 LINQ 对象转换为 JSON 对象，或 <a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Bson_BsonReader.htm">BsonReader</a> / <a href="https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Bson_BsonWriter.htm">BsonWriter</a>用于与 BSON 进行转换。</p><p>使用 JsonSerializer 将 JSON 序列化为流</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Product product = <span class="keyword">new</span> Product();</span><br><span class="line">product.ExpiryDate = <span class="keyword">new</span> DateTime(<span class="number">2008</span>, <span class="number">12</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">JsonSerializer serializer = <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">serializer.Converters.Add(<span class="keyword">new</span> JavaScriptDateTimeConverter());</span><br><span class="line">serializer.NullValueHandling = NullValueHandling.Ignore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(<span class="string">@&quot;c:\json.txt&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (JsonWriter writer = <span class="keyword">new</span> JsonTextWriter(sw))</span><br><span class="line">&#123;</span><br><span class="line">    serializer.Serialize(writer, product);</span><br><span class="line">    <span class="comment">// &#123;&quot;ExpiryDate&quot;:new Date(1230375600000),&quot;Price&quot;:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JsonSerializer 上有许多属性来自定义它如何序列化 JSON。这些也可以通过 JsonSerializerSettings 重载与 JsonConvert 上的方法一起使用。</p><h3 id="反序列化部分Json"><a href="#反序列化部分Json" class="headerlink" title="反序列化部分Json"></a>反序列化部分Json</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SearchResult</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Url &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> googleSearchText = <span class="string">@&quot;&#123;</span></span><br><span class="line"><span class="string">  &#x27;responseData&#x27;: &#123;</span></span><br><span class="line"><span class="string">    &#x27;results&#x27;: [</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        &#x27;GsearchResultClass&#x27;: &#x27;GwebSearch&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;unescapedUrl&#x27;: &#x27;http://en.wikipedia.org/wiki/Paris_Hilton&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;url&#x27;: &#x27;http://en.wikipedia.org/wiki/Paris_Hilton&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;visibleUrl&#x27;: &#x27;en.wikipedia.org&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;cacheUrl&#x27;: &#x27;http://www.google.com/search?q=cache:TwrPfhd22hYJ:en.wikipedia.org&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;title&#x27;: &#x27;&lt;b&gt;Paris Hilton&lt;/b&gt; - Wikipedia, the free encyclopedia&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;titleNoFormatting&#x27;: &#x27;Paris Hilton - Wikipedia, the free encyclopedia&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;content&#x27;: &#x27;[1] In 2006, she released her debut album...&#x27;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        &#x27;GsearchResultClass&#x27;: &#x27;GwebSearch&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;unescapedUrl&#x27;: &#x27;http://www.imdb.com/name/nm0385296/&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;url&#x27;: &#x27;http://www.imdb.com/name/nm0385296/&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;visibleUrl&#x27;: &#x27;www.imdb.com&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;cacheUrl&#x27;: &#x27;http://www.google.com/search?q=cache:1i34KkqnsooJ:www.imdb.com&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;title&#x27;: &#x27;&lt;b&gt;Paris Hilton&lt;/b&gt;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;titleNoFormatting&#x27;: &#x27;Paris Hilton&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;content&#x27;: &#x27;Self: Zoolander. Socialite &lt;b&gt;Paris Hilton&lt;/b&gt;...&#x27;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &#x27;cursor&#x27;: &#123;</span></span><br><span class="line"><span class="string">      &#x27;pages&#x27;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &#x27;start&#x27;: &#x27;0&#x27;,</span></span><br><span class="line"><span class="string">          &#x27;label&#x27;: 1</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &#x27;start&#x27;: &#x27;4&#x27;,</span></span><br><span class="line"><span class="string">          &#x27;label&#x27;: 2</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &#x27;start&#x27;: &#x27;8&#x27;,</span></span><br><span class="line"><span class="string">          &#x27;label&#x27;: 3</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &#x27;start&#x27;: &#x27;12&#x27;,</span></span><br><span class="line"><span class="string">          &#x27;label&#x27;: 4</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ],</span></span><br><span class="line"><span class="string">      &#x27;estimatedResultCount&#x27;: &#x27;59600000&#x27;,</span></span><br><span class="line"><span class="string">      &#x27;currentPageIndex&#x27;: 0,</span></span><br><span class="line"><span class="string">      &#x27;moreResultsUrl&#x27;: &#x27;http://www.google.com/search?oe=utf8&amp;ie=utf8...&#x27;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &#x27;responseDetails&#x27;: null,</span></span><br><span class="line"><span class="string">  &#x27;responseStatus&#x27;: 200</span></span><br><span class="line"><span class="string">&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">JObject googleSearch = JObject.Parse(googleSearchText);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get JSON result objects into a list</span></span><br><span class="line">IList&lt;JToken&gt; results = googleSearch[<span class="string">&quot;responseData&quot;</span>][<span class="string">&quot;results&quot;</span>].Children().ToList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// serialize JSON results into .NET objects</span></span><br><span class="line">IList&lt;SearchResult&gt; searchResults = <span class="keyword">new</span> List&lt;SearchResult&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (JToken result <span class="keyword">in</span> results)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// JToken.ToObject is a helper method that uses JsonSerializer internally</span></span><br><span class="line">    SearchResult searchResult = result.ToObject&lt;SearchResult&gt;();</span><br><span class="line">    searchResults.Add(searchResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Title = &lt;b&gt;Paris Hilton&lt;/b&gt; - Wikipedia, the free encyclopedia</span></span><br><span class="line"><span class="comment">// Content = [1] In 2006, she released her debut album...</span></span><br><span class="line"><span class="comment">// Url = http://en.wikipedia.org/wiki/Paris_Hilton</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Title = &lt;b&gt;Paris Hilton&lt;/b&gt;</span></span><br><span class="line"><span class="comment">// Content = Self: Zoolander. Socialite &lt;b&gt;Paris Hilton&lt;/b&gt;...</span></span><br><span class="line"><span class="comment">// Url = http://www.imdb.com/name/nm0385296/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JsonUtility&quot;&gt;&lt;a href=&quot;#JsonUtility&quot; class=&quot;headerlink&quot; title=&quot;JsonUtility&quot;&gt;&lt;/a&gt;JsonUtility&lt;/h2&gt;&lt;h3 id=&quot;一、Unity自带的Json库&quot;&gt;&lt;a href=&quot;#一、</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="Json" scheme="https://liuyingbo.com/tags/Json/"/>
    
  </entry>
  
  <entry>
    <title>Unity-全局屏幕点击特效</title>
    <link href="https://liuyingbo.com/posts/undefined.html"/>
    <id>https://liuyingbo.com/posts/undefined.html</id>
    <published>2022-03-14T23:11:45.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192050977.gif" alt="img"></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先canvas的设置调为camera模式</p><p><strong>Screen Space -OverLay</strong>:只显示所创建的canvas中的内容，即只渲染画布。</p><p><strong>Screen Space-Camera</strong>：只显示相机所渲染的区域，当保证camera的projection是perspective（透视模式）而不是（orthogonality）正交模式的时候通过调整canvas中image或其他物体的Rotation可以制作3D立体效果的UI，但是这种模式下不可以更改Canvas的ReactTransform,只能通过相机来调整canvas的显示位置和显示大小。</p><p><strong>World Space</strong>：canvas的ReacTransform完全可以编辑并且把canvas完全当成一个普通的类似于Cube的物体在场景中进行渲染，仔细考虑一下这种模式，如果你把canvas赋给游戏人物，那么你会发现这种模式适合给人物做血条或者在场景中一直在游戏人物的头顶显示人物名称。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192050747.png" alt="image-20220314231710281"></p><h2 id="Unity坐标"><a href="#Unity坐标" class="headerlink" title="Unity坐标"></a>Unity坐标</h2><h3 id="世界坐标："><a href="#世界坐标：" class="headerlink" title="世界坐标："></a>世界坐标：</h3><p>场景中非子物体的transform组件的坐标。Unity中的通过transform.position获取到的坐标即为世界坐标，注意:Inspector上点击子物体显示的transform上的坐标值是局部坐标，通过transform.localposition获取。</p><h3 id="屏幕坐标："><a href="#屏幕坐标：" class="headerlink" title="屏幕坐标："></a>屏幕坐标：</h3><p>屏幕坐标即当前整个游戏画面分辨率为主创建的坐标系，画面左下角为原点(0,0)，宽高根据分辨率而定，如分辨率为1920X1080，则宽Screen.width = 1920，Screen.height = 1080.</p><h3 id="视口坐标："><a href="#视口坐标：" class="headerlink" title="视口坐标："></a>视口坐标：</h3><p>将屏幕坐标normalized化，x值 = 1/Screen.width,y值 = 1/Screen.height。，即原点变不变依然为(0,0),宽高则为(1,1)。</p><h3 id="UI坐标："><a href="#UI坐标：" class="headerlink" title="UI坐标："></a>UI坐标：</h3><p>以UI上的RectTransform的width和height为宽高，根据锚点不同，原点也不一样。</p><h3 id="转换："><a href="#转换：" class="headerlink" title="转换："></a>转换：</h3><blockquote><p>1.屏幕转世界坐标<br> Vector3 Camera.main.ScreenToWorldPoint(newVector3(screenPos.x,screenPos.y,zInfo));</p><p>2.世界转屏幕坐标<br> Vector3 Camera.main.WorldToScreenPoint(newVector3(worldPos.x,worldPos.y,worldPos.z));</p><p>3.世界转视口坐标<br> Vector3 Camera.main.WorldToViewportPoint();</p><p>4.视口转世界坐标<br> Vector3 Camera.main.ViewportToWorldPoint(newVector3(viewPortPos.x,viewPortPos.y,zInfo));</p><p>5.视口转屏幕坐标<br> Vector3 Camera.main.ViewportToScreenPoint();</p><p>6.屏幕转视口坐标<br> Vector3 Camera.main.ScreenToViewportPoint();</p><p>7.屏幕转UI坐标:这个比较特殊，如果UI宽高和屏幕宽高一样，那么可以不用转换，直接通过屏幕坐标根据锚点赋值即可。其他情况下：<br> RectTransformUtility.ScreenPointToLocalPointInRectangle<br> (RectTransform rect,<br> Vector2 screenPoint,<br> Camera cam,<br> outVector2 localPoint);</p></blockquote><p>rect表示该UI的父物体的组件，<br> screenPoint表示屏幕坐标，<br> cam表示当前使用的相机(如果Canvas是Screen Space-overlay模式，cam参数应为null),<br> localPoint则是输出的UI的局部坐标。<br> 这个函数是根据父物体的坐标系来计算出当面屏幕坐标应该转换为的值，该值是相对父物体而言的局部坐标。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FXContainer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Vector2 point;</span><br><span class="line">    <span class="keyword">public</span> Transform parent;</span><br><span class="line">    <span class="keyword">public</span> GameObject effect;</span><br><span class="line">    <span class="keyword">public</span> Canvas UICanvas; <span class="comment">//你所使用的UICanvas</span></span><br><span class="line">    [<span class="meta">Range(0, 5.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> desTime = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//将鼠标点击的屏幕坐标转换为UI坐标，最后一个输出参数为转换的点</span></span><br><span class="line">            RectTransformUtility.ScreenPointToLocalPointInRectangle(UICanvas.transform <span class="keyword">as</span> RectTransform,Input.mousePosition, UICanvas.worldCamera, <span class="keyword">out</span> point);</span><br><span class="line"></span><br><span class="line">            GameObject go = Instantiate(effect, parent);</span><br><span class="line">            go.GetComponent&lt;RectTransform&gt;().anchoredPosition = point;</span><br><span class="line">            Destroy(go, desTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是靠RectTransformUtility.ScreenPointToLocalPointInRectangle获取鼠标点击的UI坐标，如果想优化的话可以写个对象池，扩展可以实现粒子效果跟随鼠标,图片跟随鼠标等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192050977.gif&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity-底层原理</title>
    <link href="https://liuyingbo.com/posts/b6d0915c.html"/>
    <id>https://liuyingbo.com/posts/b6d0915c.html</id>
    <published>2022-03-12T16:46:56.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unity是如何实现跨平台的"><a href="#Unity是如何实现跨平台的" class="headerlink" title="Unity是如何实现跨平台的"></a>Unity是如何实现跨平台的</h2><p>首先，我们要知道Unity,Mono,.Net 三者的关系。需要简单说一下.Net。</p><p>.Net拥有跨语言，跨平台性。</p><p>跨语言：就是只要是面向.Net平台的编程语言，用其中一种语言编写的类型就可以无缝的在另外一种语言编写的应用程序中互操作。</p><p>跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意在.Net实现的平台上跑，即代码不依赖于操作系统，也不依赖硬件环境。一个.Net程序运行的核心在于.Net</p><p>CLR(公共语言运行时，或者称为.Net 虚拟机，类似java虚拟机的概念)，为了让.Net程序在其他平台（目前只能在.Net 平台,windows系统）上跑,微软官方还推出了在其他平台上(MacOs,Linux)跑的</p><p>.Net的实现，就推出了.Net Core。</p><p>然而，Unity引擎需求也是需要跨平台，支持多语言（C#，Js，Boo）。就参考微软开发.Net Core的概念，于是，推出了Mono.</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049788.png" alt="img"></p><p>到这里，基本说明了.Net 与Mono和Unity的联系关系，其实没啥关系。做游戏都知道，肯定需要跨平台，不能只支持一种平台，不然每个对应的平台做出一种对应的编译器，那真的会累死。所以对于跨平台的需求，对于游戏开发而言，很重要。Unity的架构需求设计当然也需要这个特性。参考.Net依托CLR来实现设计思路，于是Mono就出来了。</p><h2 id="Mono介绍"><a href="#Mono介绍" class="headerlink" title="Mono介绍"></a>Mono介绍</h2><p><strong>Mono</strong>是一个由<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/Xamarin">Xamarin</a>公司所主持的自由开放源码项目。<br>Mono的目标是在尽可能多的平台上使.net标准的东西能正常运行的一套工具，核心在于“跨平台的让.net代码能运行起来“。<br>Mono组成组件：C# 编译器，CLI虚拟机，以及核心类别程序库。<br>Mono的编译器<strong>负责生成符合公共语言规范的映射代码</strong>，即公共中间语言（Common Intermediate Language，<strong>CIL</strong>），我的理解就是工厂方法实现不同解析。<br>IL的全称是 Intermediate Language，很多时候还会看到<strong>CIL</strong>（特指在.Net平台下的IL标准）。翻译过来就是中间语言。<br>它是一种属于通用语言架构和.NET框架的低阶的人类可读的编程语言。<br>CIL类似一个面向对象的汇编语言，并且它是完全基于堆栈的，它运行在虚拟机上（.Net Framework, Mono VM）的语言。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049879.png" alt="img"></p><h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a><strong>工作流程：</strong></h3><ol><li>通过C#编译器mcs，将C#编译为IL（中间语言，byte code）</li><li>通过Mono运行时中的编译器将IL编译成对应平台的原生码</li></ol><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a><strong>编译器</strong></h3><blockquote><p>C#编译器mcs：将C#编译为<strong>IL</strong><br>Mono Runtime编译器：将IL转移为<strong>原生码</strong>。</p></blockquote><h3 id="三种转译方式："><a href="#三种转译方式：" class="headerlink" title="三种转译方式："></a><strong>三种转译方式：</strong></h3><p><strong>即时编译（Just in time,JIT）</strong>：程序运行过程中，将CIL的byte code转译为目标平台的原生码。<br><strong>提前编译（Ahead of time,AOT）</strong>：程序运行之前，将.exe或.dll文件中的CIL的byte code部分转译为目标平台的原生码并且存储，程序运行中仍有部分CIL的byte code需要JIT编译。<br><strong>完全静态编译（Full ahead of time,Full-AOT）</strong>：程序运行前，将所有源码编译成目标平台的原生码。</p><h3 id="Unity跨平台的原理"><a href="#Unity跨平台的原理" class="headerlink" title="Unity跨平台的原理"></a>Unity跨平台的原理</h3><blockquote><p>Mono运行时编译器支持将IL代码转为对应平台原生码<br>IL可以在任何支持CLI,通用语言环境结构)中运行，IL的运行是依托于Mono运行时。</p></blockquote><h3 id="IOS不支持jit编译原因："><a href="#IOS不支持jit编译原因：" class="headerlink" title="IOS不支持jit编译原因："></a>IOS不支持jit编译原因：</h3><blockquote><p>机器码被禁止映射到内存，即封存了内存的可执行权限，变相的封锁了jit编译方式。</p></blockquote><h3 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a><strong>JIT编译</strong></h3><blockquote><p>将IL代码转为对应平台原生码并且将原生码映射到虚拟内存中执行。JIT编译的时候IL是在依托Mono运行时，转为对应的原生码后在依托本地运行。</p></blockquote><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049905.png" alt="img"></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>构建应用非常快</li><li>由于Mono的JIT(Just In Time compilation ) 机制, 所以支持更多托管类库</li><li>支持运行时代码执行</li><li>必须将代码发布成托管程序集(.dll 文件 , 由mono或者.net 生成 )</li><li>Mono VM在各个平台移植异常麻烦，有几个平台就得移植几个VM（WebGL和UWP这两个平台只支持 IL2CPP）</li><li>Mono版本授权受限，C#很多新特性无法使用</li><li>iOS仍然支持Mono , 但是不再允许Mono(32位)应用提交到Apple Store</li></ol><h2 id="IL2CPP介绍"><a href="#IL2CPP介绍" class="headerlink" title="IL2CPP介绍"></a>IL2CPP介绍</h2><p>IL2CPP 是 Unity一种新的脚本后处理(Scripting Backend)方式，针对.Net平台编译输出的IL（中间语言）进行处理。</p><h3 id="IL2CPP主要由两部分组成"><a href="#IL2CPP主要由两部分组成" class="headerlink" title="IL2CPP主要由两部分组成"></a>IL2CPP主要由两部分组成</h3><p>AOT静态编译编译器（il2cpp.exe），把IL中间语言转换成CPP文件</p><p>运行时库（libil2cpp）<br>其中AOT将 IL转换为C++源码，再交给各平台的C++编译器进行编译，达到平台兼容的目的；运行时库则会提供诸如 垃圾回收、线程/文件获取、内部调用直接修改托管数据结构的原生代码 的服务与抽象。</p><h4 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h4><blockquote><p>IL2CPP AOT编译器名为il2cpp.exe。<br>在Windows上，您可以在<code>Editor \ Data \ il2cpp</code>目录中找到它。<br>在OSX上，它位于Unity安装的<code>Contents / Frameworks / il2cpp / build</code>目录中<br>il2cpp.exe 是由C#编写的受托管的可执行程序，它接受我们在Unity中通过Mono编译器生成的托管程序集，并生成指定平台下的C++代码。</p></blockquote><h4 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a><strong>运行时库</strong></h4><blockquote><p>IL2CPP技术的另一部分是运行时库（libil2cpp），用于支持IL2CPP虚拟机的运行。<br>这个简单且可移植的运行时库是IL2CPP技术的主要优势之一！<br>通过查看我们随Unity一起提供的libil2cpp的头文件，您可以找到有关libil2cpp代码组织方式的一些线索<br>您可以在Windows的<code>Editor \ Data \ PlaybackEngines \ webglsupport \ BuildTools \ Libraries \ libil2cpp \ include</code>目录中找到它们<br>或OSX上的<code>Contents / Frameworks / il2cpp / libil2cpp</code>目录。</p></blockquote><h3 id="为何要转成CPP"><a href="#为何要转成CPP" class="headerlink" title="为何要转成CPP"></a>为何要转成CPP</h3><ul><li>运行效率快</li></ul><blockquote><p>根据官方的实验数据，换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。</p></blockquote><ul><li>Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成</li></ul><blockquote><p>Mono的跨平台是通过Mono VM实现的，有几个平台，就要实现几个VM，像Unity这样支持多平台的引擎，Mono官方的VM肯定是不能满足需求的。所以针对不同的新平台，Unity的项目组就要把VM给移植一遍，同时解决VM里面发现的bug。这非常耗时耗力。这些能移植的平台还好说，还有比如WebGL这样基于浏览器的平台。要让WebGL支持Mono的VM几乎是不可能的。</p></blockquote><ul><li><p>可以利用<strong>现成的在各个平台的C++编译器</strong>对代码执行<strong>编译期优化</strong>，这样可以进一步<strong>减小最终游戏的尺寸并提高游戏运行速度</strong>。</p></li><li><p>由于动态语言的特性，他们多半无需程序员太多关心内存管理，所有的内存分配和回收都由一个叫做GC（Garbage Collector）的组件完成。</p></li></ul><p>虽然通过IL2CPP以后代码变成了静态的C++，但是内存管理这块还是遵循C#的方式，这也是为什么最后还要有一个 <strong>IL2CPP VM</strong>的原因：<strong>它负责提供诸如GC管理，线程创建这类的服务性工作。</strong></p><p>但是由于去除了<strong>IL加载和动态解析</strong>的工作，<strong>使得IL2CPP VM可以做的很小</strong>，<strong>并且使得游戏载入时间缩短</strong>。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192049027.png" alt="img"></p><p>在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后<strong>再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</strong></p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ol><li>相比Mono, 代码生成有很大的提高</li><li>可以调试生成的C++代码</li><li>可以启用引擎代码剥离(Engine code stripping)来减少代码的大小</li><li>程序的运行效率比Mono高，运行速度快</li><li>多平台移植非常方便</li><li>相比Mono构建应用慢</li><li>只支持AOT(Ahead of Time)编译</li></ol><h2 id="ILRuntime"><a href="#ILRuntime" class="headerlink" title="ILRuntime"></a>ILRuntime</h2><p>ILRuntime项目为基于C#的平台（例如Unity）提供了一个<code>纯C#实现</code>，<code>快速</code>、<code>方便</code>且<code>可靠</code>的IL运行时，使得能够在不支持JIT的硬件环境（如iOS）能够实现代码的热更新</p><h3 id="ILRuntime的优势"><a href="#ILRuntime的优势" class="headerlink" title="ILRuntime的优势"></a>ILRuntime的优势</h3><p>同市面上的其他热更方案相比，ILRuntime主要有以下优点：</p><ul><li>无缝访问C#工程的现成代码，无需额外抽象脚本API</li><li>直接使用VS2015进行开发，ILRuntime的解译引擎支持.Net 4.6编译的DLL</li><li>执行效率是L#的10-20倍</li><li>选择性的CLR绑定使跨域调用更快速，绑定后跨域调用的性能能达到slua的2倍左右（从脚本调用GameObject之类的接口）</li><li>支持跨域继承</li><li>完整的泛型支持</li><li>拥有Visual Studio的调试插件，可以实现真机源码级调试。支持Visual Studio 2015 Update3 以及Visual Studio 2017和Visual Studio 2019</li><li>最新的2.0版引入的寄存器模式将数学运算性能进行了大幅优化</li></ul><h3 id="C-vs-Lua"><a href="#C-vs-Lua" class="headerlink" title="C# vs Lua"></a>C# vs Lua</h3><p>目前市面上主流的热更方案，主要分为Lua的实现和用C#的实现，两种实现方式各有各的优缺点。</p><p>Lua是一个已经非常成熟的解决方案，但是对于Unity项目而言，也有非常明显的缺点。就是如果使用Lua来进行逻辑开发，就势必要求团队当中的人员需要同时对Lua和C#都特别熟悉，或者将团队中的人员分成C#小组和Lua小组。不管哪一种方案，对于中小型团队都是非常痛苦的一件事情。</p><p>用C#来作为热更语言最大的优势就是项目可以用同一个语言来进行开发，对Unity项目而言，这种方式肯定是开发效率最高的。</p><p>Lua的优势在于解决方案足够成熟，之前的C++团队可能比起C#，更加习惯使用Lua来进行逻辑开发。此外借助luajit，在某些情况下的执行效率会非常不错，但是luajit现在维护情况也不容乐观，官方还是推荐使用公版Lua来开发。</p><blockquote><p>如果需要测试ILRuntime对比Lua的性能Benchmark，需要确认以下几点：</p></blockquote><ul><li>ILRuntime加载的dll文件是<code>Release</code>模式编译的</li><li>dll中对外部API的调用都进行了<code>CLR绑定</code></li><li>确保<code>没有勾选Development Build</code>的情况下发布成正式真机运行包，而<code>不是在Editor中直接运行</code></li><li>可以直接使用Demo工程中提供的性能测试进行对比</li></ul><blockquote><p>ILRuntime设计上为了在开发时提供更多的调试支持，在Unity Editor中运行会有很多额外的性能开销，<br>因此在Unity Editor中直接测试并不能代表ILRuntime的实际运行性能。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Unity是如何实现跨平台的&quot;&gt;&lt;a href=&quot;#Unity是如何实现跨平台的&quot; class=&quot;headerlink&quot; title=&quot;Unity是如何实现跨平台的&quot;&gt;&lt;/a&gt;Unity是如何实现跨平台的&lt;/h2&gt;&lt;p&gt;首先，我们要知道Unity,Mono,.Ne</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="Mono" scheme="https://liuyingbo.com/tags/Mono/"/>
    
  </entry>
  
  <entry>
    <title>Unity-Shader</title>
    <link href="https://liuyingbo.com/posts/9fa0374.html"/>
    <id>https://liuyingbo.com/posts/9fa0374.html</id>
    <published>2022-03-06T22:25:02.000Z</published>
    <updated>2023-01-30T11:35:12.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><h2 id="什么是-Shader？"><a href="#什么是-Shader？" class="headerlink" title="什么是 Shader？"></a>什么是 Shader？</h2><p>Shade 的英文意思，如下：<br>v.给…遮挡（光线）；把…涂暗</p><p>其中 把…涂暗 更贴近我们想要的意思。<br>所以：Shader 这个单词从字面上理解，就是把什么东西涂暗。</p><p>Shader 从单词字面上理解，就是把什么东西涂暗。<br>把什么东西涂暗的就是 Shader，就是着色器。</p><h2 id="Shader-把什么涂暗了？"><a href="#Shader-把什么涂暗了？" class="headerlink" title="Shader 把什么涂暗了？"></a>Shader 把什么涂暗了？</h2><p>有光明就有黑暗，有光照物体就有明暗对比，同时也会有阴影，而 Shader 之所以叫 Shader 是因为起初的时候，Shader 就是用来给物体增加明暗对比的，有了明暗对比，物体在游戏世界中就会更加立体，从而画面会更加真实。</p><p>所以 Shader 的作用就是给物体添加明暗对比。</p><h2 id="Shader-为什么叫-Shader"><a href="#Shader-为什么叫-Shader" class="headerlink" title="Shader 为什么叫 Shader"></a>Shader 为什么叫 Shader</h2><p>现在 Shader 不止可以给物体添加明暗对比，而且还可以做很多滤镜效果，也可以做很多性能优化（比如减少包大小、减少图片内存等）的事情。</p><p>也许，一开始给 Shader 起名叫 Shader 的时候，Shader 功能非常有限，仅仅只是给物体添加明暗对比（也就是光照计算），后来由于硬件和软件的发展， 很多离线渲染（电影 CG）的算法都逐步应用在实时渲染（主要是 游戏 和3D 仿真等），Shader 能做的事情就越来越多，发展到今天，Shader 主要的功能并不只有光照计算。</p><h2 id="Shader-是着色器"><a href="#Shader-是着色器" class="headerlink" title="Shader 是着色器"></a>Shader 是着色器</h2><p>什么是 Shader，中文叫做着色器，也就是给物体上色的意思，也就是说写 Shader 就是给物体上色的艺术。而这个上色不只是简单的色彩填充，而是涵盖了非常多的技巧（几何计算、颜色计算、贴图等）</p><p>所以中文的着色器，是一个非常精准的翻译。</p><p><strong>Shader 主要是光线数据作用在不同数据的物体上产生不同效果。</strong></p><h2 id="颜色的控制"><a href="#颜色的控制" class="headerlink" title="颜色的控制"></a>颜色的控制</h2><p>现有一张贴图，如下：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242145905.png" alt="5d1c4283dd75732329.png"></p><p>用来控制颜色的 shader 代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    // 图片上每个像素的颜色值</span><br><span class="line">    float4 color = tex2D(_MainTex, i.uv);</span><br><span class="line">            </span><br><span class="line">    // 返回颜色，表示将改像素的颜色值输出到屏幕上</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然，我们没有 Shader 的语法学习经验，但是凭我们的 C# 经验，可以将上述代码推测个大概来。</p><p>首先 float4 是一个类型，可以存储 4 个 float 数值。而颜色一般都是由 r（red 红色）、g（green，绿色）、b（blue，蓝色）、a（alpha，透明度） 四个值控制。所以 float4 可以存储一个颜色。</p><p>现在，我们把图片中每个像素颜色重的红色值设置为 0，图片结果则如下所示:<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192026547.png" alt="5d1c429881a1050254.png"></p><p>代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    // 图片上每个像素的颜色值</span><br><span class="line">    float4 color = tex2D(_MainTex, i.uv);</span><br><span class="line">            </span><br><span class="line">    color.r = 0;</span><br><span class="line"></span><br><span class="line">    // 返回颜色，表示将改像素的颜色值输出到屏幕上</span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，图片变成了蓝绿色。</p><h1 id="卡通着色"><a href="#卡通着色" class="headerlink" title="卡通着色"></a>卡通着色</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>创建场景。</li><li>在场景创建球、</li><li>在 Assets 目录中创建材质。</li><li>在 Assets 目录中创建 Shader。</li><li>把 Shader 贴到材质上。</li><li>把材质贴到球上。</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p>材质的本质就是 Shader + Texture（贴图）。一个材质就是由 Shader 和 Texture 组成的。</p><p>这一句适用于通常情况下，有的时候，材质只有 Shader，并没有 Texture，而是需要我们调整一些参数。</p><p>纹理也是数据，所以“材质由 Shader 和 Texture 组成”这句话，更准确地说应该是“材质由 Shader 和 数据组成”。</p><h2 id="Shader文件"><a href="#Shader文件" class="headerlink" title="Shader文件"></a>Shader文件</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unlit/Toon&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            <span class="comment">// make fog work</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">1</span>)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span> (<span class="params">appdata v</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span> (<span class="params">v2f i</span>) : SV_Target</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// sample the texture</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">// apply fog</span></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第一行-Shader-“Unlit-Toon”"><a href="#第一行-Shader-“Unlit-Toon”" class="headerlink" title="第一行 Shader “Unlit/Toon”"></a><strong>第一行 Shader “Unlit/Toon”</strong></h3><p>这句话做的事情很简单，就是定义 Shader 的名字以及路径。在这里定义的名字和路径可以在材质的 Inspector 面板上找到对应的 Shader，</p><h3 id="第二行-Properties"><a href="#第二行-Properties" class="headerlink" title="第二行 Properties"></a><strong>第二行 Properties</strong></h3><p>Properties 属性的意思，在这个代码块中，可以定义属性的。</p><p>但是 Shader 的属性可以通过 C# 脚本设置值，可以通过，所在材质的 Inspector 中进行设置值。</p><h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h3><p>SubShader 顾名思义就是子 Shader，为什么要区分出来个 SubShader 这个概念呢？</p><p>Unity 在调用 Shader 时，会扫描所有的 SubShader 并选择一个可以在目标平台上运行的 SubShader。<br>也就是说，SubShader 和目标平台有点关系。</p><p>对于 SubShader 的概念，我们目前只了解这些即可，以后再深入了解。</p><p>关于 SubShader，我们只要记住，一个 Shader 可以定义多个 SubShader ，具体选择哪个 SubShader 要看目标平台支不支持所定义的 SubShader 的特性即可。</p><h3 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h3><p>一个 Shader 可以定义多个 SubShader，同样地一个 SubShader 也可以定义多个 Pass。</p><p>这个 Pass 是什么意思呢？英语中 Pass 是通过的意思。</p><p>在 Shader 中 Pass 则是通道的意思。</p><p>这个通道又是什么？</p><p>通道的官方定义为：通道控制 GameObject 几何体的一次渲染。</p><p>也就是说我们写 Shader 一般都是在 Pass 代码块中控制渲染，在 Pass 代码块中我们可以做很多设置，以及实现很多渲染算法。</p><h2 id="纸片球变立体球"><a href="#纸片球变立体球" class="headerlink" title="纸片球变立体球"></a>纸片球变立体球</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/Toon&quot;</span><br><span class="line">&#123;</span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">_Diffuse(&quot;Diffuse&quot;,Color) = (1,1,1,1)</span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">  </span><br><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line">#pragma vertex vert</span><br><span class="line">#pragma fragment frag</span><br><span class="line"></span><br><span class="line">#include &quot;UnityCG.cginc&quot;</span><br><span class="line">#include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">struct appdata</span><br><span class="line">&#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float2 uv : TEXCOORD0;</span><br><span class="line">float3 normal:NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos: SV_POSITION; </span><br><span class="line">float3 color : Color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">float4 _Diffuse;</span><br><span class="line"></span><br><span class="line">v2f vert (appdata v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line"></span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">fixed3 worldNormal = normalize(mul(v.normal,(float3x3)unity_WorldToObject));</span><br><span class="line"></span><br><span class="line">fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));</span><br><span class="line"></span><br><span class="line">o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">return fixed4(i.color,1.0);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Diffuse基础色"><a href="#Diffuse基础色" class="headerlink" title="Diffuse基础色"></a>Diffuse基础色</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">_Diffuse(&quot;Diffuse&quot;,Color) = (1,1,1,1) // 基础色值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Properties 中，定义了一个 Diffuse 属性。</p><p>Diffuse 是什么意思呢？英文中是散射、扩散的意思，在 Shader（图形学）术语中，我们叫做漫反射，但是在这里，这个 Diffuse 属性，并不代表漫反射本身，而是一个基础颜色，我们的漫反射计算是在这个颜色的基础之上叠加而成的。</p><p>只要记住，在这个 Shader 中，它是基础颜色就好，或者干脆可以理解成它是物体上的颜色，也可。</p><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">return fixed4(i.color,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这个代码是一个方法/函数。<br>方法名为 frag，返回值为 float4 类型，接受的参数是 v2f 类型。<br>这些词都是什么意思呢？</p><p>首先介绍方法名：frag，frag 是 fragment 的缩写，fragment 在英语中是片段、碎片的意思。<br>而在图形学术语中，fragment 叫做片元，而 fragment shader 就是片元着色器。<br>那这个 frag 方法，顾名思义就是片元着色器，而里边的实现，则是处理片元的意思。</p><p>片元着色器有一个别名：叫做像素着色器，而片元（fragment) 是 OpenGL 的 GLSL（OpenGL 着色语言）中的一个概念，这个概念先不用了解。</p><p>我们只要把当前的 frag 方法，按照像素着色器去理解即可，也就是说 frag 方法做的事情是每个像素都计算（返回）一遍颜色即可。</p><p>结论：frag 方法是 像素着色器（片元着色器），这个方法对每个像素（片元）进行意思颜色计算并输出（返回）给屏幕。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shader&quot;&gt;&lt;a href=&quot;#Shader&quot; class=&quot;headerlink&quot; title=&quot;Shader&quot;&gt;&lt;/a&gt;Shader&lt;/h1&gt;&lt;h2 id=&quot;什么是-Shader？&quot;&gt;&lt;a href=&quot;#什么是-Shader？&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
    <category term="Shader" scheme="https://liuyingbo.com/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Unity-简易对象池</title>
    <link href="https://liuyingbo.com/posts/6739242f.html"/>
    <id>https://liuyingbo.com/posts/6739242f.html</id>
    <published>2022-03-01T22:51:57.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<p>在Unity中我们经常会用到对象池，使用对象池无非就是解决两个问题:</p><ul><li>一是减少 new 时候寻址造成的消耗，该消耗的原因是内存碎片。</li><li>二是减少 Object.Instantiate 时内部进行序列化和反序列化而造成的CPU消耗。</li></ul><h2 id="设计："><a href="#设计：" class="headerlink" title="设计："></a>设计：</h2><p>从字面上理解对象池，池的意思就是容器。我们可以从池中获取一个对象(一条鱼)，也可以向池中放入一个对象(一条鱼)。获取的操作我们叫Allocate(分配),而放入一个对象我们叫Recycle(回收)。所以我们可以定义池的接口为如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IPool&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">T Allocate();</span><br><span class="line"></span><br><span class="line">bool Recycle(T obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用泛型呢？如何实现一个精简并且灵活的对象池。这个灵活很大一部分是通过泛型体现的。</p><p>池是容器的意思，在C#中可以是List,Queue或者Stack甚至是数组。所以对象池本身要维护一个容器。本篇我们选取Stack来作为池容器，原因是当我们在Allocate和Recycle时并不关心缓存的存储的顺序，只要求缓存对象的地址是连续的。代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">public abstract class Pool&lt;T&gt; : IPool&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">protected Stack&lt;T&gt; mCacheStack = new Stack&lt;T&gt;();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pool是个抽象类，实现一个精简并且灵活的对象池。这个灵活很大一部分是通过抽象类体现的。</p><p>现在对象的存取和缓存接口都设计好了，那么这些对象是从哪里来的呢？我们分析下，创建对象我们知道有两种方式，反射构造方法和new一个对象。对象池的一个重要功能就是缓存，要想实现缓存就要求对象可以在对象池内部进行创建。所以我们要抽象出一个对象的工厂，代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IObjectFactory&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">T Create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用工厂? 实现一个精简并且灵活的对象池。这个灵活很大一部分是通过工厂体现的。</p><p>OK，现在对象的创建，存取，缓存的接口都设计好了。下面放出Pool的全部代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">public abstract class Pool&lt;T&gt; : IPool&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">#region ICountObserverable</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// Gets the current count.</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;value&gt;The current count.&lt;/value&gt;</span><br><span class="line">public int CurCount</span><br><span class="line">&#123;</span><br><span class="line">get &#123; return mCacheStack.Count; &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endregion</span><br><span class="line"></span><br><span class="line">protected IObjectFactory&lt;T&gt; mFactory;</span><br><span class="line"></span><br><span class="line">protected Stack&lt;T&gt; mCacheStack = new Stack&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// default is 5</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">protected int mMaxCount = 5;</span><br><span class="line"></span><br><span class="line">public virtual T Allocate()</span><br><span class="line">&#123;</span><br><span class="line">return mCacheStack.Count == 0</span><br><span class="line">? mFactory.Create()</span><br><span class="line">: mCacheStack.Pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract bool Recycle(T obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象池实现"><a href="#对象池实现" class="headerlink" title="对象池实现"></a>对象池实现</h2><p>首先要实现一个对象的创建器,代码如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">public class CustomObjectFactory&lt;T&gt; : IObjectFactory&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">public CustomObjectFactory(Func&lt;T&gt; factoryMethod)</span><br><span class="line">&#123;</span><br><span class="line">mFactoryMethod = factoryMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Func&lt;T&gt; mFactoryMethod;</span><br><span class="line"></span><br><span class="line">public T Create()</span><br><span class="line">&#123;</span><br><span class="line">return mFactoryMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，只是维护了一个返回值为T的委托。<br>对象池实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// unsafe but fast</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;</span><br><span class="line">public class SimpleObjectPool&lt;T&gt; : Pool&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">readonly Action&lt;T&gt; mResetMethod;</span><br><span class="line"></span><br><span class="line">public SimpleObjectPool(Func&lt;T&gt; factoryMethod, Action&lt;T&gt; resetMethod = null,int initCount = 0)</span><br><span class="line">&#123;</span><br><span class="line">mFactory = new CustomObjectFactory&lt;T&gt;(factoryMethod);</span><br><span class="line">mResetMethod = resetMethod;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; initCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">mCacheStack.Push(mFactory.Create());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public override bool Recycle(T obj)</span><br><span class="line">&#123;</span><br><span class="line">mResetMethod.InvokeGracefully(obj);</span><br><span class="line">mCacheStack.Push(obj);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用?"></a>如何使用?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var fishPool = new SimpleObjectPool&lt;Fish&gt;(() =&gt; new Fish(), null, 100);</span><br><span class="line"></span><br><span class="line">Log.I(&quot;fishPool.CurCount:&#123;0&#125;&quot;, fishPool.CurCount);</span><br><span class="line"></span><br><span class="line">var fishOne = fishPool.Allocate();</span><br><span class="line"></span><br><span class="line">Log.I(&quot;fishPool.CurCount:&#123;0&#125;&quot;, fishPool.CurCount);</span><br><span class="line"></span><br><span class="line">fishPool.Recycle(fishOne);</span><br><span class="line"></span><br><span class="line">Log.I(&quot;fishPool.CurCount:&#123;0&#125;&quot;, fishPool.CurCount);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">fishPool.Allocate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log.I(&quot;fishPool.CurCount:&#123;0&#125;&quot;, fishPool.CurCount);</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fishPool.CurCount:100</span><br><span class="line">fishPool.CurCount:99</span><br><span class="line">fishPool.CurCount:100</span><br><span class="line">fishPool.CurCount:90</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Unity中我们经常会用到对象池，使用对象池无非就是解决两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是减少 new 时候寻址造成的消耗，该消耗的原因是内存碎片。&lt;/li&gt;
&lt;li&gt;二是减少 Object.Instantiate 时内部进行序列化和反序列化而造成的CPU消耗。&lt;</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity-射线</title>
    <link href="https://liuyingbo.com/posts/9d4bb48a.html"/>
    <id>https://liuyingbo.com/posts/9d4bb48a.html</id>
    <published>2022-03-01T22:48:15.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity射线系统"><a href="#Unity射线系统" class="headerlink" title="Unity射线系统"></a>Unity射线系统</h1><h2 id="Demo展示"><a href="#Demo展示" class="headerlink" title="Demo展示"></a>Demo展示</h2><p>UI+Physical射线测试：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023267.gif" alt="12123123"></p><p>FPS自定义射线测试：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211192023524.gif" alt="img"></p><h2 id="UGUI射线工具"><a href="#UGUI射线工具" class="headerlink" title="UGUI射线工具"></a>UGUI射线工具</h2><p>实现功能，鼠标点击UI,返回鼠标点击的UI对象；</p><p>需要使用到鼠标点击事件-PointerEventData；</p><p>关键API:EventSystem.current.RaycastAll();</p><p>参数为鼠标点击事件，和接受射线返回结果集合；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">RaycastUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (EventSystem.current == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//鼠标点击事件</span></span><br><span class="line">    PointerEventData pointerEventData = <span class="keyword">new</span> PointerEventData(EventSystem.current);</span><br><span class="line">    <span class="comment">//设置鼠标位置</span></span><br><span class="line">    pointerEventData.position = Input.mousePosition;</span><br><span class="line">    <span class="comment">//射线检测返回结果</span></span><br><span class="line">    List&lt;RaycastResult&gt; results = <span class="keyword">new</span> List&lt;RaycastResult&gt;();</span><br><span class="line">    <span class="comment">//检测UI</span></span><br><span class="line">    EventSystem.current.RaycastAll(pointerEventData, results);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回最上层ui</span></span><br><span class="line">    <span class="keyword">if</span> (results.Count &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> results[<span class="number">0</span>].gameObject;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Physcial射线工具"><a href="#Physcial射线工具" class="headerlink" title="Physcial射线工具"></a>Physcial射线工具</h2><p>从摄像机发射射线，方向为，摄像机——鼠标位置；</p><p>可以获取射线碰撞到的3D物品的大部分信息：</p><p>可以活着hit.collider；意味着可以获取碰撞点的位置，物体等信息；</p><p>用来做鼠标点击地面控制人物位移；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">RaycastPhysical</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">    RaycastHit hit;</span><br><span class="line">    <span class="built_in">bool</span> isHit = Physics.Raycast((Ray) ray, <span class="keyword">out</span> hit);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (isHit)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(hit.collider.name);</span><br><span class="line">        <span class="keyword">return</span> hit.collider.gameObject; <span class="comment">//检测到碰撞，就把检测到的点记录下来</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject temp = RayCastTool.RaycastUI();</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (temp.CompareTag(<span class="string">&quot;Pic&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                temp.GetComponent&lt;Image&gt;().color = Color.red;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject temp = RayCastTool.RaycastPhysical();</span><br><span class="line">            </span><br><span class="line">            temp.GetComponent&lt;Renderer&gt;().material.color = Color.red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FPS射线测试"><a href="#FPS射线测试" class="headerlink" title="FPS射线测试"></a>FPS射线测试</h2><p>自定义射线的起始点Origin，方向，以及射线长度；</p><p>获取射线碰撞点的位置物体信息;</p><p>用来做第三人称FPS的射击判定，或者RPG远程技能判定；</p><p>第一人称FPS，射线起始点和方向，替换成相机——屏幕中心瞄准心；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestRayCast</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Transform player;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        player = GameObject.FindGameObjectWithTag(<span class="string">&quot;Player&quot;</span>).transform;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Ray ray = <span class="keyword">new</span> Ray(player.position, player.forward);</span><br><span class="line">        RaycastHit hit;</span><br><span class="line">        <span class="built_in">bool</span> isHit = Physics.Raycast((Ray) ray, <span class="keyword">out</span> hit,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Debug.DrawRay(player.position, player.forward*<span class="number">10</span>, Color.blue);</span><br><span class="line">        <span class="keyword">if</span> (isHit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hit.collider.CompareTag(<span class="string">&quot;Enemy&quot;</span>))</span><br><span class="line">                hit.collider.GetComponent&lt;Renderer&gt;().material.color = Color.red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity射线系统&quot;&gt;&lt;a href=&quot;#Unity射线系统&quot; class=&quot;headerlink&quot; title=&quot;Unity射线系统&quot;&gt;&lt;/a&gt;Unity射线系统&lt;/h1&gt;&lt;h2 id=&quot;Demo展示&quot;&gt;&lt;a href=&quot;#Demo展示&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://liuyingbo.com/posts/e85d694a.html"/>
    <id>https://liuyingbo.com/posts/e85d694a.html</id>
    <published>2022-02-25T12:41:43.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h3><p>简单地理解，满足以下两个条件的树就是二叉树：</p><p>本身是有序树；</p><p>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907612.gif" alt="二叉树示意图"></p><h3 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h3><ul><li>二叉树中，第 i 层最多有 2i-1 个结点。</li><li>如果二叉树的深度为 K，那么此二叉树最多有 2K-1 个结点。</li><li>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。</li></ul><blockquote><p>性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。<br>同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2<em>n2。所以，n 用另外一种方式表示为 n=n1+2</em>n2+1。<br>两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。</p></blockquote><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907257.gif" alt="满二叉树示意图"></p><p>满二叉树除了满足普通二叉树的性质，还具有以下性质：</p><ul><li>满二叉树中第 i 层的节点数为 2n-1 个。</li><li>深度为 k 的满二叉树必有 2k-1 个节点 ，叶子数为 2k-1。</li><li>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li><li>具有 n 个节点的满二叉树的深度为 log2(n+1)。</li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907572.gif" alt="完全二叉树示意图"></p><p>如图 3a) 所示是一棵完全二叉树，图 3b) 由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。</p><p>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。</p><p>⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。</p><p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：</p><ul><li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li><li>如果 2<em>i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2</em>i 。</li><li>如果 2<em>i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2</em>i+1 。</li></ul><h3 id="二叉树储存结构"><a href="#二叉树储存结构" class="headerlink" title="二叉树储存结构"></a>二叉树储存结构</h3><p>采用链式存储二叉树时，其节点结构由 3 部分构成：</p><ul><li>指向左孩子节点的指针（Lchild）；</li><li>节点存储的数据（data）；</li><li>指向右孩子节点的指针（Rchild）；</li></ul><p>表示该节点结构的 C#代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Definition for a binary tree node.</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">  public int val;</span><br><span class="line">  public TreeNode left;</span><br><span class="line">  public TreeNode right;</span><br><span class="line">  public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) &#123;</span><br><span class="line">  this.val = val;</span><br><span class="line">  this.left = left;</span><br><span class="line">  this.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907970.png" alt="img"></p><p>先序遍历：</p><ul><li>访问根节点；</li><li>访问当前节点的左子<a href="http://data.biancheng.net/view/23.html">树</a>；</li><li>若当前节点无左子树，则访问当前节点的右子树；</li></ul><p>中序遍历：</p><ol><li>访问当前节点的左子<a href="http://data.biancheng.net/view/23.html">树</a>；</li><li>访问根节点；</li><li>访问当前节点的右子树；</li></ol><p>后续遍历：</p><p>从根节点出发，依次遍历各节点的左右子树，直到当前节点左右子树遍历完成后，才访问该节点元素。</p><blockquote><p>根-&gt; 左-&gt; 右<br>左-&gt; 根-&gt; 右<br>左-&gt; 右-&gt; 根<br>根再前就是前序，在中就是中序，在最后就是后续，遍历的时候可以三个为一组比较容易看</p></blockquote><p>递归写法遍历：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历二叉树,并将遍历的结果保存到list中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="params">TreeNode node, IList&lt;TreeNode&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  list.Add(node);</span><br><span class="line">    dfs(node.left, list);</span><br><span class="line">    dfs(node.right, list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历二叉树,并将遍历的结果保存到list中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="params">TreeNode node, IList&lt;TreeNode&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(node.left, list);</span><br><span class="line">    list.Add(node);</span><br><span class="line">    dfs(node.right, list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续序遍历二叉树,并将遍历的结果保存到list中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="params">TreeNode node, IList&lt;TreeNode&gt; list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(node.left, list);</span><br><span class="line">    dfs(node.right, list);</span><br><span class="line">  list.Add(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归先序,要先访问根节点，然后再去访问左子树以及右子树，这明显是递归定义，但这里是用栈来实现的</span></span><br><span class="line"><span class="comment">//先需要先从栈顶取出节点，然后访问该节点，如果该节点不为空，则存储该节点，同时把该节点的右子树先入栈，然后左子树入栈。循环结束的条件是栈中不在有节点。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    IList&lt;TreeNode&gt; result = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span> || cur != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.Add(cur);</span><br><span class="line">            stack.Push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = stack.Pop();</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归中序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    IList&lt;TreeNode&gt; result = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span> || cur != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            stack.Push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = stack.Pop();</span><br><span class="line">          result.Add(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归后续</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">  TreeNode p = <span class="literal">null</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    IList&lt;TreeNode&gt; result = <span class="keyword">new</span> List&lt;TreeNode&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span> || cur != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span>(cur != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          stack.Push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">      cur = stack.Peek();</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span> &amp;&amp; cur.right != p)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = stack.Pop();</span><br><span class="line">          result.Add(cur);</span><br><span class="line">            p = cur;</span><br><span class="line">          cur = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层次遍历：</p><p>按照二叉树中的层次从左到右依次遍历每层中的结点。具体的实现思路是：通过使用队列的数据结构，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907124.png" alt="img"></p><h2 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h2><h3 id="比较BFS和DFS"><a href="#比较BFS和DFS" class="headerlink" title="比较BFS和DFS"></a>比较BFS和DFS</h3><p>Breadth First Search（广度优先搜索），将相邻的节点一层层查找，找到最多的。</p><p>Deep FIrst Search（深度优先搜索），一直往下寻找，若没有剩余相邻节点时，回走一步，再查找剩余的下一个相邻节点，直到回到起始点</p><p>DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？</p><p>如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。</p><p>DFS 与 BFS在二叉树上进行 DFS 遍历和 BFS 遍历的代码比较。</p><p>DFS 遍历使用递归：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span>(<span class="params">TreeNode root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS 遍历使用队列数据结构：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">    queue.Enqueue(root);<span class="comment">// C# 的 add 写作 Enqueue()</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.Dequeue(); <span class="comment">// C# 的 pop 写作 Dequeue()</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.Enqueue(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.Enqueue(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907256.gif" alt="DFS 与 BFS 对比"></p><h3 id="BFS-的应用：层序遍历"><a href="#BFS-的应用：层序遍历" class="headerlink" title="BFS 的应用：层序遍历"></a>BFS 的应用：层序遍历</h3><p>BFS 的层序遍历应用：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LeetCode 102. Binary Tree Level Order Traversal</a> 二叉树的层序遍历（Medium）</p><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p><p>什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907225.jpg" alt="二叉树的层序遍历"></p><p>乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 Count（也就是这一层的结点数量），然后一口气处理完这一层的 Count 个结点。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191907356.gif" alt="img"></p><p>在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; LevelOrder(TreeNode root) &#123;</span><br><span class="line">    IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; result = <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    IList&lt;<span class="built_in">int</span>&gt; ans = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">    <span class="built_in">int</span> len = <span class="number">0</span>;</span><br><span class="line">    queue.Enqueue(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.Count != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = queue.Count;</span><br><span class="line">        ans.Clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          TreeNode node = queue.Dequeue();</span><br><span class="line">          ans.Add(node.val);</span><br><span class="line">          <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.Enqueue(node.left);</span><br><span class="line">          <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.Enqueue(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">      result.Add(<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(ans));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS的应用：回溯算法"><a href="#DFS的应用：回溯算法" class="headerlink" title="DFS的应用：回溯算法"></a>DFS的应用：<a href="https://liuyingbo.com/archives/376d0826.html">回溯算法</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;什么是二叉树&quot;&gt;&lt;a href=&quot;#什么是二叉树&quot; class=&quot;headerlink&quot; title=&quot;什么是二叉树&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://liuyingbo.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://liuyingbo.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://liuyingbo.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Unity-Asset资源</title>
    <link href="https://liuyingbo.com/posts/521e43fc.html"/>
    <id>https://liuyingbo.com/posts/521e43fc.html</id>
    <published>2022-02-20T15:37:00.000Z</published>
    <updated>2023-01-30T11:35:12.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity资源文件夹介绍"><a href="#Unity资源文件夹介绍" class="headerlink" title="Unity资源文件夹介绍"></a>Unity资源文件夹介绍</h1><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242137186.png" alt="image-20211008233301906"></p><h2 id="编辑时"><a href="#编辑时" class="headerlink" title="编辑时"></a>编辑时</h2><p>在Asset文件下存在Resources和SteamingAsset文件夹；</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>只读不可修改，打包时直接写死，没有办法通过热更新替换资源；</p><p>可以存放任何格式的资源；</p><p>通过Resources.Load加载；</p><p>一般只存登录UI，congfig配置等不会修改的文件；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载</span></span><br><span class="line">GameObject go = Resources.Load&lt;GameObject&gt;(path);</span><br><span class="line">Sprite sp = Resouces.Load(path,<span class="keyword">typeof</span>(sprite)) <span class="keyword">as</span> sprite;</span><br><span class="line">TextAsset txt = Resources.Load(path) <span class="keyword">as</span> TextAsset;</span><br></pre></td></tr></table></figure><h3 id="SteamingAssets"><a href="#SteamingAssets" class="headerlink" title="SteamingAssets"></a>SteamingAssets</h3><p>存放打包后Unity打包后的资源，也就是我说的AssetBundle（ab包）；</p><p>可读可写，打包后移动端不能使用File类读取（用过www读取streamingAssetspath数据拷贝到persistentDataPath）；</p><h2 id="安装后"><a href="#安装后" class="headerlink" title="安装后"></a>安装后</h2><h3 id="Application-dataPath"><a href="#Application-dataPath" class="headerlink" title="Application.dataPath"></a>Application.dataPath</h3><p>包含游戏数据文件夹的路径，app程序包安装路径（不常用）；</p><p> 1.UnityEditor——<strong>默认Assets</strong>——可读可写 using StreamReader/StreamWriter/异步</p><p> 2.Andriod——data/app/xxx.apk——不可读不可写</p><p> 3.IOS——Application/…..app/Data——可读不可写（读没意义）</p><h3 id="Application-streamingAssetsPath"><a href="#Application-streamingAssetsPath" class="headerlink" title="Application.streamingAssetsPath"></a>Application.streamingAssetsPath</h3><p>数据流换成目录，外部数据文件（二进制，AssetsBundle.csv、数据裸露不加密）；</p><p> 1.除了Andriod都可读可写，使用WWW或者System.IO都可以；</p><p> 2.Andriod只读，只能用WWW读写——第三方压缩/解压库实现读写（待研究）；</p><p> <strong>3.安装包资源目录，不可修改；</strong></p><h3 id="Application-presistentDataPath"><a href="#Application-presistentDataPath" class="headerlink" title="Application.presistentDataPath"></a>Application.presistentDataPath</h3><p>持久化存储目录，应用更新、覆盖安装都不会清除；</p><p> 1.全平台可读可写——stream和file都可以读写；</p><p> <strong>2.热更新资源存放目录；</strong></p><h3 id="Application-temporaryCachePath"><a href="#Application-temporaryCachePath" class="headerlink" title="Application.temporaryCachePath"></a>Application.temporaryCachePath</h3><p>临时换成目录，可读可写（只有ios常用）；</p><h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><p>资源压缩文件（ab包），非路径，一种压缩文件的格式；</p><h1 id="AssetBundle-1"><a href="#AssetBundle-1" class="headerlink" title="AssetBundle"></a>AssetBundle</h1><h2 id="Asset-Bundle："><a href="#Asset-Bundle：" class="headerlink" title="Asset Bundle："></a><strong>Asset Bundle：</strong></h2><p><strong>AssetBundle</strong> 是一个存档文件，包含可在运行时加载的特定于平台的资源（模型、纹理、预制件、音频剪辑甚至整个场景）。AssetBundle 可以表达彼此之间的依赖关系；例如 AssetBundle A 中的材质可以引用 AssetBundle B 中的纹理。为了通过网络进行有效传递，可以根据用例要求选用内置算法来压缩 AssetBundle（LZMA 和 LZ4）。</p><p>AssetBundle 可用于可下载内容（DLC），减小初始安装大小，加载针对最终用户平台优化的资源，以及减轻运行时内存压力。</p><h2 id="AssetBundle-中有什么"><a href="#AssetBundle-中有什么" class="headerlink" title="AssetBundle 中有什么:"></a><strong>AssetBundle 中有什么:</strong></h2><p>“AssetBundle”可以指两种不同但相关的东西。</p><p>首先是磁盘上的实际文件。对于这种情况，我们称之为 AssetBundle 存档，在本文档中简称“存档”。存档可以被视为一个容器，就像文件夹一样，可以在其中包含其他文件。这些附加文件包含两种类型：</p><p>序列化文件和资源文件。序列化文件包含分解为各个对象并写入此单个文件的资源。资源文件只是为某些资源（纹理和音频）单独存储的二进制数据块，允许我们有效地在另一个线程上从磁盘加载它们。</p><p>其次是通过代码进行交互以便从特定存档加载资源的实际 AssetBundle 对象。此对象包含一个映射，即从已添加到此存档的资源的所有文件路径到按需加载的资源所包含的对象之间的映射。</p><h2 id="为-AssetBundle-分配资源"><a href="#为-AssetBundle-分配资源" class="headerlink" title="为 AssetBundle 分配资源"></a>为 AssetBundle 分配资源</h2><p>要为 AssetBundle 分配指定资源，请按照下列步骤操作：</p><p>1.从 Project 视图中选择要为捆绑包分配的资源 </p><p>2.在 Inspector 中检查对象</p><p> 3.在 Inspector 底部，应该会看到一个用于分配 AssetBundle 和变体的部分：</p><p> 4.左侧下拉选单分配 AssetBundle，而右侧下拉选单分配变量 </p><p>5.单击左侧下拉选单，其中显示“None”，表示当前注册的 AssetBundle 名称 </p><p>6.单击“New…”以创建新的 AssetBundle </p><p>7.输入所需的 AssetBundle 名称。请注意，AssetBundle 名称支持某种类型的文件夹结构，具体取决于您输入的内容。要添加子文件夹，请用“/”分隔文件夹名称。例如：AssetBundle 名称“environment/forest”将在 environment 子文件夹下创建名为 forest 的捆绑包 </p><p>8.一旦选择或创建了 AssetBundle 名称，便可以重复此过程在右侧下拉选单中分配或创建变体名称（如果需要）。构建 AssetBundle 不需要变体名称</p><h2 id="构建-AssetBundle"><a href="#构建-AssetBundle" class="headerlink" title="构建 AssetBundle"></a>构建 AssetBundle</h2><p>在 Assets 文件夹中创建一个名为 Editor 的文件夹，并将包含以下内容的脚本放在该文件夹中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using System.IO;</span><br><span class="line">using UnityEditor;</span><br><span class="line"></span><br><span class="line">public class CreateAssetBundles</span><br><span class="line">&#123;</span><br><span class="line">    [MenuItem(&quot;Assets/Build AssetBundles&quot;)]</span><br><span class="line">    static void BuildAllAssetBundles()</span><br><span class="line">    &#123;</span><br><span class="line">        string assetBundleDirectory = &quot;Assets/AssetBundles&quot;;</span><br><span class="line">        if (!Directory.Exists(assetBundleDirectory))</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(assetBundleDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">        BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, BuildTarget.StandaloneOSX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此脚本将在 Assets 菜单底部创建一个名为“Build AssetBundles”的菜单项，该菜单项将执行与该标签关联的函数中的代码。单击 Build AssetBundles 时，将随构建对话框一起显示一个进度条。此过程将会获取带有 AssetBundle 名称标签的所有资源，并将它们放在 assetBundleDirectory 定义的路径中的文件夹中。</p><h2 id="将-AssetBundle-上传到场外存储"><a href="#将-AssetBundle-上传到场外存储" class="headerlink" title="将 AssetBundle 上传到场外存储"></a>将 AssetBundle 上传到场外存储</h2><p>此步骤对每个用户都是不同的，因此 Unity 不能告诉您应该具体如何操作。如果计划将 AssetBundle 上传到第三方托管站点，请在此步中执行该操作。如果正在严格执行本地开发并打算将所有 AssetBundle 都放在磁盘上，请跳转到下一步。</p><h2 id="加载-AssetBundle-和资源"><a href="#加载-AssetBundle-和资源" class="headerlink" title="加载 AssetBundle 和资源"></a>加载 AssetBundle 和资源</h2><p>打算从本地存储加载的用户可能会对 AssetBundles.LoadFromFile API 感兴趣。该 API 如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LoadFromFileExample extends MonoBehaviour &#123;</span><br><span class="line">    function Start() &#123;</span><br><span class="line">        var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));</span><br><span class="line">        if (myLoadedAssetBundle == null) &#123;</span><br><span class="line">            Debug.Log(&quot;Failed to load AssetBundle!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(&quot;MyObject&quot;);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为-AssetBundle-准备资源"><a href="#为-AssetBundle-准备资源" class="headerlink" title="为 AssetBundle 准备资源"></a>为 AssetBundle 准备资源</h1><p>使用 AssetBundle 时，可以任意将任何资源分配给所需的任何捆绑包。但是，在设置捆绑包时需要考虑某些策略。以下分组策略旨在用于您认为适合的具体项目。可以根据需要随意混合和搭配这些策略。</p><h2 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h2><p>逻辑实体分组是指根据资源所代表的项目功能部分将资源分配给 AssetBundle。这包括各种不同部分，比如用户界面、角色、环境以及在应用程序整个生命周期中可能经常出现的任何其他内容。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>捆绑用户界面屏幕的所有纹理和布局数据</li><li>捆绑一个/一组角色的所有模型和动画</li><li>捆绑在多个关卡之间共享的景物的纹理和模型</li></ul><p>逻辑实体分组非常适合于可下载内容 (DLC)，因为通过这种方式将所有内容隔离后，可以对单个实体进行更改，而无需下载其他未更改的资源。</p><p>为了能够正确实施此策略，最大诀窍在于，负责为各自捆绑包分配资源的开发人员必须熟悉项目使用每个资源的准确时机和场合。</p><h2 id="类型分组"><a href="#类型分组" class="headerlink" title="类型分组"></a>类型分组</h2><p>根据此策略，可以将相似类型的资源（例如音频轨道或语言本地化文件）分配到单个 AssetBundle。</p><p>要构建供多个平台使用的 AssetBundle，类型分组是最佳策略之一。例如，如果音频压缩设置在 Windows 和 Mac 平台上完全相同，则可以自行将所有音频数据打包到 AssetBundle 并重复使用这些捆绑包，而着色器往往使用更多特定于平台的选项进行编译，因此为 Mac 构建的着色器捆绑包可能无法在 Windows 上重复使用。此外，这种方法非常适合让 AssetBundle 与更多 Unity 播放器版本兼容，因为纹理压缩格式和设置的更改频率低于代码脚本或预制件。</p><h2 id="并发内容分组"><a href="#并发内容分组" class="headerlink" title="并发内容分组"></a>并发内容分组</h2><p>并发内容分组是指将需要同时加载和使用的资源捆绑在一起。可以将这些类型的捆绑包用于基于关卡的游戏（其中每个关卡包含完全独特的角色、纹理、音乐等）。有时可能希望确保其中一个 AssetBundle 中的资源与该捆绑包中的其余资源同时使用。依赖于并发内容分组捆绑包中的单个资源会导致加载时间显著增加。您将被迫下载该单个资源的整个捆绑包。</p><p>并发内容分组捆绑包最常见的用例是针对基于场景的捆绑包。在此分配策略中，每个场景捆绑包应包含大部分或全部场景依赖项。</p><p>请注意，项目绝对可以也应该根据您的需求混用这些策略。对任何给定情形使用最优资源分配策略可以大大提高项目的效率。</p><p>例如，一个项目可能决定将不同平台的用户界面 (UI) 元素分组到各自的 Platform-UI 特定捆绑包中，但按关卡/场景对其交互式内容进行分组。</p><p>无论遵循何种策略，下面这些额外提示都有助于掌控全局：</p><ul><li>将频繁更新的对象与很少更改的对象拆分到不同的 AssetBundle 中</li><li>将可能同时加载的对象分到一组。例如模型及其纹理和动画</li><li>如果发现多个 AssetBundle 中的多个对象依赖于另一个完全不同的 AssetBundle 中的单个资源，请将依赖项移动到单独的 AssetBundle。如果多个 AssetBundle 引用其他 AssetBundle 中的同一组资源，一种有价值的做法可能是将这些依赖项拉入一个共享 AssetBundle 来减少重复。</li><li>如果不可能同时加载两组对象（例如标清资源和高清资源），请确保它们位于各自的 AssetBundle 中。</li><li>如果一个 AssetBundle 中只有不到 50% 的资源经常同时加载，请考虑拆分该捆绑包</li><li>考虑将多个小型的（少于 5 到 10 个资源）但经常同时加载内容的 AssetBundle 组合在一起</li><li>如果一组对象只是同一对象的不同版本，请考虑使用 AssetBundle 变体</li></ul><h1 id="构建-AssetBundle-1"><a href="#构建-AssetBundle-1" class="headerlink" title="构建 AssetBundle"></a>构建 AssetBundle</h1><p>在有关 <a href="AssetBundles-Workflow.html">AssetBundle 工作流程</a>的文档中，我们有一个代码示例将三个参数传递给 <code>BuildPipeline.BuildAssetBundles</code> 函数。让我们深入了解一下这方面。</p><p><em>Assets/AssetBundles</em>：这是 AssetBundle 要输出到的目录。可以将其更改为所需的任何输出目录，只需确保在尝试构建之前文件夹实际存在。</p><h4 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h4><p>可以指定几个具有各种效果的不同 <code>BuildAssetBundleOptions</code>。请参阅关于 <a href="../ScriptReference/BuildAssetBundleOptions.html">BuildAssetBundleOptions</a> 的脚本 API 参考查看所有这些选项的表格。</p><p>虽然可以根据需求变化和需求出现而自由组合 <code>BuildAssetBundleOptions</code>，但有三个特定的 <code>BuildAssetBundleOptions</code> 可以处理 AssetBundle 压缩：</p><ul><li><code>BuildAssetBundleOptions.None</code>: </li><li>此捆绑选项使用 LZMA 格式压缩，它是序列化数据文件的单个压缩 LZMA 流。LZMA 压缩要求在使用之前解压缩整个包。这会导致文件大小尽可能小，但由于解压缩，加载时间会稍长。值得注意的是，在使用此 BuildAssetBundleOptions 时，为了使用包中的任何资产，必须首先解压缩整个包。<br>解压缩包后，它将使用 LZ4 压缩在磁盘上重新压缩，这不需要在使用包中的资产之前解压缩整个包。当捆绑包包含资产时最好使用此方法，以便使用捆绑包中的一个资产意味着所有资产都将被加载。打包角色或场景的所有资产是可能使用此功能的捆绑包的一些示例。<br>由于文件较小，建议仅在从异地主机初始下载 AssetBundle 时使用 LZMA 压缩。<a href="../ScriptReference/Networking.UnityWebRequestAssetBundle.html">通过UnityWebRequestAssetBundle</a>加载的 LZMA 压缩资产包会自动重新压缩为 LZ4 压缩并缓存在本地文件系统上。如果您通过其他方式下载并存储该捆绑包，您可以使用<a href="../ScriptReference/AssetBundle.RecompressAssetBundleAsync.html">AssetBundle.RecompressAssetBundleAsync</a> API。</li><li><code>BuildAssetBundleOptions.UncompressedAssetBundle</code>：此捆绑包选项采用使数据完全未压缩的方式构建捆绑包。未压缩的缺点是文件下载大小增大。但是，下载后的加载时间会快得多。</li><li><code>BuildAssetBundleOptions.ChunkBasedCompression</code>：此捆绑包选项使用称为 LZ4 的压缩方法，因此压缩文件大小比 LZMA 更大，但不像 LZMA 那样需要解压缩整个包才能使用捆绑包。LZ4 使用基于块的算法，允许按段或“块”加载 AssetBundle。解压缩单个块即可使用包含的资源，即使 AssetBundle 的其他块未解压缩也不影响。</li></ul><p>使用 <code>ChunkBasedCompression</code> 时的加载时间与未压缩捆绑包大致相当，额外的优势是减小了占用的磁盘大小。</p><h4 id="BuildTarget"><a href="#BuildTarget" class="headerlink" title="BuildTarget"></a>BuildTarget</h4><p><code>BuildTarget.Standalone</code>：这里我们告诉构建管线，我们要将这些 AssetBundle 用于哪些目标平台。可以在关于 <a href="../ScriptReference/BuildTarget.html">BuildTarget</a> 的脚本 API 参考中找到可用显式构建目标的列表。但是，如果不想在构建目标中进行硬编码，请充分利用 <code>EditorUserBuildSettings.activeBuildTarget</code>，它将自动找到当前设置的目标构建平台，并根据该目标构建 AssetBundle。</p><p>一旦正确设置构建脚本，最后便可以开始构建资源包了。如果是按照上面的脚本示例进行的操作，请单击 <strong>Assets</strong> &gt; <strong>Build AssetBundles</strong> 以开始该过程。</p><p>现在已经成功构建了 AssetBundle，您可能会注意到 AssetBundles 目录包含的文件数量超出了最初的预期。确切地说，是多出了 2*(n+1) 个文件。让我们花点时间详细了解一下 <code>BuildPipeline.BuildAssetBundles</code> 产生的结果。</p><p>对于在编辑器中指定的每个 AssetBundle，可以看到一个具有 AssetBundle 名称+“.manifest”的文件。</p><p>随后会有一个额外捆绑包和清单的名称不同于先前创建的任何 AssetBundle。相反，此包以其所在的目录（构建 AssetBundle 的目录）命名。这就是清单捆绑包。我们以后会对此进行详细讨论并介绍使用方法。</p><h4 id="AssetBundle-文件"><a href="#AssetBundle-文件" class="headerlink" title="AssetBundle 文件"></a>AssetBundle 文件</h4><p>这是缺少 .manifest 扩展名的文件，其中包含在运行时为了加载资源而需要加载的内容。</p><p>AssetBundle 文件是一个存档，在内部包含多个文件。此存档的结构根据它是 AssetBundle 还是场景 AssetBundle 可能会略有不同。以下是普通 AssetBundle 的结构：</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242142639.png" alt="img"></p><p>场景 AssetBundle 与普通 AssetBundle 的不同之处在于，它针对场景及其内容的串流加载进行了优化。</p><h4 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h4><p>对于生成的每个捆绑包（包括附加的清单捆绑包），都会生成关联的清单文件。清单文件可以使用任何文本编辑器打开，并包含诸如循环冗余校验 (CRC) 数据和捆绑包的依赖性数据之类的信息。对于普通 AssetBundle，它们的清单文件将如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ManifestFileVersion: <span class="number">0</span></span><br><span class="line">CRC: <span class="number">2422268106</span></span><br><span class="line">Hashes:</span><br><span class="line">  AssetFileHash:</span><br><span class="line">    serializedVersion: <span class="number">2</span></span><br><span class="line">    Hash: <span class="number">8b</span>6db55a2344f068cf8a9be0a662ba15</span><br><span class="line">  TypeTreeHash:</span><br><span class="line">    serializedVersion: <span class="number">2</span></span><br><span class="line">    Hash: <span class="number">37</span>ad974993dbaa77485dd2a0c38f347a</span><br><span class="line">HashAppended: <span class="number">0</span></span><br><span class="line">ClassTypes:</span><br><span class="line">- Class: <span class="number">91</span></span><br><span class="line">  Script: &#123;instanceID: <span class="number">0</span>&#125;</span><br><span class="line">Assets:</span><br><span class="line">  Asset_0: Assets/Mecanim/StateMachine.controller</span><br><span class="line">Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure><p>其中显示了包含的资源、依赖项和其他信息。</p><p>生成的清单捆绑包将有一个清单，但看起来更可能如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ManifestFileVersion: <span class="number">0</span></span><br><span class="line">AssetBundleManifest:</span><br><span class="line">  AssetBundleInfos:</span><br><span class="line">    Info_0:</span><br><span class="line">      Name: scene1assetbundle</span><br><span class="line">      Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure><p>这将显示 AssetBundle 之间的关系以及它们的依赖项。就目前而言，只需要了解这个捆绑包中包含 AssetBundleManifest 对象，这对于确定在运行时加载哪些捆绑包依赖项非常有用。</p><h1 id="AssetBundle-依赖项"><a href="#AssetBundle-依赖项" class="headerlink" title="AssetBundle 依赖项"></a>AssetBundle 依赖项</h1><p>如果一个或多个 <code>UnityEngine.Objects</code> 包含对位于另一个捆绑包中的 <code>UnityEngine.Object</code> 的引用，则 AssetBundle 可以变为依赖于其他 AssetBundle。如果 <code>UnityEngine.Object</code> 包含对任何 AssetBundle 中未包含的 <code>UnityEngine.Object</code> 的引用，则不会发生依赖关系。在这种情况下，在构建 AssetBundle 时，捆绑包所依赖的对象的副本将复制到捆绑包中。如果多个捆绑包中的多个对象包含对未分配给捆绑包的同一对象的引用，则每个对该对象具有依赖关系的捆绑包将创建其自己的对象副本并将其打包到构建的 AssetBundle 中。</p><p>如果 AssetBundle 中包含依赖项，则在加载尝试实例化的对象之前，务必加载包含这些依赖项的捆绑包。Unity 不会尝试自动加载依赖项。</p><p>参考以下示例，<strong>Bundle 1</strong> 中的材质引用了 <strong>Bundle 2</strong> 中的纹理：</p><p>在此示例中，在从 <strong>Bundle 1</strong> 加载材质之前，需要将 <strong>Bundle 2</strong> 加载到内存中。加载 <strong>Bundle 1</strong> 和 <strong>Bundle 2</strong> 的顺序无关紧要，重要的是在从 <strong>Bundle 1</strong> 加载材质之前应加载 <strong>Bundle 2</strong>。在下一部分，我们将讨论如何使用我们在上一部分介绍的 <code>AssetBundleManifest</code> 对象在运行时确定并加载依赖项。</p><h1 id="使用-AssetBundle"><a href="#使用-AssetBundle" class="headerlink" title="使用 AssetBundle"></a>使用 AssetBundle</h1><p>可以使用四种不同的 API 来加载 AssetBundle。它们的行为根据加载捆绑包的平台和构建 AssetBundle 时使用的压缩方法（未压缩、LZMA 和 LZ4）而有所不同。</p><p>我们必须使用的四个 API 是：</p><ul><li><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromMemoryAsync.html?_ga=1.226802969.563709772.1479226228">AssetBundle.LoadFromMemoryAsync</a></li><li><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromFile.html?_ga=1.259297550.563709772.1479226228">AssetBundle.LoadFromFile</a></li><li><a href="https://docs.unity3d.com/ScriptReference/WWW.LoadFromCacheOrDownload.html?_ga=1.226802969.563709772.1479226228">WWW.LoadfromCacheOrDownload</a></li><li><a href="https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.html?_ga=1.259297550.563709772.1479226228">UnityWebRequest</a> 的 <a href="https://docs.unity3d.com/ScriptReference/Networking.DownloadHandlerAssetBundle.html?_ga=1.264500235.563709772.1479226228">DownloadHandlerAssetBundle </a>（Unity 5.3 或更高版本）</li></ul><h2 id="AssetBundle-LoadFromMemoryAsync"><a href="#AssetBundle-LoadFromMemoryAsync" class="headerlink" title="AssetBundle.LoadFromMemoryAsync"></a>AssetBundle.LoadFromMemoryAsync</h2><p><a href="../ScriptReference/AssetBundle.LoadFromMemoryAsync.html">AssetBundle.LoadFromMemoryAsync</a></p><p>此函数采用包含 AssetBundle 数据的字节数组。也可以根据需要传递 CRC 值。如果捆绑包采用的是 LZMA 压缩方式，将在加载时解压缩 AssetBundle。LZ4 压缩包则会以压缩状态加载。</p><p>以下是如何使用此方法的一个示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> path = Application.streamingAssetsPath + <span class="string">&quot;/AssetBundles/OSX/wall&quot;</span>;</span><br><span class="line">    AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line">        Debug.Log(<span class="string">&quot;Failed to load AssetBundle!&quot;</span> + createRequest);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> createRequest;</span><br><span class="line"></span><br><span class="line">        AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line">        <span class="keyword">var</span> prefab = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这不是实现 LoadFromMemoryAsync 的唯一策略。File.ReadAllBytes(path) 可以替换为获得字节数组的任何所需过程。</p><h2 id="AssetBundle-LoadFromFile"><a href="#AssetBundle-LoadFromFile" class="headerlink" title="AssetBundle.LoadFromFile"></a>AssetBundle.LoadFromFile</h2><p><a href="../ScriptReference/AssetBundle.LoadFromFile.html">AssetBundle.LoadFromFile</a></p><p>从本地存储中加载未压缩的捆绑包时，此 API 非常高效。如果捆绑包未压缩或采用了数据块 (LZ4) 压缩方式，LoadFromFile 将直接从磁盘加载捆绑包。使用此方法加载完全压缩的 (LZMA) 捆绑包将首先解压缩捆绑包，然后再将其加载到内存中。</p><p>如何使用 <code>LoadFromFile</code> 的一个示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromFileExample</span> <span class="title">extends</span> <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function">function <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="string">&quot;myassetBundle&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (myLoadedAssetBundle == <span class="literal">null</span>) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Failed to load AssetBundle!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(<span class="string">&quot;MyObject&quot;</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在使用 Unity 5.3 或更早版本的 Android 设备上，尝试从流媒体资源 (Streaming Assets) 路径加载 AssetBundle 时，此 API 将失败。这是因为该路径的内容将驻留在压缩的 .jar 文件中。Unity 5.4 和更高版本则可以将此 API 调用与流媒体资源一起使用。</p><h2 id="WWW-LoadFromCacheOrDownload"><a href="#WWW-LoadFromCacheOrDownload" class="headerlink" title="WWW.LoadFromCacheOrDownload"></a>WWW.LoadFromCacheOrDownload</h2><p><a href="../ScriptReference/WWW.LoadFromCacheOrDownload.html">WWW.LoadFromCacheOrDownload</a></p><p><strong>即将弃用（使用 UnityWebRequest）</strong></p><p>此 API 对于从远程服务器下载 AssetBundle 或加载本地 AssetBundle 非常有用。这是一个陈旧且不太理想的 UnityWebRequest API 版本。</p><p>从远程位置加载 AssetBundle 将自动缓存 AssetBundle。如果 AssetBundle 被压缩，则将启动工作线程来解压缩捆绑包并将其写入缓存。一旦捆绑包被解压缩并缓存，它就会像 AssetBundle.LoadFromFile 一样加载。</p><p>如何使用 <code>LoadFromCacheOrDownload</code> 的一个示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromCacheOrDownloadExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">           <span class="keyword">while</span> (!Caching.ready)</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> www = WWW.LoadFromCacheOrDownload(<span class="string">&quot;file://&quot;</span> + path, <span class="number">5</span>);</span><br><span class="line">        Debug.Log(path);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> www;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(www.error))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(www.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AssetBundle bundle = www.assetBundle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在 WWW 对象中缓存 AssetBundle 字节所需的内存开销，建议所有使用 WWW.LoadFromCacheOrDownload 的开发人员都应该确保自己的 AssetBundle 保持较小的大小 - 最多只有几兆字节。此外，还建议在有限内存平台（如移动设备）上运行的开发人员确保其代码一次只下载一个 AssetBundle，以此避免内存峰值。</p><p>如果缓存文件夹没有任何空间来缓存其他文件，LoadFromCacheOrDownload 将以迭代方式从缓存中删除最近最少使用的 AssetBundle，直到有足够的空间来存储新的 AssetBundle。如果无法腾出空间（因为硬盘已满，或者缓存中的所有文件当前都处于使用状态），LoadFromCacheOrDownload() 将不会使用缓存，而将文件流式传输到内存中</p><p>为了强制执行 LoadFromCacheOrDownload，需要更改版本参数（第二个参数）。仅当传递给函数的版本与当前缓存的 AssetBundle 的版本匹配，才会从缓存加载 AssetBundle。</p><h2 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h2><p><a href="../ScriptReference/Networking.UnityWebRequest.GetAssetBundle.html">UnityWebRequest</a></p><p>UnityWebRequest 有一个特定 API 调用来处理 AssetBundle。首先，需要使用 <code>UnityWebRequest.GetAssetBundle</code> 来创建 Web 请求。返回请求后，请将请求对象传递给 <code>DownloadHandlerAssetBundle.GetContent(UnityWebRequest)</code>。<code>GetContent</code> 调用将返回 AssetBundle 对象。</p><p>下载捆绑包后，还可以在 <a href="../ScriptReference/Networking.DownloadHandlerAssetBundle.html">DownloadHandlerAssetBundle</a> 类上使用 <code>assetBundle</code> 属性，从而以 <code>AssetBundle.LoadFromFile</code> 的效率加载 AssetBundle。</p><p>以下示例说明了如何加载包含两个游戏对象的 AssetBundle 并实例化这些游戏对象。要开始这个过程，我们只需要调用 <code>StartCoroutine(InstantiateObject())</code>;</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InstantiateObject</span>()</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(<span class="string">&quot;file://&quot;</span> + path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line">        AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">        GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Instantiate(cube);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用 UnityWebRequest 的优点在于，它允许开发人员以更灵活的方式处理下载的数据，并可能消除不必要的内存使用。这是比 UnityEngine.WWW 类更新和更优的 API。</p><h4 id="从-AssetBundle-加载资源"><a href="#从-AssetBundle-加载资源" class="headerlink" title="从 AssetBundle 加载资源"></a>从 AssetBundle 加载资源</h4><p>现在已经成功下载 AssetBundle，因此是时候最终加载一些资源了。</p><p>通用代码片段：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</span><br></pre></td></tr></table></figure><p>T 是尝试加载的资源类型。</p><p>决定如何加载资源时有几个选项。我们有 <code>LoadAsset</code>、<code>LoadAllAssets</code> 及其各自的异步对应选项 <code>LoadAssetAsync</code> 和 <code>LoadAllAssetsAsync</code>。</p><p>同步从 AssetBundle 加载资源的方法如下：</p><p>加载单个游戏对象：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject gameObject = loadedAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);</span><br></pre></td></tr></table></figure><p>加载所有资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();</span><br></pre></td></tr></table></figure><p>现在，在前面显示的方法返回要加载的对象类型或对象数组的情况下，异步方法返回 <a href="../ScriptReference/AssetBundleRequest.html">AssetBundleRequest</a>。在访问资源之前，需要等待此操作完成。加载资源：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync&lt;GameObject&gt;(assetName);</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line"><span class="keyword">var</span> loadedAsset = request.asset;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line"><span class="keyword">var</span> loadedAssets = request.allAssets;</span><br></pre></td></tr></table></figure><p>加载资源后，就可以开始了！可以像使用 Unity 中的任何对象一样使用加载的对象。</p><h4 id="加载-AssetBundle-清单"><a href="#加载-AssetBundle-清单" class="headerlink" title="加载 AssetBundle 清单"></a>加载 AssetBundle 清单</h4><p>加载 AssetBundle 清单可能非常有用。特别是在处理 AssetBundle 依赖关系时。</p><p>要获得可用的 <a href="../ScriptReference/AssetBundleManifest.html">AssetBundleManifest</a> 对象，需要加载另外的 AssetBundle（与其所在的文件夹名称相同的那个）并从中加载 AssetBundleManifest 类型的对象。</p><p>加载清单本身的操作方法与 AssetBundle 中的任何其他资源完全相同：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br></pre></td></tr></table></figure><p>现在，可以通过上面示例中的清单对象访问 <code>AssetBundleManifest</code> API 调用。从这里，可以使用清单获取所构建的 AssetBundle 的相关信息。此信息包括 AssetBundle 的依赖项数据、哈希数据和变体数据。</p><p>别忘了在前面的部分中，我们讨论过 AssetBundle 依赖项以及如果一个捆绑包对另一个捆绑包有依赖性，那么在从原始捆绑包加载任何资源之前，需要加载哪些捆绑包？清单对象可以动态地查找加载依赖项。假设我们想要为名为“assetBundle”的 AssetBundle 加载所有依赖项。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line"><span class="built_in">string</span>[] dependencies = manifest.GetAllDependencies(<span class="string">&quot;assetBundle&quot;</span>); <span class="comment">//传递想要依赖项的捆绑包的名称。</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> dependency <span class="keyword">in</span> dependencies)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经加载 AssetBundle、AssetBundle 依赖项和资源，因此是时候讨论如何管理所有这些已加载的 AssetBundle 了。</p><h2 id="管理已加载的-AssetBundle"><a href="#管理已加载的-AssetBundle" class="headerlink" title="管理已加载的 AssetBundle"></a>管理已加载的 AssetBundle</h2><p>从活动场景中删除对象时，Unity 不会自动卸载对象。资源清理在特定时间触发，也可以手动触发。</p><p>了解何时加载和卸载 AssetBundle 非常重要。不正确地卸载 AssetBundle 会导致在内存中复制对象或其他不良情况，例如缺少纹理。</p><p>关于 AssetBundle 管理最重要的事情就是何时调用</p><p><a href="../ScriptReference/AssetBundle.Unload.html">AssetBundle.Unload(bool)</a>; 以及应该将 true 还是 false 传递给函数调用。Unload 是一个非静态函数，可用于卸载 AssetBundle。此 API 会卸载正在调用的 AssetBundle 的标头信息。该参数指示是否还要卸载通过此 AssetBundle 实例化的所有对象。</p><p><code>AssetBundle.Unload(true)</code> 卸载从 AssetBundle 加载的所有游戏对象（及其依赖项）。这不包括复制的游戏对象（例如实例化的游戏对象），因为它们不再属于 AssetBundle。发生这种情况时，从该 AssetBundle 加载的纹理（并且仍然属于它）会从场景中的游戏对象消失，因此 Unity 将它们视为缺少纹理。</p><p>假设材质 M 是从 AssetBundle AB 加载的，如下所示。</p><p>如果调用 AB.Unload(true)，活动场景中的任何 M 实例也将被卸载并销毁。</p><p>如果改作调用 AB.Unload(false)，那么将会中断 M 和 AB 当前实例的链接关系。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242143748.png" alt="img"></p><p>如果稍后再次加载 AB 并且调用 AB.LoadAsset()，则 Unity 不会将现有 M 副本重新链接到新加载的材质。而是将加载 M 的两个副本。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242143614.png" alt="img"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211242143747.png" alt="img"></p><p>通常，使用 <code>AssetBundle.Unload(false)</code> 不会带来理想情况。大多数项目应该使用 <code>AssetBundle.Unload(true)</code> 来防止在内存中复制对象。</p><p>大多数项目应该使用 <code>AssetBundle.Unload(true)</code> 并采用一种方法来确保对象不会重复。两种常用方法是：</p><ul><li>在应用程序生命周期中具有明确定义的卸载瞬态 AssetBundle 的时间点，例如在关卡之间或在加载屏幕期间。</li><li>维护单个对象的引用计数，仅当未使用所有组成对象时才卸载 AssetBundle。这允许应用程序卸载和重新加载单个对象，而无需复制内存。</li></ul><p>如果应用程序必须使用 <code>AssetBundle.Unload(false)</code>，则只能以两种方式卸载单个对象：</p><ul><li>在场景和代码中消除对不需要的对象的所有引用。完成此操作后，调用 <a href="../ScriptReference/Resources.UnloadUnusedAssets.html">Resources.UnloadUnusedAssets</a>。</li><li>以非附加方式加载场景。这样会销毁当前场景中的所有对象并自动调用 <a href="../ScriptReference/Resources.UnloadUnusedAssets.html">Resources.UnloadUnusedAssets</a>。</li></ul><h1 id="加载依赖资源"><a href="#加载依赖资源" class="headerlink" title="加载依赖资源"></a>加载依赖资源</h1><h2 id="通过-API-获取-AssetBundle-依赖信息"><a href="#通过-API-获取-AssetBundle-依赖信息" class="headerlink" title="通过 API 获取 AssetBundle 依赖信息"></a>通过 API 获取 AssetBundle 依赖信息</h2><ul><li>GetAllAssetBundles()<ul><li>描述：获取所有的 AssetBundle 的名字</li></ul></li><li>GetAllDependencies(bundleName)<ul><li>描述：获取目标 AssetBundle 的所有依赖 AssetBundle 名字 (递归遍历)</li></ul></li><li>GetDirectDependencies(bundleName)<ul><li>获取目标 AssetBundle 的直接的依赖 AssetBundle 名字(只遍</li></ul></li></ul><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LYFramework.Tests</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleManifestExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> windowsBundlePath = AssetBundleUtil.FullPathForAssetBundleName(<span class="string">&quot;Windows&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> windowsBundle = AssetBundle.LoadFromFile(windowsBundlePath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> manifest = windowsBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line"></span><br><span class="line">manifest.GetAllAssetBundles()</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(Debug.Log);</span><br><span class="line"></span><br><span class="line">manifest.GetAllDependencies(<span class="string">&quot;coin_get_prefab&quot;</span>)</span><br><span class="line">.ToList()</span><br><span class="line">.ForEach(dependBundle =&gt; Debug.LogFormat(<span class="string">&quot;coin_get_prefab depends:&#123;0&#125;&quot;</span>, dependBundle));</span><br><span class="line"></span><br><span class="line">windowsBundle.Unload(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果如下。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coin_get</span><br><span class="line">coin_get_prefab</span><br><span class="line">coin_get_prefab depends:coin_get</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity资源文件夹介绍&quot;&gt;&lt;a href=&quot;#Unity资源文件夹介绍&quot; class=&quot;headerlink&quot; title=&quot;Unity资源文件夹介绍&quot;&gt;&lt;/a&gt;Unity资源文件夹介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1308267</summary>
      
    
    
    
    <category term="Unity" scheme="https://liuyingbo.com/categories/Unity/"/>
    
    
    <category term="Unity" scheme="https://liuyingbo.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C#数据结构与算法</title>
    <link href="https://liuyingbo.com/posts/ba6d86a1.html"/>
    <id>https://liuyingbo.com/posts/ba6d86a1.html</id>
    <published>2022-02-10T22:17:46.000Z</published>
    <updated>2023-01-30T11:35:12.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="什么是数据结构与算法？"><a href="#什么是数据结构与算法？" class="headerlink" title="什么是数据结构与算法？"></a>什么是数据结构与算法？</h3><p>在学习数据结构与算法的时候，常常会思考一个问题：什么是数据结构与算法？</p><p>这里比较找到了一个比较好的答案。</p><p>从宏观来讲：</p><ul><li>数据结构是一组数据的存储结构。</li><li>算法就是操作数据的方法。</li><li>数据结构为算法服务，算法要作用在特定的数据结构中。</li></ul><p>从狭义上来讲，就是数据结构与算法这门学科就是去学习比较经典的数据结构和算法。</p><p>有点像学习设计模式一样，学习 23 种设计模式。</p><h3 id="如何学习数据结构与算法？"><a href="#如何学习数据结构与算法？" class="headerlink" title="如何学习数据结构与算法？"></a>如何学习数据结构与算法？</h3><p>说到设计模式，学习数据结构与算法与学习设计模式非常相似的。</p><p>我们知道设计模式有 23 种，而一般一个开发者学习设计模式的时候，往往会对 23 个设计模式都从头到尾学一遍，但是学完之后发现除了记了个名字之外没啥卵用，就连名字也不一定记得住。</p><p>那么是以为 23 种设计模式的核心并不是设计模式本身，而是 23 种设计模式所遵循的 SOLID 原则，即六大设计原则，而开发者一开始最应该掌握的是六大设计原则，而不是设计模式，六大设计原则是核心，而 23 种设计模式算是 23 种对于六大设计原则的案例一样，一定要先搞清楚这一点。否则学习就会事倍功半，当然如果有一定的编码经验再去学设计模式更好一些。</p><p>学习数据结构与算法也是一样的，数据结构与算法的核心是时间复杂度和空间复杂度，就像对于设计模式中的六大设计原则一样，掌握了时间复杂度和空间复杂度的评估，那么剩下的经典的常用的数据结构和算法就是一个个案例而已，而不用死记硬背，当然有一定的编码经验再去学习会更好一些。</p><p>这就是数据结构与算法的学习思路。</p><h3 id="为什么要学习数据结构与算法？"><a href="#为什么要学习数据结构与算法？" class="headerlink" title="为什么要学习数据结构与算法？"></a>为什么要学习数据结构与算法？</h3><ul><li>国内大厂的面试比较爱考，但是考得不是很难</li><li>Google、Facebook、微软等更爱考，而且非常难。</li><li>可以评估代码性能，写出高性能的代码</li><li>开发时选择合适的数据结构</li><li>比较有名的基础框架，都柔和了很多基础数据解耦股和算法的设计思想</li><li>阅读源码的时候可以减少阻碍（比如遇到一些算法的实现）</li><li>提高编程能力</li><li>思维提升</li><li>简历上可以写一个精通数据结构与算法</li></ul><h3 id="数据结构与算法是不是高智商开发者的专属？"><a href="#数据结构与算法是不是高智商开发者的专属？" class="headerlink" title="数据结构与算法是不是高智商开发者的专属？"></a>数据结构与算法是不是高智商开发者的专属？</h3><p>当然不是，数据结构与算法的常用的知识点不多，而且也不需要高智商。重点还是熟能生巧。</p><h3 id="数据结构与算法学科的解决问题重点是什么？"><a href="#数据结构与算法学科的解决问题重点是什么？" class="headerlink" title="数据结构与算法学科的解决问题重点是什么？"></a>数据结构与算法学科的解决问题重点是什么？</h3><ul><li>更省更快地存储和处理数据的问题<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923357.png" alt="image.png"></li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度的定义很简单：</p><ul><li>算法的执行时间与数据规模之间的增长关系</li></ul><p>时间复杂度的全称其实叫做：渐进时间复杂度，我们就叫时间复杂度即可。</p><p>时间复杂度的定义难得的清晰，不像一些设计模式这样的定义非常抽象。</p><p>OK，既然时间复杂度的定义这么简单，那么我们也顺便说一下空间复杂度吧，空间复杂度的定义如下：</p><ul><li>算法的存储空间与数据规模之间的增长关系。</li></ul><p>空间复杂度的定义也非常直白。</p><p> List 的遍历，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 list 的数据规模是 3，其实就是数据量，那么这一段代码所执行的时间就是， Debug.Log(s) 所执行的时间 x 3。</p><p>用公式表示如下：</p><ul><li>代码总共执行的时间 = Debug.Log(s) 执行一次的时间 x list.Count</li></ul><p>那么该代码的执行时间与数据规模之间的增长关系是怎么样的呢？</p><p>其实以上的公式就回答了这个问题，代码的执行时间与数据规模之间的增长关系是一比一关系，即数据规模增长一倍，那么代码的执行时间也会增长一倍。</p><p>这里我们用 T(n) 表示代码总共执行的时间，用 UnitTime 表示 Debug.Log(s) 执行一次的时间，用 n 表示 数据的规模（lisnt.Count)，代入以上公式，如下：</p><ul><li>T(n) = UnitTime x n</li></ul><p>通过以上公式就能够算出以上代码所执行花费的时间，只不过 UnitTime 的执行时间非常依赖具体的软硬件环境，而以上这个公式实际上是 <strong>事后统计法</strong> 的统计方式。</p><p>而我们的时间复杂度，需要算出来的并不是代码中共执行所花费总时间，而是表示一个关系，即：代码执行时间与数据规模这件的增长关系。</p><p>而目前的 T(n) = UnitTime x n 这个公式，根据我们的所学的数学知识，能够得出的增长关系就是正比例关系。</p><p>但是在数据结构与算法中用大 O 表示法来表示算法执行时间与数据规模的增长关系，那么大 O 表示法如何使用呢？</p><p>很简单，就是 O(T(n))，但是这个 O(T(n)) 不是最终计算完的版本，还需要一些计算的过程。</p><p>第一步是吧 T(n) 代入到 O(T(n)) 中，结果如下：</p><ul><li>O(UnitTime x n)</li></ul><p>接着把系数、加减的常量、数量级更低的 n 都排除掉。</p><p>在 UnitTime x n 中，UnitTime 虽然目前是未知数，但是我们可以确定的是它肯定是一个常数，所以就直接把 UnitTime 去掉。</p><p>最终得到的执行时间与数据规模的增长关系如下：</p><ul><li>O(n)</li></ul><p>即，遍历 list 这个算法的执行时间与数据规模的增长关系，也就是所谓的时间复杂度为 O(n)。</p><p>时间复杂度这个概念对大家来说不是很难，但是一定要掌握，因为时间复杂度这个概念是整个 数据结构与算法 这门学科的灵魂。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// [&quot;List&quot;,&quot;数据结构与算法&quot;]</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;List&quot;</span>,</span><br><span class="line"><span class="string">&quot;数据结构与算法&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;List&quot;,&quot;数据结构与算法&quot;,&quot;框架搭建&quot;]</span></span><br><span class="line">list.Add(<span class="string">&quot;框架搭建&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;List&quot;,&quot;数据结构与算法&quot;,&quot;框架搭建&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.Add(<span class="string">&quot;Shader 案例&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构与算法&quot;,&quot;框架搭建&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.Remove(<span class="string">&quot;List&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;框架搭建&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.RemoveAll((content) =&gt; content.StartsWith(<span class="string">&quot;数据&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;插入的数据&quot;,&quot;框架搭建&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="string">&quot;插入的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;插入的数据&quot;,&quot;Shader 案例&quot;]</span></span><br><span class="line">list.RemoveAt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> content <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(content);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923086.png" alt="image.png"></p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923377.png" alt="image.png"></p><h3 id="List-中的数据结构概念"><a href="#List-中的数据结构概念" class="headerlink" title="List 中的数据结构概念"></a>List 中的数据结构概念</h3><p>List 有一些数据结构相关的特性，比如：</p><ul><li>动态扩容</li><li>内存连续（任意访问）</li></ul><p>这些仅仅是一些特性，并不是概念。</p><p>那么 List 中有哪些数据结构的概念呢？</p><p>答案是线性表。</p><h2 id="线性表-与-非线性表"><a href="#线性表-与-非线性表" class="headerlink" title="线性表 与 非线性表"></a>线性表 与 非线性表</h2><p>线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿串起来，再存储到物理空间中”。</p><p>每个线性表上的数据最多只有前和后两个方向。</p><p>List 就是一种线性表，因为 List 符合以上的线性表的定义。</p><p>List 本质是一个数组，只不过这个数组是支持动态扩容的。通过看 List 源码就可以知道 List 内部维护了一个数组。</p><p>所以数组也是一种线性表，所以 List 与数组一样，也是一种线性表。</p><p>到这里大家可能会问，除了数组是线性表之外，还有哪些类型的数据结构是线性表？</p><p>答案是：链表、栈、队列。</p><p>而恰好，C# 中也有实现的数据结构与之对应，如下：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923712.png" alt="image.png"></p><p>而这些数据结构则是接下来要学习的内容。</p><p>既然有了线性表，那么就应该有非线性表，非线性表的常见数据结构如下：</p><ul><li>散列/哈希表（hash）</li><li>树：二叉树、堆等</li><li>图</li></ul><p>之所以这些数据结构叫非线性表是因为数据之间并不是简单的前后关系。</p><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><h3 id="字典简介"><a href="#字典简介" class="headerlink" title="字典简介"></a>字典简介</h3><p>Dictionary 是 C# 中比较常用的数据结构，从功能角度来说，用 List 和 Dictionary 其实就能满足大部分的业务开发需求。</p><p>Dictionary 是 key-value 存储的数据结构，即通过 key 去访问 value 值。而 List 则是通过索引去访问 value 值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure2020</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DictionaryExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Unity C# 数据结构与算法精讲&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;price&quot;</span>,<span class="string">&quot;9.9&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;,</span></span><br><span class="line"><span class="comment">//&quot;createAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dictionary.Add(<span class="string">&quot;createAt&quot;</span>,<span class="string">&quot;2021 年 12 月 12 日&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;,</span></span><br><span class="line"><span class="comment">//&quot;createAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">//&quot;updateAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dictionary.Add(<span class="string">&quot;updateAt&quot;</span>,<span class="string">&quot;2021 年 12 月 12 日&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;,</span></span><br><span class="line"><span class="comment">//&quot;updateAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dictionary.Remove(<span class="string">&quot;createAt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &quot;name&quot;:&quot;Unity C# 数据结构与算法精讲,</span></span><br><span class="line"><span class="comment">// &quot;price&quot;:&quot;9.9&quot;,</span></span><br><span class="line"><span class="comment">//&quot;updateAt&quot;:&quot;2021 年 12 月 12 日&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">dictionary[<span class="string">&quot;updateAt&quot;</span>] = <span class="string">&quot;2021 年 12 月 12 日&quot;</span>;</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ keys @@@@&quot;</span>);</span><br><span class="line">dictionary.Keys.ToList().ForEach(Debug.Log);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ values @@@@&quot;</span>);</span><br><span class="line">dictionary.Values.ToList().ForEach(Debug.Log);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ key:value @@@@&quot;</span>);</span><br><span class="line">dictionary.ToList().ForEach(kv =&gt; Debug.LogFormat(<span class="string">&quot;key:&#123;0&#125;,value:&#123;1&#125;&quot;</span>, kv.Key, kv.Value));</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ containsKey @@@@&quot;</span>);</span><br><span class="line">Debug.LogFormat(<span class="string">&quot;dictionary.ContainsKey(updateAt):&#123;0&#125;&quot;</span>, dictionary.ContainsKey(<span class="string">&quot;updateAt&quot;</span>));</span><br><span class="line">Debug.LogFormat(<span class="string">&quot;dictionary.ContainsKey(createAt):&#123;0&#125;&quot;</span>, dictionary.ContainsKey(<span class="string">&quot;createAt&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923831.png" alt="image.png"></p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="Stack-简介"><a href="#Stack-简介" class="headerlink" title="Stack 简介"></a>Stack 简介</h3><p>Stack 叫做栈，栈数据结构的一个特点就是：后进先出，先进后出。</p><p>就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放，取的时候，我们也是从上往下一个个地依次取，不能从中间人物抽出。</p><p>从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StackExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;]</span></span><br><span class="line">stack.Push(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line">stack.Push(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;Stack&quot;,&quot;算法&quot;]</span></span><br><span class="line">stack.Push(<span class="string">&quot;Stack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">var</span> liangxie = stack.Pop();</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;pop liangxie:&quot;</span> + liangxie);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">var</span> algo = stack.Peek();</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;peek algo:&quot;</span> + algo);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ stack foreach @@@@&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> title <span class="keyword">in</span> stack)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(title);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923146.png" alt="image.png"></p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue-简介"><a href="#Queue-简介" class="headerlink" title="Queue 简介"></a>Queue 简介</h3><p>Queue 即，队列，队列是一种先进先出，后进后出的线性表。</p><p>那么队列也有两个基本的操作：</p><ul><li>Enqueue：入队</li><li>Dequeue：出队</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QueueExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;]</span></span><br><span class="line">queue.Enqueue(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line">queue.Enqueue(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;,&quot;Queue&quot;]</span></span><br><span class="line">queue.Enqueue(<span class="string">&quot;Queue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;算法&quot;,&quot;Queue&quot;]</span></span><br><span class="line"><span class="keyword">var</span> dataStructure = queue.Dequeue();</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;dequeue dataStructure:&quot;</span> + dataStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> algo = queue.Peek();</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;peek algo:&quot;</span> + algo);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ foreach queue @@@@&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> title <span class="keyword">in</span> queue)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(title);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923546.png" alt="image.png"></p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="HashSet-基本使用"><a href="#HashSet-基本使用" class="headerlink" title="HashSet 基本使用"></a>HashSet 基本使用</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HashSetExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Add(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Add(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Add(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;,&quot;HashSet&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Add(<span class="string">&quot;HashSet&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;数据结构&quot;,&quot;算法&quot;]</span></span><br><span class="line"><span class="keyword">set</span>.Remove(<span class="string">&quot;HashSet&quot;</span>);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;contains 算法:&quot;</span> + <span class="keyword">set</span>.Contains(<span class="string">&quot;算法&quot;</span>));</span><br><span class="line">Debug.Log(<span class="string">&quot;contains HashSet:&quot;</span> + <span class="keyword">set</span>.Contains(<span class="string">&quot;HashSet&quot;</span>));</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ set foreach @@@@&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> title <span class="keyword">in</span> <span class="keyword">set</span>)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(title);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191923618.png" alt=""></p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LinkedListExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> linkedList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;数据结构&quot;</span></span><br><span class="line"><span class="keyword">var</span> dataStructureNode = linkedList.AddFirst(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;数据结构&quot;</span></span><br><span class="line"><span class="keyword">var</span> algoNode = linkedList.AddFirst(<span class="string">&quot;算法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;数据结构&quot;&lt;=&gt;&quot;LinkedList&quot;</span></span><br><span class="line"><span class="keyword">var</span> liangxieNode = linkedList.AddLast(<span class="string">&quot;LinkedList&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;专栏&quot;&lt;=&gt;&quot;数据结构&quot;&lt;=&gt;&quot;LinkedList&quot;</span></span><br><span class="line">linkedList.AddAfter(algoNode, <span class="string">&quot;专栏&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;专栏&quot;&lt;=&gt;&quot;数据结构&quot;&lt;=&gt;&quot;笔记&quot;&lt;=&gt;&quot;LinkedList&quot;</span></span><br><span class="line">linkedList.AddBefore(liangxieNode, <span class="string">&quot;笔记&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;专栏&quot;&lt;=&gt;&quot;笔记&quot;&lt;=&gt;&quot;LinkedList&quot;</span></span><br><span class="line">linkedList.Remove(<span class="string">&quot;数据结构&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;算法&quot;&lt;=&gt;&quot;专栏&quot;&lt;=&gt;&quot;笔记&quot;</span></span><br><span class="line">linkedList.Remove(liangxieNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhuanlanNode = linkedList.Find(<span class="string">&quot;专栏&quot;</span>);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;find zhuanlanNode:&quot;</span> + zhuanlanNode.Value);</span><br><span class="line"></span><br><span class="line">Debug.Log(<span class="string">&quot;@@@@ linkedList foreach @@@@&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> linkedList)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果和代码中注释和结果来看，LinkedList 中存储的元素并不是数据，而是一个个节点 LinkedListNode，而其中的节点才会去存储真正的数据。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924101.png" alt="image.png"></p><h3 id="链表-简介"><a href="#链表-简介" class="headerlink" title="链表 简介"></a>链表 简介</h3><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p><p>定义中有两个重点：</p><ul><li>内存中不连续、不顺序</li><li>逻辑上通过链表节点的指针实现</li></ul><p>也就是说与数组相反，链表在内存中是不连续的，既然不连续，那就不支持任意访问。不连续还有个好处就是不用考虑因动态扩容造成的 GC Alloc 和 GC Collect。</p><p>首先我们先定义一个链表节点对象，如下：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924665.png" alt="image.png"><br>即，该类有两个字段：</p><ul><li>指向下一个节点的 Next 字段</li><li>用于存储数据的 Data</li></ul><p>而一个比较典型的链表数据结构如下图所示；<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924769.png" alt="image.png"></p><p>图中的这种链表叫做单向链表。</p><p>单向链表的特点就是只有一个 Next 指针指向下一个节点。</p><p>那么到这里大家可能会问，链表 与 数组相比有什么优劣呢？</p><p>这里笔者简单总结下它们的优劣：</p><p>链表：</p><ul><li>不支持任意访问，想要实现任意访问的时间复杂度为 O(n)</li><li>天然支持动态扩容</li><li>在头结点或者尾结点插入数据的时间复杂度为 O(1)</li><li>在中间插入结点的方式分为两种：<ul><li>得到插入位置结点的情况下，插入一个节点的时间复杂度为 O(1)</li><li>在没有得到插入位置结点的情况下，插入一个时间复杂度为 O(n)</li></ul></li><li>查询某个符合条件的节点的时间复杂度为 O(n)</li><li>删除节点的时间复杂度也同理：<ul><li>在头和尾，或者得到插入位置的节点情况下是 O(1)</li><li>否则是 O(n)</li></ul></li><li>内存中不连续</li></ul><p>数组：</p><ul><li>支持任意访问，时间复杂度为 O(1)</li><li>不支持动态扩容，List 支持</li><li>插入数据的时间复杂度为 O(n)，因为要考虑数据搬移</li><li>删除数据的时间复杂度为 O(n)，也是要考虑数据搬移</li><li>查询符合条件的某个数据的时间复杂度是 O(n)</li><li>内存中连续</li></ul><p>以上就是链表和数组的简单对比，不同的存储形式有不同的功能和作用，所以如何挑选合适的数据结构对程序的性能来说是非常重要的。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="Hash-简介"><a href="#Hash-简介" class="headerlink" title="Hash 简介"></a>Hash 简介</h3><p>Hash 即哈希或者叫散列。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataStructure2020</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HashPrincipleExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 学生类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 学生数组</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">Student[] mStudent = <span class="keyword">new</span> Student[]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1001&quot;</span>,Name = <span class="string">&quot;小数&quot;</span>&#125;, </span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1002&quot;</span>,Name = <span class="string">&quot;小据&quot;</span>&#125;, </span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1003&quot;</span>,Name = <span class="string">&quot;小结&quot;</span>&#125;, </span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1004&quot;</span>,Name = <span class="string">&quot;小构&quot;</span>&#125;, </span><br><span class="line"><span class="keyword">new</span> Student() &#123;Id =<span class="string">&quot;1005&quot;</span>,Name = <span class="string">&quot;小与&quot;</span>&#125;, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 根据 Id 获取学生对象</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;id&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function">Student <span class="title">GetStudentById</span>(<span class="params"><span class="built_in">string</span> id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> idNumber = <span class="built_in">int</span>.Parse(id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = idNumber - <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mStudent[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 查询学生</span></span><br><span class="line"><span class="keyword">var</span> student = GetStudentById(<span class="string">&quot;1003&quot;</span>);</span><br><span class="line"></span><br><span class="line">Debug.Log(student.Id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetStudentById 的所使用的思想就是散列的思想，即通过把一个 key 转换成数组的下标，根据下标直接获取数据的思想。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表，即 Hashtable，是有一种使用散列思想的数据结构。而在 C# 中也有一个叫做 Hashtable 的数据结构。</p><p>我们都知道，数组是支持下标的任意访问的，散列表用的就是数组的任意访问的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>散列表由三个部分组成，即：</p><ul><li>key（关键字）</li><li>hash function（散列/哈希函数）</li><li>table（用于存储的数组）</li></ul><p>我们在上一篇知道，散列的思想本质上就是将 key 转换为 数组的下标，然后通过下标去访问数组的数据的一种思想，所以通过这一点不难看出，以上的三个部分中 hash function 就是将 key 转换为下标的一个方法。</p><p>而 table 一般就是用数组或者能够通过下标访问的一些数据结构实现。</p><p>其流程如下图所示：<br><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924815.png" alt="image.png"></p><h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>Hashtable 的 hash function 其实就是将 key 的 hash code 转换为 数组下标。</p><p>代码如下：</p><ul><li>uint hashcode = InitHash(key, buckets.Length, out seed, out incr);</li><li>int bucketNumber = (int) (seed % (uint)buckets.Length);</li></ul><p>散列冲突指的就是，不同的 key 得到的 bucketNumber 有可能是一致的，也就是说数组的下标会产生重复的情况。</p><p>]把发生数组小标重复的情况叫做 散列冲突。</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>在发生散列冲突的时候，我们就需要解决掉这个冲突。</p><p>而解决这个冲突的方式一般有两种：</p><ul><li>开放寻址法（或闭散列法）</li><li>链表法（或开散列法）</li></ul><p>开放寻址法的特点非常简单，当发生散列冲突的时候，会在数组内寻找下一个可用的位置来存储数据，这时候会对数组进行遍历操作。</p><p>开放寻址法的缺陷就是当数组空余空间越少，发生散列冲突的概率越大，所以 C# 的 Hashtable 通过动态扩容来解决这个问题。</p><p>而链表法的特点则是，当法神散列冲突的时候，会在冲突位置来创建一个链表来存储数据。</p><p>而当发生冲突的时候，不管是开放寻址法还是链表法，都会去其他的内存空间中找到或者创建一个插槽（slot），用于存放数据。</p><p>在 C# 的 Hashtable 中，插槽可以理解为数组中一个空的 bucket。</p><p>由于在 C# Hashtable 中没有链表相关的代码，所以可以推测出 Hashtable 是使用开放寻址法来解决散列冲突。</p><h3 id="Hashtable-与-HashSet的区别"><a href="#Hashtable-与-HashSet的区别" class="headerlink" title="Hashtable 与 HashSet的区别"></a>Hashtable 与 HashSet的区别</h3><p>Hashtable 与 HashSet 的基本存储单元以及集合的不同导致了对应的 添加、删除、查询等算法的差异。</p><p>在 Hashtable 中，添加一个数据的流程如下：</p><ul><li>获取 key 的 hashcode：<ul><li>uint hashcode = InitHash(key, buckets.Length, out seed, out incr);</li></ul></li><li>获取下标：<ul><li>int bucketNumber = (int) (seed % (uint)buckets.Length);</li></ul></li><li>存储值：<ul><li>buckets[bucketNumber].val = nvalue;</li><li>buckets[bucketNumber].key = key;</li><li>buckets[bucketNumber].hash_coll |= (int) hashcode;</li></ul></li></ul><p>在 HashSet 中，添加一个数据的流程如下：</p><ul><li>获取 hash code：<ul><li>hashCode = value != null ? value.GetHashCode() : 0;</li></ul></li><li>根据 hash code 获取 bucket （Entry 的下标）<ul><li>bucket = ref GetBucketRef(hashCode);</li></ul></li><li>下标前移</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = bucket - 1; // Value in _buckets is 1-based</span><br></pre></td></tr></table></figure><ul><li>存储</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ref Entry entry = ref entries![index];</span><br><span class="line">entry.HashCode = hashCode;</span><br><span class="line">entry.Next = bucket - 1; // Value in _buckets is 1-based</span><br><span class="line">entry.Value = value;</span><br><span class="line">bucket = index + 1;</span><br><span class="line">_version++;</span><br><span class="line">location = index;</span><br></pre></td></tr></table></figure><p>其实，两者存储的流程是差不多的，区别在于当数据发生冲突的时候。</p><p><img src="https://blog-1308267163.cos.ap-shanghai.myqcloud.com/imgs/202211191924811.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h2&gt;&lt;h3 id=&quot;什么是数据结构与算法？&quot;&gt;&lt;a href=&quot;#什么是数据结构与算法？&quot; class=&quot;he</summary>
      
    
    
    
    <category term="C#" scheme="https://liuyingbo.com/categories/C/"/>
    
    
    <category term="C#" scheme="https://liuyingbo.com/tags/C/"/>
    
    <category term="语法" scheme="https://liuyingbo.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
